/*! For license information please see viewer.js.LICENSE.txt */
(()=>{var t={543:function(t,e,n){var i;t=n.nmd(t),function(){var r,s="Expected a function",o="__lodash_hash_undefined__",a="__lodash_placeholder__",l=32,c=128,h=1/0,u=9007199254740991,d=NaN,p=4294967295,f=[["ary",c],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",l],["partialRight",64],["rearg",256]],m="[object Arguments]",g="[object Array]",_="[object Boolean]",y="[object Date]",v="[object Error]",x="[object Function]",S="[object GeneratorFunction]",b="[object Map]",M="[object Number]",w="[object Object]",E="[object Promise]",T="[object RegExp]",A="[object Set]",C="[object String]",R="[object Symbol]",P="[object WeakMap]",L="[object ArrayBuffer]",I="[object DataView]",N="[object Float32Array]",D="[object Float64Array]",O="[object Int8Array]",U="[object Int16Array]",F="[object Int32Array]",B="[object Uint8Array]",z="[object Uint8ClampedArray]",V="[object Uint16Array]",k="[object Uint32Array]",G=/\b__p \+= '';/g,H=/\b(__p \+=) '' \+/g,W=/(__e\(.*?\)|\b__t\)) \+\n'';/g,j=/&(?:amp|lt|gt|quot|#39);/g,X=/[&<>"']/g,Y=RegExp(j.source),q=RegExp(X.source),$=/<%-([\s\S]+?)%>/g,Z=/<%([\s\S]+?)%>/g,J=/<%=([\s\S]+?)%>/g,K=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Q=/^\w*$/,tt=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,et=/[\\^$.*+?()[\]{}|]/g,nt=RegExp(et.source),it=/^\s+/,rt=/\s/,st=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,ot=/\{\n\/\* \[wrapped with (.+)\] \*/,at=/,? & /,lt=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,ct=/[()=,{}\[\]\/\s]/,ht=/\\(\\)?/g,ut=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dt=/\w*$/,pt=/^[-+]0x[0-9a-f]+$/i,ft=/^0b[01]+$/i,mt=/^\[object .+?Constructor\]$/,gt=/^0o[0-7]+$/i,_t=/^(?:0|[1-9]\d*)$/,yt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,vt=/($^)/,xt=/['\n\r\u2028\u2029\\]/g,St="\\ud800-\\udfff",bt="\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",Mt="\\u2700-\\u27bf",wt="a-z\\xdf-\\xf6\\xf8-\\xff",Et="A-Z\\xc0-\\xd6\\xd8-\\xde",Tt="\\ufe0e\\ufe0f",At="\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Ct="["+St+"]",Rt="["+At+"]",Pt="["+bt+"]",Lt="\\d+",It="["+Mt+"]",Nt="["+wt+"]",Dt="[^"+St+At+Lt+Mt+wt+Et+"]",Ot="\\ud83c[\\udffb-\\udfff]",Ut="[^"+St+"]",Ft="(?:\\ud83c[\\udde6-\\uddff]){2}",Bt="[\\ud800-\\udbff][\\udc00-\\udfff]",zt="["+Et+"]",Vt="\\u200d",kt="(?:"+Nt+"|"+Dt+")",Gt="(?:"+zt+"|"+Dt+")",Ht="(?:['’](?:d|ll|m|re|s|t|ve))?",Wt="(?:['’](?:D|LL|M|RE|S|T|VE))?",jt="(?:"+Pt+"|"+Ot+")?",Xt="["+Tt+"]?",Yt=Xt+jt+"(?:"+Vt+"(?:"+[Ut,Ft,Bt].join("|")+")"+Xt+jt+")*",qt="(?:"+[It,Ft,Bt].join("|")+")"+Yt,$t="(?:"+[Ut+Pt+"?",Pt,Ft,Bt,Ct].join("|")+")",Zt=RegExp("['’]","g"),Jt=RegExp(Pt,"g"),Kt=RegExp(Ot+"(?="+Ot+")|"+$t+Yt,"g"),Qt=RegExp([zt+"?"+Nt+"+"+Ht+"(?="+[Rt,zt,"$"].join("|")+")",Gt+"+"+Wt+"(?="+[Rt,zt+kt,"$"].join("|")+")",zt+"?"+kt+"+"+Ht,zt+"+"+Wt,"\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])","\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Lt,qt].join("|"),"g"),te=RegExp("["+Vt+St+bt+Tt+"]"),ee=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,ne=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],ie=-1,re={};re[N]=re[D]=re[O]=re[U]=re[F]=re[B]=re[z]=re[V]=re[k]=!0,re[m]=re[g]=re[L]=re[_]=re[I]=re[y]=re[v]=re[x]=re[b]=re[M]=re[w]=re[T]=re[A]=re[C]=re[P]=!1;var se={};se[m]=se[g]=se[L]=se[I]=se[_]=se[y]=se[N]=se[D]=se[O]=se[U]=se[F]=se[b]=se[M]=se[w]=se[T]=se[A]=se[C]=se[R]=se[B]=se[z]=se[V]=se[k]=!0,se[v]=se[x]=se[P]=!1;var oe={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},ae=parseFloat,le=parseInt,ce="object"==typeof n.g&&n.g&&n.g.Object===Object&&n.g,he="object"==typeof self&&self&&self.Object===Object&&self,ue=ce||he||Function("return this")(),de=e&&!e.nodeType&&e,pe=de&&t&&!t.nodeType&&t,fe=pe&&pe.exports===de,me=fe&&ce.process,ge=function(){try{return pe&&pe.require&&pe.require("util").types||me&&me.binding&&me.binding("util")}catch(t){}}(),_e=ge&&ge.isArrayBuffer,ye=ge&&ge.isDate,ve=ge&&ge.isMap,xe=ge&&ge.isRegExp,Se=ge&&ge.isSet,be=ge&&ge.isTypedArray;function Me(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}function we(t,e,n,i){for(var r=-1,s=null==t?0:t.length;++r<s;){var o=t[r];e(i,o,n(o),t)}return i}function Ee(t,e){for(var n=-1,i=null==t?0:t.length;++n<i&&!1!==e(t[n],n,t););return t}function Te(t,e){for(var n=null==t?0:t.length;n--&&!1!==e(t[n],n,t););return t}function Ae(t,e){for(var n=-1,i=null==t?0:t.length;++n<i;)if(!e(t[n],n,t))return!1;return!0}function Ce(t,e){for(var n=-1,i=null==t?0:t.length,r=0,s=[];++n<i;){var o=t[n];e(o,n,t)&&(s[r++]=o)}return s}function Re(t,e){return!(null==t||!t.length)&&ze(t,e,0)>-1}function Pe(t,e,n){for(var i=-1,r=null==t?0:t.length;++i<r;)if(n(e,t[i]))return!0;return!1}function Le(t,e){for(var n=-1,i=null==t?0:t.length,r=Array(i);++n<i;)r[n]=e(t[n],n,t);return r}function Ie(t,e){for(var n=-1,i=e.length,r=t.length;++n<i;)t[r+n]=e[n];return t}function Ne(t,e,n,i){var r=-1,s=null==t?0:t.length;for(i&&s&&(n=t[++r]);++r<s;)n=e(n,t[r],r,t);return n}function De(t,e,n,i){var r=null==t?0:t.length;for(i&&r&&(n=t[--r]);r--;)n=e(n,t[r],r,t);return n}function Oe(t,e){for(var n=-1,i=null==t?0:t.length;++n<i;)if(e(t[n],n,t))return!0;return!1}var Ue=He("length");function Fe(t,e,n){var i;return n(t,function(t,n,r){if(e(t,n,r))return i=n,!1}),i}function Be(t,e,n,i){for(var r=t.length,s=n+(i?1:-1);i?s--:++s<r;)if(e(t[s],s,t))return s;return-1}function ze(t,e,n){return e==e?function(t,e,n){for(var i=n-1,r=t.length;++i<r;)if(t[i]===e)return i;return-1}(t,e,n):Be(t,ke,n)}function Ve(t,e,n,i){for(var r=n-1,s=t.length;++r<s;)if(i(t[r],e))return r;return-1}function ke(t){return t!=t}function Ge(t,e){var n=null==t?0:t.length;return n?Xe(t,e)/n:d}function He(t){return function(e){return null==e?r:e[t]}}function We(t){return function(e){return null==t?r:t[e]}}function je(t,e,n,i,r){return r(t,function(t,r,s){n=i?(i=!1,t):e(n,t,r,s)}),n}function Xe(t,e){for(var n,i=-1,s=t.length;++i<s;){var o=e(t[i]);o!==r&&(n=n===r?o:n+o)}return n}function Ye(t,e){for(var n=-1,i=Array(t);++n<t;)i[n]=e(n);return i}function qe(t){return t?t.slice(0,dn(t)+1).replace(it,""):t}function $e(t){return function(e){return t(e)}}function Ze(t,e){return Le(e,function(e){return t[e]})}function Je(t,e){return t.has(e)}function Ke(t,e){for(var n=-1,i=t.length;++n<i&&ze(e,t[n],0)>-1;);return n}function Qe(t,e){for(var n=t.length;n--&&ze(e,t[n],0)>-1;);return n}var tn=We({À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"}),en=We({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"});function nn(t){return"\\"+oe[t]}function rn(t){return te.test(t)}function sn(t){var e=-1,n=Array(t.size);return t.forEach(function(t,i){n[++e]=[i,t]}),n}function on(t,e){return function(n){return t(e(n))}}function an(t,e){for(var n=-1,i=t.length,r=0,s=[];++n<i;){var o=t[n];o!==e&&o!==a||(t[n]=a,s[r++]=n)}return s}function ln(t){var e=-1,n=Array(t.size);return t.forEach(function(t){n[++e]=t}),n}function cn(t){var e=-1,n=Array(t.size);return t.forEach(function(t){n[++e]=[t,t]}),n}function hn(t){return rn(t)?function(t){for(var e=Kt.lastIndex=0;Kt.test(t);)++e;return e}(t):Ue(t)}function un(t){return rn(t)?function(t){return t.match(Kt)||[]}(t):function(t){return t.split("")}(t)}function dn(t){for(var e=t.length;e--&&rt.test(t.charAt(e)););return e}var pn=We({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),fn=function t(e){var n,i=(e=null==e?ue:fn.defaults(ue.Object(),e,fn.pick(ue,ne))).Array,rt=e.Date,St=e.Error,bt=e.Function,Mt=e.Math,wt=e.Object,Et=e.RegExp,Tt=e.String,At=e.TypeError,Ct=i.prototype,Rt=bt.prototype,Pt=wt.prototype,Lt=e["__core-js_shared__"],It=Rt.toString,Nt=Pt.hasOwnProperty,Dt=0,Ot=(n=/[^.]+$/.exec(Lt&&Lt.keys&&Lt.keys.IE_PROTO||""))?"Symbol(src)_1."+n:"",Ut=Pt.toString,Ft=It.call(wt),Bt=ue._,zt=Et("^"+It.call(Nt).replace(et,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Vt=fe?e.Buffer:r,kt=e.Symbol,Gt=e.Uint8Array,Ht=Vt?Vt.allocUnsafe:r,Wt=on(wt.getPrototypeOf,wt),jt=wt.create,Xt=Pt.propertyIsEnumerable,Yt=Ct.splice,qt=kt?kt.isConcatSpreadable:r,$t=kt?kt.iterator:r,Kt=kt?kt.toStringTag:r,te=function(){try{var t=ls(wt,"defineProperty");return t({},"",{}),t}catch(t){}}(),oe=e.clearTimeout!==ue.clearTimeout&&e.clearTimeout,ce=rt&&rt.now!==ue.Date.now&&rt.now,he=e.setTimeout!==ue.setTimeout&&e.setTimeout,de=Mt.ceil,pe=Mt.floor,me=wt.getOwnPropertySymbols,ge=Vt?Vt.isBuffer:r,Ue=e.isFinite,We=Ct.join,mn=on(wt.keys,wt),gn=Mt.max,_n=Mt.min,yn=rt.now,vn=e.parseInt,xn=Mt.random,Sn=Ct.reverse,bn=ls(e,"DataView"),Mn=ls(e,"Map"),wn=ls(e,"Promise"),En=ls(e,"Set"),Tn=ls(e,"WeakMap"),An=ls(wt,"create"),Cn=Tn&&new Tn,Rn={},Pn=Us(bn),Ln=Us(Mn),In=Us(wn),Nn=Us(En),Dn=Us(Tn),On=kt?kt.prototype:r,Un=On?On.valueOf:r,Fn=On?On.toString:r;function Bn(t){if(ta(t)&&!Ho(t)&&!(t instanceof Gn)){if(t instanceof kn)return t;if(Nt.call(t,"__wrapped__"))return Fs(t)}return new kn(t)}var zn=function(){function t(){}return function(e){if(!Qo(e))return{};if(jt)return jt(e);t.prototype=e;var n=new t;return t.prototype=r,n}}();function Vn(){}function kn(t,e){this.__wrapped__=t,this.__actions__=[],this.__chain__=!!e,this.__index__=0,this.__values__=r}function Gn(t){this.__wrapped__=t,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=p,this.__views__=[]}function Hn(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var i=t[e];this.set(i[0],i[1])}}function Wn(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var i=t[e];this.set(i[0],i[1])}}function jn(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var i=t[e];this.set(i[0],i[1])}}function Xn(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new jn;++e<n;)this.add(t[e])}function Yn(t){var e=this.__data__=new Wn(t);this.size=e.size}function qn(t,e){var n=Ho(t),i=!n&&Go(t),r=!n&&!i&&Yo(t),s=!n&&!i&&!r&&la(t),o=n||i||r||s,a=o?Ye(t.length,Tt):[],l=a.length;for(var c in t)!e&&!Nt.call(t,c)||o&&("length"==c||r&&("offset"==c||"parent"==c)||s&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||ms(c,l))||a.push(c);return a}function $n(t){var e=t.length;return e?t[ji(0,e-1)]:r}function Zn(t,e){return Ls(Tr(t),si(e,0,t.length))}function Jn(t){return Ls(Tr(t))}function Kn(t,e,n){(n!==r&&!zo(t[e],n)||n===r&&!(e in t))&&ii(t,e,n)}function Qn(t,e,n){var i=t[e];Nt.call(t,e)&&zo(i,n)&&(n!==r||e in t)||ii(t,e,n)}function ti(t,e){for(var n=t.length;n--;)if(zo(t[n][0],e))return n;return-1}function ei(t,e,n,i){return hi(t,function(t,r,s){e(i,t,n(t),s)}),i}function ni(t,e){return t&&Ar(e,Pa(e),t)}function ii(t,e,n){"__proto__"==e&&te?te(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}function ri(t,e){for(var n=-1,s=e.length,o=i(s),a=null==t;++n<s;)o[n]=a?r:Ea(t,e[n]);return o}function si(t,e,n){return t==t&&(n!==r&&(t=t<=n?t:n),e!==r&&(t=t>=e?t:e)),t}function oi(t,e,n,i,s,o){var a,l=1&e,c=2&e,h=4&e;if(n&&(a=s?n(t,i,s,o):n(t)),a!==r)return a;if(!Qo(t))return t;var u=Ho(t);if(u){if(a=function(t){var e=t.length,n=new t.constructor(e);return e&&"string"==typeof t[0]&&Nt.call(t,"index")&&(n.index=t.index,n.input=t.input),n}(t),!l)return Tr(t,a)}else{var d=us(t),p=d==x||d==S;if(Yo(t))return xr(t,l);if(d==w||d==m||p&&!s){if(a=c||p?{}:ps(t),!l)return c?function(t,e){return Ar(t,hs(t),e)}(t,function(t,e){return t&&Ar(e,La(e),t)}(a,t)):function(t,e){return Ar(t,cs(t),e)}(t,ni(a,t))}else{if(!se[d])return s?t:{};a=function(t,e,n){var i,r=t.constructor;switch(e){case L:return Sr(t);case _:case y:return new r(+t);case I:return function(t,e){var n=e?Sr(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)}(t,n);case N:case D:case O:case U:case F:case B:case z:case V:case k:return br(t,n);case b:return new r;case M:case C:return new r(t);case T:return function(t){var e=new t.constructor(t.source,dt.exec(t));return e.lastIndex=t.lastIndex,e}(t);case A:return new r;case R:return i=t,Un?wt(Un.call(i)):{}}}(t,d,l)}}o||(o=new Yn);var f=o.get(t);if(f)return f;o.set(t,a),sa(t)?t.forEach(function(i){a.add(oi(i,e,n,i,t,o))}):ea(t)&&t.forEach(function(i,r){a.set(r,oi(i,e,n,r,t,o))});var g=u?r:(h?c?es:ts:c?La:Pa)(t);return Ee(g||t,function(i,r){g&&(i=t[r=i]),Qn(a,r,oi(i,e,n,r,t,o))}),a}function ai(t,e,n){var i=n.length;if(null==t)return!i;for(t=wt(t);i--;){var s=n[i],o=e[s],a=t[s];if(a===r&&!(s in t)||!o(a))return!1}return!0}function li(t,e,n){if("function"!=typeof t)throw new At(s);return As(function(){t.apply(r,n)},e)}function ci(t,e,n,i){var r=-1,s=Re,o=!0,a=t.length,l=[],c=e.length;if(!a)return l;n&&(e=Le(e,$e(n))),i?(s=Pe,o=!1):e.length>=200&&(s=Je,o=!1,e=new Xn(e));t:for(;++r<a;){var h=t[r],u=null==n?h:n(h);if(h=i||0!==h?h:0,o&&u==u){for(var d=c;d--;)if(e[d]===u)continue t;l.push(h)}else s(e,u,i)||l.push(h)}return l}Bn.templateSettings={escape:$,evaluate:Z,interpolate:J,variable:"",imports:{_:Bn}},Bn.prototype=Vn.prototype,Bn.prototype.constructor=Bn,kn.prototype=zn(Vn.prototype),kn.prototype.constructor=kn,Gn.prototype=zn(Vn.prototype),Gn.prototype.constructor=Gn,Hn.prototype.clear=function(){this.__data__=An?An(null):{},this.size=0},Hn.prototype.delete=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e},Hn.prototype.get=function(t){var e=this.__data__;if(An){var n=e[t];return n===o?r:n}return Nt.call(e,t)?e[t]:r},Hn.prototype.has=function(t){var e=this.__data__;return An?e[t]!==r:Nt.call(e,t)},Hn.prototype.set=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=An&&e===r?o:e,this},Wn.prototype.clear=function(){this.__data__=[],this.size=0},Wn.prototype.delete=function(t){var e=this.__data__,n=ti(e,t);return!(n<0||(n==e.length-1?e.pop():Yt.call(e,n,1),--this.size,0))},Wn.prototype.get=function(t){var e=this.__data__,n=ti(e,t);return n<0?r:e[n][1]},Wn.prototype.has=function(t){return ti(this.__data__,t)>-1},Wn.prototype.set=function(t,e){var n=this.__data__,i=ti(n,t);return i<0?(++this.size,n.push([t,e])):n[i][1]=e,this},jn.prototype.clear=function(){this.size=0,this.__data__={hash:new Hn,map:new(Mn||Wn),string:new Hn}},jn.prototype.delete=function(t){var e=os(this,t).delete(t);return this.size-=e?1:0,e},jn.prototype.get=function(t){return os(this,t).get(t)},jn.prototype.has=function(t){return os(this,t).has(t)},jn.prototype.set=function(t,e){var n=os(this,t),i=n.size;return n.set(t,e),this.size+=n.size==i?0:1,this},Xn.prototype.add=Xn.prototype.push=function(t){return this.__data__.set(t,o),this},Xn.prototype.has=function(t){return this.__data__.has(t)},Yn.prototype.clear=function(){this.__data__=new Wn,this.size=0},Yn.prototype.delete=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n},Yn.prototype.get=function(t){return this.__data__.get(t)},Yn.prototype.has=function(t){return this.__data__.has(t)},Yn.prototype.set=function(t,e){var n=this.__data__;if(n instanceof Wn){var i=n.__data__;if(!Mn||i.length<199)return i.push([t,e]),this.size=++n.size,this;n=this.__data__=new jn(i)}return n.set(t,e),this.size=n.size,this};var hi=Pr(yi),ui=Pr(vi,!0);function di(t,e){var n=!0;return hi(t,function(t,i,r){return n=!!e(t,i,r)}),n}function pi(t,e,n){for(var i=-1,s=t.length;++i<s;){var o=t[i],a=e(o);if(null!=a&&(l===r?a==a&&!aa(a):n(a,l)))var l=a,c=o}return c}function fi(t,e){var n=[];return hi(t,function(t,i,r){e(t,i,r)&&n.push(t)}),n}function mi(t,e,n,i,r){var s=-1,o=t.length;for(n||(n=fs),r||(r=[]);++s<o;){var a=t[s];e>0&&n(a)?e>1?mi(a,e-1,n,i,r):Ie(r,a):i||(r[r.length]=a)}return r}var gi=Lr(),_i=Lr(!0);function yi(t,e){return t&&gi(t,e,Pa)}function vi(t,e){return t&&_i(t,e,Pa)}function xi(t,e){return Ce(e,function(e){return Zo(t[e])})}function Si(t,e){for(var n=0,i=(e=gr(e,t)).length;null!=t&&n<i;)t=t[Os(e[n++])];return n&&n==i?t:r}function bi(t,e,n){var i=e(t);return Ho(t)?i:Ie(i,n(t))}function Mi(t){return null==t?t===r?"[object Undefined]":"[object Null]":Kt&&Kt in wt(t)?function(t){var e=Nt.call(t,Kt),n=t[Kt];try{t[Kt]=r;var i=!0}catch(t){}var s=Ut.call(t);return i&&(e?t[Kt]=n:delete t[Kt]),s}(t):function(t){return Ut.call(t)}(t)}function wi(t,e){return t>e}function Ei(t,e){return null!=t&&Nt.call(t,e)}function Ti(t,e){return null!=t&&e in wt(t)}function Ai(t,e,n){for(var s=n?Pe:Re,o=t[0].length,a=t.length,l=a,c=i(a),h=1/0,u=[];l--;){var d=t[l];l&&e&&(d=Le(d,$e(e))),h=_n(d.length,h),c[l]=!n&&(e||o>=120&&d.length>=120)?new Xn(l&&d):r}d=t[0];var p=-1,f=c[0];t:for(;++p<o&&u.length<h;){var m=d[p],g=e?e(m):m;if(m=n||0!==m?m:0,!(f?Je(f,g):s(u,g,n))){for(l=a;--l;){var _=c[l];if(!(_?Je(_,g):s(t[l],g,n)))continue t}f&&f.push(g),u.push(m)}}return u}function Ci(t,e,n){var i=null==(t=ws(t,e=gr(e,t)))?t:t[Os(qs(e))];return null==i?r:Me(i,t,n)}function Ri(t){return ta(t)&&Mi(t)==m}function Pi(t,e,n,i,s){return t===e||(null==t||null==e||!ta(t)&&!ta(e)?t!=t&&e!=e:function(t,e,n,i,s,o){var a=Ho(t),l=Ho(e),c=a?g:us(t),h=l?g:us(e),u=(c=c==m?w:c)==w,d=(h=h==m?w:h)==w,p=c==h;if(p&&Yo(t)){if(!Yo(e))return!1;a=!0,u=!1}if(p&&!u)return o||(o=new Yn),a||la(t)?Kr(t,e,n,i,s,o):function(t,e,n,i,r,s,o){switch(n){case I:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case L:return!(t.byteLength!=e.byteLength||!s(new Gt(t),new Gt(e)));case _:case y:case M:return zo(+t,+e);case v:return t.name==e.name&&t.message==e.message;case T:case C:return t==e+"";case b:var a=sn;case A:var l=1&i;if(a||(a=ln),t.size!=e.size&&!l)return!1;var c=o.get(t);if(c)return c==e;i|=2,o.set(t,e);var h=Kr(a(t),a(e),i,r,s,o);return o.delete(t),h;case R:if(Un)return Un.call(t)==Un.call(e)}return!1}(t,e,c,n,i,s,o);if(!(1&n)){var f=u&&Nt.call(t,"__wrapped__"),x=d&&Nt.call(e,"__wrapped__");if(f||x){var S=f?t.value():t,E=x?e.value():e;return o||(o=new Yn),s(S,E,n,i,o)}}return!!p&&(o||(o=new Yn),function(t,e,n,i,s,o){var a=1&n,l=ts(t),c=l.length;if(c!=ts(e).length&&!a)return!1;for(var h=c;h--;){var u=l[h];if(!(a?u in e:Nt.call(e,u)))return!1}var d=o.get(t),p=o.get(e);if(d&&p)return d==e&&p==t;var f=!0;o.set(t,e),o.set(e,t);for(var m=a;++h<c;){var g=t[u=l[h]],_=e[u];if(i)var y=a?i(_,g,u,e,t,o):i(g,_,u,t,e,o);if(!(y===r?g===_||s(g,_,n,i,o):y)){f=!1;break}m||(m="constructor"==u)}if(f&&!m){var v=t.constructor,x=e.constructor;v==x||!("constructor"in t)||!("constructor"in e)||"function"==typeof v&&v instanceof v&&"function"==typeof x&&x instanceof x||(f=!1)}return o.delete(t),o.delete(e),f}(t,e,n,i,s,o))}(t,e,n,i,Pi,s))}function Li(t,e,n,i){var s=n.length,o=s,a=!i;if(null==t)return!o;for(t=wt(t);s--;){var l=n[s];if(a&&l[2]?l[1]!==t[l[0]]:!(l[0]in t))return!1}for(;++s<o;){var c=(l=n[s])[0],h=t[c],u=l[1];if(a&&l[2]){if(h===r&&!(c in t))return!1}else{var d=new Yn;if(i)var p=i(h,u,c,t,e,d);if(!(p===r?Pi(u,h,3,i,d):p))return!1}}return!0}function Ii(t){return!(!Qo(t)||(e=t,Ot&&Ot in e))&&(Zo(t)?zt:mt).test(Us(t));var e}function Ni(t){return"function"==typeof t?t:null==t?nl:"object"==typeof t?Ho(t)?Bi(t[0],t[1]):Fi(t):ul(t)}function Di(t){if(!xs(t))return mn(t);var e=[];for(var n in wt(t))Nt.call(t,n)&&"constructor"!=n&&e.push(n);return e}function Oi(t,e){return t<e}function Ui(t,e){var n=-1,r=jo(t)?i(t.length):[];return hi(t,function(t,i,s){r[++n]=e(t,i,s)}),r}function Fi(t){var e=as(t);return 1==e.length&&e[0][2]?bs(e[0][0],e[0][1]):function(n){return n===t||Li(n,t,e)}}function Bi(t,e){return _s(t)&&Ss(e)?bs(Os(t),e):function(n){var i=Ea(n,t);return i===r&&i===e?Ta(n,t):Pi(e,i,3)}}function zi(t,e,n,i,s){t!==e&&gi(e,function(o,a){if(s||(s=new Yn),Qo(o))!function(t,e,n,i,s,o,a){var l=Es(t,n),c=Es(e,n),h=a.get(c);if(h)Kn(t,n,h);else{var u=o?o(l,c,n+"",t,e,a):r,d=u===r;if(d){var p=Ho(c),f=!p&&Yo(c),m=!p&&!f&&la(c);u=c,p||f||m?Ho(l)?u=l:Xo(l)?u=Tr(l):f?(d=!1,u=xr(c,!0)):m?(d=!1,u=br(c,!0)):u=[]:ia(c)||Go(c)?(u=l,Go(l)?u=ga(l):Qo(l)&&!Zo(l)||(u=ps(c))):d=!1}d&&(a.set(c,u),s(u,c,i,o,a),a.delete(c)),Kn(t,n,u)}}(t,e,a,n,zi,i,s);else{var l=i?i(Es(t,a),o,a+"",t,e,s):r;l===r&&(l=o),Kn(t,a,l)}},La)}function Vi(t,e){var n=t.length;if(n)return ms(e+=e<0?n:0,n)?t[e]:r}function ki(t,e,n){e=e.length?Le(e,function(t){return Ho(t)?function(e){return Si(e,1===t.length?t[0]:t)}:t}):[nl];var i=-1;e=Le(e,$e(ss()));var r=Ui(t,function(t,n,r){var s=Le(e,function(e){return e(t)});return{criteria:s,index:++i,value:t}});return function(t){var e=t.length;for(t.sort(function(t,e){return function(t,e,n){for(var i=-1,r=t.criteria,s=e.criteria,o=r.length,a=n.length;++i<o;){var l=Mr(r[i],s[i]);if(l)return i>=a?l:l*("desc"==n[i]?-1:1)}return t.index-e.index}(t,e,n)});e--;)t[e]=t[e].value;return t}(r)}function Gi(t,e,n){for(var i=-1,r=e.length,s={};++i<r;){var o=e[i],a=Si(t,o);n(a,o)&&Zi(s,gr(o,t),a)}return s}function Hi(t,e,n,i){var r=i?Ve:ze,s=-1,o=e.length,a=t;for(t===e&&(e=Tr(e)),n&&(a=Le(t,$e(n)));++s<o;)for(var l=0,c=e[s],h=n?n(c):c;(l=r(a,h,l,i))>-1;)a!==t&&Yt.call(a,l,1),Yt.call(t,l,1);return t}function Wi(t,e){for(var n=t?e.length:0,i=n-1;n--;){var r=e[n];if(n==i||r!==s){var s=r;ms(r)?Yt.call(t,r,1):lr(t,r)}}return t}function ji(t,e){return t+pe(xn()*(e-t+1))}function Xi(t,e){var n="";if(!t||e<1||e>u)return n;do{e%2&&(n+=t),(e=pe(e/2))&&(t+=t)}while(e);return n}function Yi(t,e){return Cs(Ms(t,e,nl),t+"")}function qi(t){return $n(za(t))}function $i(t,e){var n=za(t);return Ls(n,si(e,0,n.length))}function Zi(t,e,n,i){if(!Qo(t))return t;for(var s=-1,o=(e=gr(e,t)).length,a=o-1,l=t;null!=l&&++s<o;){var c=Os(e[s]),h=n;if("__proto__"===c||"constructor"===c||"prototype"===c)return t;if(s!=a){var u=l[c];(h=i?i(u,c,l):r)===r&&(h=Qo(u)?u:ms(e[s+1])?[]:{})}Qn(l,c,h),l=l[c]}return t}var Ji=Cn?function(t,e){return Cn.set(t,e),t}:nl,Ki=te?function(t,e){return te(t,"toString",{configurable:!0,enumerable:!1,value:Qa(e),writable:!0})}:nl;function Qi(t){return Ls(za(t))}function tr(t,e,n){var r=-1,s=t.length;e<0&&(e=-e>s?0:s+e),(n=n>s?s:n)<0&&(n+=s),s=e>n?0:n-e>>>0,e>>>=0;for(var o=i(s);++r<s;)o[r]=t[r+e];return o}function er(t,e){var n;return hi(t,function(t,i,r){return!(n=e(t,i,r))}),!!n}function nr(t,e,n){var i=0,r=null==t?i:t.length;if("number"==typeof e&&e==e&&r<=2147483647){for(;i<r;){var s=i+r>>>1,o=t[s];null!==o&&!aa(o)&&(n?o<=e:o<e)?i=s+1:r=s}return r}return ir(t,e,nl,n)}function ir(t,e,n,i){var s=0,o=null==t?0:t.length;if(0===o)return 0;for(var a=(e=n(e))!=e,l=null===e,c=aa(e),h=e===r;s<o;){var u=pe((s+o)/2),d=n(t[u]),p=d!==r,f=null===d,m=d==d,g=aa(d);if(a)var _=i||m;else _=h?m&&(i||p):l?m&&p&&(i||!f):c?m&&p&&!f&&(i||!g):!f&&!g&&(i?d<=e:d<e);_?s=u+1:o=u}return _n(o,4294967294)}function rr(t,e){for(var n=-1,i=t.length,r=0,s=[];++n<i;){var o=t[n],a=e?e(o):o;if(!n||!zo(a,l)){var l=a;s[r++]=0===o?0:o}}return s}function sr(t){return"number"==typeof t?t:aa(t)?d:+t}function or(t){if("string"==typeof t)return t;if(Ho(t))return Le(t,or)+"";if(aa(t))return Fn?Fn.call(t):"";var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}function ar(t,e,n){var i=-1,r=Re,s=t.length,o=!0,a=[],l=a;if(n)o=!1,r=Pe;else if(s>=200){var c=e?null:Xr(t);if(c)return ln(c);o=!1,r=Je,l=new Xn}else l=e?[]:a;t:for(;++i<s;){var h=t[i],u=e?e(h):h;if(h=n||0!==h?h:0,o&&u==u){for(var d=l.length;d--;)if(l[d]===u)continue t;e&&l.push(u),a.push(h)}else r(l,u,n)||(l!==a&&l.push(u),a.push(h))}return a}function lr(t,e){return null==(t=ws(t,e=gr(e,t)))||delete t[Os(qs(e))]}function cr(t,e,n,i){return Zi(t,e,n(Si(t,e)),i)}function hr(t,e,n,i){for(var r=t.length,s=i?r:-1;(i?s--:++s<r)&&e(t[s],s,t););return n?tr(t,i?0:s,i?s+1:r):tr(t,i?s+1:0,i?r:s)}function ur(t,e){var n=t;return n instanceof Gn&&(n=n.value()),Ne(e,function(t,e){return e.func.apply(e.thisArg,Ie([t],e.args))},n)}function dr(t,e,n){var r=t.length;if(r<2)return r?ar(t[0]):[];for(var s=-1,o=i(r);++s<r;)for(var a=t[s],l=-1;++l<r;)l!=s&&(o[s]=ci(o[s]||a,t[l],e,n));return ar(mi(o,1),e,n)}function pr(t,e,n){for(var i=-1,s=t.length,o=e.length,a={};++i<s;){var l=i<o?e[i]:r;n(a,t[i],l)}return a}function fr(t){return Xo(t)?t:[]}function mr(t){return"function"==typeof t?t:nl}function gr(t,e){return Ho(t)?t:_s(t,e)?[t]:Ds(_a(t))}var _r=Yi;function yr(t,e,n){var i=t.length;return n=n===r?i:n,!e&&n>=i?t:tr(t,e,n)}var vr=oe||function(t){return ue.clearTimeout(t)};function xr(t,e){if(e)return t.slice();var n=t.length,i=Ht?Ht(n):new t.constructor(n);return t.copy(i),i}function Sr(t){var e=new t.constructor(t.byteLength);return new Gt(e).set(new Gt(t)),e}function br(t,e){var n=e?Sr(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}function Mr(t,e){if(t!==e){var n=t!==r,i=null===t,s=t==t,o=aa(t),a=e!==r,l=null===e,c=e==e,h=aa(e);if(!l&&!h&&!o&&t>e||o&&a&&c&&!l&&!h||i&&a&&c||!n&&c||!s)return 1;if(!i&&!o&&!h&&t<e||h&&n&&s&&!i&&!o||l&&n&&s||!a&&s||!c)return-1}return 0}function wr(t,e,n,r){for(var s=-1,o=t.length,a=n.length,l=-1,c=e.length,h=gn(o-a,0),u=i(c+h),d=!r;++l<c;)u[l]=e[l];for(;++s<a;)(d||s<o)&&(u[n[s]]=t[s]);for(;h--;)u[l++]=t[s++];return u}function Er(t,e,n,r){for(var s=-1,o=t.length,a=-1,l=n.length,c=-1,h=e.length,u=gn(o-l,0),d=i(u+h),p=!r;++s<u;)d[s]=t[s];for(var f=s;++c<h;)d[f+c]=e[c];for(;++a<l;)(p||s<o)&&(d[f+n[a]]=t[s++]);return d}function Tr(t,e){var n=-1,r=t.length;for(e||(e=i(r));++n<r;)e[n]=t[n];return e}function Ar(t,e,n,i){var s=!n;n||(n={});for(var o=-1,a=e.length;++o<a;){var l=e[o],c=i?i(n[l],t[l],l,n,t):r;c===r&&(c=t[l]),s?ii(n,l,c):Qn(n,l,c)}return n}function Cr(t,e){return function(n,i){var r=Ho(n)?we:ei,s=e?e():{};return r(n,t,ss(i,2),s)}}function Rr(t){return Yi(function(e,n){var i=-1,s=n.length,o=s>1?n[s-1]:r,a=s>2?n[2]:r;for(o=t.length>3&&"function"==typeof o?(s--,o):r,a&&gs(n[0],n[1],a)&&(o=s<3?r:o,s=1),e=wt(e);++i<s;){var l=n[i];l&&t(e,l,i,o)}return e})}function Pr(t,e){return function(n,i){if(null==n)return n;if(!jo(n))return t(n,i);for(var r=n.length,s=e?r:-1,o=wt(n);(e?s--:++s<r)&&!1!==i(o[s],s,o););return n}}function Lr(t){return function(e,n,i){for(var r=-1,s=wt(e),o=i(e),a=o.length;a--;){var l=o[t?a:++r];if(!1===n(s[l],l,s))break}return e}}function Ir(t){return function(e){var n=rn(e=_a(e))?un(e):r,i=n?n[0]:e.charAt(0),s=n?yr(n,1).join(""):e.slice(1);return i[t]()+s}}function Nr(t){return function(e){return Ne(Za(Ga(e).replace(Zt,"")),t,"")}}function Dr(t){return function(){var e=arguments;switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3]);case 5:return new t(e[0],e[1],e[2],e[3],e[4]);case 6:return new t(e[0],e[1],e[2],e[3],e[4],e[5]);case 7:return new t(e[0],e[1],e[2],e[3],e[4],e[5],e[6])}var n=zn(t.prototype),i=t.apply(n,e);return Qo(i)?i:n}}function Or(t){return function(e,n,i){var s=wt(e);if(!jo(e)){var o=ss(n,3);e=Pa(e),n=function(t){return o(s[t],t,s)}}var a=t(e,n,i);return a>-1?s[o?e[a]:a]:r}}function Ur(t){return Qr(function(e){var n=e.length,i=n,o=kn.prototype.thru;for(t&&e.reverse();i--;){var a=e[i];if("function"!=typeof a)throw new At(s);if(o&&!l&&"wrapper"==is(a))var l=new kn([],!0)}for(i=l?i:n;++i<n;){var c=is(a=e[i]),h="wrapper"==c?ns(a):r;l=h&&ys(h[0])&&424==h[1]&&!h[4].length&&1==h[9]?l[is(h[0])].apply(l,h[3]):1==a.length&&ys(a)?l[c]():l.thru(a)}return function(){var t=arguments,i=t[0];if(l&&1==t.length&&Ho(i))return l.plant(i).value();for(var r=0,s=n?e[r].apply(this,t):i;++r<n;)s=e[r].call(this,s);return s}})}function Fr(t,e,n,s,o,a,l,h,u,d){var p=e&c,f=1&e,m=2&e,g=24&e,_=512&e,y=m?r:Dr(t);return function c(){for(var v=arguments.length,x=i(v),S=v;S--;)x[S]=arguments[S];if(g)var b=rs(c),M=function(t,e){for(var n=t.length,i=0;n--;)t[n]===e&&++i;return i}(x,b);if(s&&(x=wr(x,s,o,g)),a&&(x=Er(x,a,l,g)),v-=M,g&&v<d){var w=an(x,b);return Wr(t,e,Fr,c.placeholder,n,x,w,h,u,d-v)}var E=f?n:this,T=m?E[t]:t;return v=x.length,h?x=function(t,e){for(var n=t.length,i=_n(e.length,n),s=Tr(t);i--;){var o=e[i];t[i]=ms(o,n)?s[o]:r}return t}(x,h):_&&v>1&&x.reverse(),p&&u<v&&(x.length=u),this&&this!==ue&&this instanceof c&&(T=y||Dr(T)),T.apply(E,x)}}function Br(t,e){return function(n,i){return function(t,e,n,i){return yi(t,function(t,r,s){e(i,n(t),r,s)}),i}(n,t,e(i),{})}}function zr(t,e){return function(n,i){var s;if(n===r&&i===r)return e;if(n!==r&&(s=n),i!==r){if(s===r)return i;"string"==typeof n||"string"==typeof i?(n=or(n),i=or(i)):(n=sr(n),i=sr(i)),s=t(n,i)}return s}}function Vr(t){return Qr(function(e){return e=Le(e,$e(ss())),Yi(function(n){var i=this;return t(e,function(t){return Me(t,i,n)})})})}function kr(t,e){var n=(e=e===r?" ":or(e)).length;if(n<2)return n?Xi(e,t):e;var i=Xi(e,de(t/hn(e)));return rn(e)?yr(un(i),0,t).join(""):i.slice(0,t)}function Gr(t){return function(e,n,s){return s&&"number"!=typeof s&&gs(e,n,s)&&(n=s=r),e=da(e),n===r?(n=e,e=0):n=da(n),function(t,e,n,r){for(var s=-1,o=gn(de((e-t)/(n||1)),0),a=i(o);o--;)a[r?o:++s]=t,t+=n;return a}(e,n,s=s===r?e<n?1:-1:da(s),t)}}function Hr(t){return function(e,n){return"string"==typeof e&&"string"==typeof n||(e=ma(e),n=ma(n)),t(e,n)}}function Wr(t,e,n,i,s,o,a,c,h,u){var d=8&e;e|=d?l:64,4&(e&=~(d?64:l))||(e&=-4);var p=[t,e,s,d?o:r,d?a:r,d?r:o,d?r:a,c,h,u],f=n.apply(r,p);return ys(t)&&Ts(f,p),f.placeholder=i,Rs(f,t,e)}function jr(t){var e=Mt[t];return function(t,n){if(t=ma(t),(n=null==n?0:_n(pa(n),292))&&Ue(t)){var i=(_a(t)+"e").split("e");return+((i=(_a(e(i[0]+"e"+(+i[1]+n)))+"e").split("e"))[0]+"e"+(+i[1]-n))}return e(t)}}var Xr=En&&1/ln(new En([,-0]))[1]==h?function(t){return new En(t)}:al;function Yr(t){return function(e){var n=us(e);return n==b?sn(e):n==A?cn(e):function(t,e){return Le(e,function(e){return[e,t[e]]})}(e,t(e))}}function qr(t,e,n,o,h,u,d,p){var f=2&e;if(!f&&"function"!=typeof t)throw new At(s);var m=o?o.length:0;if(m||(e&=-97,o=h=r),d=d===r?d:gn(pa(d),0),p=p===r?p:pa(p),m-=h?h.length:0,64&e){var g=o,_=h;o=h=r}var y=f?r:ns(t),v=[t,e,n,o,h,g,_,u,d,p];if(y&&function(t,e){var n=t[1],i=e[1],r=n|i,s=r<131,o=i==c&&8==n||i==c&&256==n&&t[7].length<=e[8]||384==i&&e[7].length<=e[8]&&8==n;if(!s&&!o)return t;1&i&&(t[2]=e[2],r|=1&n?0:4);var l=e[3];if(l){var h=t[3];t[3]=h?wr(h,l,e[4]):l,t[4]=h?an(t[3],a):e[4]}(l=e[5])&&(h=t[5],t[5]=h?Er(h,l,e[6]):l,t[6]=h?an(t[5],a):e[6]),(l=e[7])&&(t[7]=l),i&c&&(t[8]=null==t[8]?e[8]:_n(t[8],e[8])),null==t[9]&&(t[9]=e[9]),t[0]=e[0],t[1]=r}(v,y),t=v[0],e=v[1],n=v[2],o=v[3],h=v[4],!(p=v[9]=v[9]===r?f?0:t.length:gn(v[9]-m,0))&&24&e&&(e&=-25),e&&1!=e)x=8==e||16==e?function(t,e,n){var s=Dr(t);return function o(){for(var a=arguments.length,l=i(a),c=a,h=rs(o);c--;)l[c]=arguments[c];var u=a<3&&l[0]!==h&&l[a-1]!==h?[]:an(l,h);return(a-=u.length)<n?Wr(t,e,Fr,o.placeholder,r,l,u,r,r,n-a):Me(this&&this!==ue&&this instanceof o?s:t,this,l)}}(t,e,p):e!=l&&33!=e||h.length?Fr.apply(r,v):function(t,e,n,r){var s=1&e,o=Dr(t);return function e(){for(var a=-1,l=arguments.length,c=-1,h=r.length,u=i(h+l),d=this&&this!==ue&&this instanceof e?o:t;++c<h;)u[c]=r[c];for(;l--;)u[c++]=arguments[++a];return Me(d,s?n:this,u)}}(t,e,n,o);else var x=function(t,e,n){var i=1&e,r=Dr(t);return function e(){return(this&&this!==ue&&this instanceof e?r:t).apply(i?n:this,arguments)}}(t,e,n);return Rs((y?Ji:Ts)(x,v),t,e)}function $r(t,e,n,i){return t===r||zo(t,Pt[n])&&!Nt.call(i,n)?e:t}function Zr(t,e,n,i,s,o){return Qo(t)&&Qo(e)&&(o.set(e,t),zi(t,e,r,Zr,o),o.delete(e)),t}function Jr(t){return ia(t)?r:t}function Kr(t,e,n,i,s,o){var a=1&n,l=t.length,c=e.length;if(l!=c&&!(a&&c>l))return!1;var h=o.get(t),u=o.get(e);if(h&&u)return h==e&&u==t;var d=-1,p=!0,f=2&n?new Xn:r;for(o.set(t,e),o.set(e,t);++d<l;){var m=t[d],g=e[d];if(i)var _=a?i(g,m,d,e,t,o):i(m,g,d,t,e,o);if(_!==r){if(_)continue;p=!1;break}if(f){if(!Oe(e,function(t,e){if(!Je(f,e)&&(m===t||s(m,t,n,i,o)))return f.push(e)})){p=!1;break}}else if(m!==g&&!s(m,g,n,i,o)){p=!1;break}}return o.delete(t),o.delete(e),p}function Qr(t){return Cs(Ms(t,r,Hs),t+"")}function ts(t){return bi(t,Pa,cs)}function es(t){return bi(t,La,hs)}var ns=Cn?function(t){return Cn.get(t)}:al;function is(t){for(var e=t.name+"",n=Rn[e],i=Nt.call(Rn,e)?n.length:0;i--;){var r=n[i],s=r.func;if(null==s||s==t)return r.name}return e}function rs(t){return(Nt.call(Bn,"placeholder")?Bn:t).placeholder}function ss(){var t=Bn.iteratee||il;return t=t===il?Ni:t,arguments.length?t(arguments[0],arguments[1]):t}function os(t,e){var n,i,r=t.__data__;return("string"==(i=typeof(n=e))||"number"==i||"symbol"==i||"boolean"==i?"__proto__"!==n:null===n)?r["string"==typeof e?"string":"hash"]:r.map}function as(t){for(var e=Pa(t),n=e.length;n--;){var i=e[n],r=t[i];e[n]=[i,r,Ss(r)]}return e}function ls(t,e){var n=function(t,e){return null==t?r:t[e]}(t,e);return Ii(n)?n:r}var cs=me?function(t){return null==t?[]:(t=wt(t),Ce(me(t),function(e){return Xt.call(t,e)}))}:fl,hs=me?function(t){for(var e=[];t;)Ie(e,cs(t)),t=Wt(t);return e}:fl,us=Mi;function ds(t,e,n){for(var i=-1,r=(e=gr(e,t)).length,s=!1;++i<r;){var o=Os(e[i]);if(!(s=null!=t&&n(t,o)))break;t=t[o]}return s||++i!=r?s:!!(r=null==t?0:t.length)&&Ko(r)&&ms(o,r)&&(Ho(t)||Go(t))}function ps(t){return"function"!=typeof t.constructor||xs(t)?{}:zn(Wt(t))}function fs(t){return Ho(t)||Go(t)||!!(qt&&t&&t[qt])}function ms(t,e){var n=typeof t;return!!(e=null==e?u:e)&&("number"==n||"symbol"!=n&&_t.test(t))&&t>-1&&t%1==0&&t<e}function gs(t,e,n){if(!Qo(n))return!1;var i=typeof e;return!!("number"==i?jo(n)&&ms(e,n.length):"string"==i&&e in n)&&zo(n[e],t)}function _s(t,e){if(Ho(t))return!1;var n=typeof t;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!aa(t))||Q.test(t)||!K.test(t)||null!=e&&t in wt(e)}function ys(t){var e=is(t),n=Bn[e];if("function"!=typeof n||!(e in Gn.prototype))return!1;if(t===n)return!0;var i=ns(n);return!!i&&t===i[0]}(bn&&us(new bn(new ArrayBuffer(1)))!=I||Mn&&us(new Mn)!=b||wn&&us(wn.resolve())!=E||En&&us(new En)!=A||Tn&&us(new Tn)!=P)&&(us=function(t){var e=Mi(t),n=e==w?t.constructor:r,i=n?Us(n):"";if(i)switch(i){case Pn:return I;case Ln:return b;case In:return E;case Nn:return A;case Dn:return P}return e});var vs=Lt?Zo:ml;function xs(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||Pt)}function Ss(t){return t==t&&!Qo(t)}function bs(t,e){return function(n){return null!=n&&n[t]===e&&(e!==r||t in wt(n))}}function Ms(t,e,n){return e=gn(e===r?t.length-1:e,0),function(){for(var r=arguments,s=-1,o=gn(r.length-e,0),a=i(o);++s<o;)a[s]=r[e+s];s=-1;for(var l=i(e+1);++s<e;)l[s]=r[s];return l[e]=n(a),Me(t,this,l)}}function ws(t,e){return e.length<2?t:Si(t,tr(e,0,-1))}function Es(t,e){if(("constructor"!==e||"function"!=typeof t[e])&&"__proto__"!=e)return t[e]}var Ts=Ps(Ji),As=he||function(t,e){return ue.setTimeout(t,e)},Cs=Ps(Ki);function Rs(t,e,n){var i=e+"";return Cs(t,function(t,e){var n=e.length;if(!n)return t;var i=n-1;return e[i]=(n>1?"& ":"")+e[i],e=e.join(n>2?", ":" "),t.replace(st,"{\n/* [wrapped with "+e+"] */\n")}(i,function(t,e){return Ee(f,function(n){var i="_."+n[0];e&n[1]&&!Re(t,i)&&t.push(i)}),t.sort()}(function(t){var e=t.match(ot);return e?e[1].split(at):[]}(i),n)))}function Ps(t){var e=0,n=0;return function(){var i=yn(),s=16-(i-n);if(n=i,s>0){if(++e>=800)return arguments[0]}else e=0;return t.apply(r,arguments)}}function Ls(t,e){var n=-1,i=t.length,s=i-1;for(e=e===r?i:e;++n<e;){var o=ji(n,s),a=t[o];t[o]=t[n],t[n]=a}return t.length=e,t}var Is,Ns,Ds=(Is=No(function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(tt,function(t,n,i,r){e.push(i?r.replace(ht,"$1"):n||t)}),e},function(t){return 500===Ns.size&&Ns.clear(),t}),Ns=Is.cache,Is);function Os(t){if("string"==typeof t||aa(t))return t;var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}function Us(t){if(null!=t){try{return It.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function Fs(t){if(t instanceof Gn)return t.clone();var e=new kn(t.__wrapped__,t.__chain__);return e.__actions__=Tr(t.__actions__),e.__index__=t.__index__,e.__values__=t.__values__,e}var Bs=Yi(function(t,e){return Xo(t)?ci(t,mi(e,1,Xo,!0)):[]}),zs=Yi(function(t,e){var n=qs(e);return Xo(n)&&(n=r),Xo(t)?ci(t,mi(e,1,Xo,!0),ss(n,2)):[]}),Vs=Yi(function(t,e){var n=qs(e);return Xo(n)&&(n=r),Xo(t)?ci(t,mi(e,1,Xo,!0),r,n):[]});function ks(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var r=null==n?0:pa(n);return r<0&&(r=gn(i+r,0)),Be(t,ss(e,3),r)}function Gs(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var s=i-1;return n!==r&&(s=pa(n),s=n<0?gn(i+s,0):_n(s,i-1)),Be(t,ss(e,3),s,!0)}function Hs(t){return null!=t&&t.length?mi(t,1):[]}function Ws(t){return t&&t.length?t[0]:r}var js=Yi(function(t){var e=Le(t,fr);return e.length&&e[0]===t[0]?Ai(e):[]}),Xs=Yi(function(t){var e=qs(t),n=Le(t,fr);return e===qs(n)?e=r:n.pop(),n.length&&n[0]===t[0]?Ai(n,ss(e,2)):[]}),Ys=Yi(function(t){var e=qs(t),n=Le(t,fr);return(e="function"==typeof e?e:r)&&n.pop(),n.length&&n[0]===t[0]?Ai(n,r,e):[]});function qs(t){var e=null==t?0:t.length;return e?t[e-1]:r}var $s=Yi(Zs);function Zs(t,e){return t&&t.length&&e&&e.length?Hi(t,e):t}var Js=Qr(function(t,e){var n=null==t?0:t.length,i=ri(t,e);return Wi(t,Le(e,function(t){return ms(t,n)?+t:t}).sort(Mr)),i});function Ks(t){return null==t?t:Sn.call(t)}var Qs=Yi(function(t){return ar(mi(t,1,Xo,!0))}),to=Yi(function(t){var e=qs(t);return Xo(e)&&(e=r),ar(mi(t,1,Xo,!0),ss(e,2))}),eo=Yi(function(t){var e=qs(t);return e="function"==typeof e?e:r,ar(mi(t,1,Xo,!0),r,e)});function no(t){if(!t||!t.length)return[];var e=0;return t=Ce(t,function(t){if(Xo(t))return e=gn(t.length,e),!0}),Ye(e,function(e){return Le(t,He(e))})}function io(t,e){if(!t||!t.length)return[];var n=no(t);return null==e?n:Le(n,function(t){return Me(e,r,t)})}var ro=Yi(function(t,e){return Xo(t)?ci(t,e):[]}),so=Yi(function(t){return dr(Ce(t,Xo))}),oo=Yi(function(t){var e=qs(t);return Xo(e)&&(e=r),dr(Ce(t,Xo),ss(e,2))}),ao=Yi(function(t){var e=qs(t);return e="function"==typeof e?e:r,dr(Ce(t,Xo),r,e)}),lo=Yi(no),co=Yi(function(t){var e=t.length,n=e>1?t[e-1]:r;return n="function"==typeof n?(t.pop(),n):r,io(t,n)});function ho(t){var e=Bn(t);return e.__chain__=!0,e}function uo(t,e){return e(t)}var po=Qr(function(t){var e=t.length,n=e?t[0]:0,i=this.__wrapped__,s=function(e){return ri(e,t)};return!(e>1||this.__actions__.length)&&i instanceof Gn&&ms(n)?((i=i.slice(n,+n+(e?1:0))).__actions__.push({func:uo,args:[s],thisArg:r}),new kn(i,this.__chain__).thru(function(t){return e&&!t.length&&t.push(r),t})):this.thru(s)}),fo=Cr(function(t,e,n){Nt.call(t,n)?++t[n]:ii(t,n,1)}),mo=Or(ks),go=Or(Gs);function _o(t,e){return(Ho(t)?Ee:hi)(t,ss(e,3))}function yo(t,e){return(Ho(t)?Te:ui)(t,ss(e,3))}var vo=Cr(function(t,e,n){Nt.call(t,n)?t[n].push(e):ii(t,n,[e])}),xo=Yi(function(t,e,n){var r=-1,s="function"==typeof e,o=jo(t)?i(t.length):[];return hi(t,function(t){o[++r]=s?Me(e,t,n):Ci(t,e,n)}),o}),So=Cr(function(t,e,n){ii(t,n,e)});function bo(t,e){return(Ho(t)?Le:Ui)(t,ss(e,3))}var Mo=Cr(function(t,e,n){t[n?0:1].push(e)},function(){return[[],[]]}),wo=Yi(function(t,e){if(null==t)return[];var n=e.length;return n>1&&gs(t,e[0],e[1])?e=[]:n>2&&gs(e[0],e[1],e[2])&&(e=[e[0]]),ki(t,mi(e,1),[])}),Eo=ce||function(){return ue.Date.now()};function To(t,e,n){return e=n?r:e,e=t&&null==e?t.length:e,qr(t,c,r,r,r,r,e)}function Ao(t,e){var n;if("function"!=typeof e)throw new At(s);return t=pa(t),function(){return--t>0&&(n=e.apply(this,arguments)),t<=1&&(e=r),n}}var Co=Yi(function(t,e,n){var i=1;if(n.length){var r=an(n,rs(Co));i|=l}return qr(t,i,e,n,r)}),Ro=Yi(function(t,e,n){var i=3;if(n.length){var r=an(n,rs(Ro));i|=l}return qr(e,i,t,n,r)});function Po(t,e,n){var i,o,a,l,c,h,u=0,d=!1,p=!1,f=!0;if("function"!=typeof t)throw new At(s);function m(e){var n=i,s=o;return i=o=r,u=e,l=t.apply(s,n)}function g(t){var n=t-h;return h===r||n>=e||n<0||p&&t-u>=a}function _(){var t=Eo();if(g(t))return y(t);c=As(_,function(t){var n=e-(t-h);return p?_n(n,a-(t-u)):n}(t))}function y(t){return c=r,f&&i?m(t):(i=o=r,l)}function v(){var t=Eo(),n=g(t);if(i=arguments,o=this,h=t,n){if(c===r)return function(t){return u=t,c=As(_,e),d?m(t):l}(h);if(p)return vr(c),c=As(_,e),m(h)}return c===r&&(c=As(_,e)),l}return e=ma(e)||0,Qo(n)&&(d=!!n.leading,a=(p="maxWait"in n)?gn(ma(n.maxWait)||0,e):a,f="trailing"in n?!!n.trailing:f),v.cancel=function(){c!==r&&vr(c),u=0,i=h=o=c=r},v.flush=function(){return c===r?l:y(Eo())},v}var Lo=Yi(function(t,e){return li(t,1,e)}),Io=Yi(function(t,e,n){return li(t,ma(e)||0,n)});function No(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new At(s);var n=function(){var i=arguments,r=e?e.apply(this,i):i[0],s=n.cache;if(s.has(r))return s.get(r);var o=t.apply(this,i);return n.cache=s.set(r,o)||s,o};return n.cache=new(No.Cache||jn),n}function Do(t){if("function"!=typeof t)throw new At(s);return function(){var e=arguments;switch(e.length){case 0:return!t.call(this);case 1:return!t.call(this,e[0]);case 2:return!t.call(this,e[0],e[1]);case 3:return!t.call(this,e[0],e[1],e[2])}return!t.apply(this,e)}}No.Cache=jn;var Oo=_r(function(t,e){var n=(e=1==e.length&&Ho(e[0])?Le(e[0],$e(ss())):Le(mi(e,1),$e(ss()))).length;return Yi(function(i){for(var r=-1,s=_n(i.length,n);++r<s;)i[r]=e[r].call(this,i[r]);return Me(t,this,i)})}),Uo=Yi(function(t,e){var n=an(e,rs(Uo));return qr(t,l,r,e,n)}),Fo=Yi(function(t,e){var n=an(e,rs(Fo));return qr(t,64,r,e,n)}),Bo=Qr(function(t,e){return qr(t,256,r,r,r,e)});function zo(t,e){return t===e||t!=t&&e!=e}var Vo=Hr(wi),ko=Hr(function(t,e){return t>=e}),Go=Ri(function(){return arguments}())?Ri:function(t){return ta(t)&&Nt.call(t,"callee")&&!Xt.call(t,"callee")},Ho=i.isArray,Wo=_e?$e(_e):function(t){return ta(t)&&Mi(t)==L};function jo(t){return null!=t&&Ko(t.length)&&!Zo(t)}function Xo(t){return ta(t)&&jo(t)}var Yo=ge||ml,qo=ye?$e(ye):function(t){return ta(t)&&Mi(t)==y};function $o(t){if(!ta(t))return!1;var e=Mi(t);return e==v||"[object DOMException]"==e||"string"==typeof t.message&&"string"==typeof t.name&&!ia(t)}function Zo(t){if(!Qo(t))return!1;var e=Mi(t);return e==x||e==S||"[object AsyncFunction]"==e||"[object Proxy]"==e}function Jo(t){return"number"==typeof t&&t==pa(t)}function Ko(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=u}function Qo(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}function ta(t){return null!=t&&"object"==typeof t}var ea=ve?$e(ve):function(t){return ta(t)&&us(t)==b};function na(t){return"number"==typeof t||ta(t)&&Mi(t)==M}function ia(t){if(!ta(t)||Mi(t)!=w)return!1;var e=Wt(t);if(null===e)return!0;var n=Nt.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&It.call(n)==Ft}var ra=xe?$e(xe):function(t){return ta(t)&&Mi(t)==T},sa=Se?$e(Se):function(t){return ta(t)&&us(t)==A};function oa(t){return"string"==typeof t||!Ho(t)&&ta(t)&&Mi(t)==C}function aa(t){return"symbol"==typeof t||ta(t)&&Mi(t)==R}var la=be?$e(be):function(t){return ta(t)&&Ko(t.length)&&!!re[Mi(t)]},ca=Hr(Oi),ha=Hr(function(t,e){return t<=e});function ua(t){if(!t)return[];if(jo(t))return oa(t)?un(t):Tr(t);if($t&&t[$t])return function(t){for(var e,n=[];!(e=t.next()).done;)n.push(e.value);return n}(t[$t]());var e=us(t);return(e==b?sn:e==A?ln:za)(t)}function da(t){return t?(t=ma(t))===h||t===-1/0?17976931348623157e292*(t<0?-1:1):t==t?t:0:0===t?t:0}function pa(t){var e=da(t),n=e%1;return e==e?n?e-n:e:0}function fa(t){return t?si(pa(t),0,p):0}function ma(t){if("number"==typeof t)return t;if(aa(t))return d;if(Qo(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=Qo(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=qe(t);var n=ft.test(t);return n||gt.test(t)?le(t.slice(2),n?2:8):pt.test(t)?d:+t}function ga(t){return Ar(t,La(t))}function _a(t){return null==t?"":or(t)}var ya=Rr(function(t,e){if(xs(e)||jo(e))Ar(e,Pa(e),t);else for(var n in e)Nt.call(e,n)&&Qn(t,n,e[n])}),va=Rr(function(t,e){Ar(e,La(e),t)}),xa=Rr(function(t,e,n,i){Ar(e,La(e),t,i)}),Sa=Rr(function(t,e,n,i){Ar(e,Pa(e),t,i)}),ba=Qr(ri),Ma=Yi(function(t,e){t=wt(t);var n=-1,i=e.length,s=i>2?e[2]:r;for(s&&gs(e[0],e[1],s)&&(i=1);++n<i;)for(var o=e[n],a=La(o),l=-1,c=a.length;++l<c;){var h=a[l],u=t[h];(u===r||zo(u,Pt[h])&&!Nt.call(t,h))&&(t[h]=o[h])}return t}),wa=Yi(function(t){return t.push(r,Zr),Me(Na,r,t)});function Ea(t,e,n){var i=null==t?r:Si(t,e);return i===r?n:i}function Ta(t,e){return null!=t&&ds(t,e,Ti)}var Aa=Br(function(t,e,n){null!=e&&"function"!=typeof e.toString&&(e=Ut.call(e)),t[e]=n},Qa(nl)),Ca=Br(function(t,e,n){null!=e&&"function"!=typeof e.toString&&(e=Ut.call(e)),Nt.call(t,e)?t[e].push(n):t[e]=[n]},ss),Ra=Yi(Ci);function Pa(t){return jo(t)?qn(t):Di(t)}function La(t){return jo(t)?qn(t,!0):function(t){if(!Qo(t))return function(t){var e=[];if(null!=t)for(var n in wt(t))e.push(n);return e}(t);var e=xs(t),n=[];for(var i in t)("constructor"!=i||!e&&Nt.call(t,i))&&n.push(i);return n}(t)}var Ia=Rr(function(t,e,n){zi(t,e,n)}),Na=Rr(function(t,e,n,i){zi(t,e,n,i)}),Da=Qr(function(t,e){var n={};if(null==t)return n;var i=!1;e=Le(e,function(e){return e=gr(e,t),i||(i=e.length>1),e}),Ar(t,es(t),n),i&&(n=oi(n,7,Jr));for(var r=e.length;r--;)lr(n,e[r]);return n}),Oa=Qr(function(t,e){return null==t?{}:function(t,e){return Gi(t,e,function(e,n){return Ta(t,n)})}(t,e)});function Ua(t,e){if(null==t)return{};var n=Le(es(t),function(t){return[t]});return e=ss(e),Gi(t,n,function(t,n){return e(t,n[0])})}var Fa=Yr(Pa),Ba=Yr(La);function za(t){return null==t?[]:Ze(t,Pa(t))}var Va=Nr(function(t,e,n){return e=e.toLowerCase(),t+(n?ka(e):e)});function ka(t){return $a(_a(t).toLowerCase())}function Ga(t){return(t=_a(t))&&t.replace(yt,tn).replace(Jt,"")}var Ha=Nr(function(t,e,n){return t+(n?"-":"")+e.toLowerCase()}),Wa=Nr(function(t,e,n){return t+(n?" ":"")+e.toLowerCase()}),ja=Ir("toLowerCase"),Xa=Nr(function(t,e,n){return t+(n?"_":"")+e.toLowerCase()}),Ya=Nr(function(t,e,n){return t+(n?" ":"")+$a(e)}),qa=Nr(function(t,e,n){return t+(n?" ":"")+e.toUpperCase()}),$a=Ir("toUpperCase");function Za(t,e,n){return t=_a(t),(e=n?r:e)===r?function(t){return ee.test(t)}(t)?function(t){return t.match(Qt)||[]}(t):function(t){return t.match(lt)||[]}(t):t.match(e)||[]}var Ja=Yi(function(t,e){try{return Me(t,r,e)}catch(t){return $o(t)?t:new St(t)}}),Ka=Qr(function(t,e){return Ee(e,function(e){e=Os(e),ii(t,e,Co(t[e],t))}),t});function Qa(t){return function(){return t}}var tl=Ur(),el=Ur(!0);function nl(t){return t}function il(t){return Ni("function"==typeof t?t:oi(t,1))}var rl=Yi(function(t,e){return function(n){return Ci(n,t,e)}}),sl=Yi(function(t,e){return function(n){return Ci(t,n,e)}});function ol(t,e,n){var i=Pa(e),r=xi(e,i);null!=n||Qo(e)&&(r.length||!i.length)||(n=e,e=t,t=this,r=xi(e,Pa(e)));var s=!(Qo(n)&&"chain"in n&&!n.chain),o=Zo(t);return Ee(r,function(n){var i=e[n];t[n]=i,o&&(t.prototype[n]=function(){var e=this.__chain__;if(s||e){var n=t(this.__wrapped__);return(n.__actions__=Tr(this.__actions__)).push({func:i,args:arguments,thisArg:t}),n.__chain__=e,n}return i.apply(t,Ie([this.value()],arguments))})}),t}function al(){}var ll=Vr(Le),cl=Vr(Ae),hl=Vr(Oe);function ul(t){return _s(t)?He(Os(t)):function(t){return function(e){return Si(e,t)}}(t)}var dl=Gr(),pl=Gr(!0);function fl(){return[]}function ml(){return!1}var gl,_l=zr(function(t,e){return t+e},0),yl=jr("ceil"),vl=zr(function(t,e){return t/e},1),xl=jr("floor"),Sl=zr(function(t,e){return t*e},1),bl=jr("round"),Ml=zr(function(t,e){return t-e},0);return Bn.after=function(t,e){if("function"!=typeof e)throw new At(s);return t=pa(t),function(){if(--t<1)return e.apply(this,arguments)}},Bn.ary=To,Bn.assign=ya,Bn.assignIn=va,Bn.assignInWith=xa,Bn.assignWith=Sa,Bn.at=ba,Bn.before=Ao,Bn.bind=Co,Bn.bindAll=Ka,Bn.bindKey=Ro,Bn.castArray=function(){if(!arguments.length)return[];var t=arguments[0];return Ho(t)?t:[t]},Bn.chain=ho,Bn.chunk=function(t,e,n){e=(n?gs(t,e,n):e===r)?1:gn(pa(e),0);var s=null==t?0:t.length;if(!s||e<1)return[];for(var o=0,a=0,l=i(de(s/e));o<s;)l[a++]=tr(t,o,o+=e);return l},Bn.compact=function(t){for(var e=-1,n=null==t?0:t.length,i=0,r=[];++e<n;){var s=t[e];s&&(r[i++]=s)}return r},Bn.concat=function(){var t=arguments.length;if(!t)return[];for(var e=i(t-1),n=arguments[0],r=t;r--;)e[r-1]=arguments[r];return Ie(Ho(n)?Tr(n):[n],mi(e,1))},Bn.cond=function(t){var e=null==t?0:t.length,n=ss();return t=e?Le(t,function(t){if("function"!=typeof t[1])throw new At(s);return[n(t[0]),t[1]]}):[],Yi(function(n){for(var i=-1;++i<e;){var r=t[i];if(Me(r[0],this,n))return Me(r[1],this,n)}})},Bn.conforms=function(t){return function(t){var e=Pa(t);return function(n){return ai(n,t,e)}}(oi(t,1))},Bn.constant=Qa,Bn.countBy=fo,Bn.create=function(t,e){var n=zn(t);return null==e?n:ni(n,e)},Bn.curry=function t(e,n,i){var s=qr(e,8,r,r,r,r,r,n=i?r:n);return s.placeholder=t.placeholder,s},Bn.curryRight=function t(e,n,i){var s=qr(e,16,r,r,r,r,r,n=i?r:n);return s.placeholder=t.placeholder,s},Bn.debounce=Po,Bn.defaults=Ma,Bn.defaultsDeep=wa,Bn.defer=Lo,Bn.delay=Io,Bn.difference=Bs,Bn.differenceBy=zs,Bn.differenceWith=Vs,Bn.drop=function(t,e,n){var i=null==t?0:t.length;return i?tr(t,(e=n||e===r?1:pa(e))<0?0:e,i):[]},Bn.dropRight=function(t,e,n){var i=null==t?0:t.length;return i?tr(t,0,(e=i-(e=n||e===r?1:pa(e)))<0?0:e):[]},Bn.dropRightWhile=function(t,e){return t&&t.length?hr(t,ss(e,3),!0,!0):[]},Bn.dropWhile=function(t,e){return t&&t.length?hr(t,ss(e,3),!0):[]},Bn.fill=function(t,e,n,i){var s=null==t?0:t.length;return s?(n&&"number"!=typeof n&&gs(t,e,n)&&(n=0,i=s),function(t,e,n,i){var s=t.length;for((n=pa(n))<0&&(n=-n>s?0:s+n),(i=i===r||i>s?s:pa(i))<0&&(i+=s),i=n>i?0:fa(i);n<i;)t[n++]=e;return t}(t,e,n,i)):[]},Bn.filter=function(t,e){return(Ho(t)?Ce:fi)(t,ss(e,3))},Bn.flatMap=function(t,e){return mi(bo(t,e),1)},Bn.flatMapDeep=function(t,e){return mi(bo(t,e),h)},Bn.flatMapDepth=function(t,e,n){return n=n===r?1:pa(n),mi(bo(t,e),n)},Bn.flatten=Hs,Bn.flattenDeep=function(t){return null!=t&&t.length?mi(t,h):[]},Bn.flattenDepth=function(t,e){return null!=t&&t.length?mi(t,e=e===r?1:pa(e)):[]},Bn.flip=function(t){return qr(t,512)},Bn.flow=tl,Bn.flowRight=el,Bn.fromPairs=function(t){for(var e=-1,n=null==t?0:t.length,i={};++e<n;){var r=t[e];i[r[0]]=r[1]}return i},Bn.functions=function(t){return null==t?[]:xi(t,Pa(t))},Bn.functionsIn=function(t){return null==t?[]:xi(t,La(t))},Bn.groupBy=vo,Bn.initial=function(t){return null!=t&&t.length?tr(t,0,-1):[]},Bn.intersection=js,Bn.intersectionBy=Xs,Bn.intersectionWith=Ys,Bn.invert=Aa,Bn.invertBy=Ca,Bn.invokeMap=xo,Bn.iteratee=il,Bn.keyBy=So,Bn.keys=Pa,Bn.keysIn=La,Bn.map=bo,Bn.mapKeys=function(t,e){var n={};return e=ss(e,3),yi(t,function(t,i,r){ii(n,e(t,i,r),t)}),n},Bn.mapValues=function(t,e){var n={};return e=ss(e,3),yi(t,function(t,i,r){ii(n,i,e(t,i,r))}),n},Bn.matches=function(t){return Fi(oi(t,1))},Bn.matchesProperty=function(t,e){return Bi(t,oi(e,1))},Bn.memoize=No,Bn.merge=Ia,Bn.mergeWith=Na,Bn.method=rl,Bn.methodOf=sl,Bn.mixin=ol,Bn.negate=Do,Bn.nthArg=function(t){return t=pa(t),Yi(function(e){return Vi(e,t)})},Bn.omit=Da,Bn.omitBy=function(t,e){return Ua(t,Do(ss(e)))},Bn.once=function(t){return Ao(2,t)},Bn.orderBy=function(t,e,n,i){return null==t?[]:(Ho(e)||(e=null==e?[]:[e]),Ho(n=i?r:n)||(n=null==n?[]:[n]),ki(t,e,n))},Bn.over=ll,Bn.overArgs=Oo,Bn.overEvery=cl,Bn.overSome=hl,Bn.partial=Uo,Bn.partialRight=Fo,Bn.partition=Mo,Bn.pick=Oa,Bn.pickBy=Ua,Bn.property=ul,Bn.propertyOf=function(t){return function(e){return null==t?r:Si(t,e)}},Bn.pull=$s,Bn.pullAll=Zs,Bn.pullAllBy=function(t,e,n){return t&&t.length&&e&&e.length?Hi(t,e,ss(n,2)):t},Bn.pullAllWith=function(t,e,n){return t&&t.length&&e&&e.length?Hi(t,e,r,n):t},Bn.pullAt=Js,Bn.range=dl,Bn.rangeRight=pl,Bn.rearg=Bo,Bn.reject=function(t,e){return(Ho(t)?Ce:fi)(t,Do(ss(e,3)))},Bn.remove=function(t,e){var n=[];if(!t||!t.length)return n;var i=-1,r=[],s=t.length;for(e=ss(e,3);++i<s;){var o=t[i];e(o,i,t)&&(n.push(o),r.push(i))}return Wi(t,r),n},Bn.rest=function(t,e){if("function"!=typeof t)throw new At(s);return Yi(t,e=e===r?e:pa(e))},Bn.reverse=Ks,Bn.sampleSize=function(t,e,n){return e=(n?gs(t,e,n):e===r)?1:pa(e),(Ho(t)?Zn:$i)(t,e)},Bn.set=function(t,e,n){return null==t?t:Zi(t,e,n)},Bn.setWith=function(t,e,n,i){return i="function"==typeof i?i:r,null==t?t:Zi(t,e,n,i)},Bn.shuffle=function(t){return(Ho(t)?Jn:Qi)(t)},Bn.slice=function(t,e,n){var i=null==t?0:t.length;return i?(n&&"number"!=typeof n&&gs(t,e,n)?(e=0,n=i):(e=null==e?0:pa(e),n=n===r?i:pa(n)),tr(t,e,n)):[]},Bn.sortBy=wo,Bn.sortedUniq=function(t){return t&&t.length?rr(t):[]},Bn.sortedUniqBy=function(t,e){return t&&t.length?rr(t,ss(e,2)):[]},Bn.split=function(t,e,n){return n&&"number"!=typeof n&&gs(t,e,n)&&(e=n=r),(n=n===r?p:n>>>0)?(t=_a(t))&&("string"==typeof e||null!=e&&!ra(e))&&!(e=or(e))&&rn(t)?yr(un(t),0,n):t.split(e,n):[]},Bn.spread=function(t,e){if("function"!=typeof t)throw new At(s);return e=null==e?0:gn(pa(e),0),Yi(function(n){var i=n[e],r=yr(n,0,e);return i&&Ie(r,i),Me(t,this,r)})},Bn.tail=function(t){var e=null==t?0:t.length;return e?tr(t,1,e):[]},Bn.take=function(t,e,n){return t&&t.length?tr(t,0,(e=n||e===r?1:pa(e))<0?0:e):[]},Bn.takeRight=function(t,e,n){var i=null==t?0:t.length;return i?tr(t,(e=i-(e=n||e===r?1:pa(e)))<0?0:e,i):[]},Bn.takeRightWhile=function(t,e){return t&&t.length?hr(t,ss(e,3),!1,!0):[]},Bn.takeWhile=function(t,e){return t&&t.length?hr(t,ss(e,3)):[]},Bn.tap=function(t,e){return e(t),t},Bn.throttle=function(t,e,n){var i=!0,r=!0;if("function"!=typeof t)throw new At(s);return Qo(n)&&(i="leading"in n?!!n.leading:i,r="trailing"in n?!!n.trailing:r),Po(t,e,{leading:i,maxWait:e,trailing:r})},Bn.thru=uo,Bn.toArray=ua,Bn.toPairs=Fa,Bn.toPairsIn=Ba,Bn.toPath=function(t){return Ho(t)?Le(t,Os):aa(t)?[t]:Tr(Ds(_a(t)))},Bn.toPlainObject=ga,Bn.transform=function(t,e,n){var i=Ho(t),r=i||Yo(t)||la(t);if(e=ss(e,4),null==n){var s=t&&t.constructor;n=r?i?new s:[]:Qo(t)&&Zo(s)?zn(Wt(t)):{}}return(r?Ee:yi)(t,function(t,i,r){return e(n,t,i,r)}),n},Bn.unary=function(t){return To(t,1)},Bn.union=Qs,Bn.unionBy=to,Bn.unionWith=eo,Bn.uniq=function(t){return t&&t.length?ar(t):[]},Bn.uniqBy=function(t,e){return t&&t.length?ar(t,ss(e,2)):[]},Bn.uniqWith=function(t,e){return e="function"==typeof e?e:r,t&&t.length?ar(t,r,e):[]},Bn.unset=function(t,e){return null==t||lr(t,e)},Bn.unzip=no,Bn.unzipWith=io,Bn.update=function(t,e,n){return null==t?t:cr(t,e,mr(n))},Bn.updateWith=function(t,e,n,i){return i="function"==typeof i?i:r,null==t?t:cr(t,e,mr(n),i)},Bn.values=za,Bn.valuesIn=function(t){return null==t?[]:Ze(t,La(t))},Bn.without=ro,Bn.words=Za,Bn.wrap=function(t,e){return Uo(mr(e),t)},Bn.xor=so,Bn.xorBy=oo,Bn.xorWith=ao,Bn.zip=lo,Bn.zipObject=function(t,e){return pr(t||[],e||[],Qn)},Bn.zipObjectDeep=function(t,e){return pr(t||[],e||[],Zi)},Bn.zipWith=co,Bn.entries=Fa,Bn.entriesIn=Ba,Bn.extend=va,Bn.extendWith=xa,ol(Bn,Bn),Bn.add=_l,Bn.attempt=Ja,Bn.camelCase=Va,Bn.capitalize=ka,Bn.ceil=yl,Bn.clamp=function(t,e,n){return n===r&&(n=e,e=r),n!==r&&(n=(n=ma(n))==n?n:0),e!==r&&(e=(e=ma(e))==e?e:0),si(ma(t),e,n)},Bn.clone=function(t){return oi(t,4)},Bn.cloneDeep=function(t){return oi(t,5)},Bn.cloneDeepWith=function(t,e){return oi(t,5,e="function"==typeof e?e:r)},Bn.cloneWith=function(t,e){return oi(t,4,e="function"==typeof e?e:r)},Bn.conformsTo=function(t,e){return null==e||ai(t,e,Pa(e))},Bn.deburr=Ga,Bn.defaultTo=function(t,e){return null==t||t!=t?e:t},Bn.divide=vl,Bn.endsWith=function(t,e,n){t=_a(t),e=or(e);var i=t.length,s=n=n===r?i:si(pa(n),0,i);return(n-=e.length)>=0&&t.slice(n,s)==e},Bn.eq=zo,Bn.escape=function(t){return(t=_a(t))&&q.test(t)?t.replace(X,en):t},Bn.escapeRegExp=function(t){return(t=_a(t))&&nt.test(t)?t.replace(et,"\\$&"):t},Bn.every=function(t,e,n){var i=Ho(t)?Ae:di;return n&&gs(t,e,n)&&(e=r),i(t,ss(e,3))},Bn.find=mo,Bn.findIndex=ks,Bn.findKey=function(t,e){return Fe(t,ss(e,3),yi)},Bn.findLast=go,Bn.findLastIndex=Gs,Bn.findLastKey=function(t,e){return Fe(t,ss(e,3),vi)},Bn.floor=xl,Bn.forEach=_o,Bn.forEachRight=yo,Bn.forIn=function(t,e){return null==t?t:gi(t,ss(e,3),La)},Bn.forInRight=function(t,e){return null==t?t:_i(t,ss(e,3),La)},Bn.forOwn=function(t,e){return t&&yi(t,ss(e,3))},Bn.forOwnRight=function(t,e){return t&&vi(t,ss(e,3))},Bn.get=Ea,Bn.gt=Vo,Bn.gte=ko,Bn.has=function(t,e){return null!=t&&ds(t,e,Ei)},Bn.hasIn=Ta,Bn.head=Ws,Bn.identity=nl,Bn.includes=function(t,e,n,i){t=jo(t)?t:za(t),n=n&&!i?pa(n):0;var r=t.length;return n<0&&(n=gn(r+n,0)),oa(t)?n<=r&&t.indexOf(e,n)>-1:!!r&&ze(t,e,n)>-1},Bn.indexOf=function(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var r=null==n?0:pa(n);return r<0&&(r=gn(i+r,0)),ze(t,e,r)},Bn.inRange=function(t,e,n){return e=da(e),n===r?(n=e,e=0):n=da(n),function(t,e,n){return t>=_n(e,n)&&t<gn(e,n)}(t=ma(t),e,n)},Bn.invoke=Ra,Bn.isArguments=Go,Bn.isArray=Ho,Bn.isArrayBuffer=Wo,Bn.isArrayLike=jo,Bn.isArrayLikeObject=Xo,Bn.isBoolean=function(t){return!0===t||!1===t||ta(t)&&Mi(t)==_},Bn.isBuffer=Yo,Bn.isDate=qo,Bn.isElement=function(t){return ta(t)&&1===t.nodeType&&!ia(t)},Bn.isEmpty=function(t){if(null==t)return!0;if(jo(t)&&(Ho(t)||"string"==typeof t||"function"==typeof t.splice||Yo(t)||la(t)||Go(t)))return!t.length;var e=us(t);if(e==b||e==A)return!t.size;if(xs(t))return!Di(t).length;for(var n in t)if(Nt.call(t,n))return!1;return!0},Bn.isEqual=function(t,e){return Pi(t,e)},Bn.isEqualWith=function(t,e,n){var i=(n="function"==typeof n?n:r)?n(t,e):r;return i===r?Pi(t,e,r,n):!!i},Bn.isError=$o,Bn.isFinite=function(t){return"number"==typeof t&&Ue(t)},Bn.isFunction=Zo,Bn.isInteger=Jo,Bn.isLength=Ko,Bn.isMap=ea,Bn.isMatch=function(t,e){return t===e||Li(t,e,as(e))},Bn.isMatchWith=function(t,e,n){return n="function"==typeof n?n:r,Li(t,e,as(e),n)},Bn.isNaN=function(t){return na(t)&&t!=+t},Bn.isNative=function(t){if(vs(t))throw new St("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");return Ii(t)},Bn.isNil=function(t){return null==t},Bn.isNull=function(t){return null===t},Bn.isNumber=na,Bn.isObject=Qo,Bn.isObjectLike=ta,Bn.isPlainObject=ia,Bn.isRegExp=ra,Bn.isSafeInteger=function(t){return Jo(t)&&t>=-9007199254740991&&t<=u},Bn.isSet=sa,Bn.isString=oa,Bn.isSymbol=aa,Bn.isTypedArray=la,Bn.isUndefined=function(t){return t===r},Bn.isWeakMap=function(t){return ta(t)&&us(t)==P},Bn.isWeakSet=function(t){return ta(t)&&"[object WeakSet]"==Mi(t)},Bn.join=function(t,e){return null==t?"":We.call(t,e)},Bn.kebabCase=Ha,Bn.last=qs,Bn.lastIndexOf=function(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var s=i;return n!==r&&(s=(s=pa(n))<0?gn(i+s,0):_n(s,i-1)),e==e?function(t,e,n){for(var i=n+1;i--;)if(t[i]===e)return i;return i}(t,e,s):Be(t,ke,s,!0)},Bn.lowerCase=Wa,Bn.lowerFirst=ja,Bn.lt=ca,Bn.lte=ha,Bn.max=function(t){return t&&t.length?pi(t,nl,wi):r},Bn.maxBy=function(t,e){return t&&t.length?pi(t,ss(e,2),wi):r},Bn.mean=function(t){return Ge(t,nl)},Bn.meanBy=function(t,e){return Ge(t,ss(e,2))},Bn.min=function(t){return t&&t.length?pi(t,nl,Oi):r},Bn.minBy=function(t,e){return t&&t.length?pi(t,ss(e,2),Oi):r},Bn.stubArray=fl,Bn.stubFalse=ml,Bn.stubObject=function(){return{}},Bn.stubString=function(){return""},Bn.stubTrue=function(){return!0},Bn.multiply=Sl,Bn.nth=function(t,e){return t&&t.length?Vi(t,pa(e)):r},Bn.noConflict=function(){return ue._===this&&(ue._=Bt),this},Bn.noop=al,Bn.now=Eo,Bn.pad=function(t,e,n){t=_a(t);var i=(e=pa(e))?hn(t):0;if(!e||i>=e)return t;var r=(e-i)/2;return kr(pe(r),n)+t+kr(de(r),n)},Bn.padEnd=function(t,e,n){t=_a(t);var i=(e=pa(e))?hn(t):0;return e&&i<e?t+kr(e-i,n):t},Bn.padStart=function(t,e,n){t=_a(t);var i=(e=pa(e))?hn(t):0;return e&&i<e?kr(e-i,n)+t:t},Bn.parseInt=function(t,e,n){return n||null==e?e=0:e&&(e=+e),vn(_a(t).replace(it,""),e||0)},Bn.random=function(t,e,n){if(n&&"boolean"!=typeof n&&gs(t,e,n)&&(e=n=r),n===r&&("boolean"==typeof e?(n=e,e=r):"boolean"==typeof t&&(n=t,t=r)),t===r&&e===r?(t=0,e=1):(t=da(t),e===r?(e=t,t=0):e=da(e)),t>e){var i=t;t=e,e=i}if(n||t%1||e%1){var s=xn();return _n(t+s*(e-t+ae("1e-"+((s+"").length-1))),e)}return ji(t,e)},Bn.reduce=function(t,e,n){var i=Ho(t)?Ne:je,r=arguments.length<3;return i(t,ss(e,4),n,r,hi)},Bn.reduceRight=function(t,e,n){var i=Ho(t)?De:je,r=arguments.length<3;return i(t,ss(e,4),n,r,ui)},Bn.repeat=function(t,e,n){return e=(n?gs(t,e,n):e===r)?1:pa(e),Xi(_a(t),e)},Bn.replace=function(){var t=arguments,e=_a(t[0]);return t.length<3?e:e.replace(t[1],t[2])},Bn.result=function(t,e,n){var i=-1,s=(e=gr(e,t)).length;for(s||(s=1,t=r);++i<s;){var o=null==t?r:t[Os(e[i])];o===r&&(i=s,o=n),t=Zo(o)?o.call(t):o}return t},Bn.round=bl,Bn.runInContext=t,Bn.sample=function(t){return(Ho(t)?$n:qi)(t)},Bn.size=function(t){if(null==t)return 0;if(jo(t))return oa(t)?hn(t):t.length;var e=us(t);return e==b||e==A?t.size:Di(t).length},Bn.snakeCase=Xa,Bn.some=function(t,e,n){var i=Ho(t)?Oe:er;return n&&gs(t,e,n)&&(e=r),i(t,ss(e,3))},Bn.sortedIndex=function(t,e){return nr(t,e)},Bn.sortedIndexBy=function(t,e,n){return ir(t,e,ss(n,2))},Bn.sortedIndexOf=function(t,e){var n=null==t?0:t.length;if(n){var i=nr(t,e);if(i<n&&zo(t[i],e))return i}return-1},Bn.sortedLastIndex=function(t,e){return nr(t,e,!0)},Bn.sortedLastIndexBy=function(t,e,n){return ir(t,e,ss(n,2),!0)},Bn.sortedLastIndexOf=function(t,e){if(null!=t&&t.length){var n=nr(t,e,!0)-1;if(zo(t[n],e))return n}return-1},Bn.startCase=Ya,Bn.startsWith=function(t,e,n){return t=_a(t),n=null==n?0:si(pa(n),0,t.length),e=or(e),t.slice(n,n+e.length)==e},Bn.subtract=Ml,Bn.sum=function(t){return t&&t.length?Xe(t,nl):0},Bn.sumBy=function(t,e){return t&&t.length?Xe(t,ss(e,2)):0},Bn.template=function(t,e,n){var i=Bn.templateSettings;n&&gs(t,e,n)&&(e=r),t=_a(t),e=xa({},e,i,$r);var s,o,a=xa({},e.imports,i.imports,$r),l=Pa(a),c=Ze(a,l),h=0,u=e.interpolate||vt,d="__p += '",p=Et((e.escape||vt).source+"|"+u.source+"|"+(u===J?ut:vt).source+"|"+(e.evaluate||vt).source+"|$","g"),f="//# sourceURL="+(Nt.call(e,"sourceURL")?(e.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++ie+"]")+"\n";t.replace(p,function(e,n,i,r,a,l){return i||(i=r),d+=t.slice(h,l).replace(xt,nn),n&&(s=!0,d+="' +\n__e("+n+") +\n'"),a&&(o=!0,d+="';\n"+a+";\n__p += '"),i&&(d+="' +\n((__t = ("+i+")) == null ? '' : __t) +\n'"),h=l+e.length,e}),d+="';\n";var m=Nt.call(e,"variable")&&e.variable;if(m){if(ct.test(m))throw new St("Invalid `variable` option passed into `_.template`")}else d="with (obj) {\n"+d+"\n}\n";d=(o?d.replace(G,""):d).replace(H,"$1").replace(W,"$1;"),d="function("+(m||"obj")+") {\n"+(m?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(s?", __e = _.escape":"")+(o?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+d+"return __p\n}";var g=Ja(function(){return bt(l,f+"return "+d).apply(r,c)});if(g.source=d,$o(g))throw g;return g},Bn.times=function(t,e){if((t=pa(t))<1||t>u)return[];var n=p,i=_n(t,p);e=ss(e),t-=p;for(var r=Ye(i,e);++n<t;)e(n);return r},Bn.toFinite=da,Bn.toInteger=pa,Bn.toLength=fa,Bn.toLower=function(t){return _a(t).toLowerCase()},Bn.toNumber=ma,Bn.toSafeInteger=function(t){return t?si(pa(t),-9007199254740991,u):0===t?t:0},Bn.toString=_a,Bn.toUpper=function(t){return _a(t).toUpperCase()},Bn.trim=function(t,e,n){if((t=_a(t))&&(n||e===r))return qe(t);if(!t||!(e=or(e)))return t;var i=un(t),s=un(e);return yr(i,Ke(i,s),Qe(i,s)+1).join("")},Bn.trimEnd=function(t,e,n){if((t=_a(t))&&(n||e===r))return t.slice(0,dn(t)+1);if(!t||!(e=or(e)))return t;var i=un(t);return yr(i,0,Qe(i,un(e))+1).join("")},Bn.trimStart=function(t,e,n){if((t=_a(t))&&(n||e===r))return t.replace(it,"");if(!t||!(e=or(e)))return t;var i=un(t);return yr(i,Ke(i,un(e))).join("")},Bn.truncate=function(t,e){var n=30,i="...";if(Qo(e)){var s="separator"in e?e.separator:s;n="length"in e?pa(e.length):n,i="omission"in e?or(e.omission):i}var o=(t=_a(t)).length;if(rn(t)){var a=un(t);o=a.length}if(n>=o)return t;var l=n-hn(i);if(l<1)return i;var c=a?yr(a,0,l).join(""):t.slice(0,l);if(s===r)return c+i;if(a&&(l+=c.length-l),ra(s)){if(t.slice(l).search(s)){var h,u=c;for(s.global||(s=Et(s.source,_a(dt.exec(s))+"g")),s.lastIndex=0;h=s.exec(u);)var d=h.index;c=c.slice(0,d===r?l:d)}}else if(t.indexOf(or(s),l)!=l){var p=c.lastIndexOf(s);p>-1&&(c=c.slice(0,p))}return c+i},Bn.unescape=function(t){return(t=_a(t))&&Y.test(t)?t.replace(j,pn):t},Bn.uniqueId=function(t){var e=++Dt;return _a(t)+e},Bn.upperCase=qa,Bn.upperFirst=$a,Bn.each=_o,Bn.eachRight=yo,Bn.first=Ws,ol(Bn,(gl={},yi(Bn,function(t,e){Nt.call(Bn.prototype,e)||(gl[e]=t)}),gl),{chain:!1}),Bn.VERSION="4.17.21",Ee(["bind","bindKey","curry","curryRight","partial","partialRight"],function(t){Bn[t].placeholder=Bn}),Ee(["drop","take"],function(t,e){Gn.prototype[t]=function(n){n=n===r?1:gn(pa(n),0);var i=this.__filtered__&&!e?new Gn(this):this.clone();return i.__filtered__?i.__takeCount__=_n(n,i.__takeCount__):i.__views__.push({size:_n(n,p),type:t+(i.__dir__<0?"Right":"")}),i},Gn.prototype[t+"Right"]=function(e){return this.reverse()[t](e).reverse()}}),Ee(["filter","map","takeWhile"],function(t,e){var n=e+1,i=1==n||3==n;Gn.prototype[t]=function(t){var e=this.clone();return e.__iteratees__.push({iteratee:ss(t,3),type:n}),e.__filtered__=e.__filtered__||i,e}}),Ee(["head","last"],function(t,e){var n="take"+(e?"Right":"");Gn.prototype[t]=function(){return this[n](1).value()[0]}}),Ee(["initial","tail"],function(t,e){var n="drop"+(e?"":"Right");Gn.prototype[t]=function(){return this.__filtered__?new Gn(this):this[n](1)}}),Gn.prototype.compact=function(){return this.filter(nl)},Gn.prototype.find=function(t){return this.filter(t).head()},Gn.prototype.findLast=function(t){return this.reverse().find(t)},Gn.prototype.invokeMap=Yi(function(t,e){return"function"==typeof t?new Gn(this):this.map(function(n){return Ci(n,t,e)})}),Gn.prototype.reject=function(t){return this.filter(Do(ss(t)))},Gn.prototype.slice=function(t,e){t=pa(t);var n=this;return n.__filtered__&&(t>0||e<0)?new Gn(n):(t<0?n=n.takeRight(-t):t&&(n=n.drop(t)),e!==r&&(n=(e=pa(e))<0?n.dropRight(-e):n.take(e-t)),n)},Gn.prototype.takeRightWhile=function(t){return this.reverse().takeWhile(t).reverse()},Gn.prototype.toArray=function(){return this.take(p)},yi(Gn.prototype,function(t,e){var n=/^(?:filter|find|map|reject)|While$/.test(e),i=/^(?:head|last)$/.test(e),s=Bn[i?"take"+("last"==e?"Right":""):e],o=i||/^find/.test(e);s&&(Bn.prototype[e]=function(){var e=this.__wrapped__,a=i?[1]:arguments,l=e instanceof Gn,c=a[0],h=l||Ho(e),u=function(t){var e=s.apply(Bn,Ie([t],a));return i&&d?e[0]:e};h&&n&&"function"==typeof c&&1!=c.length&&(l=h=!1);var d=this.__chain__,p=!!this.__actions__.length,f=o&&!d,m=l&&!p;if(!o&&h){e=m?e:new Gn(this);var g=t.apply(e,a);return g.__actions__.push({func:uo,args:[u],thisArg:r}),new kn(g,d)}return f&&m?t.apply(this,a):(g=this.thru(u),f?i?g.value()[0]:g.value():g)})}),Ee(["pop","push","shift","sort","splice","unshift"],function(t){var e=Ct[t],n=/^(?:push|sort|unshift)$/.test(t)?"tap":"thru",i=/^(?:pop|shift)$/.test(t);Bn.prototype[t]=function(){var t=arguments;if(i&&!this.__chain__){var r=this.value();return e.apply(Ho(r)?r:[],t)}return this[n](function(n){return e.apply(Ho(n)?n:[],t)})}}),yi(Gn.prototype,function(t,e){var n=Bn[e];if(n){var i=n.name+"";Nt.call(Rn,i)||(Rn[i]=[]),Rn[i].push({name:e,func:n})}}),Rn[Fr(r,2).name]=[{name:"wrapper",func:r}],Gn.prototype.clone=function(){var t=new Gn(this.__wrapped__);return t.__actions__=Tr(this.__actions__),t.__dir__=this.__dir__,t.__filtered__=this.__filtered__,t.__iteratees__=Tr(this.__iteratees__),t.__takeCount__=this.__takeCount__,t.__views__=Tr(this.__views__),t},Gn.prototype.reverse=function(){if(this.__filtered__){var t=new Gn(this);t.__dir__=-1,t.__filtered__=!0}else(t=this.clone()).__dir__*=-1;return t},Gn.prototype.value=function(){var t=this.__wrapped__.value(),e=this.__dir__,n=Ho(t),i=e<0,r=n?t.length:0,s=function(t,e,n){for(var i=-1,r=n.length;++i<r;){var s=n[i],o=s.size;switch(s.type){case"drop":t+=o;break;case"dropRight":e-=o;break;case"take":e=_n(e,t+o);break;case"takeRight":t=gn(t,e-o)}}return{start:t,end:e}}(0,r,this.__views__),o=s.start,a=s.end,l=a-o,c=i?a:o-1,h=this.__iteratees__,u=h.length,d=0,p=_n(l,this.__takeCount__);if(!n||!i&&r==l&&p==l)return ur(t,this.__actions__);var f=[];t:for(;l--&&d<p;){for(var m=-1,g=t[c+=e];++m<u;){var _=h[m],y=_.iteratee,v=_.type,x=y(g);if(2==v)g=x;else if(!x){if(1==v)continue t;break t}}f[d++]=g}return f},Bn.prototype.at=po,Bn.prototype.chain=function(){return ho(this)},Bn.prototype.commit=function(){return new kn(this.value(),this.__chain__)},Bn.prototype.next=function(){this.__values__===r&&(this.__values__=ua(this.value()));var t=this.__index__>=this.__values__.length;return{done:t,value:t?r:this.__values__[this.__index__++]}},Bn.prototype.plant=function(t){for(var e,n=this;n instanceof Vn;){var i=Fs(n);i.__index__=0,i.__values__=r,e?s.__wrapped__=i:e=i;var s=i;n=n.__wrapped__}return s.__wrapped__=t,e},Bn.prototype.reverse=function(){var t=this.__wrapped__;if(t instanceof Gn){var e=t;return this.__actions__.length&&(e=new Gn(this)),(e=e.reverse()).__actions__.push({func:uo,args:[Ks],thisArg:r}),new kn(e,this.__chain__)}return this.thru(Ks)},Bn.prototype.toJSON=Bn.prototype.valueOf=Bn.prototype.value=function(){return ur(this.__wrapped__,this.__actions__)},Bn.prototype.first=Bn.prototype.head,$t&&(Bn.prototype[$t]=function(){return this}),Bn}();ue._=fn,(i=function(){return fn}.call(e,n,e,t))===r||(t.exports=i)}.call(this)}},e={};function n(i){var r=e[i];if(void 0!==r)return r.exports;var s=e[i]={id:i,loaded:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t);var i={};(()=>{"use strict";var t={};n.r(t),n.d(t,{ACESFilmicToneMapping:()=>rt,AddEquation:()=>M,AddOperation:()=>Q,AdditiveAnimationBlendMode:()=>Ve,AdditiveBlending:()=>v,AgXToneMapping:()=>ot,AlphaFormat:()=>kt,AlwaysCompare:()=>En,AlwaysDepth:()=>W,AlwaysStencilFunc:()=>_n,AmbientLight:()=>Gh,AnimationAction:()=>Nu,AnimationClip:()=>hh,AnimationLoader:()=>vh,AnimationMixer:()=>Ou,AnimationObjectGroup:()=>Iu,AnimationUtils:()=>Jc,ArcCurve:()=>bl,ArrayCamera:()=>cu,ArrowHelper:()=>Rd,AttachedBindMode:()=>lt,Audio:()=>_u,AudioAnalyser:()=>Mu,AudioContext:()=>iu,AudioListener:()=>gu,AudioLoader:()=>ru,AxesHelper:()=>Pd,BackSide:()=>m,BasicDepthPacking:()=>We,BasicShadowMap:()=>h,BatchedMesh:()=>Na,Bone:()=>Wo,BooleanKeyframeTrack:()=>ih,Box2:()=>Zu,Box3:()=>Oi,Box3Helper:()=>wd,BoxGeometry:()=>Ws,BoxHelper:()=>Md,BufferAttribute:()=>ps,BufferGeometry:()=>Ps,BufferGeometryLoader:()=>$h,ByteType:()=>Pt,Cache:()=>dh,Camera:()=>Zs,CameraHelper:()=>xd,CanvasTexture:()=>al,CapsuleGeometry:()=>cl,CatmullRomCurve3:()=>Cl,CineonToneMapping:()=>it,CircleGeometry:()=>hl,ClampToEdgeWrapping:()=>_t,Clock:()=>hu,Color:()=>ts,ColorKeyframeTrack:()=>rh,ColorManagement:()=>_i,CompressedArrayTexture:()=>sl,CompressedCubeTexture:()=>ol,CompressedTexture:()=>rl,CompressedTextureLoader:()=>xh,ConeGeometry:()=>dl,ConstantAlphaFactor:()=>k,ConstantColorFactor:()=>z,Controls:()=>Id,CubeCamera:()=>no,CubeReflectionMapping:()=>ut,CubeRefractionMapping:()=>dt,CubeTexture:()=>io,CubeTextureLoader:()=>Mh,CubeUVReflectionMapping:()=>mt,CubicBezierCurve:()=>Il,CubicBezierCurve3:()=>Nl,CubicInterpolant:()=>Qc,CullFaceBack:()=>a,CullFaceFront:()=>l,CullFaceFrontBack:()=>c,CullFaceNone:()=>o,Curve:()=>xl,CurvePath:()=>Vl,CustomBlending:()=>b,CustomToneMapping:()=>st,CylinderGeometry:()=>ul,Cylindrical:()=>Yu,Data3DTexture:()=>Ni,DataArrayTexture:()=>Li,DataTexture:()=>jo,DataTextureLoader:()=>wh,DataUtils:()=>cs,DecrementStencilOp:()=>on,DecrementWrapStencilOp:()=>ln,DefaultLoadingManager:()=>fh,DepthFormat:()=>Wt,DepthStencilFormat:()=>jt,DepthTexture:()=>ll,DetachedBindMode:()=>ct,DirectionalLight:()=>kh,DirectionalLightHelper:()=>_d,DiscreteInterpolant:()=>eh,DodecahedronGeometry:()=>fl,DoubleSide:()=>g,DstAlphaFactor:()=>D,DstColorFactor:()=>U,DynamicCopyUsage:()=>Nn,DynamicDrawUsage:()=>An,DynamicReadUsage:()=>Pn,EdgesGeometry:()=>vl,EllipseCurve:()=>Sl,EqualCompare:()=>xn,EqualDepth:()=>Y,EqualStencilFunc:()=>dn,EquirectangularReflectionMapping:()=>pt,EquirectangularRefractionMapping:()=>ft,Euler:()=>yr,EventDispatcher:()=>Gn,ExtrudeGeometry:()=>yc,FileLoader:()=>yh,Float16BufferAttribute:()=>Ss,Float32BufferAttribute:()=>bs,FloatType:()=>Ot,Fog:()=>co,FogExp2:()=>lo,FramebufferTexture:()=>il,FrontSide:()=>f,Frustum:()=>ua,FrustumArray:()=>fa,GLBufferAttribute:()=>ku,GLSL1:()=>On,GLSL3:()=>Un,GreaterCompare:()=>bn,GreaterDepth:()=>$,GreaterEqualCompare:()=>wn,GreaterEqualDepth:()=>q,GreaterEqualStencilFunc:()=>gn,GreaterStencilFunc:()=>fn,GridHelper:()=>dd,Group:()=>so,HalfFloatType:()=>Ut,HemisphereLight:()=>Ah,HemisphereLightHelper:()=>ud,IcosahedronGeometry:()=>xc,ImageBitmapLoader:()=>eu,ImageLoader:()=>bh,ImageUtils:()=>Si,IncrementStencilOp:()=>sn,IncrementWrapStencilOp:()=>an,InstancedBufferAttribute:()=>$o,InstancedBufferGeometry:()=>qh,InstancedInterleavedBuffer:()=>Vu,InstancedMesh:()=>ia,Int16BufferAttribute:()=>_s,Int32BufferAttribute:()=>vs,Int8BufferAttribute:()=>fs,IntType:()=>Nt,InterleavedBuffer:()=>uo,InterleavedBufferAttribute:()=>fo,Interpolant:()=>Kc,InterpolateDiscrete:()=>Ne,InterpolateLinear:()=>De,InterpolateSmooth:()=>Oe,InterpolationSamplingMode:()=>kn,InterpolationSamplingType:()=>Vn,InvertStencilOp:()=>cn,KeepStencilOp:()=>nn,KeyframeTrack:()=>nh,LOD:()=>No,LatheGeometry:()=>Sc,Layers:()=>vr,LessCompare:()=>vn,LessDepth:()=>j,LessEqualCompare:()=>Sn,LessEqualDepth:()=>X,LessEqualStencilFunc:()=>pn,LessStencilFunc:()=>un,Light:()=>Th,LightProbe:()=>jh,Line:()=>Ga,Line3:()=>Qu,LineBasicMaterial:()=>Da,LineCurve:()=>Dl,LineCurve3:()=>Ol,LineDashedMaterial:()=>jc,LineLoop:()=>Ya,LineSegments:()=>Xa,LinearFilter:()=>wt,LinearInterpolant:()=>th,LinearMipMapLinearFilter:()=>Ct,LinearMipMapNearestFilter:()=>Tt,LinearMipmapLinearFilter:()=>At,LinearMipmapNearestFilter:()=>Et,LinearSRGBColorSpace:()=>Ke,LinearToneMapping:()=>et,LinearTransfer:()=>Qe,Loader:()=>mh,LoaderUtils:()=>Yh,LoadingManager:()=>ph,LoopOnce:()=>Pe,LoopPingPong:()=>Ie,LoopRepeat:()=>Le,MOUSE:()=>r,Material:()=>is,MaterialLoader:()=>Xh,MathUtils:()=>Qn,Matrix2:()=>qu,Matrix3:()=>si,Matrix4:()=>lr,MaxEquation:()=>A,Mesh:()=>Gs,MeshBasicMaterial:()=>rs,MeshDepthMaterial:()=>Gc,MeshDistanceMaterial:()=>Hc,MeshLambertMaterial:()=>kc,MeshMatcapMaterial:()=>Wc,MeshNormalMaterial:()=>Vc,MeshPhongMaterial:()=>Bc,MeshPhysicalMaterial:()=>Fc,MeshStandardMaterial:()=>Uc,MeshToonMaterial:()=>zc,MinEquation:()=>T,MirroredRepeatWrapping:()=>yt,MixOperation:()=>K,MultiplyBlending:()=>S,MultiplyOperation:()=>J,NearestFilter:()=>vt,NearestMipMapLinearFilter:()=>Mt,NearestMipMapNearestFilter:()=>St,NearestMipmapLinearFilter:()=>bt,NearestMipmapNearestFilter:()=>xt,NeutralToneMapping:()=>at,NeverCompare:()=>yn,NeverDepth:()=>H,NeverStencilFunc:()=>hn,NoBlending:()=>_,NoColorSpace:()=>Ze,NoToneMapping:()=>tt,NormalAnimationBlendMode:()=>ze,NormalBlending:()=>y,NotEqualCompare:()=>Mn,NotEqualDepth:()=>Z,NotEqualStencilFunc:()=>mn,NumberKeyframeTrack:()=>sh,Object3D:()=>Or,ObjectLoader:()=>Zh,ObjectSpaceNormalMap:()=>$e,OctahedronGeometry:()=>bc,OneFactor:()=>R,OneMinusConstantAlphaFactor:()=>G,OneMinusConstantColorFactor:()=>V,OneMinusDstAlphaFactor:()=>O,OneMinusDstColorFactor:()=>F,OneMinusSrcAlphaFactor:()=>N,OneMinusSrcColorFactor:()=>L,OrthographicCamera:()=>zh,PCFShadowMap:()=>u,PCFSoftShadowMap:()=>d,PMREMGenerator:()=>op,Path:()=>kl,PerspectiveCamera:()=>to,Plane:()=>aa,PlaneGeometry:()=>Mc,PlaneHelper:()=>Ed,PointLight:()=>Bh,PointLightHelper:()=>ad,Points:()=>Qa,PointsMaterial:()=>qa,PolarGridHelper:()=>pd,PolyhedronGeometry:()=>pl,PositionalAudio:()=>bu,PropertyBinding:()=>Lu,PropertyMixer:()=>wu,QuadraticBezierCurve:()=>Ul,QuadraticBezierCurve3:()=>Fl,Quaternion:()=>ei,QuaternionKeyframeTrack:()=>ah,QuaternionLinearInterpolant:()=>oh,RED_GREEN_RGTC2_Format:()=>Ce,RED_RGTC1_Format:()=>Te,REVISION:()=>i,RGBADepthPacking:()=>je,RGBAFormat:()=>Ht,RGBAIntegerFormat:()=>Jt,RGBA_ASTC_10x10_Format:()=>xe,RGBA_ASTC_10x5_Format:()=>_e,RGBA_ASTC_10x6_Format:()=>ye,RGBA_ASTC_10x8_Format:()=>ve,RGBA_ASTC_12x10_Format:()=>Se,RGBA_ASTC_12x12_Format:()=>be,RGBA_ASTC_4x4_Format:()=>ce,RGBA_ASTC_5x4_Format:()=>he,RGBA_ASTC_5x5_Format:()=>ue,RGBA_ASTC_6x5_Format:()=>de,RGBA_ASTC_6x6_Format:()=>pe,RGBA_ASTC_8x5_Format:()=>fe,RGBA_ASTC_8x6_Format:()=>me,RGBA_ASTC_8x8_Format:()=>ge,RGBA_BPTC_Format:()=>Me,RGBA_ETC2_EAC_Format:()=>le,RGBA_PVRTC_2BPPV1_Format:()=>se,RGBA_PVRTC_4BPPV1_Format:()=>re,RGBA_S3TC_DXT1_Format:()=>Qt,RGBA_S3TC_DXT3_Format:()=>te,RGBA_S3TC_DXT5_Format:()=>ee,RGBDepthPacking:()=>Xe,RGBFormat:()=>Gt,RGBIntegerFormat:()=>Zt,RGB_BPTC_SIGNED_Format:()=>we,RGB_BPTC_UNSIGNED_Format:()=>Ee,RGB_ETC1_Format:()=>oe,RGB_ETC2_Format:()=>ae,RGB_PVRTC_2BPPV1_Format:()=>ie,RGB_PVRTC_4BPPV1_Format:()=>ne,RGB_S3TC_DXT1_Format:()=>Kt,RGDepthPacking:()=>Ye,RGFormat:()=>qt,RGIntegerFormat:()=>$t,RawShaderMaterial:()=>Oc,Ray:()=>ar,Raycaster:()=>Hu,RectAreaLight:()=>Hh,RedFormat:()=>Xt,RedIntegerFormat:()=>Yt,ReinhardToneMapping:()=>nt,RenderTarget:()=>Ri,RenderTarget3D:()=>Uu,RepeatWrapping:()=>gt,ReplaceStencilOp:()=>rn,ReverseSubtractEquation:()=>E,RingGeometry:()=>wc,SIGNED_RED_GREEN_RGTC2_Format:()=>Re,SIGNED_RED_RGTC1_Format:()=>Ae,SRGBColorSpace:()=>Je,SRGBTransfer:()=>tn,Scene:()=>ho,ShaderChunk:()=>Fd,ShaderLib:()=>zd,ShaderMaterial:()=>$s,ShadowMaterial:()=>Dc,Shape:()=>Gl,ShapeGeometry:()=>Ec,ShapePath:()=>Ld,ShapeUtils:()=>mc,ShortType:()=>Lt,Skeleton:()=>qo,SkeletonHelper:()=>sd,SkinnedMesh:()=>Ho,Source:()=>Mi,Sphere:()=>Qi,SphereGeometry:()=>Tc,Spherical:()=>Xu,SphericalHarmonics3:()=>Wh,SplineCurve:()=>Bl,SpotLight:()=>Nh,SpotLightHelper:()=>ed,Sprite:()=>Ro,SpriteMaterial:()=>mo,SrcAlphaFactor:()=>I,SrcAlphaSaturateFactor:()=>B,SrcColorFactor:()=>P,StaticCopyUsage:()=>In,StaticDrawUsage:()=>Tn,StaticReadUsage:()=>Rn,StereoCamera:()=>lu,StreamCopyUsage:()=>Dn,StreamDrawUsage:()=>Cn,StreamReadUsage:()=>Ln,StringKeyframeTrack:()=>lh,SubtractEquation:()=>w,SubtractiveBlending:()=>x,TOUCH:()=>s,TangentSpaceNormalMap:()=>qe,TetrahedronGeometry:()=>Ac,Texture:()=>Ai,TextureLoader:()=>Eh,TextureUtils:()=>Dd,TimestampQuery:()=>zn,TorusGeometry:()=>Cc,TorusKnotGeometry:()=>Rc,Triangle:()=>$r,TriangleFanDrawMode:()=>He,TriangleStripDrawMode:()=>Ge,TrianglesDrawMode:()=>ke,TubeGeometry:()=>Pc,UVMapping:()=>ht,Uint16BufferAttribute:()=>ys,Uint32BufferAttribute:()=>xs,Uint8BufferAttribute:()=>ms,Uint8ClampedBufferAttribute:()=>gs,Uniform:()=>Fu,UniformsGroup:()=>zu,UniformsLib:()=>Bd,UniformsUtils:()=>qs,UnsignedByteType:()=>Rt,UnsignedInt248Type:()=>zt,UnsignedInt5999Type:()=>Vt,UnsignedIntType:()=>Dt,UnsignedShort4444Type:()=>Ft,UnsignedShort5551Type:()=>Bt,UnsignedShortType:()=>It,VSMShadowMap:()=>p,Vector2:()=>ti,Vector3:()=>ni,Vector4:()=>Ci,VectorKeyframeTrack:()=>ch,VideoFrameTexture:()=>nl,VideoTexture:()=>el,WebGL3DRenderTarget:()=>Di,WebGLArrayRenderTarget:()=>Ii,WebGLCoordinateSystem:()=>Fn,WebGLCubeRenderTarget:()=>ro,WebGLRenderTarget:()=>Pi,WebGLRenderer:()=>mm,WebGLUtils:()=>lm,WebGPUCoordinateSystem:()=>Bn,WebXRController:()=>ao,WireframeGeometry:()=>Lc,WrapAroundEnding:()=>Be,ZeroCurvatureEnding:()=>Ue,ZeroFactor:()=>C,ZeroSlopeEnding:()=>Fe,ZeroStencilOp:()=>en,createCanvasElement:()=>ui});var e={};n.r(e),n.d(e,{ACESFilmicToneMapping:()=>gg,AddEquation:()=>zm,AddOperation:()=>ug,AdditiveAnimationBlendMode:()=>j_,AdditiveBlending:()=>Om,AlphaFormat:()=>qg,AlwaysCompare:()=>Cy,AlwaysDepth:()=>ng,AlwaysStencilFunc:()=>xy,AmbientLight:()=>BC,AmbientLightProbe:()=>eR,AnimationAction:()=>RR,AnimationClip:()=>lC,AnimationLoader:()=>_C,AnimationMixer:()=>LR,AnimationObjectGroup:()=>CR,AnimationUtils:()=>$A,ArcCurve:()=>pT,ArrayCamera:()=>Uw,ArrowHelper:()=>bP,Audio:()=>pR,AudioAnalyser:()=>vR,AudioContext:()=>KC,AudioListener:()=>dR,AudioLoader:()=>QC,AxesHelper:()=>MP,BackSide:()=>Pm,BasicDepthPacking:()=>J_,BasicShadowMap:()=>Em,Bone:()=>CE,BooleanKeyframeTrack:()=>eC,Box2:()=>HR,Box3:()=>Bv,Box3Helper:()=>_P,BoxBufferGeometry:()=>EP,BoxGeometry:()=>$S,BoxHelper:()=>gP,BufferAttribute:()=>uS,BufferGeometry:()=>RS,BufferGeometryLoader:()=>jC,ByteType:()=>Bg,Cache:()=>hC,Camera:()=>eb,CameraHelper:()=>pP,CanvasTexture:()=>hT,CapsuleBufferGeometry:()=>TP,CapsuleGeometry:()=>DT,CatmullRomCurve3:()=>vT,CineonToneMapping:()=>mg,CircleBufferGeometry:()=>AP,CircleGeometry:()=>OT,ClampToEdgeWrapping:()=>Eg,Clock:()=>oR,Color:()=>eS,ColorKeyframeTrack:()=>nC,ColorManagement:()=>vv,CompressedArrayTexture:()=>cT,CompressedTexture:()=>lT,CompressedTextureLoader:()=>yC,ConeBufferGeometry:()=>CP,ConeGeometry:()=>FT,CubeCamera:()=>rb,CubeReflectionMapping:()=>vg,CubeRefractionMapping:()=>xg,CubeTexture:()=>sb,CubeTextureLoader:()=>xC,CubeUVReflectionMapping:()=>Mg,CubicBezierCurve:()=>MT,CubicBezierCurve3:()=>wT,CubicInterpolant:()=>JA,CullFaceBack:()=>bm,CullFaceFront:()=>Mm,CullFaceFrontBack:()=>wm,CullFaceNone:()=>Sm,Curve:()=>uT,CurvePath:()=>LT,CustomBlending:()=>Bm,CustomToneMapping:()=>_g,CylinderBufferGeometry:()=>RP,CylinderGeometry:()=>UT,Cylindrical:()=>kR,Data3DTexture:()=>Lv,DataArrayTexture:()=>Rv,DataTexture:()=>RE,DataTextureLoader:()=>SC,DataUtils:()=>lS,DecrementStencilOp:()=>cy,DecrementWrapStencilOp:()=>uy,DefaultLoadingManager:()=>dC,DepthFormat:()=>Kg,DepthStencilFormat:()=>Qg,DepthTexture:()=>Vw,DirectionalLight:()=>FC,DirectionalLightHelper:()=>hP,DiscreteInterpolant:()=>QA,DisplayP3ColorSpace:()=>ry,DodecahedronBufferGeometry:()=>PP,DodecahedronGeometry:()=>zT,DoubleSide:()=>Lm,DstAlphaFactor:()=>Zm,DstColorFactor:()=>Km,DynamicCopyUsage:()=>Uy,DynamicDrawUsage:()=>Py,DynamicReadUsage:()=>Ny,EdgesGeometry:()=>WT,EllipseCurve:()=>dT,EqualCompare:()=>My,EqualDepth:()=>sg,EqualStencilFunc:()=>my,EquirectangularReflectionMapping:()=>Sg,EquirectangularRefractionMapping:()=>bg,Euler:()=>Sx,EventDispatcher:()=>Hy,ExtrudeBufferGeometry:()=>LP,ExtrudeGeometry:()=>vA,FileLoader:()=>gC,Float16BufferAttribute:()=>vS,Float32BufferAttribute:()=>xS,Float64BufferAttribute:()=>SS,FloatType:()=>Hg,Fog:()=>qw,FogExp2:()=>Yw,FramebufferTexture:()=>aT,FrontSide:()=>Rm,Frustum:()=>pb,GLBufferAttribute:()=>UR,GLSL1:()=>By,GLSL3:()=>zy,GreaterCompare:()=>Ey,GreaterDepth:()=>ag,GreaterEqualCompare:()=>Ay,GreaterEqualDepth:()=>og,GreaterEqualStencilFunc:()=>vy,GreaterStencilFunc:()=>_y,GridHelper:()=>sP,Group:()=>Fw,HalfFloatType:()=>Wg,HemisphereLight:()=>wC,HemisphereLightHelper:()=>rP,HemisphereLightProbe:()=>tR,IcosahedronBufferGeometry:()=>IP,IcosahedronGeometry:()=>SA,ImageBitmapLoader:()=>ZC,ImageLoader:()=>vC,ImageUtils:()=>Sv,IncrementStencilOp:()=>ly,IncrementWrapStencilOp:()=>hy,InstancedBufferAttribute:()=>NE,InstancedBufferGeometry:()=>WC,InstancedInterleavedBuffer:()=>OR,InstancedMesh:()=>kE,Int16BufferAttribute:()=>mS,Int32BufferAttribute:()=>_S,Int8BufferAttribute:()=>dS,IntType:()=>kg,InterleavedBuffer:()=>Zw,InterleavedBufferAttribute:()=>Kw,Interpolant:()=>ZA,InterpolateDiscrete:()=>B_,InterpolateLinear:()=>z_,InterpolateSmooth:()=>V_,InvertStencilOp:()=>dy,KeepStencilOp:()=>oy,KeyframeTrack:()=>tC,LOD:()=>_E,LatheBufferGeometry:()=>NP,LatheGeometry:()=>NT,Layers:()=>bx,LessCompare:()=>by,LessDepth:()=>ig,LessEqualCompare:()=>wy,LessEqualDepth:()=>rg,LessEqualStencilFunc:()=>gy,LessStencilFunc:()=>fy,Light:()=>MC,LightProbe:()=>kC,Line:()=>qE,Line3:()=>XR,LineBasicMaterial:()=>GE,LineCurve:()=>ET,LineCurve3:()=>TT,LineDashedMaterial:()=>GA,LineLoop:()=>KE,LineSegments:()=>JE,LinearEncoding:()=>$_,LinearFilter:()=>Ig,LinearInterpolant:()=>KA,LinearMipMapLinearFilter:()=>Ug,LinearMipMapNearestFilter:()=>Dg,LinearMipmapLinearFilter:()=>Og,LinearMipmapNearestFilter:()=>Ng,LinearSRGBColorSpace:()=>iy,LinearToneMapping:()=>pg,Loader:()=>pC,LoaderUtils:()=>HC,LoadingManager:()=>uC,LoopOnce:()=>O_,LoopPingPong:()=>F_,LoopRepeat:()=>U_,LuminanceAlphaFormat:()=>Jg,LuminanceFormat:()=>Zg,MOUSE:()=>vm,Material:()=>Zx,MaterialLoader:()=>GC,MathUtils:()=>iv,Matrix3:()=>sv,Matrix4:()=>ux,MaxEquation:()=>Hm,Mesh:()=>YS,MeshBasicMaterial:()=>iS,MeshDepthMaterial:()=>Pw,MeshDistanceMaterial:()=>Lw,MeshLambertMaterial:()=>VA,MeshMatcapMaterial:()=>kA,MeshNormalMaterial:()=>zA,MeshPhongMaterial:()=>FA,MeshPhysicalMaterial:()=>UA,MeshStandardMaterial:()=>OA,MeshToonMaterial:()=>BA,MinEquation:()=>Gm,MirroredRepeatWrapping:()=>Tg,MixOperation:()=>hg,MultiplyBlending:()=>Fm,MultiplyOperation:()=>cg,NearestFilter:()=>Ag,NearestMipMapLinearFilter:()=>Lg,NearestMipMapNearestFilter:()=>Rg,NearestMipmapLinearFilter:()=>Pg,NearestMipmapNearestFilter:()=>Cg,NeverCompare:()=>Sy,NeverDepth:()=>eg,NeverStencilFunc:()=>py,NoBlending:()=>Nm,NoColorSpace:()=>ey,NoToneMapping:()=>dg,NormalAnimationBlendMode:()=>W_,NormalBlending:()=>Dm,NotEqualCompare:()=>Ty,NotEqualDepth:()=>lg,NotEqualStencilFunc:()=>yy,NumberKeyframeTrack:()=>iC,Object3D:()=>Ux,ObjectLoader:()=>XC,ObjectSpaceNormalMap:()=>ty,OctahedronBufferGeometry:()=>DP,OctahedronGeometry:()=>bA,OneFactor:()=>jm,OneMinusDstAlphaFactor:()=>Jm,OneMinusDstColorFactor:()=>Qm,OneMinusSrcAlphaFactor:()=>$m,OneMinusSrcColorFactor:()=>Ym,OrthographicCamera:()=>Ab,PCFShadowMap:()=>Tm,PCFSoftShadowMap:()=>Am,PMREMGenerator:()=>Ob,Path:()=>IT,PerspectiveCamera:()=>nb,Plane:()=>hb,PlaneBufferGeometry:()=>OP,PlaneGeometry:()=>gb,PlaneHelper:()=>yP,PointLight:()=>OC,PointLightHelper:()=>tP,Points:()=>rT,PointsMaterial:()=>QE,PolarGridHelper:()=>oP,PolyhedronBufferGeometry:()=>UP,PolyhedronGeometry:()=>BT,PositionalAudio:()=>yR,PropertyBinding:()=>AR,PropertyMixer:()=>xR,QuadraticBezierCurve:()=>AT,QuadraticBezierCurve3:()=>CT,Quaternion:()=>Dv,QuaternionKeyframeTrack:()=>sC,QuaternionLinearInterpolant:()=>rC,RED_GREEN_RGTC2_Format:()=>N_,RED_RGTC1_Format:()=>L_,REVISION:()=>ym,RGBADepthPacking:()=>K_,RGBAFormat:()=>$g,RGBAIntegerFormat:()=>r_,RGBA_ASTC_10x10_Format:()=>A_,RGBA_ASTC_10x5_Format:()=>w_,RGBA_ASTC_10x6_Format:()=>E_,RGBA_ASTC_10x8_Format:()=>T_,RGBA_ASTC_12x10_Format:()=>C_,RGBA_ASTC_12x12_Format:()=>R_,RGBA_ASTC_4x4_Format:()=>g_,RGBA_ASTC_5x4_Format:()=>__,RGBA_ASTC_5x5_Format:()=>y_,RGBA_ASTC_6x5_Format:()=>v_,RGBA_ASTC_6x6_Format:()=>x_,RGBA_ASTC_8x5_Format:()=>S_,RGBA_ASTC_8x6_Format:()=>b_,RGBA_ASTC_8x8_Format:()=>M_,RGBA_BPTC_Format:()=>P_,RGBA_ETC2_EAC_Format:()=>m_,RGBA_PVRTC_2BPPV1_Format:()=>d_,RGBA_PVRTC_4BPPV1_Format:()=>u_,RGBA_S3TC_DXT1_Format:()=>o_,RGBA_S3TC_DXT3_Format:()=>a_,RGBA_S3TC_DXT5_Format:()=>l_,RGB_ETC1_Format:()=>p_,RGB_ETC2_Format:()=>f_,RGB_PVRTC_2BPPV1_Format:()=>h_,RGB_PVRTC_4BPPV1_Format:()=>c_,RGB_S3TC_DXT1_Format:()=>s_,RGFormat:()=>n_,RGIntegerFormat:()=>i_,RawShaderMaterial:()=>DA,Ray:()=>hx,Raycaster:()=>FR,RectAreaLight:()=>zC,RedFormat:()=>t_,RedIntegerFormat:()=>e_,ReinhardToneMapping:()=>fg,RepeatWrapping:()=>wg,ReplaceStencilOp:()=>ay,ReverseSubtractEquation:()=>km,RingBufferGeometry:()=>FP,RingGeometry:()=>MA,SIGNED_RED_GREEN_RGTC2_Format:()=>D_,SIGNED_RED_RGTC1_Format:()=>I_,SRGBColorSpace:()=>ny,Scene:()=>$w,ShaderChunk:()=>_b,ShaderLib:()=>vb,ShaderMaterial:()=>tb,ShadowMaterial:()=>NA,Shape:()=>jT,ShapeBufferGeometry:()=>BP,ShapeGeometry:()=>wA,ShapePath:()=>wP,ShapeUtils:()=>gA,ShortType:()=>zg,Skeleton:()=>IE,SkeletonHelper:()=>KR,SkinnedMesh:()=>AE,Source:()=>Mv,Sphere:()=>nx,SphereBufferGeometry:()=>zP,SphereGeometry:()=>EA,Spherical:()=>VR,SphericalHarmonics3:()=>VC,SplineCurve:()=>RT,SpotLight:()=>PC,SpotLightHelper:()=>qR,Sprite:()=>pE,SpriteMaterial:()=>Qw,SrcAlphaFactor:()=>qm,SrcAlphaSaturateFactor:()=>tg,SrcColorFactor:()=>Xm,StaticCopyUsage:()=>Oy,StaticDrawUsage:()=>Ry,StaticReadUsage:()=>Iy,StereoCamera:()=>sR,StreamCopyUsage:()=>Fy,StreamDrawUsage:()=>Ly,StreamReadUsage:()=>Dy,StringKeyframeTrack:()=>oC,SubtractEquation:()=>Vm,SubtractiveBlending:()=>Um,TOUCH:()=>xm,TangentSpaceNormalMap:()=>Q_,TetrahedronBufferGeometry:()=>VP,TetrahedronGeometry:()=>TA,Texture:()=>Tv,TextureLoader:()=>bC,TorusBufferGeometry:()=>kP,TorusGeometry:()=>AA,TorusKnotBufferGeometry:()=>GP,TorusKnotGeometry:()=>CA,Triangle:()=>qx,TriangleFanDrawMode:()=>q_,TriangleStripDrawMode:()=>Y_,TrianglesDrawMode:()=>X_,TubeBufferGeometry:()=>HP,TubeGeometry:()=>RA,TwoPassDoubleSide:()=>Im,UVMapping:()=>yg,Uint16BufferAttribute:()=>gS,Uint32BufferAttribute:()=>yS,Uint8BufferAttribute:()=>pS,Uint8ClampedBufferAttribute:()=>fS,Uniform:()=>IR,UniformsGroup:()=>DR,UniformsLib:()=>yb,UniformsUtils:()=>QS,UnsignedByteType:()=>Fg,UnsignedInt248Type:()=>Yg,UnsignedIntType:()=>Gg,UnsignedShort4444Type:()=>jg,UnsignedShort5551Type:()=>Xg,UnsignedShortType:()=>Vg,VSMShadowMap:()=>Cm,Vector2:()=>rv,Vector3:()=>Ov,Vector4:()=>Av,VectorKeyframeTrack:()=>aC,VideoTexture:()=>oT,WebGL1Renderer:()=>Xw,WebGL3DRenderTarget:()=>Iv,WebGLArrayRenderTarget:()=>Pv,WebGLCoordinateSystem:()=>ky,WebGLCubeRenderTarget:()=>ob,WebGLMultipleRenderTargets:()=>Nv,WebGLRenderTarget:()=>Cv,WebGLRenderer:()=>jw,WebGLUtils:()=>Ow,WebGPUCoordinateSystem:()=>Gy,WireframeGeometry:()=>PA,WrapAroundEnding:()=>H_,ZeroCurvatureEnding:()=>k_,ZeroFactor:()=>Wm,ZeroSlopeEnding:()=>G_,ZeroStencilOp:()=>sy,_SRGBAFormat:()=>Vy,sRGBEncoding:()=>Z_});const i="178",r={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},s={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},o=0,a=1,l=2,c=3,h=0,u=1,d=2,p=3,f=0,m=1,g=2,_=0,y=1,v=2,x=3,S=4,b=5,M=100,w=101,E=102,T=103,A=104,C=200,R=201,P=202,L=203,I=204,N=205,D=206,O=207,U=208,F=209,B=210,z=211,V=212,k=213,G=214,H=0,W=1,j=2,X=3,Y=4,q=5,$=6,Z=7,J=0,K=1,Q=2,tt=0,et=1,nt=2,it=3,rt=4,st=5,ot=6,at=7,lt="attached",ct="detached",ht=300,ut=301,dt=302,pt=303,ft=304,mt=306,gt=1e3,_t=1001,yt=1002,vt=1003,xt=1004,St=1004,bt=1005,Mt=1005,wt=1006,Et=1007,Tt=1007,At=1008,Ct=1008,Rt=1009,Pt=1010,Lt=1011,It=1012,Nt=1013,Dt=1014,Ot=1015,Ut=1016,Ft=1017,Bt=1018,zt=1020,Vt=35902,kt=1021,Gt=1022,Ht=1023,Wt=1026,jt=1027,Xt=1028,Yt=1029,qt=1030,$t=1031,Zt=1032,Jt=1033,Kt=33776,Qt=33777,te=33778,ee=33779,ne=35840,ie=35841,re=35842,se=35843,oe=36196,ae=37492,le=37496,ce=37808,he=37809,ue=37810,de=37811,pe=37812,fe=37813,me=37814,ge=37815,_e=37816,ye=37817,ve=37818,xe=37819,Se=37820,be=37821,Me=36492,we=36494,Ee=36495,Te=36283,Ae=36284,Ce=36285,Re=36286,Pe=2200,Le=2201,Ie=2202,Ne=2300,De=2301,Oe=2302,Ue=2400,Fe=2401,Be=2402,ze=2500,Ve=2501,ke=0,Ge=1,He=2,We=3200,je=3201,Xe=3202,Ye=3203,qe=0,$e=1,Ze="",Je="srgb",Ke="srgb-linear",Qe="linear",tn="srgb",en=0,nn=7680,rn=7681,sn=7682,on=7683,an=34055,ln=34056,cn=5386,hn=512,un=513,dn=514,pn=515,fn=516,mn=517,gn=518,_n=519,yn=512,vn=513,xn=514,Sn=515,bn=516,Mn=517,wn=518,En=519,Tn=35044,An=35048,Cn=35040,Rn=35045,Pn=35049,Ln=35041,In=35046,Nn=35050,Dn=35042,On="100",Un="300 es",Fn=2e3,Bn=2001,zn={COMPUTE:"compute",RENDER:"render"},Vn={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},kn={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};class Gn{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){const n=this._listeners;return void 0!==n&&void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){const n=this._listeners;if(void 0===n)return;const i=n[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){const e=this._listeners;if(void 0===e)return;const n=e[t.type];if(void 0!==n){t.target=this;const e=n.slice(0);for(let n=0,i=e.length;n<i;n++)e[n].call(this,t);t.target=null}}}const Hn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Wn=1234567;const jn=Math.PI/180,Xn=180/Math.PI;function Yn(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Hn[255&t]+Hn[t>>8&255]+Hn[t>>16&255]+Hn[t>>24&255]+"-"+Hn[255&e]+Hn[e>>8&255]+"-"+Hn[e>>16&15|64]+Hn[e>>24&255]+"-"+Hn[63&n|128]+Hn[n>>8&255]+"-"+Hn[n>>16&255]+Hn[n>>24&255]+Hn[255&i]+Hn[i>>8&255]+Hn[i>>16&255]+Hn[i>>24&255]).toLowerCase()}function qn(t,e,n){return Math.max(e,Math.min(n,t))}function $n(t,e){return(t%e+e)%e}function Zn(t,e,n){return(1-n)*t+n*e}function Jn(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Kn(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const Qn={DEG2RAD:jn,RAD2DEG:Xn,generateUUID:Yn,clamp:qn,euclideanModulo:$n,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Zn,damp:function(t,e,n,i){return Zn(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs($n(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(Wn=t);let e=Wn+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*jn},radToDeg:function(t){return t*Xn},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+i)/2),h=o((e+i)/2),u=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":t.set(a*h,l*u,l*d,a*c);break;case"YZY":t.set(l*d,a*h,l*u,a*c);break;case"ZXZ":t.set(l*u,l*d,a*h,a*c);break;case"XZX":t.set(a*h,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*h,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:Kn,denormalize:Jn};class ti{constructor(t=0,e=0){ti.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=qn(this.x,t.x,e.x),this.y=qn(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=qn(this.x,t,e),this.y=qn(this.y,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(qn(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(qn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class ei{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,s,o){let a=n[i+0],l=n[i+1],c=n[i+2],h=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===o)return t[e+0]=a,t[e+1]=l,t[e+2]=c,void(t[e+3]=h);if(1===o)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(h!==f||a!==u||l!==d||c!==p){let t=1-o;const e=a*u+l*d+c*p+h*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,o=Math.sin(o*s)/r}const r=o*n;if(a=a*t+u*r,l=l*t+d*r,c=c*t+p*r,h=h*t+f*r,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+h*h);a*=t,l*=t,c*=t,h*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],a=n[i+1],l=n[i+2],c=n[i+3],h=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=o*p+c*h+a*d-l*u,t[e+1]=a*p+c*u+l*h-o*d,t[e+2]=l*p+c*d+o*u-a*h,t[e+3]=c*p-o*h-a*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(i/2),h=o(r/2),u=a(n/2),d=a(i/2),p=a(r/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],h=e[10],u=n+o+h;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>o&&n>h){const t=2*Math.sqrt(1+n-o-h);this._w=(c-a)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(o>h){const t=2*Math.sqrt(1+o-n-h);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+h-n-o);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<1e-8?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(qn(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+i*l-r*a,this._y=i*c+s*a+r*o-n*l,this._z=r*c+s*l+n*a-i*o,this._w=s*c-n*o-i*a-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),h=Math.sin((1-e)*c)/l,u=Math.sin(e*c)/l;return this._w=s*h+this._w*u,this._x=n*h+this._x*u,this._y=i*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),r=Math.sqrt(n);return this.set(i*Math.sin(t),i*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ni{constructor(t=0,e=0,n=0){ni.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(ri.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ri.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,a=t.w,l=2*(s*i-o*n),c=2*(o*e-r*i),h=2*(r*n-s*e);return this.x=e+a*l+s*h-o*c,this.y=n+a*c+o*l-r*h,this.z=i+a*h+r*c-s*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=qn(this.x,t.x,e.x),this.y=qn(this.y,t.y,e.y),this.z=qn(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=qn(this.x,t,e),this.y=qn(this.y,t,e),this.z=qn(this.z,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(qn(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*s-n*a,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return ii.copy(this).projectOnVector(t),this.sub(ii)}reflect(t){return this.sub(ii.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(qn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ii=new ni,ri=new ei;class si{constructor(t,e,n,i,r,s,o,a,l){si.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,o,a,l)}set(t,e,n,i,r,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],_=i[1],y=i[4],v=i[7],x=i[2],S=i[5],b=i[8];return r[0]=s*f+o*_+a*x,r[3]=s*m+o*y+a*S,r[6]=s*g+o*v+a*b,r[1]=l*f+c*_+h*x,r[4]=l*m+c*y+h*S,r[7]=l*g+c*v+h*b,r[2]=u*f+d*_+p*x,r[5]=u*m+d*y+p*S,r[8]=u*g+d*v+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*r*c+n*o*a+i*r*l-i*s*a}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],h=c*s-o*l,u=o*a-c*r,d=l*r-s*a,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=h*f,t[1]=(i*l-c*n)*f,t[2]=(o*n-i*s)*f,t[3]=u*f,t[4]=(c*e-i*a)*f,t[5]=(i*r-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-i*l,i*a,-i*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(oi.makeScale(t,e)),this}rotate(t){return this.premultiply(oi.makeRotation(-t)),this}translate(t,e){return this.premultiply(oi.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const oi=new si;function ai(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const li={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ci(t,e){return new li[t](e)}function hi(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function ui(){const t=hi("canvas");return t.style.display="block",t}const di={};function pi(t){t in di||(di[t]=!0,console.warn(t))}const fi=(new si).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),mi=(new si).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function gi(){const t={enabled:!0,workingColorSpace:Ke,spaces:{},convert:function(t,e,n){return!1!==this.enabled&&e!==n&&e&&n?(this.spaces[e].transfer===tn&&(t.r=yi(t.r),t.g=yi(t.g),t.b=yi(t.b)),this.spaces[e].primaries!==this.spaces[n].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[n].fromXYZ)),this.spaces[n].transfer===tn&&(t.r=vi(t.r),t.g=vi(t.g),t.b=vi(t.b)),t):t},workingToColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},colorSpaceToWorking:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===Ze?Qe:this.spaces[t].transfer},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,n){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(e,n){return pi("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),t.workingToColorSpace(e,n)},toWorkingColorSpace:function(e,n){return pi("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),t.colorSpaceToWorking(e,n)}},e=[.64,.33,.3,.6,.15,.06],n=[.2126,.7152,.0722],i=[.3127,.329];return t.define({[Ke]:{primaries:e,whitePoint:i,transfer:Qe,toXYZ:fi,fromXYZ:mi,luminanceCoefficients:n,workingColorSpaceConfig:{unpackColorSpace:Je},outputColorSpaceConfig:{drawingBufferColorSpace:Je}},[Je]:{primaries:e,whitePoint:i,transfer:tn,toXYZ:fi,fromXYZ:mi,luminanceCoefficients:n,outputColorSpaceConfig:{drawingBufferColorSpace:Je}}}),t}const _i=gi();function yi(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function vi(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}let xi;class Si{static getDataURL(t,e="image/png"){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let n;if(t instanceof HTMLCanvasElement)n=t;else{void 0===xi&&(xi=hi("canvas")),xi.width=t.width,xi.height=t.height;const e=xi.getContext("2d");t instanceof ImageData?e.putImageData(t,0,0):e.drawImage(t,0,0,t.width,t.height),n=xi}return n.toDataURL(e)}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=hi("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t<r.length;t++)r[t]=255*yi(r[t]/255);return n.putImageData(i,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*yi(e[t]/255)):e[t]=yi(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let bi=0;class Mi{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:bi++}),this.uuid=Yn(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const e=this.data;return e instanceof HTMLVideoElement?t.set(e.videoWidth,e.videoHeight):null!==e?t.set(e.width,e.height,e.depth||0):t.set(0,0,0),t}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(null!==i){let t;if(Array.isArray(i)){t=[];for(let e=0,n=i.length;e<n;e++)i[e].isDataTexture?t.push(wi(i[e].image)):t.push(wi(i[e]))}else t=wi(i);n.url=t}return e||(t.images[this.uuid]=n),n}}function wi(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Si.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Ei=0;const Ti=new ni;class Ai extends Gn{constructor(t=Ai.DEFAULT_IMAGE,e=Ai.DEFAULT_MAPPING,n=_t,i=_t,r=wt,s=At,o=Ht,a=Rt,l=Ai.DEFAULT_ANISOTROPY,c=Ze){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Ei++}),this.uuid=Yn(),this.name="",this.source=new Mi(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new ti(0,0),this.repeat=new ti(1,1),this.center=new ti(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new si,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(Ti).x}get height(){return this.source.getSize(Ti).y}get depth(){return this.source.getSize(Ti).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const e in t){const n=t[e];if(void 0===n){console.warn(`THREE.Texture.setValues(): parameter '${e}' has value of undefined.`);continue}const i=this[e];void 0!==i?i&&n&&i.isVector2&&n.isVector2||i&&n&&i.isVector3&&n.isVector3||i&&n&&i.isMatrix3&&n.isMatrix3?i.copy(n):this[e]=n:console.warn(`THREE.Texture.setValues(): property '${e}' does not exist.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ht)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case gt:t.x=t.x-Math.floor(t.x);break;case _t:t.x=t.x<0?0:1;break;case yt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case gt:t.y=t.y-Math.floor(t.y);break;case _t:t.y=t.y<0?0:1;break;case yt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}Ai.DEFAULT_IMAGE=null,Ai.DEFAULT_MAPPING=ht,Ai.DEFAULT_ANISOTROPY=1;class Ci{constructor(t=0,e=0,n=0,i=1){Ci.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],h=a[8],u=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-u)<s&&Math.abs(h-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+u)<o&&Math.abs(h+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,_=(g+1)/2,y=(c+u)/4,v=(h+f)/4,x=(p+m)/4;return t>a&&t>_?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=y/n,r=v/n):a>_?a<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(a),n=y/i,r=x/i):_<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(_),n=v/r,i=x/r),this.set(n,i,r,e),this}let _=Math.sqrt((m-p)*(m-p)+(h-f)*(h-f)+(u-c)*(u-c));return Math.abs(_)<.001&&(_=1),this.x=(m-p)/_,this.y=(h-f)/_,this.z=(u-c)/_,this.w=Math.acos((l+d+g-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=qn(this.x,t.x,e.x),this.y=qn(this.y,t.y,e.y),this.z=qn(this.z,t.z,e.z),this.w=qn(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=qn(this.x,t,e),this.y=qn(this.y,t,e),this.z=qn(this.z,t,e),this.w=qn(this.w,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(qn(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Ri extends Gn{constructor(t=1,e=1,n={}){super(),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:wt,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},n),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=n.depth,this.scissor=new Ci(0,0,t,e),this.scissorTest=!1,this.viewport=new Ci(0,0,t,e);const i={width:t,height:e,depth:n.depth},r=new Ai(i);this.textures=[];const s=n.count;for(let t=0;t<s;t++)this.textures[t]=r.clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;this._setTextureOptions(n),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=n.depthTexture,this.samples=n.samples,this.multiview=n.multiview}_setTextureOptions(t={}){const e={minFilter:wt,generateMipmaps:!1,flipY:!1,internalFormat:null};void 0!==t.mapping&&(e.mapping=t.mapping),void 0!==t.wrapS&&(e.wrapS=t.wrapS),void 0!==t.wrapT&&(e.wrapT=t.wrapT),void 0!==t.wrapR&&(e.wrapR=t.wrapR),void 0!==t.magFilter&&(e.magFilter=t.magFilter),void 0!==t.minFilter&&(e.minFilter=t.minFilter),void 0!==t.format&&(e.format=t.format),void 0!==t.type&&(e.type=t.type),void 0!==t.anisotropy&&(e.anisotropy=t.anisotropy),void 0!==t.colorSpace&&(e.colorSpace=t.colorSpace),void 0!==t.flipY&&(e.flipY=t.flipY),void 0!==t.generateMipmaps&&(e.generateMipmaps=t.generateMipmaps),void 0!==t.internalFormat&&(e.internalFormat=t.internalFormat);for(let t=0;t<this.textures.length;t++)this.textures[t].setValues(e)}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==t&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=n,this.textures[i].isArrayTexture=this.textures[i].image.depth>1;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,n=t.textures.length;e<n;e++){this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const n=Object.assign({},t.textures[e].image);this.textures[e].source=new Mi(n)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Pi extends Ri{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class Li extends Ai{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=vt,this.minFilter=vt,this.wrapR=_t,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class Ii extends Pi{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new Li(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Ni extends Ai{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=vt,this.minFilter=vt,this.wrapR=_t,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Di extends Pi{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new Ni(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Oi{constructor(t=new ni(1/0,1/0,1/0),e=new ni(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(Fi.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(Fi.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Fi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n){const i=n.getAttribute("position");if(!0===e&&void 0!==i&&!0!==t.isInstancedMesh)for(let e=0,n=i.count;e<n;e++)!0===t.isMesh?t.getVertexPosition(e,Fi):Fi.fromBufferAttribute(i,e),Fi.applyMatrix4(t.matrixWorld),this.expandByPoint(Fi);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),Bi.copy(t.boundingBox)):(null===n.boundingBox&&n.computeBoundingBox(),Bi.copy(n.boundingBox)),Bi.applyMatrix4(t.matrixWorld),this.union(Bi)}const i=t.children;for(let t=0,n=i.length;t<n;t++)this.expandByObject(i[t],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Fi),Fi.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(ji),Xi.subVectors(this.max,ji),zi.subVectors(t.a,ji),Vi.subVectors(t.b,ji),ki.subVectors(t.c,ji),Gi.subVectors(Vi,zi),Hi.subVectors(ki,Vi),Wi.subVectors(zi,ki);let e=[0,-Gi.z,Gi.y,0,-Hi.z,Hi.y,0,-Wi.z,Wi.y,Gi.z,0,-Gi.x,Hi.z,0,-Hi.x,Wi.z,0,-Wi.x,-Gi.y,Gi.x,0,-Hi.y,Hi.x,0,-Wi.y,Wi.x,0];return!!$i(e,zi,Vi,ki,Xi)&&(e=[1,0,0,0,1,0,0,0,1],!!$i(e,zi,Vi,ki,Xi)&&(Yi.crossVectors(Gi,Hi),e=[Yi.x,Yi.y,Yi.z],$i(e,zi,Vi,ki,Xi)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Fi).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(Fi).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(Ui[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Ui[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Ui[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Ui[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Ui[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Ui[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Ui[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Ui[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Ui)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const Ui=[new ni,new ni,new ni,new ni,new ni,new ni,new ni,new ni],Fi=new ni,Bi=new Oi,zi=new ni,Vi=new ni,ki=new ni,Gi=new ni,Hi=new ni,Wi=new ni,ji=new ni,Xi=new ni,Yi=new ni,qi=new ni;function $i(t,e,n,i,r){for(let s=0,o=t.length-3;s<=o;s+=3){qi.fromArray(t,s);const o=r.x*Math.abs(qi.x)+r.y*Math.abs(qi.y)+r.z*Math.abs(qi.z),a=e.dot(qi),l=n.dot(qi),c=i.dot(qi);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const Zi=new Oi,Ji=new ni,Ki=new ni;class Qi{constructor(t=new ni,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Zi.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Ji.subVectors(t,this.center);const e=Ji.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(Ji,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Ki.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Ji.copy(t.center).add(Ki)),this.expandByPoint(Ji.copy(t.center).sub(Ki))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const tr=new ni,er=new ni,nr=new ni,ir=new ni,rr=new ni,sr=new ni,or=new ni;class ar{constructor(t=new ni,e=new ni(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,tr)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=tr.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(tr.copy(this.origin).addScaledVector(this.direction,e),tr.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){er.copy(t).add(e).multiplyScalar(.5),nr.copy(e).sub(t).normalize(),ir.copy(this.origin).sub(er);const r=.5*t.distanceTo(e),s=-this.direction.dot(nr),o=ir.dot(this.direction),a=-ir.dot(nr),l=ir.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*a-o,u=s*o-a,p=r*c,h>=0)if(u>=-p)if(u<=p){const t=1/c;h*=t,u*=t,d=h*(h+s*u+2*o)+u*(s*h+u+2*a)+l}else u=r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u=-r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u<=-p?(h=Math.max(0,-(-s*r+o)),u=h>0?-r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l):u<=p?(h=0,u=Math.min(Math.max(-r,-a),r),d=u*(u+2*a)+l):(h=Math.max(0,-(s*r+o)),u=h>0?r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l);else u=s>0?-r:r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(er).addScaledVector(nr,u),d}intersectSphere(t,e){tr.subVectors(t.center,this.origin);const n=tr.dot(this.direction),i=tr.dot(tr)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,a=n+s;return a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(t){return!(t.radius<0)&&this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),c>=0?(r=(t.min.y-u.y)*c,s=(t.max.y-u.y)*c):(r=(t.max.y-u.y)*c,s=(t.min.y-u.y)*c),n>s||r>i?null:((r>n||isNaN(n))&&(n=r),(s<i||isNaN(i))&&(i=s),h>=0?(o=(t.min.z-u.z)*h,a=(t.max.z-u.z)*h):(o=(t.max.z-u.z)*h,a=(t.min.z-u.z)*h),n>a||o>i?null:((o>n||n!=n)&&(n=o),(a<i||i!=i)&&(i=a),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,tr)}intersectTriangle(t,e,n,i,r){rr.subVectors(e,t),sr.subVectors(n,t),or.crossVectors(rr,sr);let s,o=this.direction.dot(or);if(o>0){if(i)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}ir.subVectors(this.origin,t);const a=s*this.direction.dot(sr.crossVectors(ir,sr));if(a<0)return null;const l=s*this.direction.dot(rr.cross(ir));if(l<0)return null;if(a+l>o)return null;const c=-s*ir.dot(or);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class lr{constructor(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m){lr.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m)}set(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new lr).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/cr.setFromMatrixColumn(t,0).length(),r=1/cr.setFromMatrixColumn(t,1).length(),s=1/cr.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(i),l=Math.sin(i),c=Math.cos(r),h=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*h,i=o*c,r=o*h;e[0]=a*c,e[4]=-a*h,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-o*a,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*h,i=l*c,r=l*h;e[0]=t+r*o,e[4]=i*o-n,e[8]=s*l,e[1]=s*h,e[5]=s*c,e[9]=-o,e[2]=n*o-i,e[6]=r+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*h,i=l*c,r=l*h;e[0]=t-r*o,e[4]=-s*h,e[8]=i+n*o,e[1]=n+i*o,e[5]=s*c,e[9]=r-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*h,i=o*c,r=o*h;e[0]=a*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=a*h,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=r-t*h,e[8]=i*h+n,e[1]=h,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*h+i,e[10]=t-r*h}else if("XZY"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=-h,e[8]=l*c,e[1]=t*h+r,e[5]=s*c,e[9]=n*h-i,e[2]=i*h-n,e[6]=o*c,e[10]=r*h+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(ur,t,dr)}lookAt(t,e,n){const i=this.elements;return mr.subVectors(t,e),0===mr.lengthSq()&&(mr.z=1),mr.normalize(),pr.crossVectors(n,mr),0===pr.lengthSq()&&(1===Math.abs(n.z)?mr.x+=1e-4:mr.z+=1e-4,mr.normalize(),pr.crossVectors(n,mr)),pr.normalize(),fr.crossVectors(mr,pr),i[0]=pr.x,i[4]=fr.x,i[8]=mr.x,i[1]=pr.y,i[5]=fr.y,i[9]=mr.y,i[2]=pr.z,i[6]=fr.z,i[10]=mr.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],_=n[3],y=n[7],v=n[11],x=n[15],S=i[0],b=i[4],M=i[8],w=i[12],E=i[1],T=i[5],A=i[9],C=i[13],R=i[2],P=i[6],L=i[10],I=i[14],N=i[3],D=i[7],O=i[11],U=i[15];return r[0]=s*S+o*E+a*R+l*N,r[4]=s*b+o*T+a*P+l*D,r[8]=s*M+o*A+a*L+l*O,r[12]=s*w+o*C+a*I+l*U,r[1]=c*S+h*E+u*R+d*N,r[5]=c*b+h*T+u*P+d*D,r[9]=c*M+h*A+u*L+d*O,r[13]=c*w+h*C+u*I+d*U,r[2]=p*S+f*E+m*R+g*N,r[6]=p*b+f*T+m*P+g*D,r[10]=p*M+f*A+m*L+g*O,r[14]=p*w+f*C+m*I+g*U,r[3]=_*S+y*E+v*R+x*N,r[7]=_*b+y*T+v*P+x*D,r[11]=_*M+y*A+v*L+x*O,r[15]=_*w+y*C+v*I+x*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],h=t[6],u=t[10],d=t[14];return t[3]*(+r*a*h-i*l*h-r*o*u+n*l*u+i*o*d-n*a*d)+t[7]*(+e*a*d-e*l*u+r*s*u-i*s*d+i*l*c-r*a*c)+t[11]*(+e*l*h-e*o*d-r*s*h+n*s*d+r*o*c-n*l*c)+t[15]*(-i*o*c-e*a*h+e*o*u+i*s*h-n*s*u+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],_=h*m*l-f*u*l+f*a*d-o*m*d-h*a*g+o*u*g,y=p*u*l-c*m*l-p*a*d+s*m*d+c*a*g-s*u*g,v=c*f*l-p*h*l+p*o*d-s*f*d-c*o*g+s*h*g,x=p*h*a-c*f*a-p*o*u+s*f*u+c*o*m-s*h*m,S=e*_+n*y+i*v+r*x;if(0===S)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/S;return t[0]=_*b,t[1]=(f*u*r-h*m*r-f*i*d+n*m*d+h*i*g-n*u*g)*b,t[2]=(o*m*r-f*a*r+f*i*l-n*m*l-o*i*g+n*a*g)*b,t[3]=(h*a*r-o*u*r-h*i*l+n*u*l+o*i*d-n*a*d)*b,t[4]=y*b,t[5]=(c*m*r-p*u*r+p*i*d-e*m*d-c*i*g+e*u*g)*b,t[6]=(p*a*r-s*m*r-p*i*l+e*m*l+s*i*g-e*a*g)*b,t[7]=(s*u*r-c*a*r+c*i*l-e*u*l-s*i*d+e*a*d)*b,t[8]=v*b,t[9]=(p*h*r-c*f*r-p*n*d+e*f*d+c*n*g-e*h*g)*b,t[10]=(s*f*r-p*o*r+p*n*l-e*f*l-s*n*g+e*o*g)*b,t[11]=(c*o*r-s*h*r-c*n*l+e*h*l+s*n*d-e*o*d)*b,t[12]=x*b,t[13]=(c*f*i-p*h*i+p*n*u-e*f*u-c*n*m+e*h*m)*b,t[14]=(p*o*i-s*f*i-p*n*a+e*f*a+s*n*m-e*o*m)*b,t[15]=(s*h*i-c*o*i+c*n*a-e*h*a-s*n*u+e*o*u)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,a=t.z,l=r*s,c=r*o;return this.set(l*s+n,l*o-i*a,l*a+i*o,0,l*o+i*a,c*o+n,c*a-i*s,0,l*a-i*o,c*a+i*s,r*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,a=e._w,l=r+r,c=s+s,h=o+o,u=r*l,d=r*c,p=r*h,f=s*c,m=s*h,g=o*h,_=a*l,y=a*c,v=a*h,x=n.x,S=n.y,b=n.z;return i[0]=(1-(f+g))*x,i[1]=(d+v)*x,i[2]=(p-y)*x,i[3]=0,i[4]=(d-v)*S,i[5]=(1-(u+g))*S,i[6]=(m+_)*S,i[7]=0,i[8]=(p+y)*b,i[9]=(m-_)*b,i[10]=(1-(u+f))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=cr.set(i[0],i[1],i[2]).length();const s=cr.set(i[4],i[5],i[6]).length(),o=cr.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],hr.copy(this);const a=1/r,l=1/s,c=1/o;return hr.elements[0]*=a,hr.elements[1]*=a,hr.elements[2]*=a,hr.elements[4]*=l,hr.elements[5]*=l,hr.elements[6]*=l,hr.elements[8]*=c,hr.elements[9]*=c,hr.elements[10]*=c,e.setFromRotationMatrix(hr),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s,o=Fn){const a=this.elements,l=2*r/(e-t),c=2*r/(n-i),h=(e+t)/(e-t),u=(n+i)/(n-i);let d,p;if(o===Fn)d=-(s+r)/(s-r),p=-2*s*r/(s-r);else{if(o!==Bn)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);d=-s/(s-r),p=-s*r/(s-r)}return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,s,o=Fn){const a=this.elements,l=1/(e-t),c=1/(n-i),h=1/(s-r),u=(e+t)*l,d=(n+i)*c;let p,f;if(o===Fn)p=(s+r)*h,f=-2*h;else{if(o!==Bn)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);p=r*h,f=-1*h}return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=f,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const cr=new ni,hr=new lr,ur=new ni(0,0,0),dr=new ni(1,1,1),pr=new ni,fr=new ni,mr=new ni,gr=new lr,_r=new ei;class yr{constructor(t=0,e=0,n=0,i=yr.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],o=i[8],a=i[1],l=i[5],c=i[9],h=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(qn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-qn(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(qn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-qn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(qn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-qn(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return gr.makeRotationFromQuaternion(t),this.setFromRotationMatrix(gr,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return _r.setFromEuler(this),this.setFromQuaternion(_r,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}yr.DEFAULT_ORDER="XYZ";class vr{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let xr=0;const Sr=new ni,br=new ei,Mr=new lr,wr=new ni,Er=new ni,Tr=new ni,Ar=new ei,Cr=new ni(1,0,0),Rr=new ni(0,1,0),Pr=new ni(0,0,1),Lr={type:"added"},Ir={type:"removed"},Nr={type:"childadded",child:null},Dr={type:"childremoved",child:null};class Or extends Gn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:xr++}),this.uuid=Yn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Or.DEFAULT_UP.clone();const t=new ni,e=new yr,n=new ei,i=new ni(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new lr},normalMatrix:{value:new si}}),this.matrix=new lr,this.matrixWorld=new lr,this.matrixAutoUpdate=Or.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new vr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return br.setFromAxisAngle(t,e),this.quaternion.multiply(br),this}rotateOnWorldAxis(t,e){return br.setFromAxisAngle(t,e),this.quaternion.premultiply(br),this}rotateX(t){return this.rotateOnAxis(Cr,t)}rotateY(t){return this.rotateOnAxis(Rr,t)}rotateZ(t){return this.rotateOnAxis(Pr,t)}translateOnAxis(t,e){return Sr.copy(t).applyQuaternion(this.quaternion),this.position.add(Sr.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Cr,t)}translateY(t){return this.translateOnAxis(Rr,t)}translateZ(t){return this.translateOnAxis(Pr,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Mr.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?wr.copy(t):wr.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Er.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Mr.lookAt(Er,wr,this.up):Mr.lookAt(wr,Er,this.up),this.quaternion.setFromRotationMatrix(Mr),i&&(Mr.extractRotation(i.matrixWorld),br.setFromRotationMatrix(Mr),this.quaternion.premultiply(br.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Lr),Nr.child=t,this.dispatchEvent(Nr),Nr.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Ir),Dr.child=t,this.dispatchEvent(Dr),Dr.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Mr.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),Mr.multiply(t.parent.matrixWorld)),t.applyMatrix4(Mr),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Lr),Nr.child=t,this.dispatchEvent(Nr),Nr.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Er,t,Tr),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Er,Ar,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox?t.boundingBox.toJSON():void 0,boundingSphere:t.boundingSphere?t.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(t=>({...t})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(t),i.indirectTexture=this._indirectTexture.toJSON(t),null!==this._colorsTexture&&(i.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(i.boundingSphere=this.boundingSphere.toJSON()),null!==this.boundingBox&&(i.boundingBox=this.boundingBox.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations),h=s(t.nodes);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),h.length>0&&(n.nodes=h)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}Or.DEFAULT_UP=new ni(0,1,0),Or.DEFAULT_MATRIX_AUTO_UPDATE=!0,Or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Ur=new ni,Fr=new ni,Br=new ni,zr=new ni,Vr=new ni,kr=new ni,Gr=new ni,Hr=new ni,Wr=new ni,jr=new ni,Xr=new Ci,Yr=new Ci,qr=new Ci;class $r{constructor(t=new ni,e=new ni,n=new ni){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Ur.subVectors(t,e),i.cross(Ur);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){Ur.subVectors(i,e),Fr.subVectors(n,e),Br.subVectors(t,e);const s=Ur.dot(Ur),o=Ur.dot(Fr),a=Ur.dot(Br),l=Fr.dot(Fr),c=Fr.dot(Br),h=s*l-o*o;if(0===h)return r.set(0,0,0),null;const u=1/h,d=(l*a-o*c)*u,p=(s*c-o*a)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return null!==this.getBarycoord(t,e,n,i,zr)&&zr.x>=0&&zr.y>=0&&zr.x+zr.y<=1}static getInterpolation(t,e,n,i,r,s,o,a){return null===this.getBarycoord(t,e,n,i,zr)?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(r,zr.x),a.addScaledVector(s,zr.y),a.addScaledVector(o,zr.z),a)}static getInterpolatedAttribute(t,e,n,i,r,s){return Xr.setScalar(0),Yr.setScalar(0),qr.setScalar(0),Xr.fromBufferAttribute(t,e),Yr.fromBufferAttribute(t,n),qr.fromBufferAttribute(t,i),s.setScalar(0),s.addScaledVector(Xr,r.x),s.addScaledVector(Yr,r.y),s.addScaledVector(qr,r.z),s}static isFrontFacing(t,e,n,i){return Ur.subVectors(n,e),Fr.subVectors(t,e),Ur.cross(Fr).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Ur.subVectors(this.c,this.b),Fr.subVectors(this.a,this.b),.5*Ur.cross(Fr).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return $r.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return $r.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,i,r){return $r.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return $r.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return $r.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,o;Vr.subVectors(i,n),kr.subVectors(r,n),Hr.subVectors(t,n);const a=Vr.dot(Hr),l=kr.dot(Hr);if(a<=0&&l<=0)return e.copy(n);Wr.subVectors(t,i);const c=Vr.dot(Wr),h=kr.dot(Wr);if(c>=0&&h<=c)return e.copy(i);const u=a*h-c*l;if(u<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(Vr,s);jr.subVectors(t,r);const d=Vr.dot(jr),p=kr.dot(jr);if(p>=0&&d<=p)return e.copy(r);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(kr,o);const m=c*p-d*h;if(m<=0&&h-c>=0&&d-p>=0)return Gr.subVectors(r,i),o=(h-c)/(h-c+(d-p)),e.copy(i).addScaledVector(Gr,o);const g=1/(m+f+u);return s=f*g,o=u*g,e.copy(n).addScaledVector(Vr,s).addScaledVector(kr,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Zr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Jr={h:0,s:0,l:0},Kr={h:0,s:0,l:0};function Qr(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}class ts{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(void 0===e&&void 0===n){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Je){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,_i.colorSpaceToWorking(this,e),this}setRGB(t,e,n,i=_i.workingColorSpace){return this.r=t,this.g=e,this.b=n,_i.colorSpaceToWorking(this,i),this}setHSL(t,e,n,i=_i.workingColorSpace){if(t=$n(t,1),e=qn(e,0,1),n=qn(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Qr(r,i,t+1/3),this.g=Qr(r,i,t),this.b=Qr(r,i,t-1/3)}return _i.colorSpaceToWorking(this,i),this}setStyle(t,e=Je){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=i[1],r=n.length;if(3===r)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(6===r)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Je){const n=Zr[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=yi(t.r),this.g=yi(t.g),this.b=yi(t.b),this}copyLinearToSRGB(t){return this.r=vi(t.r),this.g=vi(t.g),this.b=vi(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Je){return _i.workingToColorSpace(es.copy(this),t),65536*Math.round(qn(255*es.r,0,255))+256*Math.round(qn(255*es.g,0,255))+Math.round(qn(255*es.b,0,255))}getHexString(t=Je){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=_i.workingColorSpace){_i.workingToColorSpace(es.copy(this),e);const n=es.r,i=es.g,r=es.b,s=Math.max(n,i,r),o=Math.min(n,i,r);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const t=s-o;switch(l=c<=.5?t/(s+o):t/(2-s-o),s){case n:a=(i-r)/t+(i<r?6:0);break;case i:a=(r-n)/t+2;break;case r:a=(n-i)/t+4}a/=6}return t.h=a,t.s=l,t.l=c,t}getRGB(t,e=_i.workingColorSpace){return _i.workingToColorSpace(es.copy(this),e),t.r=es.r,t.g=es.g,t.b=es.b,t}getStyle(t=Je){_i.workingToColorSpace(es.copy(this),t);const e=es.r,n=es.g,i=es.b;return t!==Je?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`}offsetHSL(t,e,n){return this.getHSL(Jr),this.setHSL(Jr.h+t,Jr.s+e,Jr.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Jr),t.getHSL(Kr);const n=Zn(Jr.h,Kr.h,e),i=Zn(Jr.s,Kr.s,e),r=Zn(Jr.l,Kr.l,e);return this.setHSL(n,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*n+r[6]*i,this.g=r[1]*e+r[4]*n+r[7]*i,this.b=r[2]*e+r[5]*n+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const es=new ts;ts.NAMES=Zr;let ns=0;class is extends Gn{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:ns++}),this.uuid=Yn(),this.name="",this.type="Material",this.blending=y,this.side=f,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=I,this.blendDst=N,this.blendEquation=M,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ts(0,0,0),this.blendAlpha=0,this.depthFunc=X,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=_n,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=nn,this.stencilZFail=nn,this.stencilZPass=nn,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(n.dispersion=this.dispersion),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(n.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapRotation&&(n.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==y&&(n.blending=this.blending),this.side!==f&&(n.side=this.side),!0===this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=!0),this.blendSrc!==I&&(n.blendSrc=this.blendSrc),this.blendDst!==N&&(n.blendDst=this.blendDst),this.blendEquation!==M&&(n.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(n.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(n.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==X&&(n.depthFunc=this.depthFunc),!1===this.depthTest&&(n.depthTest=this.depthTest),!1===this.depthWrite&&(n.depthWrite=this.depthWrite),!1===this.colorWrite&&(n.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==_n&&(n.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(n.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==nn&&(n.stencilFail=this.stencilFail),this.stencilZFail!==nn&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==nn&&(n.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(n.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaHash&&(n.alphaHash=!0),!0===this.alphaToCoverage&&(n.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=!0),!0===this.forceSinglePass&&(n.forceSinglePass=!0),!0===this.wireframe&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}class rs extends is{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ts(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new yr,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const ss=os();function os(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),i=new Uint32Array(512),r=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(i[t]=0,i[256|t]=32768,r[t]=24,r[256|t]=24):e<-14?(i[t]=1024>>-e-14,i[256|t]=1024>>-e-14|32768,r[t]=-e-1,r[256|t]=-e-1):e<=15?(i[t]=e+15<<10,i[256|t]=e+15<<10|32768,r[t]=13,r[256|t]=13):e<128?(i[t]=31744,i[256|t]=64512,r[t]=24,r[256|t]=24):(i[t]=31744,i[256|t]=64512,r[t]=13,r[256|t]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,s[t]=e|n}for(let t=1024;t<2048;++t)s[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)o[t]=t<<23;o[31]=1199570944,o[32]=2147483648;for(let t=33;t<63;++t)o[t]=2147483648+(t-32<<23);o[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(a[t]=1024);return{floatView:e,uint32View:n,baseTable:i,shiftTable:r,mantissaTable:s,exponentTable:o,offsetTable:a}}function as(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=qn(t,-65504,65504),ss.floatView[0]=t;const e=ss.uint32View[0],n=e>>23&511;return ss.baseTable[n]+((8388607&e)>>ss.shiftTable[n])}function ls(t){const e=t>>10;return ss.uint32View[0]=ss.mantissaTable[ss.offsetTable[e]+(1023&t)]+ss.exponentTable[e],ss.floatView[0]}class cs{static toHalfFloat(t){return as(t)}static fromHalfFloat(t){return ls(t)}}const hs=new ni,us=new ti;let ds=0;class ps{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:ds++}),this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=n,this.usage=Tn,this.updateRanges=[],this.gpuType=Ot,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)us.fromBufferAttribute(this,e),us.applyMatrix3(t),this.setXY(e,us.x,us.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)hs.fromBufferAttribute(this,e),hs.applyMatrix3(t),this.setXYZ(e,hs.x,hs.y,hs.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)hs.fromBufferAttribute(this,e),hs.applyMatrix4(t),this.setXYZ(e,hs.x,hs.y,hs.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)hs.fromBufferAttribute(this,e),hs.applyNormalMatrix(t),this.setXYZ(e,hs.x,hs.y,hs.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)hs.fromBufferAttribute(this,e),hs.transformDirection(t),this.setXYZ(e,hs.x,hs.y,hs.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=Jn(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Kn(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Jn(e,this.array)),e}setX(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Jn(e,this.array)),e}setY(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Jn(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Jn(e,this.array)),e}setW(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array),r=Kn(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==Tn&&(t.usage=this.usage),t}}class fs extends ps{constructor(t,e,n){super(new Int8Array(t),e,n)}}class ms extends ps{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class gs extends ps{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class _s extends ps{constructor(t,e,n){super(new Int16Array(t),e,n)}}class ys extends ps{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class vs extends ps{constructor(t,e,n){super(new Int32Array(t),e,n)}}class xs extends ps{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Ss extends ps{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}getX(t){let e=ls(this.array[t*this.itemSize]);return this.normalized&&(e=Jn(e,this.array)),e}setX(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize]=as(e),this}getY(t){let e=ls(this.array[t*this.itemSize+1]);return this.normalized&&(e=Jn(e,this.array)),e}setY(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+1]=as(e),this}getZ(t){let e=ls(this.array[t*this.itemSize+2]);return this.normalized&&(e=Jn(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+2]=as(e),this}getW(t){let e=ls(this.array[t*this.itemSize+3]);return this.normalized&&(e=Jn(e,this.array)),e}setW(t,e){return this.normalized&&(e=Kn(e,this.array)),this.array[t*this.itemSize+3]=as(e),this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array)),this.array[t+0]=as(e),this.array[t+1]=as(n),this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array)),this.array[t+0]=as(e),this.array[t+1]=as(n),this.array[t+2]=as(i),this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array),r=Kn(r,this.array)),this.array[t+0]=as(e),this.array[t+1]=as(n),this.array[t+2]=as(i),this.array[t+3]=as(r),this}}class bs extends ps{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Ms=0;const ws=new lr,Es=new Or,Ts=new ni,As=new Oi,Cs=new Oi,Rs=new ni;class Ps extends Gn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ms++}),this.uuid=Yn(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(ai(t)?xs:ys)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new si).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return ws.makeRotationFromQuaternion(t),this.applyMatrix4(ws),this}rotateX(t){return ws.makeRotationX(t),this.applyMatrix4(ws),this}rotateY(t){return ws.makeRotationY(t),this.applyMatrix4(ws),this}rotateZ(t){return ws.makeRotationZ(t),this.applyMatrix4(ws),this}translate(t,e,n){return ws.makeTranslation(t,e,n),this.applyMatrix4(ws),this}scale(t,e,n){return ws.makeScale(t,e,n),this.applyMatrix4(ws),this}lookAt(t){return Es.lookAt(t),Es.updateMatrix(),this.applyMatrix4(Es.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ts).negate(),this.translate(Ts.x,Ts.y,Ts.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}this.setAttribute("position",new bs(e,3))}else{const n=Math.min(t.length,e.count);for(let i=0;i<n;i++){const n=t[i];e.setXYZ(i,n.x,n.y,n.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Oi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new ni(-1/0,-1/0,-1/0),new ni(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];As.setFromBufferAttribute(n),this.morphTargetsRelative?(Rs.addVectors(this.boundingBox.min,As.min),this.boundingBox.expandByPoint(Rs),Rs.addVectors(this.boundingBox.max,As.max),this.boundingBox.expandByPoint(Rs)):(this.boundingBox.expandByPoint(As.min),this.boundingBox.expandByPoint(As.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Qi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new ni,1/0);if(t){const n=this.boundingSphere.center;if(As.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Cs.setFromBufferAttribute(n),this.morphTargetsRelative?(Rs.addVectors(As.min,Cs.min),As.expandByPoint(Rs),Rs.addVectors(As.max,Cs.max),As.expandByPoint(Rs)):(As.expandByPoint(Cs.min),As.expandByPoint(Cs.max))}As.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)Rs.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(Rs));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],o=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)Rs.fromBufferAttribute(s,e),o&&(Ts.fromBufferAttribute(t,e),Rs.add(Ts)),i=Math.max(i,n.distanceToSquared(Rs))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.position,i=e.normal,r=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ps(new Float32Array(4*n.count),4));const s=this.getAttribute("tangent"),o=[],a=[];for(let t=0;t<n.count;t++)o[t]=new ni,a[t]=new ni;const l=new ni,c=new ni,h=new ni,u=new ti,d=new ti,p=new ti,f=new ni,m=new ni;function g(t,e,i){l.fromBufferAttribute(n,t),c.fromBufferAttribute(n,e),h.fromBufferAttribute(n,i),u.fromBufferAttribute(r,t),d.fromBufferAttribute(r,e),p.fromBufferAttribute(r,i),c.sub(l),h.sub(l),d.sub(u),p.sub(u);const s=1/(d.x*p.y-p.x*d.y);isFinite(s)&&(f.copy(c).multiplyScalar(p.y).addScaledVector(h,-d.y).multiplyScalar(s),m.copy(h).multiplyScalar(d.x).addScaledVector(c,-p.x).multiplyScalar(s),o[t].add(f),o[e].add(f),o[i].add(f),a[t].add(m),a[e].add(m),a[i].add(m))}let _=this.groups;0===_.length&&(_=[{start:0,count:t.count}]);for(let e=0,n=_.length;e<n;++e){const n=_[e],i=n.start;for(let e=i,r=i+n.count;e<r;e+=3)g(t.getX(e+0),t.getX(e+1),t.getX(e+2))}const y=new ni,v=new ni,x=new ni,S=new ni;function b(t){x.fromBufferAttribute(i,t),S.copy(x);const e=o[t];y.copy(e),y.sub(x.multiplyScalar(x.dot(e))).normalize(),v.crossVectors(S,e);const n=v.dot(a[t])<0?-1:1;s.setXYZW(t,y.x,y.y,y.z,n)}for(let e=0,n=_.length;e<n;++e){const n=_[e],i=n.start;for(let e=i,r=i+n.count;e<r;e+=3)b(t.getX(e+0)),b(t.getX(e+1)),b(t.getX(e+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new ps(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new ni,r=new ni,s=new ni,o=new ni,a=new ni,l=new ni,c=new ni,h=new ni;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),f=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,o=e.count;t<o;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Rs.fromBufferAttribute(t,e),Rs.normalize(),t.setXYZ(e,Rs.x,Rs.y,Rs.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let o=0,a=0;for(let r=0,l=e.length;r<l;r++){o=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)s[a++]=n[o++]}return new ps(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ps,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],o=r[i];for(let e=0,i=o.length;e<i;e++){const i=t(o[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];s.push(i.toJSON(t.data))}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere=o.toJSON()),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone());const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ls=new lr,Is=new ar,Ns=new Qi,Ds=new ni,Os=new ni,Us=new ni,Fs=new ni,Bs=new ni,zs=new ni,Vs=new ni,ks=new ni;class Gs extends Or{constructor(t=new Ps,e=new rs){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,s=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const o=this.morphTargetInfluences;if(r&&o){zs.set(0,0,0);for(let n=0,i=r.length;n<i;n++){const i=o[n],a=r[n];0!==i&&(Bs.fromBufferAttribute(a,t),s?zs.addScaledVector(Bs,i):zs.addScaledVector(Bs.sub(e),i))}e.add(zs)}return e}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0!==i){if(null===n.boundingSphere&&n.computeBoundingSphere(),Ns.copy(n.boundingSphere),Ns.applyMatrix4(r),Is.copy(t.ray).recast(t.near),!1===Ns.containsPoint(Is.origin)){if(null===Is.intersectSphere(Ns,Ds))return;if(Is.origin.distanceToSquared(Ds)>(t.far-t.near)**2)return}Ls.copy(r).invert(),Is.copy(t.ray).applyMatrix4(Ls),null!==n.boundingBox&&!1===Is.intersectsBox(n.boundingBox)||this._computeIntersections(t,e,Is)}}_computeIntersections(t,e,n){let i;const r=this.geometry,s=this.material,o=r.index,a=r.attributes.position,l=r.attributes.uv,c=r.attributes.uv1,h=r.attributes.normal,u=r.groups,d=r.drawRange;if(null!==o)if(Array.isArray(s))for(let r=0,a=u.length;r<a;r++){const a=u[r],p=s[a.materialIndex];for(let r=Math.max(a.start,d.start),s=Math.min(o.count,Math.min(a.start+a.count,d.start+d.count));r<s;r+=3)i=Hs(this,p,t,n,l,c,h,o.getX(r),o.getX(r+1),o.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=a.materialIndex,e.push(i))}else for(let r=Math.max(0,d.start),a=Math.min(o.count,d.start+d.count);r<a;r+=3)i=Hs(this,s,t,n,l,c,h,o.getX(r),o.getX(r+1),o.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),e.push(i));else if(void 0!==a)if(Array.isArray(s))for(let r=0,o=u.length;r<o;r++){const o=u[r],p=s[o.materialIndex];for(let r=Math.max(o.start,d.start),s=Math.min(a.count,Math.min(o.start+o.count,d.start+d.count));r<s;r+=3)i=Hs(this,p,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=o.materialIndex,e.push(i))}else for(let r=Math.max(0,d.start),o=Math.min(a.count,d.start+d.count);r<o;r+=3)i=Hs(this,s,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}function Hs(t,e,n,i,r,s,o,a,l,c){t.getVertexPosition(a,Os),t.getVertexPosition(l,Us),t.getVertexPosition(c,Fs);const h=function(t,e,n,i,r,s,o,a){let l;if(l=e.side===m?i.intersectTriangle(o,s,r,!0,a):i.intersectTriangle(r,s,o,e.side===f,a),null===l)return null;ks.copy(a),ks.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(ks);return c<n.near||c>n.far?null:{distance:c,point:ks.clone(),object:t}}(t,e,n,i,Os,Us,Fs,Vs);if(h){const t=new ni;$r.getBarycoord(Vs,Os,Us,Fs,t),r&&(h.uv=$r.getInterpolatedAttribute(r,a,l,c,t,new ti)),s&&(h.uv1=$r.getInterpolatedAttribute(s,a,l,c,t,new ti)),o&&(h.normal=$r.getInterpolatedAttribute(o,a,l,c,t,new ni),h.normal.dot(i.direction)>0&&h.normal.multiplyScalar(-1));const e={a,b:l,c,normal:new ni,materialIndex:0};$r.getNormal(Os,Us,Fs,e.normal),h.face=e,h.barycoord=t}return h}class Ws extends Ps{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],h=[];let u=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,_){const y=s/m,v=p/g,x=s/2,S=p/2,b=f/2,M=m+1,w=g+1;let E=0,T=0;const A=new ni;for(let s=0;s<w;s++){const o=s*v-S;for(let a=0;a<M;a++){const u=a*y-x;A[t]=u*i,A[e]=o*r,A[n]=b,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),h.push(a/m),h.push(1-s/g),E+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=u+e+M*t,i=u+e+M*(t+1),r=u+(e+1)+M*(t+1),s=u+(e+1)+M*t;a.push(n,i,s),a.push(i,r,s),T+=6}o.addGroup(d,T,_),d+=T,u+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(a),this.setAttribute("position",new bs(l,3)),this.setAttribute("normal",new bs(c,3)),this.setAttribute("uv",new bs(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ws(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function js(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][i]=null):e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function Xs(t){const e={};for(let n=0;n<t.length;n++){const i=js(t[n]);for(const t in i)e[t]=i[t]}return e}function Ys(t){const e=t.getRenderTarget();return null===e?t.outputColorSpace:!0===e.isXRRenderTarget?e.texture.colorSpace:_i.workingColorSpace}const qs={clone:js,merge:Xs};class $s extends is{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=js(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class Zs extends Or{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new lr,this.projectionMatrix=new lr,this.projectionMatrixInverse=new lr,this.coordinateSystem=Fn}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const Js=new ni,Ks=new ti,Qs=new ti;class to extends Zs{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*Xn*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*jn*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*Xn*Math.atan(Math.tan(.5*jn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){Js.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Js.x,Js.y).multiplyScalar(-t/Js.z),Js.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Js.x,Js.y).multiplyScalar(-t/Js.z)}getViewSize(t,e){return this.getViewBounds(t,Ks,Qs),e.subVectors(Qs,Ks)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*jn*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/o,i*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const eo=-90;class no extends Or{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new to(eo,1,t,e);i.layers=this.layers,this.add(i);const r=new to(eo,1,t,e);r.layers=this.layers,this.add(r);const s=new to(eo,1,t,e);s.layers=this.layers,this.add(s);const o=new to(eo,1,t,e);o.layers=this.layers,this.add(o);const a=new to(eo,1,t,e);a.layers=this.layers,this.add(a);const l=new to(eo,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,r,s,o,a]=e;for(const t of e)this.remove(t);if(t===Fn)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),s.up.set(0,0,1),s.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),a.up.set(0,1,0),a.lookAt(0,0,-1);else{if(t!==Bn)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),s.up.set(0,0,-1),s.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),a.up.set(0,-1,0),a.lookAt(0,0,-1)}for(const t of e)this.add(t),t.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[r,s,o,a,l,c]=this.children,h=t.getRenderTarget(),u=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,r),t.setRenderTarget(n,1,i),t.render(e,s),t.setRenderTarget(n,2,i),t.render(e,o),t.setRenderTarget(n,3,i),t.render(e,a),t.setRenderTarget(n,4,i),t.render(e,l),n.texture.generateMipmaps=f,t.setRenderTarget(n,5,i),t.render(e,c),t.setRenderTarget(h,u,d),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class io extends Ai{constructor(t=[],e=ut,n,i,r,s,o,a,l,c){super(t,e,n,i,r,s,o,a,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class ro extends Pi{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new io(i),this._setTextureOptions(e),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},i="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",r="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new Ws(5,5,5),o=new $s({name:"CubemapFromEquirect",uniforms:js(n),vertexShader:i,fragmentShader:r,side:m,blending:_});o.uniforms.tEquirect.value=e;const a=new Gs(s,o),l=e.minFilter;return e.minFilter===At&&(e.minFilter=wt),new no(1,10,this).update(t,a),e.minFilter=l,a.geometry.dispose(),a.material.dispose(),this}clear(t,e=!0,n=!0,i=!0){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}class so extends Or{constructor(){super(),this.isGroup=!0,this.type="Group"}}const oo={type:"move"};class ao{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new so,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new so,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ni,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ni),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new so,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ni,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ni),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n),r=this._getHandJoint(l,i);null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],o=i.position.distanceTo(r.position),a=.02,c=.005;l.inputState.pinching&&o>a+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&o<=a-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1));null!==o&&(i=e.getPose(t.targetRaySpace,n),null===i&&null!==r&&(i=r),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(oo)))}return null!==o&&(o.visible=null!==i),null!==a&&(a.visible=null!==r),null!==l&&(l.visible=null!==s),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const n=new so;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class lo{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new ts(t),this.density=e}clone(){return new lo(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class co{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new ts(t),this.near=e,this.far=n}clone(){return new co(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class ho extends Or{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new yr,this.environmentIntensity=1,this.environmentRotation=new yr,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class uo{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=Tn,this.updateRanges=[],this.version=0,this.uuid=Yn()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Yn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Yn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const po=new ni;class fo{constructor(t,e,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)po.fromBufferAttribute(this,e),po.applyMatrix4(t),this.setXYZ(e,po.x,po.y,po.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)po.fromBufferAttribute(this,e),po.applyNormalMatrix(t),this.setXYZ(e,po.x,po.y,po.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)po.fromBufferAttribute(this,e),po.transformDirection(t),this.setXYZ(e,po.x,po.y,po.z);return this}getComponent(t,e){let n=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(n=Jn(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Kn(n,this.array)),this.data.array[t*this.data.stride+this.offset+e]=n,this}setX(t,e){return this.normalized&&(e=Kn(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Kn(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Kn(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Kn(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Jn(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Jn(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Jn(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Jn(e,this.array)),e}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=Kn(e,this.array),n=Kn(n,this.array),i=Kn(i,this.array),r=Kn(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new ps(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new fo(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class mo extends is{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ts(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let go;const _o=new ni,yo=new ni,vo=new ni,xo=new ti,So=new ti,bo=new lr,Mo=new ni,wo=new ni,Eo=new ni,To=new ti,Ao=new ti,Co=new ti;class Ro extends Or{constructor(t=new mo){if(super(),this.isSprite=!0,this.type="Sprite",void 0===go){go=new Ps;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new uo(t,5);go.setIndex([0,1,2,0,2,3]),go.setAttribute("position",new fo(e,3,0,!1)),go.setAttribute("uv",new fo(e,2,3,!1))}this.geometry=go,this.material=t,this.center=new ti(.5,.5),this.count=1}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),yo.setFromMatrixScale(this.matrixWorld),bo.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),vo.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&yo.multiplyScalar(-vo.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;Po(Mo.set(-.5,-.5,0),vo,s,yo,i,r),Po(wo.set(.5,-.5,0),vo,s,yo,i,r),Po(Eo.set(.5,.5,0),vo,s,yo,i,r),To.set(0,0),Ao.set(1,0),Co.set(1,1);let o=t.ray.intersectTriangle(Mo,wo,Eo,!1,_o);if(null===o&&(Po(wo.set(-.5,.5,0),vo,s,yo,i,r),Ao.set(0,1),o=t.ray.intersectTriangle(Mo,Eo,wo,!1,_o),null===o))return;const a=t.ray.origin.distanceTo(_o);a<t.near||a>t.far||e.push({distance:a,point:_o.clone(),uv:$r.getInterpolation(_o,Mo,wo,Eo,To,Ao,Co,new ti),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Po(t,e,n,i,r,s){xo.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(So.x=s*xo.x-r*xo.y,So.y=r*xo.x+s*xo.y):So.copy(xo),t.copy(e),t.x+=So.x,t.y+=So.y,t.applyMatrix4(bo)}const Lo=new ni,Io=new ni;class No extends Or{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance,n.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,n=0){e=Math.abs(e);const i=this.levels;let r;for(r=0;r<i.length&&!(e<i[r].distance);r++);return i.splice(r,0,{distance:e,hysteresis:n,object:t}),this.add(t),this}removeLevel(t){const e=this.levels;for(let n=0;n<e.length;n++)if(e[n].distance===t){const t=e.splice(n,1);return this.remove(t[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i;n++){let i=e[n].distance;if(e[n].object.visible&&(i-=i*e[n].hysteresis),t<i)break}return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Lo.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Lo);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Lo.setFromMatrixPosition(t.matrixWorld),Io.setFromMatrixPosition(this.matrixWorld);const n=Lo.distanceTo(Io)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r;i++){let t=e[i].distance;if(e[i].object.visible&&(t-=t*e[i].hysteresis),!(n>=t))break;e[i-1].object.visible=!1,e[i].object.visible=!0}for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,i=n.length;t<i;t++){const i=n[t];e.object.levels.push({object:i.object.uuid,distance:i.distance,hysteresis:i.hysteresis})}return e}}const Do=new ni,Oo=new Ci,Uo=new Ci,Fo=new ni,Bo=new lr,zo=new ni,Vo=new Qi,ko=new lr,Go=new ar;class Ho extends Gs{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=lt,this.bindMatrix=new lr,this.bindMatrixInverse=new lr,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new Oi),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,zo),this.boundingBox.expandByPoint(zo)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Qi),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,zo),this.boundingSphere.expandByPoint(zo)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const n=this.material,i=this.matrixWorld;void 0!==n&&(null===this.boundingSphere&&this.computeBoundingSphere(),Vo.copy(this.boundingSphere),Vo.applyMatrix4(i),!1!==t.ray.intersectsSphere(Vo)&&(ko.copy(i).invert(),Go.copy(t.ray).applyMatrix4(ko),null!==this.boundingBox&&!1===Go.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,Go)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Ci,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.fromBufferAttribute(e,n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===lt?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===ct?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const n=this.skeleton,i=this.geometry;Oo.fromBufferAttribute(i.attributes.skinIndex,t),Uo.fromBufferAttribute(i.attributes.skinWeight,t),Do.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=Uo.getComponent(t);if(0!==i){const r=Oo.getComponent(t);Bo.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Fo.copy(Do).applyMatrix4(Bo),i)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Wo extends Or{constructor(){super(),this.isBone=!0,this.type="Bone"}}class jo extends Ai{constructor(t=null,e=1,n=1,i,r,s,o,a,l=vt,c=vt,h,u){super(null,s,o,a,l,c,i,r,h,u),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Xo=new lr,Yo=new lr;class qo{constructor(t=[],e=[]){this.uuid=Yn(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new lr)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new lr;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,r=t.length;i<r;i++){const r=t[i]?t[i].matrixWorld:Yo;Xo.multiplyMatrices(r,e[i]),Xo.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)}clone(){return new qo(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new jo(e,t,t,Ht,Ot);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new Wo),this.bones.push(r),this.boneInverses.push((new lr).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const r=e[i];t.bones.push(r.uuid);const s=n[i];t.boneInverses.push(s.toArray())}return t}}class $o extends ps{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Zo=new lr,Jo=new lr,Ko=[],Qo=new Oi,ta=new lr,ea=new Gs,na=new Qi;class ia extends Gs{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new $o(new Float32Array(16*n),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<n;t++)this.setMatrixAt(t,ta)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new Oi),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,Zo),Qo.copy(t.boundingBox).applyMatrix4(Zo),this.boundingBox.union(Qo)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new Qi),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,Zo),na.copy(t.boundingSphere).applyMatrix4(Zo),this.boundingSphere.union(na)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const n=e.morphTargetInfluences,i=this.morphTexture.source.data.data,r=t*(n.length+1)+1;for(let t=0;t<n.length;t++)n[t]=i[r+t]}raycast(t,e){const n=this.matrixWorld,i=this.count;if(ea.geometry=this.geometry,ea.material=this.material,void 0!==ea.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),na.copy(this.boundingSphere),na.applyMatrix4(n),!1!==t.ray.intersectsSphere(na)))for(let r=0;r<i;r++){this.getMatrixAt(r,Zo),Jo.multiplyMatrices(n,Zo),ea.matrixWorld=Jo,ea.raycast(t,Ko);for(let t=0,n=Ko.length;t<n;t++){const n=Ko[t];n.instanceId=r,n.object=this,e.push(n)}Ko.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new $o(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const n=e.morphTargetInfluences,i=n.length+1;null===this.morphTexture&&(this.morphTexture=new jo(new Float32Array(i*this.count),i,this.count,Xt,Ot));const r=this.morphTexture.source.data.data;let s=0;for(let t=0;t<n.length;t++)s+=n[t];const o=this.geometry.morphTargetsRelative?1:1-s,a=i*t;r[a]=o,r.set(n,a+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}const ra=new ni,sa=new ni,oa=new si;class aa{constructor(t=new ni(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=ra.subVectors(n,e).cross(sa.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(ra),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(n,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||oa.getNormalMatrix(t),i=this.coplanarPoint(ra).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const la=new Qi,ca=new ti(.5,.5),ha=new ni;class ua{constructor(t=new aa,e=new aa,n=new aa,i=new aa,r=new aa,s=new aa){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=Fn){const n=this.planes,i=t.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],h=i[6],u=i[7],d=i[8],p=i[9],f=i[10],m=i[11],g=i[12],_=i[13],y=i[14],v=i[15];if(n[0].setComponents(a-r,u-l,m-d,v-g).normalize(),n[1].setComponents(a+r,u+l,m+d,v+g).normalize(),n[2].setComponents(a+s,u+c,m+p,v+_).normalize(),n[3].setComponents(a-s,u-c,m-p,v-_).normalize(),n[4].setComponents(a-o,u-h,m-f,v-y).normalize(),e===Fn)n[5].setComponents(a+o,u+h,m+f,v+y).normalize();else{if(e!==Bn)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);n[5].setComponents(o,h,f,y).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),la.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),la.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(la)}intersectsSprite(t){la.center.set(0,0,0);const e=ca.distanceTo(t.center);return la.radius=.7071067811865476+e,la.applyMatrix4(t.matrixWorld),this.intersectsSphere(la)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(ha.x=i.normal.x>0?t.max.x:t.min.x,ha.y=i.normal.y>0?t.max.y:t.min.y,ha.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(ha)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}const da=new lr,pa=new ua;class fa{constructor(){this.coordinateSystem=Fn}intersectsObject(t,e){if(!e.isArrayCamera||0===e.cameras.length)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(da.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),pa.setFromProjectionMatrix(da,this.coordinateSystem),pa.intersectsObject(t))return!0}return!1}intersectsSprite(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(da.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),pa.setFromProjectionMatrix(da,this.coordinateSystem),pa.intersectsSprite(t))return!0}return!1}intersectsSphere(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(da.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),pa.setFromProjectionMatrix(da,this.coordinateSystem),pa.intersectsSphere(t))return!0}return!1}intersectsBox(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(da.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),pa.setFromProjectionMatrix(da,this.coordinateSystem),pa.intersectsBox(t))return!0}return!1}containsPoint(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(da.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),pa.setFromProjectionMatrix(da,this.coordinateSystem),pa.containsPoint(t))return!0}return!1}clone(){return new fa}}function ma(t,e){return t-e}function ga(t,e){return t.z-e.z}function _a(t,e){return e.z-t.z}class ya{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,n,i){const r=this.pool,s=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const o=r[this.index];s.push(o),this.index++,o.start=t,o.count=e,o.z=n,o.index=i}reset(){this.list.length=0,this.index=0}}const va=new lr,xa=new ts(1,1,1),Sa=new ua,ba=new fa,Ma=new Oi,wa=new Qi,Ea=new ni,Ta=new ni,Aa=new ni,Ca=new ya,Ra=new Gs,Pa=[];function La(t,e,n=0){const i=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const r=t.count;for(let s=0;s<r;s++)for(let r=0;r<i;r++)e.setComponent(s+n,r,t.getComponent(s,r))}else e.array.set(t.array,n*i);e.needsUpdate=!0}function Ia(t,e){if(t.constructor!==e.constructor){const n=Math.min(t.length,e.length);for(let i=0;i<n;i++)e[i]=t[i]}else{const n=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,n))}}class Na extends Gs{constructor(t,e,n=2*e,i){super(new Ps,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=n,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(4*this._maxInstanceCount);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4),n=new jo(e,t,t,Ht,Ot);this._matricesTexture=n}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),n=new jo(e,t,t,Yt,Dt);this._indirectTexture=n}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),n=new jo(e,t,t,Ht,Ot);n.colorSpace=_i.workingColorSpace,this._colorsTexture=n}_initializeGeometry(t){const e=this.geometry,n=this._maxVertexCount,i=this._maxIndexCount;if(!1===this._geometryInitialized){for(const i in t.attributes){const r=t.getAttribute(i),{array:s,itemSize:o,normalized:a}=r,l=new s.constructor(n*o),c=new ps(l,o,a);e.setAttribute(i,c)}if(null!==t.getIndex()){const t=n>65535?new Uint32Array(i):new Uint16Array(i);e.setIndex(new ps(t,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(Boolean(t.getIndex())!==Boolean(e.getIndex()))throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const n in e.attributes){if(!t.hasAttribute(n))throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);const i=t.getAttribute(n),r=e.getAttribute(n);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const e=this._instanceInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const e=this._geometryInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Oi);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let n=0,i=e.length;n<i;n++){if(!1===e[n].active)continue;const i=e[n].geometryIndex;this.getMatrixAt(n,va),this.getBoundingBoxAt(i,Ma).applyMatrix4(va),t.union(Ma)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Qi);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let n=0,i=e.length;n<i;n++){if(!1===e[n].active)continue;const i=e[n].geometryIndex;this.getMatrixAt(n,va),this.getBoundingSphereAt(i,wa).applyMatrix4(va),t.union(wa)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&0===this._availableInstanceIds.length)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const e={visible:!0,active:!0,geometryIndex:t};let n=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(ma),n=this._availableInstanceIds.shift(),this._instanceInfo[n]=e):(n=this._instanceInfo.length,this._instanceInfo.push(e));const i=this._matricesTexture;va.identity().toArray(i.image.data,16*n),i.needsUpdate=!0;const r=this._colorsTexture;return r&&(xa.toArray(r.image.data,4*n),r.needsUpdate=!0),this._visibilityChanged=!0,n}addGeometry(t,e=-1,n=-1){this._initializeGeometry(t),this._validateGeometry(t);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=-1===e?t.getAttribute("position").count:e;const s=t.getIndex();if(null!==s&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=-1===n?s.count:n),-1!==i.indexStart&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let o;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(ma),o=this._availableGeometryIds.shift(),r[o]=i):(o=this._geometryCount,this._geometryCount++,r.push(i)),this.setGeometryAt(o,t),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,o}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const n=this.geometry,i=null!==n.getIndex(),r=n.getIndex(),s=e.getIndex(),o=this._geometryInfo[t];if(i&&s.count>o.reservedIndexCount||e.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const a=o.vertexStart,l=o.reservedVertexCount;o.vertexCount=e.getAttribute("position").count;for(const t in n.attributes){const i=e.getAttribute(t),r=n.getAttribute(t);La(i,r,a);const s=i.itemSize;for(let t=i.count,e=l;t<e;t++){const e=a+t;for(let t=0;t<s;t++)r.setComponent(e,t,0)}r.needsUpdate=!0,r.addUpdateRange(a*s,l*s)}if(i){const t=o.indexStart,n=o.reservedIndexCount;o.indexCount=e.getIndex().count;for(let e=0;e<s.count;e++)r.setX(t+e,a+s.getX(e));for(let e=s.count,i=n;e<i;e++)r.setX(t+e,a);r.needsUpdate=!0,r.addUpdateRange(t,o.reservedIndexCount)}return o.start=i?o.indexStart:o.vertexStart,o.count=i?o.indexCount:o.vertexCount,o.boundingBox=null,null!==e.boundingBox&&(o.boundingBox=e.boundingBox.clone()),o.boundingSphere=null,null!==e.boundingSphere&&(o.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||!1===e[t].active)return this;const n=this._instanceInfo;for(let e=0,i=n.length;e<i;e++)n[e].active&&n[e].geometryIndex===t&&this.deleteInstance(e);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,e=0;const n=this._geometryInfo,i=n.map((t,e)=>e).sort((t,e)=>n[t].vertexStart-n[e].vertexStart),r=this.geometry;for(let s=0,o=n.length;s<o;s++){const o=i[s],a=n[o];if(!1!==a.active){if(null!==r.index){if(a.indexStart!==e){const{indexStart:n,vertexStart:i,reservedIndexCount:s}=a,o=r.index,l=o.array,c=t-i;for(let t=n;t<n+s;t++)l[t]=l[t]+c;o.array.copyWithin(e,n,n+s),o.addUpdateRange(e,s),a.indexStart=e}e+=a.reservedIndexCount}if(a.vertexStart!==t){const{vertexStart:e,reservedVertexCount:n}=a,i=r.attributes;for(const r in i){const s=i[r],{array:o,itemSize:a}=s;o.copyWithin(t*a,e*a,(e+n)*a),s.addUpdateRange(t*a,n*a)}a.vertexStart=t}t+=a.reservedVertexCount,a.start=r.index?a.indexStart:a.vertexStart,this._nextIndexStart=r.index?a.indexStart+a.reservedIndexCount:0,this._nextVertexStart=a.vertexStart+a.reservedVertexCount}}return this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[t];if(null===i.boundingBox){const t=new Oi,e=n.index,r=n.attributes.position;for(let n=i.start,s=i.start+i.count;n<s;n++){let i=n;e&&(i=e.getX(i)),t.expandByPoint(Ea.fromBufferAttribute(r,i))}i.boundingBox=t}return e.copy(i.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[t];if(null===i.boundingSphere){const e=new Qi;this.getBoundingBoxAt(t,Ma),Ma.getCenter(e.center);const r=n.index,s=n.attributes.position;let o=0;for(let t=i.start,n=i.start+i.count;t<n;t++){let n=t;r&&(n=r.getX(n)),Ea.fromBufferAttribute(s,n),o=Math.max(o,e.center.distanceToSquared(Ea))}e.radius=Math.sqrt(o),i.boundingSphere=e}return e.copy(i.boundingSphere),e}setMatrixAt(t,e){this.validateInstanceId(t);const n=this._matricesTexture,i=this._matricesTexture.image.data;return e.toArray(i,16*t),n.needsUpdate=!0,this}getMatrixAt(t,e){return this.validateInstanceId(t),e.fromArray(this._matricesTexture.image.data,16*t)}setColorAt(t,e){return this.validateInstanceId(t),null===this._colorsTexture&&this._initColorsTexture(),e.toArray(this._colorsTexture.image.data,4*t),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,e){return this.validateInstanceId(t),e.fromArray(this._colorsTexture.image.data,4*t)}setVisibleAt(t,e){return this.validateInstanceId(t),this._instanceInfo[t].visible===e||(this._instanceInfo[t].visible=e,this._visibilityChanged=!0),this}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,e){return this.validateInstanceId(t),this.validateGeometryId(e),this._instanceInfo[t].geometryIndex=e,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,e={}){this.validateGeometryId(t);const n=this._geometryInfo[t];return e.vertexStart=n.vertexStart,e.vertexCount=n.vertexCount,e.reservedVertexCount=n.reservedVertexCount,e.indexStart=n.indexStart,e.indexCount=n.indexCount,e.reservedIndexCount=n.reservedIndexCount,e.start=n.start,e.count=n.count,e}setInstanceCount(t){const e=this._availableInstanceIds,n=this._instanceInfo;for(e.sort(ma);e[e.length-1]===n.length;)n.pop(),e.pop();if(t<n.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const i=new Int32Array(t),r=new Int32Array(t);Ia(this._multiDrawCounts,i),Ia(this._multiDrawStarts,r),this._multiDrawCounts=i,this._multiDrawStarts=r,this._maxInstanceCount=t;const s=this._indirectTexture,o=this._matricesTexture,a=this._colorsTexture;s.dispose(),this._initIndirectTexture(),Ia(s.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),Ia(o.image.data,this._matricesTexture.image.data),a&&(a.dispose(),this._initColorsTexture(),Ia(a.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const n=[...this._geometryInfo].filter(t=>t.active);if(Math.max(...n.map(t=>t.vertexStart+t.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...n.map(t=>t.indexStart+t.reservedIndexCount))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);const i=this.geometry;i.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Ps,this._initializeGeometry(i));const r=this.geometry;i.index&&Ia(i.index.array,r.index.array);for(const t in i.attributes)Ia(i.attributes[t].array,r.attributes[t].array)}raycast(t,e){const n=this._instanceInfo,i=this._geometryInfo,r=this.matrixWorld,s=this.geometry;Ra.material=this.material,Ra.geometry.index=s.index,Ra.geometry.attributes=s.attributes,null===Ra.geometry.boundingBox&&(Ra.geometry.boundingBox=new Oi),null===Ra.geometry.boundingSphere&&(Ra.geometry.boundingSphere=new Qi);for(let s=0,o=n.length;s<o;s++){if(!n[s].visible||!n[s].active)continue;const o=n[s].geometryIndex,a=i[o];Ra.geometry.setDrawRange(a.start,a.count),this.getMatrixAt(s,Ra.matrixWorld).premultiply(r),this.getBoundingBoxAt(o,Ra.geometry.boundingBox),this.getBoundingSphereAt(o,Ra.geometry.boundingSphere),Ra.raycast(t,Pa);for(let t=0,n=Pa.length;t<n;t++){const n=Pa[t];n.object=this,n.batchId=s,e.push(n)}Pa.length=0}Ra.material=null,Ra.geometry.index=null,Ra.geometry.attributes={},Ra.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=null!==t.boundingBox?t.boundingBox.clone():null,this.boundingSphere=null!==t.boundingSphere?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(t=>({...t,boundingBox:null!==t.boundingBox?t.boundingBox.clone():null,boundingSphere:null!==t.boundingSphere?t.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(t=>({...t})),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),null!==this._colorsTexture&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,null!==this._colorsTexture&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,e,n,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const s=i.getIndex(),o=null===s?1:s.array.BYTES_PER_ELEMENT,a=this._instanceInfo,l=this._multiDrawStarts,c=this._multiDrawCounts,h=this._geometryInfo,u=this.perObjectFrustumCulled,d=this._indirectTexture,p=d.image.data,f=n.isArrayCamera?ba:Sa;u&&!n.isArrayCamera&&(va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse).multiply(this.matrixWorld),Sa.setFromProjectionMatrix(va,t.coordinateSystem));let m=0;if(this.sortObjects){va.copy(this.matrixWorld).invert(),Ea.setFromMatrixPosition(n.matrixWorld).applyMatrix4(va),Ta.set(0,0,-1).transformDirection(n.matrixWorld).transformDirection(va);for(let t=0,e=a.length;t<e;t++)if(a[t].visible&&a[t].active){const e=a[t].geometryIndex;this.getMatrixAt(t,va),this.getBoundingSphereAt(e,wa).applyMatrix4(va);let i=!1;if(u&&(i=!f.intersectsSphere(wa,n)),!i){const n=h[e],i=Aa.subVectors(wa.center,Ea).dot(Ta);Ca.push(n.start,n.count,i,t)}}const t=Ca.list,e=this.customSort;null===e?t.sort(r.transparent?_a:ga):e.call(this,t,n);for(let e=0,n=t.length;e<n;e++){const n=t[e];l[m]=n.start*o,c[m]=n.count,p[m]=n.index,m++}Ca.reset()}else for(let t=0,e=a.length;t<e;t++)if(a[t].visible&&a[t].active){const e=a[t].geometryIndex;let i=!1;if(u&&(this.getMatrixAt(t,va),this.getBoundingSphereAt(e,wa).applyMatrix4(va),i=!f.intersectsSphere(wa,n)),!i){const n=h[e];l[m]=n.start*o,c[m]=n.count,p[m]=t,m++}}d.needsUpdate=!0,this._multiDrawCount=m,this._visibilityChanged=!1}onBeforeShadow(t,e,n,i,r,s){this.onBeforeRender(t,null,i,r,s)}}class Da extends is{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ts(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Oa=new ni,Ua=new ni,Fa=new lr,Ba=new ar,za=new Qi,Va=new ni,ka=new ni;class Ga extends Or{constructor(t=new Ps,e=new Da){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)Oa.fromBufferAttribute(e,t-1),Ua.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Oa.distanceTo(Ua);t.setAttribute("lineDistance",new bs(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),za.copy(n.boundingSphere),za.applyMatrix4(i),za.radius+=r,!1===t.ray.intersectsSphere(za))return;Fa.copy(i).invert(),Ba.copy(t.ray).applyMatrix4(Fa);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=this.isLineSegments?2:1,c=n.index,h=n.attributes.position;if(null!==c){const n=Math.max(0,s.start),i=Math.min(c.count,s.start+s.count);for(let r=n,s=i-1;r<s;r+=l){const n=c.getX(r),i=c.getX(r+1),s=Ha(this,t,Ba,a,n,i,r);s&&e.push(s)}if(this.isLineLoop){const r=c.getX(i-1),s=c.getX(n),o=Ha(this,t,Ba,a,r,s,i-1);o&&e.push(o)}}else{const n=Math.max(0,s.start),i=Math.min(h.count,s.start+s.count);for(let r=n,s=i-1;r<s;r+=l){const n=Ha(this,t,Ba,a,r,r+1,r);n&&e.push(n)}if(this.isLineLoop){const r=Ha(this,t,Ba,a,i-1,n,i-1);r&&e.push(r)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Ha(t,e,n,i,r,s,o){const a=t.geometry.attributes.position;if(Oa.fromBufferAttribute(a,r),Ua.fromBufferAttribute(a,s),n.distanceSqToSegment(Oa,Ua,Va,ka)>i)return;Va.applyMatrix4(t.matrixWorld);const l=e.ray.origin.distanceTo(Va);return l<e.near||l>e.far?void 0:{distance:l,point:ka.clone().applyMatrix4(t.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:t}}const Wa=new ni,ja=new ni;class Xa extends Ga{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)Wa.fromBufferAttribute(e,t),ja.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+Wa.distanceTo(ja);t.setAttribute("lineDistance",new bs(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Ya extends Ga{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class qa extends is{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ts(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const $a=new lr,Za=new ar,Ja=new Qi,Ka=new ni;class Qa extends Or{constructor(t=new Ps,e=new qa){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ja.copy(n.boundingSphere),Ja.applyMatrix4(i),Ja.radius+=r,!1===t.ray.intersectsSphere(Ja))return;$a.copy(i).invert(),Za.copy(t.ray).applyMatrix4($a);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=n.index,c=n.attributes.position;if(null!==l)for(let n=Math.max(0,s.start),r=Math.min(l.count,s.start+s.count);n<r;n++){const r=l.getX(n);Ka.fromBufferAttribute(c,r),tl(Ka,r,a,i,t,e,this)}else for(let n=Math.max(0,s.start),r=Math.min(c.count,s.start+s.count);n<r;n++)Ka.fromBufferAttribute(c,n),tl(Ka,n,a,i,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function tl(t,e,n,i,r,s,o){const a=Za.distanceSqToPoint(t);if(a<n){const n=new ni;Za.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,faceIndex:null,barycoord:null,object:o})}}class el extends Ai{constructor(t,e,n,i,r=wt,s=wt,o,a,l){super(t,e,n,i,r,s,o,a,l),this.isVideoTexture=!0,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)})}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class nl extends el{constructor(t,e,n,i,r,s,o,a){super({},t,e,n,i,r,s,o,a),this.isVideoFrameTexture=!0}update(){}clone(){return(new this.constructor).copy(this)}setFrame(t){this.image=t,this.needsUpdate=!0}}class il extends Ai{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=vt,this.minFilter=vt,this.generateMipmaps=!1,this.needsUpdate=!0}}class rl extends Ai{constructor(t,e,n,i,r,s,o,a,l,c,h,u){super(null,s,o,a,l,c,i,r,h,u),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class sl extends rl{constructor(t,e,n,i,r,s){super(t,e,n,r,s),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=_t,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class ol extends rl{constructor(t,e,n){super(void 0,t[0].width,t[0].height,e,n,ut),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}}class al extends Ai{constructor(t,e,n,i,r,s,o,a,l){super(t,e,n,i,r,s,o,a,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class ll extends Ai{constructor(t,e,n=Dt,i,r,s,o=vt,a=vt,l,c=Wt,h=1){if(c!==Wt&&c!==jt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super({width:t,height:e,depth:h},i,r,s,o,a,c,n,l),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new Mi(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}class cl extends Ps{constructor(t=1,e=1,n=4,i=8,r=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:i,heightSegments:r},e=Math.max(0,e),n=Math.max(1,Math.floor(n)),i=Math.max(3,Math.floor(i)),r=Math.max(1,Math.floor(r));const s=[],o=[],a=[],l=[],c=e/2,h=Math.PI/2*t,u=e,d=2*h+u,p=2*n+r,f=i+1,m=new ni,g=new ni;for(let _=0;_<=p;_++){let y=0,v=0,x=0,S=0;if(_<=n){const e=_/n,i=e*Math.PI/2;v=-c-t*Math.cos(i),x=t*Math.sin(i),S=-t*Math.cos(i),y=e*h}else if(_<=n+r){const i=(_-n)/r;v=i*e-c,x=t,S=0,y=h+i*u}else{const e=(_-n-r)/n,i=e*Math.PI/2;v=c+t*Math.sin(i),x=t*Math.cos(i),S=t*Math.sin(i),y=h+u+e*h}const b=Math.max(0,Math.min(1,y/d));let M=0;0===_?M=.5/i:_===p&&(M=-.5/i);for(let t=0;t<=i;t++){const e=t/i,n=e*Math.PI*2,r=Math.sin(n),s=Math.cos(n);g.x=-x*s,g.y=v,g.z=x*r,o.push(g.x,g.y,g.z),m.set(-x*s,S,x*r),m.normalize(),a.push(m.x,m.y,m.z),l.push(e+M,b)}if(_>0){const t=(_-1)*f;for(let e=0;e<i;e++){const n=t+e,i=t+e+1,r=_*f+e,o=_*f+e+1;s.push(n,i,r),s.push(i,o,r)}}}this.setIndex(s),this.setAttribute("position",new bs(o,3)),this.setAttribute("normal",new bs(a,3)),this.setAttribute("uv",new bs(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new cl(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class hl extends Ps{constructor(t=1,e=32,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],s=[],o=[],a=[],l=new ni,c=new ti;s.push(0,0,0),o.push(0,0,1),a.push(.5,.5);for(let r=0,h=3;r<=e;r++,h+=3){const u=n+r/e*i;l.x=t*Math.cos(u),l.y=t*Math.sin(u),s.push(l.x,l.y,l.z),o.push(0,0,1),c.x=(s[h]/t+1)/2,c.y=(s[h+1]/t+1)/2,a.push(c.x,c.y)}for(let t=1;t<=e;t++)r.push(t,t+1,0);this.setIndex(r),this.setAttribute("position",new bs(s,3)),this.setAttribute("normal",new bs(o,3)),this.setAttribute("uv",new bs(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new hl(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class ul extends Ps{constructor(t=1,e=1,n=1,i=32,r=1,s=!1,o=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a};const l=this;i=Math.floor(i),r=Math.floor(r);const c=[],h=[],u=[],d=[];let p=0;const f=[],m=n/2;let g=0;function _(n){const r=p,s=new ti,f=new ni;let _=0;const y=!0===n?t:e,v=!0===n?1:-1;for(let t=1;t<=i;t++)h.push(0,m*v,0),u.push(0,v,0),d.push(.5,.5),p++;const x=p;for(let t=0;t<=i;t++){const e=t/i*a+o,n=Math.cos(e),r=Math.sin(e);f.x=y*r,f.y=m*v,f.z=y*n,h.push(f.x,f.y,f.z),u.push(0,v,0),s.x=.5*n+.5,s.y=.5*r*v+.5,d.push(s.x,s.y),p++}for(let t=0;t<i;t++){const e=r+t,i=x+t;!0===n?c.push(i,i+1,e):c.push(i+1,i,e),_+=3}l.addGroup(g,_,!0===n?1:2),g+=_}!function(){const s=new ni,_=new ni;let y=0;const v=(e-t)/n;for(let l=0;l<=r;l++){const c=[],g=l/r,y=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*a+o,l=Math.sin(r),f=Math.cos(r);_.x=y*l,_.y=-g*n+m,_.z=y*f,h.push(_.x,_.y,_.z),s.set(l,v,f).normalize(),u.push(s.x,s.y,s.z),d.push(e,1-g),c.push(p++)}f.push(c)}for(let n=0;n<i;n++)for(let i=0;i<r;i++){const s=f[i][n],o=f[i+1][n],a=f[i+1][n+1],l=f[i][n+1];(t>0||0!==i)&&(c.push(s,o,l),y+=3),(e>0||i!==r-1)&&(c.push(o,a,l),y+=3)}l.addGroup(g,y,0),g+=y}(),!1===s&&(t>0&&_(!0),e>0&&_(!1)),this.setIndex(c),this.setAttribute("position",new bs(h,3)),this.setAttribute("normal",new bs(u,3)),this.setAttribute("uv",new bs(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ul(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class dl extends ul{constructor(t=1,e=1,n=32,i=1,r=!1,s=0,o=2*Math.PI){super(0,t,e,n,i,r,s,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:o}}static fromJSON(t){return new dl(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class pl extends Ps{constructor(t=[],e=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],s=[];function o(t,e,n,i){const r=i+1,s=[];for(let i=0;i<=r;i++){s[i]=[];const o=t.clone().lerp(n,i/r),a=e.clone().lerp(n,i/r),l=r-i;for(let t=0;t<=l;t++)s[i][t]=0===t&&i===r?o:o.clone().lerp(a,t/l)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const n=Math.floor(e/2);e%2==0?(a(s[t][n+1]),a(s[t+1][n]),a(s[t][n])):(a(s[t][n+1]),a(s[t+1][n+1]),a(s[t+1][n]))}}function a(t){r.push(t.x,t.y,t.z)}function l(e,n){const i=3*e;n.x=t[i+0],n.y=t[i+1],n.z=t[i+2]}function c(t,e,n,i){i<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=i/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}function u(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}!function(t){const n=new ni,i=new ni,r=new ni;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],i),l(e[s+2],r),o(n,i,r,t)}(i),function(t){const e=new ni;for(let n=0;n<r.length;n+=3)e.x=r[n+0],e.y=r[n+1],e.z=r[n+2],e.normalize().multiplyScalar(t),r[n+0]=e.x,r[n+1]=e.y,r[n+2]=e.z}(n),function(){const t=new ni;for(let e=0;e<r.length;e+=3){t.x=r[e+0],t.y=r[e+1],t.z=r[e+2];const n=h(t)/2/Math.PI+.5,i=u(t)/Math.PI+.5;s.push(n,1-i)}(function(){const t=new ni,e=new ni,n=new ni,i=new ni,o=new ti,a=new ti,l=new ti;for(let u=0,d=0;u<r.length;u+=9,d+=6){t.set(r[u+0],r[u+1],r[u+2]),e.set(r[u+3],r[u+4],r[u+5]),n.set(r[u+6],r[u+7],r[u+8]),o.set(s[d+0],s[d+1]),a.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),i.copy(t).add(e).add(n).divideScalar(3);const p=h(i);c(o,d+0,t,p),c(a,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],i=s[t+4],r=Math.max(e,n,i),o=Math.min(e,n,i);r>.9&&o<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),i<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new bs(r,3)),this.setAttribute("normal",new bs(r.slice(),3)),this.setAttribute("uv",new bs(s,2)),0===i?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new pl(t.vertices,t.indices,t.radius,t.details)}}class fl extends pl{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new fl(t.radius,t.detail)}}const ml=new ni,gl=new ni,_l=new ni,yl=new $r;class vl extends Ps{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,i=Math.pow(10,n),r=Math.cos(jn*e),s=t.getIndex(),o=t.getAttribute("position"),a=s?s.count:o.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let t=0;t<a;t+=3){s?(l[0]=s.getX(t),l[1]=s.getX(t+1),l[2]=s.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:a}=yl;if(e.fromBufferAttribute(o,l[0]),n.fromBufferAttribute(o,l[1]),a.fromBufferAttribute(o,l[2]),yl.getNormal(_l),h[0]=`${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`,h[1]=`${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`,h[2]=`${Math.round(a.x*i)},${Math.round(a.y*i)},${Math.round(a.z*i)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=h[t],i=h[e],s=yl[c[t]],o=yl[c[e]],a=`${n}_${i}`,p=`${i}_${n}`;p in u&&u[p]?(_l.dot(u[p].normal)<=r&&(d.push(s.x,s.y,s.z),d.push(o.x,o.y,o.z)),u[p]=null):a in u||(u[a]={index0:l[t],index1:l[e],normal:_l.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];ml.fromBufferAttribute(o,e),gl.fromBufferAttribute(o,n),d.push(ml.x,ml.y,ml.z),d.push(gl.x,gl.y,gl.z)}this.setAttribute("position",new bs(d,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class xl{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let o,a=0,l=r-1;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),o=n[i]-s,o<0)a=i+1;else{if(!(o>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const c=n[i];return(i+(s-c)/(n[i+1]-c))/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=e||(s.isVector2?new ti:new ni);return a.copy(o).sub(s).normalize(),a}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e=!1){const n=new ni,i=[],r=[],s=[],o=new ni,a=new lr;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new ni)}r[0]=new ni,s[0]=new ni;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),h=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),s[e]=s[e-1].clone(),o.crossVectors(i[e-1],i[e]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos(qn(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(a.makeRotationAxis(o,t))}s[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos(qn(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(a.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Sl extends xl{constructor(t=0,e=0,n=1,i=1,r=0,s=2*Math.PI,o=!1,a=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=o,this.aRotation=a}getPoint(t,e=new ti){const n=e,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const o=this.aStartAngle+t*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,i=l-this.aY;a=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(a,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class bl extends Sl{constructor(t,e,n,i,r,s){super(t,e,n,n,i,r,s),this.isArcCurve=!0,this.type="ArcCurve"}}function Ml(){let t=0,e=0,n=0,i=0;function r(r,s,o,a){t=r,e=o,n=-3*r+3*s-2*o-a,i=2*r-2*s+o+a}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,o,a){let l=(e-t)/s-(n-t)/(s+o)+(n-e)/o,c=(n-e)/o-(i-e)/(o+a)+(i-n)/a;l*=o,c*=o,r(e,n,l,c)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}const wl=new ni,El=new Ml,Tl=new Ml,Al=new Ml;class Cl extends xl{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new ni){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let o,a,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?o=i[(l-1)%r]:(wl.subVectors(i[0],i[1]).add(i[0]),o=wl);const h=i[l%r],u=i[(l+1)%r];if(this.closed||l+2<r?a=i[(l+2)%r]:(wl.subVectors(i[r-1],i[r-2]).add(i[r-1]),a=wl),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(h),t),n=Math.pow(h.distanceToSquared(u),t),i=Math.pow(u.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),El.initNonuniformCatmullRom(o.x,h.x,u.x,a.x,e,n,i),Tl.initNonuniformCatmullRom(o.y,h.y,u.y,a.y,e,n,i),Al.initNonuniformCatmullRom(o.z,h.z,u.z,a.z,e,n,i)}else"catmullrom"===this.curveType&&(El.initCatmullRom(o.x,h.x,u.x,a.x,this.tension),Tl.initCatmullRom(o.y,h.y,u.y,a.y,this.tension),Al.initCatmullRom(o.z,h.z,u.z,a.z,this.tension));return n.set(El.calc(c),Tl.calc(c),Al.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new ni).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Rl(t,e,n,i,r){const s=.5*(i-e),o=.5*(r-n),a=t*t;return(2*n-2*i+s+o)*(t*a)+(-3*n+3*i-2*s-o)*a+s*t+n}function Pl(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function Ll(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}class Il extends xl{constructor(t=new ti,e=new ti,n=new ti,i=new ti){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new ti){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ll(t,i.x,r.x,s.x,o.x),Ll(t,i.y,r.y,s.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Nl extends xl{constructor(t=new ni,e=new ni,n=new ni,i=new ni){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new ni){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Ll(t,i.x,r.x,s.x,o.x),Ll(t,i.y,r.y,s.y,o.y),Ll(t,i.z,r.z,s.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Dl extends xl{constructor(t=new ti,e=new ti){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new ti){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new ti){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Ol extends xl{constructor(t=new ni,e=new ni){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new ni){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new ni){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Ul extends xl{constructor(t=new ti,e=new ti,n=new ti){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new ti){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Pl(t,i.x,r.x,s.x),Pl(t,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Fl extends xl{constructor(t=new ni,e=new ni,n=new ni){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new ni){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(Pl(t,i.x,r.x,s.x),Pl(t,i.y,r.y,s.y),Pl(t,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Bl extends xl{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new ti){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),o=r-s,a=i[0===s?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],h=i[s>i.length-3?i.length-1:s+2];return n.set(Rl(o,a.x,l.x,c.x,h.x),Rl(o,a.y,l.y,c.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new ti).fromArray(n))}return this}}var zl=Object.freeze({__proto__:null,ArcCurve:bl,CatmullRomCurve3:Cl,CubicBezierCurve:Il,CubicBezierCurve3:Nl,EllipseCurve:Sl,LineCurve:Dl,LineCurve3:Ol,QuadraticBezierCurve:Ul,QuadraticBezierCurve3:Fl,SplineCurve:Bl});class Vl extends xl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const n=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new zl[n](e,t))}return this}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const t=i[r]-n,s=this.curves[r],o=s.getLength(),a=0===o?0:1-t/o;return s.getPointAt(a,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s.isEllipseCurve?2*t:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?t*s.points.length:t,a=s.getPoints(o);for(let t=0;t<a.length;t++){const i=a[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new zl[n.type]).fromJSON(n))}return this}}class kl extends Vl{constructor(t){super(),this.type="Path",this.currentPoint=new ti,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Dl(this.currentPoint.clone(),new ti(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new Ul(this.currentPoint.clone(),new ti(t,e),new ti(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,s){const o=new Il(this.currentPoint.clone(),new ti(t,e),new ti(n,i),new ti(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Bl(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,n,i,r,s),this}absarc(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this}ellipse(t,e,n,i,r,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,i,r,s,o,a),this}absellipse(t,e,n,i,r,s,o,a){const l=new Sl(t,e,n,i,r,s,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Gl extends kl{constructor(t){super(t),this.uuid=Yn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new kl).fromJSON(n))}return this}}function Hl(t,e,n,i,r){let s;if(r===function(t,e,n,i){let r=0;for(let s=e,o=n-i;s<n;s+=i)r+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return r}(t,e,n,i)>0)for(let r=e;r<n;r+=i)s=uc(r/i|0,t[r],t[r+1],s);else for(let r=n-i;r>=e;r-=i)s=uc(r/i|0,t[r],t[r+1],s);return s&&sc(s,s.next)&&(dc(s),s=s.next),s}function Wl(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!sc(i,i.next)&&0!==rc(i.prev,i,i.next))i=i.next;else{if(dc(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function jl(t,e,n,i,r,s,o){if(!t)return;!o&&s&&function(t,e,n,i){let r=t;do{0===r.z&&(r.z=Ql(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n=1;do{let i,r=t;t=null;let s=null;for(e=0;r;){e++;let o=r,a=0;for(let t=0;t<n&&(a++,o=o.nextZ,o);t++);let l=n;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||r.z<=o.z)?(i=r,r=r.nextZ,a--):(i=o,o=o.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;r=o}s.nextZ=null,n*=2}while(e>1)}(r)}(t,i,r,s);let a=t;for(;t.prev!==t.next;){const l=t.prev,c=t.next;if(s?Yl(t,i,r,s):Xl(t))e.push(l.i,t.i,c.i),dc(t),t=c.next,a=c.next;else if((t=c)===a){o?1===o?jl(t=ql(Wl(t),e),e,n,i,r,s,2):2===o&&$l(t,e,n,i,r,s):jl(Wl(t),e,n,i,r,s,1);break}}}function Xl(t){const e=t.prev,n=t,i=t.next;if(rc(e,n,i)>=0)return!1;const r=e.x,s=n.x,o=i.x,a=e.y,l=n.y,c=i.y,h=Math.min(r,s,o),u=Math.min(a,l,c),d=Math.max(r,s,o),p=Math.max(a,l,c);let f=i.next;for(;f!==e;){if(f.x>=h&&f.x<=d&&f.y>=u&&f.y<=p&&nc(r,a,s,l,o,c,f.x,f.y)&&rc(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function Yl(t,e,n,i){const r=t.prev,s=t,o=t.next;if(rc(r,s,o)>=0)return!1;const a=r.x,l=s.x,c=o.x,h=r.y,u=s.y,d=o.y,p=Math.min(a,l,c),f=Math.min(h,u,d),m=Math.max(a,l,c),g=Math.max(h,u,d),_=Ql(p,f,e,n,i),y=Ql(m,g,e,n,i);let v=t.prevZ,x=t.nextZ;for(;v&&v.z>=_&&x&&x.z<=y;){if(v.x>=p&&v.x<=m&&v.y>=f&&v.y<=g&&v!==r&&v!==o&&nc(a,h,l,u,c,d,v.x,v.y)&&rc(v.prev,v,v.next)>=0)return!1;if(v=v.prevZ,x.x>=p&&x.x<=m&&x.y>=f&&x.y<=g&&x!==r&&x!==o&&nc(a,h,l,u,c,d,x.x,x.y)&&rc(x.prev,x,x.next)>=0)return!1;x=x.nextZ}for(;v&&v.z>=_;){if(v.x>=p&&v.x<=m&&v.y>=f&&v.y<=g&&v!==r&&v!==o&&nc(a,h,l,u,c,d,v.x,v.y)&&rc(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;x&&x.z<=y;){if(x.x>=p&&x.x<=m&&x.y>=f&&x.y<=g&&x!==r&&x!==o&&nc(a,h,l,u,c,d,x.x,x.y)&&rc(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function ql(t,e){let n=t;do{const i=n.prev,r=n.next.next;!sc(i,r)&&oc(i,n,n.next,r)&&cc(i,r)&&cc(r,i)&&(e.push(i.i,n.i,r.i),dc(n),dc(n.next),n=t=r),n=n.next}while(n!==t);return Wl(n)}function $l(t,e,n,i,r,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&ic(o,t)){let a=hc(o,t);return o=Wl(o,o.next),a=Wl(a,a.next),jl(o,e,n,i,r,s,0),void jl(a,e,n,i,r,s,0)}t=t.next}o=o.next}while(o!==t)}function Zl(t,e){let n=t.x-e.x;return 0===n&&(n=t.y-e.y,0===n)&&(n=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)),n}function Jl(t,e){const n=function(t,e){let n=e;const i=t.x,r=t.y;let s,o=-1/0;if(sc(t,n))return n;do{if(sc(t,n.next))return n.next;if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const t=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=i&&t>o&&(o=t,s=n.x<n.next.x?n:n.next,t===i))return s}n=n.next}while(n!==e);if(!s)return null;const a=s,l=s.x,c=s.y;let h=1/0;n=s;do{if(i>=n.x&&n.x>=l&&i!==n.x&&ec(r<c?i:o,r,l,c,r<c?o:i,r,n.x,n.y)){const e=Math.abs(r-n.y)/(i-n.x);cc(n,t)&&(e<h||e===h&&(n.x>s.x||n.x===s.x&&Kl(s,n)))&&(s=n,h=e)}n=n.next}while(n!==a);return s}(t,e);if(!n)return e;const i=hc(n,t);return Wl(i,i.next),Wl(n,n.next)}function Kl(t,e){return rc(t.prev,t,e.prev)<0&&rc(e.next,t,t.next)<0}function Ql(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function tc(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function ec(t,e,n,i,r,s,o,a){return(r-o)*(e-a)>=(t-o)*(s-a)&&(t-o)*(i-a)>=(n-o)*(e-a)&&(n-o)*(s-a)>=(r-o)*(i-a)}function nc(t,e,n,i,r,s,o,a){return!(t===o&&e===a)&&ec(t,e,n,i,r,s,o,a)}function ic(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&oc(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(cc(t,e)&&cc(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(rc(t.prev,t,e.prev)||rc(t,e.prev,e))||sc(t,e)&&rc(t.prev,t,t.next)>0&&rc(e.prev,e,e.next)>0)}function rc(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function sc(t,e){return t.x===e.x&&t.y===e.y}function oc(t,e,n,i){const r=lc(rc(t,e,n)),s=lc(rc(t,e,i)),o=lc(rc(n,i,t)),a=lc(rc(n,i,e));return r!==s&&o!==a||!(0!==r||!ac(t,n,e))||!(0!==s||!ac(t,i,e))||!(0!==o||!ac(n,t,i))||!(0!==a||!ac(n,e,i))}function ac(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function lc(t){return t>0?1:t<0?-1:0}function cc(t,e){return rc(t.prev,t,t.next)<0?rc(t,e,t.next)>=0&&rc(t,t.prev,e)>=0:rc(t,e,t.prev)<0||rc(t,t.next,e)<0}function hc(t,e){const n=pc(t.i,t.x,t.y),i=pc(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function uc(t,e,n,i){const r=pc(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function dc(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function pc(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class fc{static triangulate(t,e,n=2){return function(t,e,n=2){const i=e&&e.length,r=i?e[0]*n:t.length;let s=Hl(t,0,r,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c;if(i&&(s=function(t,e,n,i){const r=[];for(let n=0,s=e.length;n<s;n++){const o=Hl(t,e[n]*i,n<s-1?e[n+1]*i:t.length,i,!1);o===o.next&&(o.steiner=!0),r.push(tc(o))}r.sort(Zl);for(let t=0;t<r.length;t++)n=Jl(r[t],n);return n}(t,e,s,n)),t.length>80*n){a=1/0,l=1/0;let e=-1/0,i=-1/0;for(let s=n;s<r;s+=n){const n=t[s],r=t[s+1];n<a&&(a=n),r<l&&(l=r),n>e&&(e=n),r>i&&(i=r)}c=Math.max(e-a,i-l),c=0!==c?32767/c:0}return jl(s,o,n,a,l,c,0),o}(t,e,n)}}class mc{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n}static isClockWise(t){return mc.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];gc(t),_c(n,t);let s=t.length;e.forEach(gc);for(let t=0;t<e.length;t++)i.push(s),s+=e[t].length,_c(n,e[t]);const o=fc.triangulate(n,i);for(let t=0;t<o.length;t+=3)r.push(o.slice(t,t+3));return r}}function gc(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function _c(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class yc extends Ps{constructor(t=new Gl([new ti(.5,.5),new ti(-.5,.5),new ti(-.5,-.5),new ti(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++)s(t[e]);function s(t){const s=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let c=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:vc;let g,_,y,v,x,S=!1;f&&(g=f.getSpacedPoints(a),S=!0,c=!1,_=f.computeFrenetFrames(a,!1),y=new ni,v=new ni,x=new ni),c||(p=0,h=0,u=0,d=0);const b=t.extractPoints(o);let M=b.shape;const w=b.holes;if(!mc.isClockWise(M)){M=M.reverse();for(let t=0,e=w.length;t<e;t++){const e=w[t];mc.isClockWise(e)&&(w[t]=e.reverse())}}function E(t){const e=1e-10*1e-10;let n=t[0];for(let i=1;i<=t.length;i++){const r=i%t.length,s=t[r],o=s.x-n.x,a=s.y-n.y,l=o*o+a*a,c=Math.max(Math.abs(s.x),Math.abs(s.y),Math.abs(n.x),Math.abs(n.y));l<=e*c*c?(t.splice(r,1),i--):n=s}}E(M),w.forEach(E);const T=w.length,A=M;for(let t=0;t<T;t++){const e=w[t];M=M.concat(e)}function C(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,n)}const R=M.length;function P(t,e,n){let i,r,s;const o=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,h=o*o+a*a,u=o*c-a*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=e.x-a/u,f=e.y+o/u,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(o*c-a*l);i=p+o*m-t.x,r=f+a*m-t.y;const g=i*i+r*r;if(g<=2)return new ti(i,r);s=Math.sqrt(g/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(i=-a,r=o,s=Math.sqrt(h)):(i=o,r=a,s=Math.sqrt(h/2))}return new ti(i/s,r/s)}const L=[];for(let t=0,e=A.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),L[t]=P(A[t],A[n],A[i]);const I=[];let N,D,O=L.concat();for(let t=0,e=T;t<e;t++){const e=w[t];N=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),N[t]=P(e[t],e[i],e[r]);I.push(N),O=O.concat(N)}if(0===p)D=mc.triangulateShape(A,w);else{const t=[],e=[];for(let n=0;n<p;n++){const i=n/p,r=h*Math.cos(i*Math.PI/2),s=u*Math.sin(i*Math.PI/2)+d;for(let e=0,n=A.length;e<n;e++){const n=C(A[e],L[e],s);z(n.x,n.y,-r),0===i&&t.push(n)}for(let t=0,n=T;t<n;t++){const n=w[t];N=I[t];const o=[];for(let t=0,e=n.length;t<e;t++){const e=C(n[t],N[t],s);z(e.x,e.y,-r),0===i&&o.push(e)}0===i&&e.push(o)}}D=mc.triangulateShape(t,e)}const U=D.length,F=u+d;for(let t=0;t<R;t++){const e=c?C(M[t],O[t],F):M[t];S?(v.copy(_.normals[0]).multiplyScalar(e.x),y.copy(_.binormals[0]).multiplyScalar(e.y),x.copy(g[0]).add(v).add(y),z(x.x,x.y,x.z)):z(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<R;e++){const n=c?C(M[e],O[e],F):M[e];S?(v.copy(_.normals[t]).multiplyScalar(n.x),y.copy(_.binormals[t]).multiplyScalar(n.y),x.copy(g[t]).add(v).add(y),z(x.x,x.y,x.z)):z(n.x,n.y,l/a*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=A.length;t<e;t++){const e=C(A[t],L[t],i);z(e.x,e.y,l+n)}for(let t=0,e=w.length;t<e;t++){const e=w[t];N=I[t];for(let t=0,r=e.length;t<r;t++){const r=C(e[t],N[t],i);S?z(r.x,r.y+g[a-1].y,g[a-1].x+n):z(r.x,r.y,l+n)}}}function B(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=a+2*p;t<n;t++){const n=R*t,s=R*(t+1);k(e+i+n,e+r+n,e+r+s,e+i+s)}}}function z(t,e,n){s.push(t),s.push(e),s.push(n)}function V(t,e,r){G(t),G(e),G(r);const s=i.length/3,o=m.generateTopUV(n,i,s-3,s-2,s-1);H(o[0]),H(o[1]),H(o[2])}function k(t,e,r,s){G(t),G(e),G(s),G(e),G(r),G(s);const o=i.length/3,a=m.generateSideWallUV(n,i,o-6,o-3,o-2,o-1);H(a[0]),H(a[1]),H(a[3]),H(a[1]),H(a[2]),H(a[3])}function G(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function H(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=R*t;for(let t=0;t<U;t++){const n=D[t];V(n[2]+e,n[1]+e,n[0]+e)}t=a+2*p,e=R*t;for(let t=0;t<U;t++){const n=D[t];V(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<U;t++){const e=D[t];V(e[2],e[1],e[0])}for(let t=0;t<U;t++){const e=D[t];V(e[0]+R*a,e[1]+R*a,e[2]+R*a)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;B(A,e),e+=A.length;for(let t=0,n=w.length;t<n;t++){const n=w[t];B(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new bs(i,3)),this.setAttribute("uv",new bs(r,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);return n.options=Object.assign({},e),void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}const i=t.options.extrudePath;return void 0!==i&&(t.options.extrudePath=(new zl[i.type]).fromJSON(i)),new yc(n,t.options)}}const vc={generateTopUV:function(t,e,n,i,r){const s=e[3*n],o=e[3*n+1],a=e[3*i],l=e[3*i+1],c=e[3*r],h=e[3*r+1];return[new ti(s,o),new ti(a,l),new ti(c,h)]},generateSideWallUV:function(t,e,n,i,r,s){const o=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*i],h=e[3*i+1],u=e[3*i+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*s],g=e[3*s+1],_=e[3*s+2];return Math.abs(a-h)<Math.abs(o-c)?[new ti(o,1-l),new ti(c,1-u),new ti(d,1-f),new ti(m,1-_)]:[new ti(a,1-l),new ti(h,1-u),new ti(p,1-f),new ti(g,1-_)]}};class xc extends pl{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new xc(t.radius,t.detail)}}class Sc extends Ps{constructor(t=[new ti(0,-.5),new ti(.5,0),new ti(0,.5)],e=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=qn(i,0,2*Math.PI);const r=[],s=[],o=[],a=[],l=[],c=1/e,h=new ni,u=new ti,d=new ni,p=new ni,f=new ni;let m=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),a.push(d.x,d.y,d.z);break;case t.length-1:a.push(f.x,f.y,f.z);break;default:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),a.push(d.x,d.y,d.z),f.copy(p)}for(let r=0;r<=e;r++){const d=n+r*c*i,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=t.length-1;n++){h.x=t[n].x*p,h.y=t[n].y,h.z=t[n].x*f,s.push(h.x,h.y,h.z),u.x=r/e,u.y=n/(t.length-1),o.push(u.x,u.y);const i=a[3*n+0]*p,c=a[3*n+1],d=a[3*n+0]*f;l.push(i,c,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const i=e+n*t.length,s=i,o=i+t.length,a=i+t.length+1,l=i+1;r.push(s,o,l),r.push(a,l,o)}this.setIndex(r),this.setAttribute("position",new bs(s,3)),this.setAttribute("uv",new bs(o,2)),this.setAttribute("normal",new bs(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Sc(t.points,t.segments,t.phiStart,t.phiLength)}}class bc extends pl{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new bc(t.radius,t.detail)}}class Mc extends Ps{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),a=Math.floor(i),l=o+1,c=a+1,h=t/o,u=e/a,d=[],p=[],f=[],m=[];for(let t=0;t<c;t++){const e=t*u-s;for(let n=0;n<l;n++){const i=n*h-r;p.push(i,-e,0),f.push(0,0,1),m.push(n/o),m.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<o;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new bs(p,3)),this.setAttribute("normal",new bs(f,3)),this.setAttribute("uv",new bs(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Mc(t.width,t.height,t.widthSegments,t.heightSegments)}}class wc extends Ps{constructor(t=.5,e=1,n=32,i=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n);const o=[],a=[],l=[],c=[];let h=t;const u=(e-t)/(i=Math.max(1,i)),d=new ni,p=new ti;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*s;d.x=h*Math.cos(i),d.y=h*Math.sin(i),a.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}h+=u}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,s=i+n+1,a=i+n+2,l=i+1;o.push(r,s,l),o.push(s,a,l)}}this.setIndex(o),this.setAttribute("position",new bs(a,3)),this.setAttribute("normal",new bs(l,3)),this.setAttribute("uv",new bs(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new wc(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Ec extends Ps{constructor(t=new Gl([new ti(0,.5),new ti(-.5,-.5),new ti(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(o,a,e),o+=a,a=0;function l(t){const o=i.length/3,l=t.extractPoints(e);let c=l.shape;const h=l.holes;!1===mc.isClockWise(c)&&(c=c.reverse());for(let t=0,e=h.length;t<e;t++){const e=h[t];!0===mc.isClockWise(e)&&(h[t]=e.reverse())}const u=mc.triangulateShape(c,h);for(let t=0,e=h.length;t<e;t++){const e=h[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];i.push(e.x,e.y,0),r.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],i=e[0]+o,r=e[1]+o,s=e[2]+o;n.push(i,r,s),a+=3}}this.setIndex(n),this.setAttribute("position",new bs(i,3)),this.setAttribute("normal",new bs(r,3)),this.setAttribute("uv",new bs(s,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}return new Ec(n,t.curveSegments)}}class Tc extends Ps{constructor(t=1,e=32,n=16,i=0,r=2*Math.PI,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:o},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const a=Math.min(s+o,Math.PI);let l=0;const c=[],h=new ni,u=new ni,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],_=d/n;let y=0;0===d&&0===s?y=.5/e:d===n&&a===Math.PI&&(y=-.5/e);for(let n=0;n<=e;n++){const a=n/e;h.x=-t*Math.cos(i+a*r)*Math.sin(s+_*o),h.y=t*Math.cos(s+_*o),h.z=t*Math.sin(i+a*r)*Math.sin(s+_*o),p.push(h.x,h.y,h.z),u.copy(h).normalize(),f.push(u.x,u.y,u.z),m.push(a+y,1-_),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=c[t][i+1],r=c[t][i],o=c[t+1][i],l=c[t+1][i+1];(0!==t||s>0)&&d.push(e,r,l),(t!==n-1||a<Math.PI)&&d.push(r,o,l)}this.setIndex(d),this.setAttribute("position",new bs(p,3)),this.setAttribute("normal",new bs(f,3)),this.setAttribute("uv",new bs(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Tc(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Ac extends pl{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ac(t.radius,t.detail)}}class Cc extends Ps{constructor(t=1,e=.4,n=12,i=48,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const s=[],o=[],a=[],l=[],c=new ni,h=new ni,u=new ni;for(let s=0;s<=n;s++)for(let d=0;d<=i;d++){const p=d/i*r,f=s/n*Math.PI*2;h.x=(t+e*Math.cos(f))*Math.cos(p),h.y=(t+e*Math.cos(f))*Math.sin(p),h.z=e*Math.sin(f),o.push(h.x,h.y,h.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),u.subVectors(h,c).normalize(),a.push(u.x,u.y,u.z),l.push(d/i),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*t+e-1,r=(i+1)*(t-1)+e-1,o=(i+1)*(t-1)+e,a=(i+1)*t+e;s.push(n,r,a),s.push(r,o,a)}this.setIndex(s),this.setAttribute("position",new bs(o,3)),this.setAttribute("normal",new bs(a,3)),this.setAttribute("uv",new bs(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Cc(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Rc extends Ps{constructor(t=1,e=.4,n=64,i=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:s},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],l=[],c=[],h=new ni,u=new ni,d=new ni,p=new ni,f=new ni,m=new ni,g=new ni;for(let o=0;o<=n;++o){const y=o/n*r*Math.PI*2;_(y,r,s,t,d),_(y+.01,r,s,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=i;++t){const r=t/i*Math.PI*2,s=-e*Math.cos(r),p=e*Math.sin(r);h.x=d.x+(s*g.x+p*f.x),h.y=d.y+(s*g.y+p*f.y),h.z=d.z+(s*g.z+p*f.z),a.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(o/n),c.push(t/i)}}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,a=(i+1)*(t-1)+e;o.push(n,r,a),o.push(r,s,a)}function _(t,e,n,i,r){const s=Math.cos(t),o=Math.sin(t),a=n/e*t,l=Math.cos(a);r.x=i*(2+l)*.5*s,r.y=i*(2+l)*o*.5,r.z=i*Math.sin(a)*.5}this.setIndex(o),this.setAttribute("position",new bs(a,3)),this.setAttribute("normal",new bs(l,3)),this.setAttribute("uv",new bs(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Rc(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Pc extends Ps{constructor(t=new Fl(new ni(-1,-1,0),new ni(-1,1,0),new ni(1,1,0)),e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const s=t.computeFrenetFrames(e,r);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const o=new ni,a=new ni,l=new ti;let c=new ni;const h=[],u=[],d=[],p=[];function f(r){c=t.getPointAt(r/e,c);const l=s.normals[r],d=s.binormals[r];for(let t=0;t<=i;t++){const e=t/i*Math.PI*2,r=Math.sin(e),s=-Math.cos(e);a.x=s*l.x+r*d.x,a.y=s*l.y+r*d.y,a.z=s*l.z+r*d.z,a.normalize(),u.push(a.x,a.y,a.z),o.x=c.x+n*a.x,o.y=c.y+n*a.y,o.z=c.z+n*a.z,h.push(o.x,o.y,o.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===r?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=i;n++)l.x=t/e,l.y=n/i,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,o=(i+1)*(t-1)+e;p.push(n,r,o),p.push(r,s,o)}}()}(),this.setIndex(p),this.setAttribute("position",new bs(h,3)),this.setAttribute("normal",new bs(u,3)),this.setAttribute("uv",new bs(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Pc((new zl[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Lc extends Ps{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,i=new ni,r=new ni;if(null!==t.index){const s=t.attributes.position,o=t.index;let a=t.groups;0===a.length&&(a=[{start:0,count:o.count,materialIndex:0}]);for(let t=0,l=a.length;t<l;++t){const l=a[t],c=l.start;for(let t=c,a=c+l.count;t<a;t+=3)for(let a=0;a<3;a++){const l=o.getX(t+a),c=o.getX(t+(a+1)%3);i.fromBufferAttribute(s,l),r.fromBufferAttribute(s,c),!0===Ic(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const s=t.attributes.position;for(let t=0,o=s.count/3;t<o;t++)for(let o=0;o<3;o++){const a=3*t+o,l=3*t+(o+1)%3;i.fromBufferAttribute(s,a),r.fromBufferAttribute(s,l),!0===Ic(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new bs(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function Ic(t,e,n){const i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(i)&&!0!==n.has(r)&&(n.add(i),n.add(r),!0)}var Nc=Object.freeze({__proto__:null,BoxGeometry:Ws,CapsuleGeometry:cl,CircleGeometry:hl,ConeGeometry:dl,CylinderGeometry:ul,DodecahedronGeometry:fl,EdgesGeometry:vl,ExtrudeGeometry:yc,IcosahedronGeometry:xc,LatheGeometry:Sc,OctahedronGeometry:bc,PlaneGeometry:Mc,PolyhedronGeometry:pl,RingGeometry:wc,ShapeGeometry:Ec,SphereGeometry:Tc,TetrahedronGeometry:Ac,TorusGeometry:Cc,TorusKnotGeometry:Rc,TubeGeometry:Pc,WireframeGeometry:Lc});class Dc extends is{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ts(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class Oc extends $s{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Uc extends is{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new ts(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ts(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new yr,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Fc extends Uc{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new ti(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return qn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ts(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ts(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ts(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Bc extends is{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ts(16777215),this.specular=new ts(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ts(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new yr,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class zc extends is{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ts(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ts(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Vc extends is{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class kc extends is{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ts(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ts(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new yr,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Gc extends is{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=We,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Hc extends is{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class Wc extends is{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ts(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qe,this.normalScale=new ti(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class jc extends Da{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Xc(t,e){return t&&t.constructor!==e?"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t):t}function Yc(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function qc(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort(function(e,n){return t[e]-t[n]}),n}function $c(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,o=0;o!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[o++]=t[i+n]}return r}function Zc(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let o=s[i];if(void 0!==o)if(Array.isArray(o))do{o=s[i],void 0!==o&&(e.push(s.time),n.push(...o)),s=t[r++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[i],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{o=s[i],void 0!==o&&(e.push(s.time),n.push(o)),s=t[r++]}while(void 0!==s)}class Jc{static convertArray(t,e){return Xc(t,e)}static isTypedArray(t){return Yc(t)}static getKeyframeOrder(t){return qc(t)}static sortedArray(t,e,n){return $c(t,e,n)}static flattenJSON(t,e,n,i){Zc(t,e,n,i)}static subclip(t,e,n,i,r=30){return function(t,e,n,i,r=30){const s=t.clone();s.name=e;const o=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],a=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*r;if(!(s<n||s>=i)){l.push(e.times[t]);for(let n=0;n<a;++n)c.push(e.values[t*a+n])}}0!==l.length&&(e.times=Xc(l,e.times.constructor),e.values=Xc(c,e.values.constructor),o.push(e))}s.tracks=o;let a=1/0;for(let t=0;t<s.tracks.length;++t)a>s.tracks[t].times[0]&&(a=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*a);return s.resetDuration(),s}(t,e,n,i,r)}static makeClipAdditive(t,e=0,n=t,i=30){return function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const o=t.tracks.find(function(t){return t.name===i.name&&t.ValueTypeName===r});if(void 0===o)continue;let a=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=i.times.length-1;let d;if(s<=i.times[0]){const t=a,e=l-a;d=i.values.slice(t,e)}else if(s>=i.times[u]){const t=u*l+a,e=t+l-a;d=i.values.slice(t,e)}else{const t=i.createInterpolant(),e=a,n=l-a;t.evaluate(s),d=t.resultBuffer.slice(e,n)}"quaternion"===r&&(new ei).fromArray(d).normalize().conjugate().toArray(d);const p=o.times.length;for(let t=0;t<p;++t){const e=t*h+c;if("quaternion"===r)ei.multiplyQuaternionsFlat(o.values,e,d,0,o.values,e);else{const t=h-2*c;for(let n=0;n<t;++n)o.values[e+n]-=d[n]}}}return t.blendMode=Ve,t}(t,e,n,i)}}class Kc{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(!(t>=r)){const o=e[1];t<o&&(n=2,r=o);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0;break n}break t}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===i)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Qc extends Kc{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ue,endingEnd:Ue}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],a=i[s];if(void 0===o)switch(this.getSettings_().endingStart){case Fe:r=t,o=2*e-n;break;case Be:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case Fe:s=t,a=2*n-e;break;case Be:s=1,a=n+i[1]-i[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-u*m+2*u*f-u*p,_=(1+u)*m+(-1.5-2*u)*f+(-.5+u)*p+1,y=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;for(let t=0;t!==o;++t)r[t]=g*s[c+t]+_*s[l+t]+y*s[a+t]+v*s[h+t];return r}}class th extends Kc{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(i-e),h=1-c;for(let t=0;t!==o;++t)r[t]=s[l+t]*h+s[a+t]*c;return r}}class eh extends Kc{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class nh{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Xc(e,this.TimeBufferType),this.values=Xc(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Xc(t.times,Array),values:Xc(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new eh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new th(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Qc(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Ne:e=this.InterpolantFactoryMethodDiscrete;break;case De:e=this.InterpolantFactoryMethodLinear;break;case Oe:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ne;case this.InterpolantFactoryMethodLinear:return De;case this.InterpolantFactoryMethodSmooth:return Oe}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=n.slice(r,s),this.values=this.values.slice(r*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==s&&s>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,s),t=!1;break}s=i}if(void 0!==i&&Yc(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===Oe,r=t.length-1;let s=1;for(let o=1;o<r;++o){let r=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(i)r=!0;else{const t=o*n,i=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[i+o]||n!==e[s+o]){r=!0;break}}}if(r){if(o!==s){t[s]=t[o];const i=o*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,o=0;o!==n;++o)e[i+o]=e[t+o];++s}return s!==t.length?(this.times=t.slice(0,s),this.values=e.slice(0,s*n)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}nh.prototype.ValueTypeName="",nh.prototype.TimeBufferType=Float32Array,nh.prototype.ValueBufferType=Float32Array,nh.prototype.DefaultInterpolation=De;class ih extends nh{constructor(t,e,n){super(t,e,n)}}ih.prototype.ValueTypeName="bool",ih.prototype.ValueBufferType=Array,ih.prototype.DefaultInterpolation=Ne,ih.prototype.InterpolantFactoryMethodLinear=void 0,ih.prototype.InterpolantFactoryMethodSmooth=void 0;class rh extends nh{constructor(t,e,n,i){super(t,e,n,i)}}rh.prototype.ValueTypeName="color";class sh extends nh{constructor(t,e,n,i){super(t,e,n,i)}}sh.prototype.ValueTypeName="number";class oh extends Kc{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(i-e);let l=t*o;for(let t=l+o;l!==t;l+=4)ei.slerpFlat(r,0,s,l-o,s,l,a);return r}}class ah extends nh{constructor(t,e,n,i){super(t,e,n,i)}InterpolantFactoryMethodLinear(t){return new oh(this.times,this.values,this.getValueSize(),t)}}ah.prototype.ValueTypeName="quaternion",ah.prototype.InterpolantFactoryMethodSmooth=void 0;class lh extends nh{constructor(t,e,n){super(t,e,n)}}lh.prototype.ValueTypeName="string",lh.prototype.ValueBufferType=Array,lh.prototype.DefaultInterpolation=Ne,lh.prototype.InterpolantFactoryMethodLinear=void 0,lh.prototype.InterpolantFactoryMethodSmooth=void 0;class ch extends nh{constructor(t,e,n,i){super(t,e,n,i)}}ch.prototype.ValueTypeName="vector";class hh{constructor(t="",e=-1,n=[],i=ze){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=Yn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(uh(n[t]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(nh.toJSON(n[t]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let t=0;t<r;t++){let o=[],a=[];o.push((t+r-1)%r,t,(t+1)%r),a.push(0,1,0);const l=qc(o);o=$c(o,1,l),a=$c(a,1,l),i||0!==o[0]||(o.push(r),a.push(a[0])),s.push(new sh(".morphTargetInfluences["+e[t].name+"]",o,a).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(r);if(s&&s.length>1){const t=s[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const s=[];for(const t in i)s.push(this.CreateFromMorphTargetSequence(t,i[t],e,n));return s}static parseAnimation(t,e){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],o=[];Zc(n,s,o,i),0!==s.length&&r.push(new t(e,s,o))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new sh(".morphTargetInfluence["+n+"]",t,s))}a=t.length*s}else{const s=".bones["+e[t].name+"]";n(ch,s+".position",r,"pos",i),n(ah,s+".quaternion",r,"rot",i),n(ch,s+".scale",r,"scl",i)}}return 0===i.length?null:new this(r,a,i,o)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function uh(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return sh;case"vector":case"vector2":case"vector3":case"vector4":return ch;case"color":return rh;case"quaternion":return ah;case"bool":case"boolean":return ih;case"string":return lh}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Zc(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const dh={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class ph{constructor(t,e,n){const i=this;let r,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===s&&void 0!==i.onStart&&i.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==i.onProgress&&i.onProgress(t,o,a),o===a&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}}const fh=new ph;class mh{constructor(t){this.manager=void 0!==t?t:fh,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}mh.DEFAULT_MATERIAL_NAME="__DEFAULT";const gh={};class _h extends Error{constructor(t,e){super(t),this.response=e}}class yh extends mh{constructor(t){super(t),this.mimeType="",this.responseType=""}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=dh.get(`file:${t}`);if(void 0!==r)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(void 0!==gh[t])return void gh[t].push({onLoad:e,onProgress:n,onError:i});gh[t]=[],gh[t].push({onLoad:e,onProgress:n,onError:i});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(s).then(e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=gh[t],i=e.body.getReader(),r=e.headers.get("X-File-Size")||e.headers.get("Content-Length"),s=r?parseInt(r):0,o=0!==s;let a=0;const l=new ReadableStream({start(t){!function e(){i.read().then(({done:i,value:r})=>{if(i)t.close();else{a+=r.byteLength;const i=new ProgressEvent("progress",{lengthComputable:o,loaded:a,total:s});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(i)}t.enqueue(r),e()}},e=>{t.error(e)})}()}});return new Response(l)}throw new _h(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)}).then(t=>{switch(a){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then(t=>(new DOMParser).parseFromString(t,o));case"json":return t.json();default:if(""===o)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(o),n=e&&e[1]?e[1].toLowerCase():void 0,i=new TextDecoder(n);return t.arrayBuffer().then(t=>i.decode(t))}}}).then(e=>{dh.add(`file:${t}`,e);const n=gh[t];delete gh[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onLoad&&i.onLoad(e)}}).catch(e=>{const n=gh[t];if(void 0===n)throw this.manager.itemError(t),e;delete gh[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class vh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new yh(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=hh.parse(t[n]);e.push(i)}return e}}class xh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=[],o=new rl,a=new yh(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=wt),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))},n,i)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else a.load(t,function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=wt),o.format=n.format,o.needsUpdate=!0,e&&e(o)},n,i);return o}}const Sh=new WeakMap;class bh extends mh{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=dh.get(`image:${t}`);if(void 0!==s){if(!0===s.complete)r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0);else{let t=Sh.get(s);void 0===t&&(t=[],Sh.set(s,t)),t.push({onLoad:e,onError:i})}return s}const o=hi("img");function a(){c(),e&&e(this);const n=Sh.get(this)||[];for(let t=0;t<n.length;t++){const e=n[t];e.onLoad&&e.onLoad(this)}Sh.delete(this),r.manager.itemEnd(t)}function l(e){c(),i&&i(e),dh.remove(`image:${t}`);const n=Sh.get(this)||[];for(let t=0;t<n.length;t++){const i=n[t];i.onError&&i.onError(e)}Sh.delete(this),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),dh.add(`image:${t}`,o),r.manager.itemStart(t),o.src=t,o}}class Mh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=new io;r.colorSpace=Je;const s=new bh(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],function(t){r.images[n]=t,o++,6===o&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let e=0;e<t.length;++e)a(e);return r}}class wh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new jo,o=new yh(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(t){let n;try{n=r.parse(t)}catch(t){if(void 0===i)return void console.error(t);i(t)}void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:_t,s.wrapT=void 0!==n.wrapT?n.wrapT:_t,s.magFilter=void 0!==n.magFilter?n.magFilter:wt,s.minFilter=void 0!==n.minFilter?n.minFilter:wt,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.colorSpace&&(s.colorSpace=n.colorSpace),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=At),1===n.mipmapCount&&(s.minFilter=wt),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n)},n,i),s}}class Eh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=new Ai,s=new bh(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(t){r.image=t,r.needsUpdate=!0,void 0!==e&&e(r)},n,i),r}}class Th extends Or{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new ts(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(e.object.target=this.target.uuid),e}}class Ah extends Th{constructor(t,e,n){super(t,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Or.DEFAULT_UP),this.updateMatrix(),this.groundColor=new ts(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const Ch=new lr,Rh=new ni,Ph=new ni;class Lh{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ti(512,512),this.mapType=Rt,this.map=null,this.mapPass=null,this.matrix=new lr,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ua,this._frameExtents=new ti(1,1),this._viewportCount=1,this._viewports=[new Ci(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Rh.setFromMatrixPosition(t.matrixWorld),e.position.copy(Rh),Ph.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Ph),e.updateMatrixWorld(),Ch.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ch),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Ch)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Ih extends Lh{constructor(){super(new to(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(t){const e=this.camera,n=2*Xn*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Nh extends Th{constructor(t,e,n=0,i=Math.PI/3,r=0,s=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Or.DEFAULT_UP),this.updateMatrix(),this.target=new Or,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.map=null,this.shadow=new Ih}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Dh=new lr,Oh=new ni,Uh=new ni;class Fh extends Lh{constructor(){super(new to(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new ti(4,2),this._viewportCount=6,this._viewports=[new Ci(2,1,1,1),new Ci(0,1,1,1),new Ci(3,1,1,1),new Ci(1,1,1,1),new Ci(3,0,1,1),new Ci(1,0,1,1)],this._cubeDirections=[new ni(1,0,0),new ni(-1,0,0),new ni(0,0,1),new ni(0,0,-1),new ni(0,1,0),new ni(0,-1,0)],this._cubeUps=[new ni(0,1,0),new ni(0,1,0),new ni(0,1,0),new ni(0,1,0),new ni(0,0,1),new ni(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),Oh.setFromMatrixPosition(t.matrixWorld),n.position.copy(Oh),Uh.copy(n.position),Uh.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Uh),n.updateMatrixWorld(),i.makeTranslation(-Oh.x,-Oh.y,-Oh.z),Dh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Dh)}}class Bh extends Th{constructor(t,e,n=0,i=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new Fh}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class zh extends Zs{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,a=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}class Vh extends Lh{constructor(){super(new zh(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class kh extends Th{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Or.DEFAULT_UP),this.updateMatrix(),this.target=new Or,this.shadow=new Vh}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Gh extends Th{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class Hh extends Th{constructor(t,e,n=10,i=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class Wh{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new ni)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}class jh extends Th{constructor(t=new Wh,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class Xh extends mh{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,s=new yh(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=this.createMaterialFromType(t.type);if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=t.sheen),void 0!==t.sheenColor&&(i.sheenColor=(new ts).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(i.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.specularIntensity&&(i.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==i.specularColor&&i.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.dispersion&&(i.dispersion=t.dispersion),void 0!==t.iridescence&&(i.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(i.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(i.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.thickness&&(i.thickness=t.thickness),void 0!==t.attenuationDistance&&(i.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==i.attenuationColor&&i.attenuationColor.setHex(t.attenuationColor),void 0!==t.anisotropy&&(i.anisotropy=t.anisotropy),void 0!==t.anisotropyRotation&&(i.anisotropyRotation=t.anisotropyRotation),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.shadowSide&&(i.shadowSide=t.shadowSide),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.alphaHash&&(i.alphaHash=t.alphaHash),void 0!==t.depthFunc&&(i.depthFunc=t.depthFunc),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.blendSrc&&(i.blendSrc=t.blendSrc),void 0!==t.blendDst&&(i.blendDst=t.blendDst),void 0!==t.blendEquation&&(i.blendEquation=t.blendEquation),void 0!==t.blendSrcAlpha&&(i.blendSrcAlpha=t.blendSrcAlpha),void 0!==t.blendDstAlpha&&(i.blendDstAlpha=t.blendDstAlpha),void 0!==t.blendEquationAlpha&&(i.blendEquationAlpha=t.blendEquationAlpha),void 0!==t.blendColor&&void 0!==i.blendColor&&i.blendColor.setHex(t.blendColor),void 0!==t.blendAlpha&&(i.blendAlpha=t.blendAlpha),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),void 0!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.alphaToCoverage&&(i.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(i.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.forceSinglePass&&(i.forceSinglePass=t.forceSinglePass),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const r=t.uniforms[e];switch(i.uniforms[e]={},r.type){case"t":i.uniforms[e].value=n(r.value);break;case"c":i.uniforms[e].value=(new ts).setHex(r.value);break;case"v2":i.uniforms[e].value=(new ti).fromArray(r.value);break;case"v3":i.uniforms[e].value=(new ni).fromArray(r.value);break;case"v4":i.uniforms[e].value=(new Ci).fromArray(r.value);break;case"m3":i.uniforms[e].value=(new si).fromArray(r.value);break;case"m4":i.uniforms[e].value=(new lr).fromArray(r.value);break;default:i.uniforms[e].value=r.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.glslVersion&&(i.glslVersion=t.glslVersion),void 0!==t.extensions)for(const e in t.extensions)i.extensions[e]=t.extensions[e];if(void 0!==t.lights&&(i.lights=t.lights),void 0!==t.clipping&&(i.clipping=t.clipping),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new ti).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(i.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(i.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapRotation&&i.envMapRotation.fromArray(t.envMapRotation),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new ti).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(i.iridescenceMap=n(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(i.iridescenceThicknessMap=n(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(i.thicknessMap=n(t.thicknessMap)),void 0!==t.anisotropyMap&&(i.anisotropyMap=n(t.anisotropyMap)),void 0!==t.sheenColorMap&&(i.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(i.sheenRoughnessMap=n(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return Xh.createMaterialFromType(t)}static createMaterialFromType(t){return new{ShadowMaterial:Dc,SpriteMaterial:mo,RawShaderMaterial:Oc,ShaderMaterial:$s,PointsMaterial:qa,MeshPhysicalMaterial:Fc,MeshStandardMaterial:Uc,MeshPhongMaterial:Bc,MeshToonMaterial:zc,MeshNormalMaterial:Vc,MeshLambertMaterial:kc,MeshDepthMaterial:Gc,MeshDistanceMaterial:Hc,MeshBasicMaterial:rs,MeshMatcapMaterial:Wc,LineDashedMaterial:jc,LineBasicMaterial:Da,Material:is}[t]}}class Yh{static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class qh extends Ps{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class $h extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new yh(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],s=function(t,e){if(void 0!==n[e])return n[e];const i=t.arrayBuffers[e],r=new Uint32Array(i).buffer;return n[e]=r,r}(t,r.buffer),o=ci(r.type,s),a=new uo(o,r.stride);return a.uuid=r.uuid,e[i]=a,a}const r=t.isInstancedBufferGeometry?new qh:new Ps,s=t.data.index;if(void 0!==s){const t=ci(s.type,s.array);r.setIndex(new ps(t,1))}const o=t.data.attributes;for(const e in o){const n=o[e];let s;if(n.isInterleavedBufferAttribute){const e=i(t.data,n.data);s=new fo(e,n.itemSize,n.offset,n.normalized)}else{const t=ci(n.type,n.array);s=new(n.isInstancedBufferAttribute?$o:ps)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),r.setAttribute(e,s)}const a=t.data.morphAttributes;if(a)for(const e in a){const n=a[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];let o;if(r.isInterleavedBufferAttribute){const e=i(t.data,r.data);o=new fo(e,r.itemSize,r.offset,r.normalized)}else{const t=ci(r.type,r.array);o=new ps(t,r.itemSize,r.normalized)}void 0!==r.name&&(o.name=r.name),s.push(o)}r.morphAttributes[e]=s}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];r.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;return void 0!==c&&(r.boundingSphere=(new Qi).fromJSON(c)),t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}class Zh extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=""===this.path?Yh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const o=new yh(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==i&&i(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const o=s.metadata;if(void 0===o||void 0===o.type||"geometry"===o.type.toLowerCase())return void 0!==i&&i(new Error("THREE.ObjectLoader: Can't load "+t)),void console.error("THREE.ObjectLoader: Can't load "+t);r.parse(s,e)},n,i)}async loadAsync(t,e){const n=""===this.path?Yh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const i=new yh(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const r=await i.loadAsync(t,e),s=JSON.parse(r),o=s.metadata;if(void 0===o||void 0===o.type||"geometry"===o.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),s=this.parseImages(t.images,function(){void 0!==e&&e(l)}),o=this.parseTextures(t.textures,s),a=this.parseMaterials(t.materials,o),l=this.parseObject(t.object,r,a,o,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),this.bindLightTargets(l),void 0!==e){let t=!1;for(const e in s)if(s[e].data instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,r),o=this.parseMaterials(t.materials,s),a=this.parseObject(t.object,i,o,s,e),l=this.parseSkeletons(t.skeletons,a);return this.bindSkeletons(a,l),this.bindLightTargets(a),a}parseShapes(t){const e={};if(void 0!==t)for(let n=0,i=t.length;n<i;n++){const i=(new Gl).fromJSON(t[n]);e[i.uuid]=i}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse(function(t){t.isBone&&(i[t.uuid]=t)}),void 0!==t)for(let e=0,r=t.length;e<r;e++){const r=(new qo).fromJSON(t[e],i);n[r.uuid]=r}return n}parseGeometries(t,e){const n={};if(void 0!==t){const i=new $h;for(let r=0,s=t.length;r<s;r++){let s;const o=t[r];switch(o.type){case"BufferGeometry":case"InstancedBufferGeometry":s=i.parse(o);break;default:o.type in Nc?s=Nc[o.type].fromJSON(o,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)}s.uuid=o.uuid,void 0!==o.name&&(s.name=o.name),void 0!==o.userData&&(s.userData=o.userData),n[o.uuid]=s}}return n}parseMaterials(t,e){const n={},i={};if(void 0!==t){const r=new Xh;r.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];void 0===n[s.uuid]&&(n[s.uuid]=r.parse(s)),i[s.uuid]=n[s.uuid]}}return i}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const i=t[n],r=hh.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),r.load(t,function(){n.manager.itemEnd(t)},void 0,function(){n.manager.itemError(t),n.manager.itemEnd(t)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:ci(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new ph(e);r=new bh(n),r.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.url;if(Array.isArray(r)){const t=[];for(let e=0,n=r.length;e<n;e++){const n=s(r[e]);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new jo(n.data,n.width,n.height)))}i[n.uuid]=new Mi(t)}else{const t=s(n.url);i[n.uuid]=new Mi(t)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(t){if("string"==typeof t){const n=t,r=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await i.loadAsync(r)}return t.data?{data:ci(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){i=new bh(this.manager),i.setCrossOrigin(this.crossOrigin);for(let e=0,i=t.length;e<i;e++){const i=t[e],s=i.url;if(Array.isArray(s)){const t=[];for(let e=0,n=s.length;e<n;e++){const n=s[e],i=await r(n);null!==i&&(i instanceof HTMLImageElement?t.push(i):t.push(new jo(i.data,i.width,i.height)))}n[i.uuid]=new Mi(t)}else{const t=await r(i.url);n[i.uuid]=new Mi(t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const i={};if(void 0!==t)for(let r=0,s=t.length;r<s;r++){const s=t[r];void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const o=e[s.image],a=o.data;let l;Array.isArray(a)?(l=new io,6===a.length&&(l.needsUpdate=!0)):(l=a&&a.data?new jo:new Ai,a&&(l.needsUpdate=!0)),l.source=o,l.uuid=s.uuid,void 0!==s.name&&(l.name=s.name),void 0!==s.mapping&&(l.mapping=n(s.mapping,Jh)),void 0!==s.channel&&(l.channel=s.channel),void 0!==s.offset&&l.offset.fromArray(s.offset),void 0!==s.repeat&&l.repeat.fromArray(s.repeat),void 0!==s.center&&l.center.fromArray(s.center),void 0!==s.rotation&&(l.rotation=s.rotation),void 0!==s.wrap&&(l.wrapS=n(s.wrap[0],Kh),l.wrapT=n(s.wrap[1],Kh)),void 0!==s.format&&(l.format=s.format),void 0!==s.internalFormat&&(l.internalFormat=s.internalFormat),void 0!==s.type&&(l.type=s.type),void 0!==s.colorSpace&&(l.colorSpace=s.colorSpace),void 0!==s.minFilter&&(l.minFilter=n(s.minFilter,Qh)),void 0!==s.magFilter&&(l.magFilter=n(s.magFilter,Qh)),void 0!==s.anisotropy&&(l.anisotropy=s.anisotropy),void 0!==s.flipY&&(l.flipY=s.flipY),void 0!==s.generateMipmaps&&(l.generateMipmaps=s.generateMipmaps),void 0!==s.premultiplyAlpha&&(l.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(l.unpackAlignment=s.unpackAlignment),void 0!==s.compareFunction&&(l.compareFunction=s.compareFunction),void 0!==s.userData&&(l.userData=s.userData),i[s.uuid]=l}return i}parseObject(t,e,n,i,r){let s,o,a;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function c(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];void 0===n[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(n[r])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function h(t){return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),i[t]}switch(t.type){case"Scene":s=new ho,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new ts(t.background):s.background=h(t.background)),void 0!==t.environment&&(s.environment=h(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new co(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new lo(t.fog.color,t.fog.density)),""!==t.fog.name&&(s.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(s.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(s.backgroundIntensity=t.backgroundIntensity),void 0!==t.backgroundRotation&&s.backgroundRotation.fromArray(t.backgroundRotation),void 0!==t.environmentIntensity&&(s.environmentIntensity=t.environmentIntensity),void 0!==t.environmentRotation&&s.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":s=new to(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new zh(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new Gh(t.color,t.intensity);break;case"DirectionalLight":s=new kh(t.color,t.intensity),s.target=t.target||"";break;case"PointLight":s=new Bh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new Hh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new Nh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),s.target=t.target||"";break;case"HemisphereLight":s=new Ah(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new jh).fromJSON(t);break;case"SkinnedMesh":o=l(t.geometry),a=c(t.material),s=new Ho(o,a),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":o=l(t.geometry),a=c(t.material),s=new Gs(o,a);break;case"InstancedMesh":o=l(t.geometry),a=c(t.material);const e=t.count,n=t.instanceMatrix,i=t.instanceColor;s=new ia(o,a,e),s.instanceMatrix=new $o(new Float32Array(n.array),16),void 0!==i&&(s.instanceColor=new $o(new Float32Array(i.array),i.itemSize));break;case"BatchedMesh":o=l(t.geometry),a=c(t.material),s=new Na(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,a),s.geometry=o,s.perObjectFrustumCulled=t.perObjectFrustumCulled,s.sortObjects=t.sortObjects,s._drawRanges=t.drawRanges,s._reservedRanges=t.reservedRanges,s._geometryInfo=t.geometryInfo.map(t=>{let e=null,n=null;return void 0!==t.boundingBox&&(e=(new Oi).fromJSON(t.boundingBox)),void 0!==t.boundingSphere&&(n=(new Qi).fromJSON(t.boundingSphere)),{...t,boundingBox:e,boundingSphere:n}}),s._instanceInfo=t.instanceInfo,s._availableInstanceIds=t._availableInstanceIds,s._availableGeometryIds=t._availableGeometryIds,s._nextIndexStart=t.nextIndexStart,s._nextVertexStart=t.nextVertexStart,s._geometryCount=t.geometryCount,s._maxInstanceCount=t.maxInstanceCount,s._maxVertexCount=t.maxVertexCount,s._maxIndexCount=t.maxIndexCount,s._geometryInitialized=t.geometryInitialized,s._matricesTexture=h(t.matricesTexture.uuid),s._indirectTexture=h(t.indirectTexture.uuid),void 0!==t.colorsTexture&&(s._colorsTexture=h(t.colorsTexture.uuid)),void 0!==t.boundingSphere&&(s.boundingSphere=(new Qi).fromJSON(t.boundingSphere)),void 0!==t.boundingBox&&(s.boundingBox=(new Oi).fromJSON(t.boundingBox));break;case"LOD":s=new No;break;case"Line":s=new Ga(l(t.geometry),c(t.material));break;case"LineLoop":s=new Ya(l(t.geometry),c(t.material));break;case"LineSegments":s=new Xa(l(t.geometry),c(t.material));break;case"PointCloud":case"Points":s=new Qa(l(t.geometry),c(t.material));break;case"Sprite":s=new Ro(c(t.material));break;case"Group":s=new so;break;case"Bone":s=new Wo;break;default:s=new Or}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.up&&s.up.fromArray(t.up),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.intensity&&(s.shadow.intensity=t.shadow.intensity),void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const o=t.children;for(let t=0;t<o.length;t++)s.add(this.parseObject(o[t],e,n,i,r))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];s.animations.push(r[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],i=s.getObjectByProperty("uuid",n.object);void 0!==i&&s.addLevel(i,n.distance,n.hysteresis)}}return s}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse(function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}})}bindLightTargets(t){t.traverse(function(e){if(e.isDirectionalLight||e.isSpotLight){const n=e.target,i=t.getObjectByProperty("uuid",n);e.target=void 0!==i?i:new Or}})}}const Jh={UVMapping:ht,CubeReflectionMapping:ut,CubeRefractionMapping:dt,EquirectangularReflectionMapping:pt,EquirectangularRefractionMapping:ft,CubeUVReflectionMapping:mt},Kh={RepeatWrapping:gt,ClampToEdgeWrapping:_t,MirroredRepeatWrapping:yt},Qh={NearestFilter:vt,NearestMipmapNearestFilter:xt,NearestMipmapLinearFilter:bt,LinearFilter:wt,LinearMipmapNearestFilter:Et,LinearMipmapLinearFilter:At},tu=new WeakMap;class eu extends mh{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=dh.get(`image-bitmap:${t}`);if(void 0!==s)return r.manager.itemStart(t),s.then?void s.then(n=>{if(!0!==tu.has(s))return e&&e(n),r.manager.itemEnd(t),n;i&&i(tu.get(s)),r.manager.itemError(t),r.manager.itemEnd(t)}):(setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s);const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader;const a=fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(n){return dh.add(`image-bitmap:${t}`,n),e&&e(n),r.manager.itemEnd(t),n}).catch(function(e){i&&i(e),tu.set(a,e),dh.remove(`image-bitmap:${t}`),r.manager.itemError(t),r.manager.itemEnd(t)});dh.add(`image-bitmap:${t}`,a),r.manager.itemStart(t)}}let nu;class iu{static getContext(){return void 0===nu&&(nu=new(window.AudioContext||window.webkitAudioContext)),nu}static setContext(t){nu=t}}class ru extends mh{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new yh(this.manager);function o(e){i?i(e):console.error(e),r.manager.itemError(t)}s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(t){try{const n=t.slice(0);iu.getContext().decodeAudioData(n,function(t){e(t)}).catch(o)}catch(t){o(t)}},n,i)}}const su=new lr,ou=new lr,au=new lr;class lu{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new to,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new to,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,au.copy(t.projectionMatrix);const n=e.eyeSep/2,i=n*e.near/e.focus,r=e.near*Math.tan(jn*e.fov*.5)/e.zoom;let s,o;ou.elements[12]=-n,su.elements[12]=n,s=-r*e.aspect+i,o=r*e.aspect+i,au.elements[0]=2*e.near/(o-s),au.elements[8]=(o+s)/(o-s),this.cameraL.projectionMatrix.copy(au),s=-r*e.aspect-i,o=r*e.aspect-i,au.elements[0]=2*e.near/(o-s),au.elements[8]=(o+s)/(o-s),this.cameraR.projectionMatrix.copy(au)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(ou),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(su)}}class cu extends to{constructor(t=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=t}}class hu{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=performance.now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const uu=new ni,du=new ei,pu=new ni,fu=new ni,mu=new ni;class gu extends Or{constructor(){super(),this.type="AudioListener",this.context=iu.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new hu}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(uu,du,pu),fu.set(0,0,-1).applyQuaternion(du),mu.set(0,1,0).applyQuaternion(du),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(uu.x,t),e.positionY.linearRampToValueAtTime(uu.y,t),e.positionZ.linearRampToValueAtTime(uu.z,t),e.forwardX.linearRampToValueAtTime(fu.x,t),e.forwardY.linearRampToValueAtTime(fu.y,t),e.forwardZ.linearRampToValueAtTime(fu.z,t),e.upX.linearRampToValueAtTime(mu.x,t),e.upY.linearRampToValueAtTime(mu.y,t),e.upZ.linearRampToValueAtTime(mu.z,t)}else e.setPosition(uu.x,uu.y,uu.z),e.setOrientation(fu.x,fu.y,fu.z,mu.x,mu.y,mu.z)}}class _u extends Or{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(t=0){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}copy(t,e){return super.copy(t,e),"buffer"!==t.sourceType?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.hasPlaybackControl=t.hasPlaybackControl,this.sourceType=t.sourceType,this.filters=t.filters.slice(),this)}clone(t){return new this.constructor(this.listener).copy(this,t)}}const yu=new ni,vu=new ei,xu=new ni,Su=new ni;class bu extends _u{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(yu,vu,xu),Su.set(0,0,1).applyQuaternion(vu);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(yu.x,t),e.positionY.linearRampToValueAtTime(yu.y,t),e.positionZ.linearRampToValueAtTime(yu.z,t),e.orientationX.linearRampToValueAtTime(Su.x,t),e.orientationY.linearRampToValueAtTime(Su.y,t),e.orientationZ.linearRampToValueAtTime(Su.z,t)}else e.setPosition(yu.x,yu.y,yu.z),e.setOrientation(Su.x,Su.y,Su.z)}}class Mu{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class wu{constructor(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){o.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}_slerp(t,e,n,i){ei.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;ei.multiplyQuaternionsFlat(t,s,t,e,t,n),ei.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const r=e+o;t[r]=t[r]*s+t[n+o]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}}const Eu="\\[\\]\\.:\\/",Tu=new RegExp("["+Eu+"]","g"),Au="[^"+Eu+"]",Cu="[^"+Eu.replace("\\.","")+"]",Ru=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",Au)+/(WCOD+)?/.source.replace("WCOD",Cu)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Au)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Au)+"$"),Pu=["material","materials","bones","map"];class Lu{constructor(t,e,n){this.path=e,this.parsedPath=n||Lu.parseTrackName(e),this.node=Lu.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Lu.Composite(t,e,n):new Lu(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Tu,"")}static parseTrackName(t){const e=Ru.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==Pu.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=Lu.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,!0===t.isMaterial?o=this.Versioning.NeedsUpdate:!0===t.isObject3D&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Lu.Composite=class{constructor(t,e,n){const i=n||Lu.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},Lu.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Lu.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Lu.prototype.GetterByBindingType=[Lu.prototype._getValue_direct,Lu.prototype._getValue_array,Lu.prototype._getValue_arrayElement,Lu.prototype._getValue_toArray],Lu.prototype.SetterByBindingTypeAndVersioning=[[Lu.prototype._setValue_direct,Lu.prototype._setValue_direct_setNeedsUpdate,Lu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Lu.prototype._setValue_array,Lu.prototype._setValue_array_setNeedsUpdate,Lu.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Lu.prototype._setValue_arrayElement,Lu.prototype._setValue_arrayElement_setNeedsUpdate,Lu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Lu.prototype._setValue_fromArray,Lu.prototype._setValue_fromArray_setNeedsUpdate,Lu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Iu{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Yn(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=t.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=e[u];if(void 0===d){d=a++,e[u]=d,t.push(h);for(let t=0,e=s;t!==e;++t)r[t].push(new Lu(h,n[t],i[t]))}else if(d<l){o=t[d];const a=--l,c=t[a];e[c.uuid]=d,t[d]=c,e[u]=a,t[a]=h;for(let t=0,e=s;t!==e;++t){const e=r[t],s=e[a];let o=e[d];e[d]=s,void 0===o&&(o=new Lu(h,n[t],i[t])),e[a]=o}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s],a=o.uuid,l=e[a];if(void 0!==l&&l>=r){const s=r++,c=t[s];e[c.uuid]=l,t[l]=c,e[a]=s,t[s]=o;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[s],r=e[l];e[l]=i,e[s]=r}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){const a=arguments[o].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<r){const o=--r,a=t[o],c=--s,h=t[c];e[a.uuid]=l,t[l]=a,e[h.uuid]=o,t[o]=h,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[o],r=e[c];e[l]=i,e[o]=r,e.pop()}}else{const r=--s,o=t[r];r>0&&(e[o.uuid]=l),t[l]=o,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,h=new Array(l);i=r.length,n[t]=i,s.push(t),o.push(e),r.push(h);for(let n=c,i=a.length;n!==i;++n){const i=a[n];h[n]=new Lu(i,t,e)}return h}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o];e[t[o]]=n,s[n]=a,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}}class Nu{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),a={endingStart:Ue,endingEnd:Ue};for(let t=0;t!==s;++t){const e=r[t].createInterpolant(null);o[t]=e,e.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Le,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n=!1){if(t.fadeOut(e),this.fadeIn(e),!0===n){const n=this._clip.duration,i=t._clip.duration,r=i/n,s=n/i;t.warp(1,r,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n=!1){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,a[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;i<0||0===n?e=0:(this._startTime=null,e=n*i)}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===Ve)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=n===Ie;if(0===t)return-1===r||!s||1&~r?i:e-i;if(n===Pe){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const o=this.repetitions-r;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&!(1&~r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Fe,i.endingEnd=Fe):(i.endingStart=t?this.zeroSlopeAtStart?Fe:Ue:Be,i.endingEnd=e?this.zeroSlopeAtEnd?Fe:Ue:Be)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=r,a[0]=e,o[1]=r+t,a[1]=n,this}}const Du=new Float32Array(1);class Ou extends Gn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let h=c[l];if(void 0!==h)++h.referenceCount,s[t]=h;else{if(h=s[t],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,a,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;h=new wu(Lu.create(n,l,i),r.ValueTypeName,r.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,a,l),s[t]=h}o[t].resultBuffer=h.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],0===Object.keys(o).length&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new th(new Float32Array(2),new Float32Array(2),1,Du),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?hh.findByName(i,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:ze),void 0!==a){const t=a.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new Nu(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?hh.findByName(n,t):t,s=r?r.uuid:t,o=this._actionsByClip[s];return void 0!==o&&o.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let o=0;o!==n;++o)e[o]._update(i,t,r,s);const o=this._bindings,a=this._nActiveBindings;for(let t=0;t!==a;++t)o[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class Uu extends Ri{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isRenderTarget3D=!0,this.depth=n,this.texture=new Ni(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Fu{constructor(t){this.value=t}clone(){return new Fu(void 0===this.value.clone?this.value:this.value.clone())}}let Bu=0;class zu extends Gn{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Bu++}),this.name="",this.usage=Tn,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,n=e.length;t<n;t++){const n=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0;t<n.length;t++)this.uniforms.push(n[t].clone())}return this}clone(){return(new this.constructor).copy(this)}}class Vu extends uo{constructor(t,e,n=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class ku{constructor(t,e,n,i,r,s=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.normalized=s,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}const Gu=new lr;class Hu{constructor(t,e,n=0,i=1/0){this.ray=new ar(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new vr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return Gu.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(Gu),this}intersectObject(t,e=!0,n=[]){return ju(t,this,n,e),n.sort(Wu),n}intersectObjects(t,e=!0,n=[]){for(let i=0,r=t.length;i<r;i++)ju(t[i],this,n,e);return n.sort(Wu),n}}function Wu(t,e){return t.distance-e.distance}function ju(t,e,n,i){let r=!0;if(t.layers.test(e.layers)&&!1===t.raycast(e,n)&&(r=!1),!0===r&&!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)ju(i[t],e,n,!0)}}class Xu{constructor(t=1,e=0,n=0){this.radius=t,this.phi=e,this.theta=n}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=qn(this.phi,t,Math.PI-t),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(qn(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class Yu{constructor(t=1,e=0,n=0){this.radius=t,this.theta=e,this.y=n}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}}class qu{constructor(t,e,n,i){qu.prototype.isMatrix2=!0,this.elements=[1,0,0,1],void 0!==t&&this.set(t,e,n,i)}identity(){return this.set(1,0,0,1),this}fromArray(t,e=0){for(let n=0;n<4;n++)this.elements[n]=t[n+e];return this}set(t,e,n,i){const r=this.elements;return r[0]=t,r[2]=e,r[1]=n,r[3]=i,this}}const $u=new ti;class Zu{constructor(t=new ti(1/0,1/0),e=new ti(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=$u.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,$u).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Ju=new ni,Ku=new ni;class Qu{constructor(t=new ni,e=new ni){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Ju.subVectors(t,this.start),Ku.subVectors(this.end,this.start);const n=Ku.dot(Ku);let i=Ku.dot(Ju)/n;return e&&(i=qn(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const td=new ni;class ed extends Or{constructor(t,e){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const n=new Ps,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const r=t/n*Math.PI*2,s=e/n*Math.PI*2;i.push(Math.cos(r),Math.sin(r),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new bs(i,3));const r=new Da({fog:!1,toneMapped:!1});this.cone=new Xa(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),td.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(td),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const nd=new ni,id=new lr,rd=new lr;class sd extends Xa{constructor(t){const e=od(t),n=new Ps,i=[],r=[],s=new ts(0,0,1),o=new ts(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new bs(i,3)),n.setAttribute("color",new bs(r,3)),super(n,new Da({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");rd.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(id.multiplyMatrices(rd,r.matrixWorld),nd.setFromMatrixPosition(id),i.setXYZ(n,nd.x,nd.y,nd.z),id.multiplyMatrices(rd,r.parent.matrixWorld),nd.setFromMatrixPosition(id),i.setXYZ(n+1,nd.x,nd.y,nd.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose()}}function od(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push(...od(t.children[n]));return e}class ad extends Gs{constructor(t,e,n){super(new Tc(e,4,2),new rs({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const ld=new ni,cd=new ts,hd=new ts;class ud extends Or{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new bc(e);i.rotateY(.5*Math.PI),this.material=new rs({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),s=new Float32Array(3*r.count);i.setAttribute("color",new ps(s,3)),this.add(new Gs(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");cd.copy(this.light.color),hd.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?cd:hd;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(ld.setFromMatrixPosition(this.light.matrixWorld).negate())}}class dd extends Xa{constructor(t=10,e=10,n=4473924,i=8947848){n=new ts(n),i=new ts(i);const r=e/2,s=t/e,o=t/2,a=[],l=[];for(let t=0,c=0,h=-o;t<=e;t++,h+=s){a.push(-o,0,h,o,0,h),a.push(h,0,-o,h,0,o);const e=t===r?n:i;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new Ps;c.setAttribute("position",new bs(a,3)),c.setAttribute("color",new bs(l,3)),super(c,new Da({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class pd extends Xa{constructor(t=10,e=16,n=8,i=64,r=4473924,s=8947848){r=new ts(r),s=new ts(s);const o=[],a=[];if(e>1)for(let n=0;n<e;n++){const i=n/e*(2*Math.PI),l=Math.sin(i)*t,c=Math.cos(i)*t;o.push(0,0,0),o.push(l,0,c);const h=1&n?r:s;a.push(h.r,h.g,h.b),a.push(h.r,h.g,h.b)}for(let e=0;e<n;e++){const l=1&e?r:s,c=t-t/n*e;for(let t=0;t<i;t++){let e=t/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c;o.push(n,0,r),a.push(l.r,l.g,l.b),e=(t+1)/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c,o.push(n,0,r),a.push(l.r,l.g,l.b)}}const l=new Ps;l.setAttribute("position",new bs(o,3)),l.setAttribute("color",new bs(a,3)),super(l,new Da({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const fd=new ni,md=new ni,gd=new ni;class _d extends Or{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",void 0===e&&(e=1);let i=new Ps;i.setAttribute("position",new bs([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new Da({fog:!1,toneMapped:!1});this.lightPlane=new Ga(i,r),this.add(this.lightPlane),i=new Ps,i.setAttribute("position",new bs([0,0,0,0,0,1],3)),this.targetLine=new Ga(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),fd.setFromMatrixPosition(this.light.matrixWorld),md.setFromMatrixPosition(this.light.target.matrixWorld),gd.subVectors(md,fd),this.lightPlane.lookAt(md),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(md),this.targetLine.scale.z=gd.length()}}const yd=new ni,vd=new Zs;class xd extends Xa{constructor(t){const e=new Ps,n=new Da({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],s={};function o(t,e){a(t),a(e)}function a(t){i.push(0,0,0),r.push(0,0,0),void 0===s[t]&&(s[t]=[]),s[t].push(i.length/3-1)}o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4"),e.setAttribute("position",new bs(i,3)),e.setAttribute("color",new bs(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update();const l=new ts(16755200),c=new ts(16711680),h=new ts(43775),u=new ts(16777215),d=new ts(3355443);this.setColors(l,c,h,u,d)}setColors(t,e,n,i,r){const s=this.geometry.getAttribute("color");s.setXYZ(0,t.r,t.g,t.b),s.setXYZ(1,t.r,t.g,t.b),s.setXYZ(2,t.r,t.g,t.b),s.setXYZ(3,t.r,t.g,t.b),s.setXYZ(4,t.r,t.g,t.b),s.setXYZ(5,t.r,t.g,t.b),s.setXYZ(6,t.r,t.g,t.b),s.setXYZ(7,t.r,t.g,t.b),s.setXYZ(8,t.r,t.g,t.b),s.setXYZ(9,t.r,t.g,t.b),s.setXYZ(10,t.r,t.g,t.b),s.setXYZ(11,t.r,t.g,t.b),s.setXYZ(12,t.r,t.g,t.b),s.setXYZ(13,t.r,t.g,t.b),s.setXYZ(14,t.r,t.g,t.b),s.setXYZ(15,t.r,t.g,t.b),s.setXYZ(16,t.r,t.g,t.b),s.setXYZ(17,t.r,t.g,t.b),s.setXYZ(18,t.r,t.g,t.b),s.setXYZ(19,t.r,t.g,t.b),s.setXYZ(20,t.r,t.g,t.b),s.setXYZ(21,t.r,t.g,t.b),s.setXYZ(22,t.r,t.g,t.b),s.setXYZ(23,t.r,t.g,t.b),s.setXYZ(24,e.r,e.g,e.b),s.setXYZ(25,e.r,e.g,e.b),s.setXYZ(26,e.r,e.g,e.b),s.setXYZ(27,e.r,e.g,e.b),s.setXYZ(28,e.r,e.g,e.b),s.setXYZ(29,e.r,e.g,e.b),s.setXYZ(30,e.r,e.g,e.b),s.setXYZ(31,e.r,e.g,e.b),s.setXYZ(32,n.r,n.g,n.b),s.setXYZ(33,n.r,n.g,n.b),s.setXYZ(34,n.r,n.g,n.b),s.setXYZ(35,n.r,n.g,n.b),s.setXYZ(36,n.r,n.g,n.b),s.setXYZ(37,n.r,n.g,n.b),s.setXYZ(38,i.r,i.g,i.b),s.setXYZ(39,i.r,i.g,i.b),s.setXYZ(40,r.r,r.g,r.b),s.setXYZ(41,r.r,r.g,r.b),s.setXYZ(42,r.r,r.g,r.b),s.setXYZ(43,r.r,r.g,r.b),s.setXYZ(44,r.r,r.g,r.b),s.setXYZ(45,r.r,r.g,r.b),s.setXYZ(46,r.r,r.g,r.b),s.setXYZ(47,r.r,r.g,r.b),s.setXYZ(48,r.r,r.g,r.b),s.setXYZ(49,r.r,r.g,r.b),s.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;vd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const n=this.camera.coordinateSystem===Fn?-1:0;Sd("c",e,t,vd,0,0,n),Sd("t",e,t,vd,0,0,1),Sd("n1",e,t,vd,-1,-1,n),Sd("n2",e,t,vd,1,-1,n),Sd("n3",e,t,vd,-1,1,n),Sd("n4",e,t,vd,1,1,n),Sd("f1",e,t,vd,-1,-1,1),Sd("f2",e,t,vd,1,-1,1),Sd("f3",e,t,vd,-1,1,1),Sd("f4",e,t,vd,1,1,1),Sd("u1",e,t,vd,.7,1.1,n),Sd("u2",e,t,vd,-.7,1.1,n),Sd("u3",e,t,vd,0,2,n),Sd("cf1",e,t,vd,-1,0,1),Sd("cf2",e,t,vd,1,0,1),Sd("cf3",e,t,vd,0,-1,1),Sd("cf4",e,t,vd,0,1,1),Sd("cn1",e,t,vd,-1,0,n),Sd("cn2",e,t,vd,1,0,n),Sd("cn3",e,t,vd,0,-1,n),Sd("cn4",e,t,vd,0,1,n),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Sd(t,e,n,i,r,s,o){yd.set(r,s,o).unproject(i);const a=e[t];if(void 0!==a){const t=n.getAttribute("position");for(let e=0,n=a.length;e<n;e++)t.setXYZ(a[e],yd.x,yd.y,yd.z)}}const bd=new Oi;class Md extends Xa{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Ps;r.setIndex(new ps(n,1)),r.setAttribute("position",new ps(i,3)),super(r,new Da({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(void 0!==this.object&&bd.setFromObject(this.object),bd.isEmpty())return;const t=bd.min,e=bd.max,n=this.geometry.attributes.position,i=n.array;i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=t.x,i[4]=e.y,i[5]=e.z,i[6]=t.x,i[7]=t.y,i[8]=e.z,i[9]=e.x,i[10]=t.y,i[11]=e.z,i[12]=e.x,i[13]=e.y,i[14]=t.z,i[15]=t.x,i[16]=e.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=e.x,i[22]=t.y,i[23]=t.z,n.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class wd extends Xa{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Ps;i.setIndex(new ps(n,1)),i.setAttribute("position",new bs([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new Da({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}class Ed extends Ga{constructor(t,e=1,n=16776960){const i=n,r=new Ps;r.setAttribute("position",new bs([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),r.computeBoundingSphere(),super(r,new Da({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new Ps;s.setAttribute("position",new bs([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),s.computeBoundingSphere(),this.add(new Gs(s,new rs({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const Td=new ni;let Ad,Cd;class Rd extends Or{constructor(t=new ni(0,0,1),e=new ni(0,0,0),n=1,i=16776960,r=.2*n,s=.2*r){super(),this.type="ArrowHelper",void 0===Ad&&(Ad=new Ps,Ad.setAttribute("position",new bs([0,0,0,0,1,0],3)),Cd=new dl(.5,1,5,1),Cd.translate(0,-.5,0)),this.position.copy(e),this.line=new Ga(Ad,new Da({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Gs(Cd,new rs({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Td.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Td,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class Pd extends Xa{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new Ps;n.setAttribute("position",new bs(e,3)),n.setAttribute("color",new bs([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new Da({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const i=new ts,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Ld{constructor(){this.type="ShapePath",this.color=new ts,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new kl,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,s){return this.currentPath.bezierCurveTo(t,e,n,i,r,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const n=e.length;let i=!1;for(let r=n-1,s=0;s<n;r=s++){let n=e[r],o=e[s],a=o.x-n.x,l=o.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],a=-a,o=e[r],l=-l),t.y<n.y||t.y>o.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(o.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=o.x)return!0}}return i}const n=mc.isClockWise,i=this.subPaths;if(0===i.length)return[];let r,s,o;const a=[];if(1===i.length)return s=i[0],o=new Gl,o.curves=s.curves,a.push(o),a;let l=!n(i[0].getPoints());l=t?!l:l;const c=[],h=[];let u,d,p=[],f=0;h[f]=void 0,p[f]=[];for(let e=0,o=i.length;e<o;e++)s=i[e],u=s.getPoints(),r=n(u),r=t?!r:r,r?(!l&&h[f]&&f++,h[f]={s:new Gl,p:u},h[f].s.curves=s.curves,l&&f++,p[f]=[]):p[f].push({h:s,p:u[0]});if(!h[0])return function(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new Gl;r.curves=i.curves,e.push(r)}return e}(i);if(h.length>1){let t=!1,n=0;for(let t=0,e=h.length;t<e;t++)c[t]=[];for(let i=0,r=h.length;i<r;i++){const r=p[i];for(let s=0;s<r.length;s++){const o=r[s];let a=!0;for(let r=0;r<h.length;r++)e(o.p,h[r].p)&&(i!==r&&n++,a?(a=!1,c[r].push(o)):t=!0);a&&c[i].push(o)}}n>0&&!1===t&&(p=c)}for(let t=0,e=h.length;t<e;t++){o=h[t].s,a.push(o),d=p[t];for(let t=0,e=d.length;t<e;t++)o.holes.push(d[t].h)}return a}}class Id extends Gn{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(t){void 0!==t?(null!==this.domElement&&this.disconnect(),this.domElement=t):console.warn("THREE.Controls: connect() now requires an element.")}disconnect(){}dispose(){}update(){}}function Nd(t,e,n,i){const r=function(t){switch(t){case Rt:case Pt:return{byteLength:1,components:1};case It:case Lt:case Ut:return{byteLength:2,components:1};case Ft:case Bt:return{byteLength:2,components:4};case Dt:case Nt:case Ot:return{byteLength:4,components:1};case Vt:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}(i);switch(n){case kt:return t*e;case Xt:case Yt:return t*e/r.components*r.byteLength;case qt:case $t:return t*e*2/r.components*r.byteLength;case Gt:return t*e*3/r.components*r.byteLength;case Ht:case Jt:return t*e*4/r.components*r.byteLength;case Kt:case Qt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case te:case ee:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case ie:case se:return Math.max(t,16)*Math.max(e,8)/4;case ne:case re:return Math.max(t,8)*Math.max(e,8)/2;case oe:case ae:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case le:case ce:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case he:return Math.floor((t+4)/5)*Math.floor((e+3)/4)*16;case ue:return Math.floor((t+4)/5)*Math.floor((e+4)/5)*16;case de:return Math.floor((t+5)/6)*Math.floor((e+4)/5)*16;case pe:return Math.floor((t+5)/6)*Math.floor((e+5)/6)*16;case fe:return Math.floor((t+7)/8)*Math.floor((e+4)/5)*16;case me:return Math.floor((t+7)/8)*Math.floor((e+5)/6)*16;case ge:return Math.floor((t+7)/8)*Math.floor((e+7)/8)*16;case _e:return Math.floor((t+9)/10)*Math.floor((e+4)/5)*16;case ye:return Math.floor((t+9)/10)*Math.floor((e+5)/6)*16;case ve:return Math.floor((t+9)/10)*Math.floor((e+7)/8)*16;case xe:return Math.floor((t+9)/10)*Math.floor((e+9)/10)*16;case Se:return Math.floor((t+11)/12)*Math.floor((e+9)/10)*16;case be:return Math.floor((t+11)/12)*Math.floor((e+11)/12)*16;case Me:case we:case Ee:return Math.ceil(t/4)*Math.ceil(e/4)*16;case Te:case Ae:return Math.ceil(t/4)*Math.ceil(e/4)*8;case Ce:case Re:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}class Dd{static contain(t,e){return function(t,e){const n=t.image&&t.image.width?t.image.width/t.image.height:1;return n>e?(t.repeat.x=1,t.repeat.y=n/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2):(t.repeat.x=e/n,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0),t}(t,e)}static cover(t,e){return function(t,e){const n=t.image&&t.image.width?t.image.width/t.image.height:1;return n>e?(t.repeat.x=e/n,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0):(t.repeat.x=1,t.repeat.y=n/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2),t}(t,e)}static fill(t){return function(t){return t.repeat.x=1,t.repeat.y=1,t.offset.x=0,t.offset.y=0,t}(t)}static getByteLength(t,e,n,i){return Nd(t,e,n,i)}}function Od(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Ud(t){const e=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),e.get(t)},remove:function(n){n.isInterleavedBufferAttribute&&(n=n.data);const i=e.get(n);i&&(t.deleteBuffer(i.buffer),e.delete(n))},update:function(n,i){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const t=e.get(n);return void((!t||t.version<n.version)&&e.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const r=e.get(n);if(void 0===r)e.set(n,function(e,n){const i=e.array,r=e.usage,s=i.byteLength,o=t.createBuffer();let a;if(t.bindBuffer(n,o),t.bufferData(n,i,r),e.onUploadCallback(),i instanceof Float32Array)a=t.FLOAT;else if("undefined"!=typeof Float16Array&&i instanceof Float16Array)a=t.HALF_FLOAT;else if(i instanceof Uint16Array)a=e.isFloat16BufferAttribute?t.HALF_FLOAT:t.UNSIGNED_SHORT;else if(i instanceof Int16Array)a=t.SHORT;else if(i instanceof Uint32Array)a=t.UNSIGNED_INT;else if(i instanceof Int32Array)a=t.INT;else if(i instanceof Int8Array)a=t.BYTE;else if(i instanceof Uint8Array)a=t.UNSIGNED_BYTE;else{if(!(i instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+i);a=t.UNSIGNED_BYTE}return{buffer:o,type:a,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version,size:s}}(n,i));else if(r.version<n.version){if(r.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(e,n,i){const r=n.array,s=n.updateRanges;if(t.bindBuffer(i,e),0===s.length)t.bufferSubData(i,0,r);else{s.sort((t,e)=>t.start-e.start);let e=0;for(let t=1;t<s.length;t++){const n=s[e],i=s[t];i.start<=n.start+n.count+1?n.count=Math.max(n.count,i.start+i.count-n.start):(++e,s[e]=i)}s.length=e+1;for(let e=0,n=s.length;e<n;e++){const n=s[e];t.bufferSubData(i,n.start*r.BYTES_PER_ELEMENT,r,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(r.buffer,n,i),r.version=n.version}}}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:i}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=i);const Fd={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Bd={common:{diffuse:{value:new ts(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new si},alphaMap:{value:null},alphaMapTransform:{value:new si},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new si}},envmap:{envMap:{value:null},envMapRotation:{value:new si},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new si}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new si}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new si},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new si},normalScale:{value:new ti(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new si},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new si}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new si}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new si}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ts(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ts(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new si},alphaTest:{value:0},uvTransform:{value:new si}},sprite:{diffuse:{value:new ts(16777215)},opacity:{value:1},center:{value:new ti(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new si},alphaMap:{value:null},alphaMapTransform:{value:new si},alphaTest:{value:0}}},zd={basic:{uniforms:Xs([Bd.common,Bd.specularmap,Bd.envmap,Bd.aomap,Bd.lightmap,Bd.fog]),vertexShader:Fd.meshbasic_vert,fragmentShader:Fd.meshbasic_frag},lambert:{uniforms:Xs([Bd.common,Bd.specularmap,Bd.envmap,Bd.aomap,Bd.lightmap,Bd.emissivemap,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,Bd.fog,Bd.lights,{emissive:{value:new ts(0)}}]),vertexShader:Fd.meshlambert_vert,fragmentShader:Fd.meshlambert_frag},phong:{uniforms:Xs([Bd.common,Bd.specularmap,Bd.envmap,Bd.aomap,Bd.lightmap,Bd.emissivemap,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,Bd.fog,Bd.lights,{emissive:{value:new ts(0)},specular:{value:new ts(1118481)},shininess:{value:30}}]),vertexShader:Fd.meshphong_vert,fragmentShader:Fd.meshphong_frag},standard:{uniforms:Xs([Bd.common,Bd.envmap,Bd.aomap,Bd.lightmap,Bd.emissivemap,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,Bd.roughnessmap,Bd.metalnessmap,Bd.fog,Bd.lights,{emissive:{value:new ts(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Fd.meshphysical_vert,fragmentShader:Fd.meshphysical_frag},toon:{uniforms:Xs([Bd.common,Bd.aomap,Bd.lightmap,Bd.emissivemap,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,Bd.gradientmap,Bd.fog,Bd.lights,{emissive:{value:new ts(0)}}]),vertexShader:Fd.meshtoon_vert,fragmentShader:Fd.meshtoon_frag},matcap:{uniforms:Xs([Bd.common,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,Bd.fog,{matcap:{value:null}}]),vertexShader:Fd.meshmatcap_vert,fragmentShader:Fd.meshmatcap_frag},points:{uniforms:Xs([Bd.points,Bd.fog]),vertexShader:Fd.points_vert,fragmentShader:Fd.points_frag},dashed:{uniforms:Xs([Bd.common,Bd.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Fd.linedashed_vert,fragmentShader:Fd.linedashed_frag},depth:{uniforms:Xs([Bd.common,Bd.displacementmap]),vertexShader:Fd.depth_vert,fragmentShader:Fd.depth_frag},normal:{uniforms:Xs([Bd.common,Bd.bumpmap,Bd.normalmap,Bd.displacementmap,{opacity:{value:1}}]),vertexShader:Fd.meshnormal_vert,fragmentShader:Fd.meshnormal_frag},sprite:{uniforms:Xs([Bd.sprite,Bd.fog]),vertexShader:Fd.sprite_vert,fragmentShader:Fd.sprite_frag},background:{uniforms:{uvTransform:{value:new si},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Fd.background_vert,fragmentShader:Fd.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new si}},vertexShader:Fd.backgroundCube_vert,fragmentShader:Fd.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Fd.cube_vert,fragmentShader:Fd.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Fd.equirect_vert,fragmentShader:Fd.equirect_frag},distanceRGBA:{uniforms:Xs([Bd.common,Bd.displacementmap,{referencePosition:{value:new ni},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Fd.distanceRGBA_vert,fragmentShader:Fd.distanceRGBA_frag},shadow:{uniforms:Xs([Bd.lights,Bd.fog,{color:{value:new ts(0)},opacity:{value:1}}]),vertexShader:Fd.shadow_vert,fragmentShader:Fd.shadow_frag}};zd.physical={uniforms:Xs([zd.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new si},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new si},clearcoatNormalScale:{value:new ti(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new si},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new si},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new si},sheen:{value:0},sheenColor:{value:new ts(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new si},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new si},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new si},transmissionSamplerSize:{value:new ti},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new si},attenuationDistance:{value:0},attenuationColor:{value:new ts(0)},specularColor:{value:new ts(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new si},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new si},anisotropyVector:{value:new ti},anisotropyMap:{value:null},anisotropyMapTransform:{value:new si}}]),vertexShader:Fd.meshphysical_vert,fragmentShader:Fd.meshphysical_frag};const Vd={r:0,b:0,g:0},kd=new yr,Gd=new lr;function Hd(t,e,n,i,r,s,o){const a=new ts(0);let l,c,h=!0===s?0:1,u=null,d=0,p=null;function g(t){let i=!0===t.isScene?t.background:null;return i&&i.isTexture&&(i=(t.backgroundBlurriness>0?n:e).get(i)),i}function _(e,n){e.getRGB(Vd,Ys(t)),i.buffers.color.setClear(Vd.r,Vd.g,Vd.b,n,o)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),h=e,_(a,h)},getClearAlpha:function(){return h},setClearAlpha:function(t){h=t,_(a,h)},render:function(e){let n=!1;const r=g(e);null===r?_(a,h):r&&r.isColor&&(_(r,1),n=!0);const s=t.xr.getEnvironmentBlendMode();"additive"===s?i.buffers.color.setClear(0,0,0,1,o):"alpha-blend"===s&&i.buffers.color.setClear(0,0,0,0,o),(t.autoClear||n)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))},addToRenderList:function(e,n){const i=g(n);i&&(i.isCubeTexture||i.mapping===mt)?(void 0===c&&(c=new Gs(new Ws(1,1,1),new $s({name:"BackgroundCubeMaterial",uniforms:js(zd.backgroundCube.uniforms),vertexShader:zd.backgroundCube.vertexShader,fragmentShader:zd.backgroundCube.fragmentShader,side:m,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),kd.copy(n.backgroundRotation),kd.x*=-1,kd.y*=-1,kd.z*=-1,i.isCubeTexture&&!1===i.isRenderTargetTexture&&(kd.y*=-1,kd.z*=-1),c.material.uniforms.envMap.value=i,c.material.uniforms.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,c.material.uniforms.backgroundRotation.value.setFromMatrix4(Gd.makeRotationFromEuler(kd)),c.material.toneMapped=_i.getTransfer(i.colorSpace)!==tn,u===i&&d===i.version&&p===t.toneMapping||(c.material.needsUpdate=!0,u=i,d=i.version,p=t.toneMapping),c.layers.enableAll(),e.unshift(c,c.geometry,c.material,0,0,null)):i&&i.isTexture&&(void 0===l&&(l=new Gs(new Mc(2,2),new $s({name:"BackgroundMaterial",uniforms:js(zd.background.uniforms),vertexShader:zd.background.vertexShader,fragmentShader:zd.background.fragmentShader,side:f,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(l)),l.material.uniforms.t2D.value=i,l.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,l.material.toneMapped=_i.getTransfer(i.colorSpace)!==tn,!0===i.matrixAutoUpdate&&i.updateMatrix(),l.material.uniforms.uvTransform.value.copy(i.matrix),u===i&&d===i.version&&p===t.toneMapping||(l.material.needsUpdate=!0,u=i,d=i.version,p=t.toneMapping),l.layers.enableAll(),e.unshift(l,l.geometry,l.material,0,0,null))},dispose:function(){void 0!==c&&(c.geometry.dispose(),c.material.dispose(),c=void 0),void 0!==l&&(l.geometry.dispose(),l.material.dispose(),l=void 0)}}}function Wd(t,e){const n=t.getParameter(t.MAX_VERTEX_ATTRIBS),i={},r=c(null);let s=r,o=!1;function a(e){return t.bindVertexArray(e)}function l(e){return t.deleteVertexArray(e)}function c(t){const e=[],i=[],r=[];for(let t=0;t<n;t++)e[t]=0,i[t]=0,r[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:i,attributeDivisors:r,object:t,attributes:{},index:null}}function h(){const t=s.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function u(t){d(t,0)}function d(e,n){const i=s.newAttributes,r=s.enabledAttributes,o=s.attributeDivisors;i[e]=1,0===r[e]&&(t.enableVertexAttribArray(e),r[e]=1),o[e]!==n&&(t.vertexAttribDivisor(e,n),o[e]=n)}function p(){const e=s.newAttributes,n=s.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function f(e,n,i,r,s,o,a){!0===a?t.vertexAttribIPointer(e,n,i,s,o):t.vertexAttribPointer(e,n,i,r,s,o)}function m(){g(),o=!0,s!==r&&(s=r,a(s.object))}function g(){r.geometry=null,r.program=null,r.wireframe=!1}return{setup:function(n,r,l,m,g){let _=!1;const y=function(e,n,r){const s=!0===r.wireframe;let o=i[e.id];void 0===o&&(o={},i[e.id]=o);let a=o[n.id];void 0===a&&(a={},o[n.id]=a);let l=a[s];return void 0===l&&(l=c(t.createVertexArray()),a[s]=l),l}(m,l,r);s!==y&&(s=y,a(s.object)),_=function(t,e,n,i){const r=s.attributes,o=e.attributes;let a=0;const l=n.getAttributes();for(const e in l)if(l[e].location>=0){const n=r[e];let i=o[e];if(void 0===i&&("instanceMatrix"===e&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(i=t.instanceColor)),void 0===n)return!0;if(n.attribute!==i)return!0;if(i&&n.data!==i.data)return!0;a++}return s.attributesNum!==a||s.index!==i}(n,m,l,g),_&&function(t,e,n,i){const r={},o=e.attributes;let a=0;const l=n.getAttributes();for(const e in l)if(l[e].location>=0){let n=o[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const i={};i.attribute=n,n&&n.data&&(i.data=n.data),r[e]=i,a++}s.attributes=r,s.attributesNum=a,s.index=i}(n,m,l,g),null!==g&&e.update(g,t.ELEMENT_ARRAY_BUFFER),(_||o)&&(o=!1,function(n,i,r,s){h();const o=s.attributes,a=r.getAttributes(),l=i.defaultAttributeValues;for(const i in a){const r=a[i];if(r.location>=0){let a=o[i];if(void 0===a&&("instanceMatrix"===i&&n.instanceMatrix&&(a=n.instanceMatrix),"instanceColor"===i&&n.instanceColor&&(a=n.instanceColor)),void 0!==a){const i=a.normalized,o=a.itemSize,l=e.get(a);if(void 0===l)continue;const c=l.buffer,h=l.type,p=l.bytesPerElement,m=h===t.INT||h===t.UNSIGNED_INT||a.gpuType===Nt;if(a.isInterleavedBufferAttribute){const e=a.data,l=e.stride,g=a.offset;if(e.isInstancedInterleavedBuffer){for(let t=0;t<r.locationSize;t++)d(r.location+t,e.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===s._maxInstanceCount&&(s._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let t=0;t<r.locationSize;t++)u(r.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<r.locationSize;t++)f(r.location+t,o/r.locationSize,h,i,l*p,(g+o/r.locationSize*t)*p,m)}else{if(a.isInstancedBufferAttribute){for(let t=0;t<r.locationSize;t++)d(r.location+t,a.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===s._maxInstanceCount&&(s._maxInstanceCount=a.meshPerAttribute*a.count)}else for(let t=0;t<r.locationSize;t++)u(r.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<r.locationSize;t++)f(r.location+t,o/r.locationSize,h,i,o*p,o/r.locationSize*t*p,m)}}else if(void 0!==l){const e=l[i];if(void 0!==e)switch(e.length){case 2:t.vertexAttrib2fv(r.location,e);break;case 3:t.vertexAttrib3fv(r.location,e);break;case 4:t.vertexAttrib4fv(r.location,e);break;default:t.vertexAttrib1fv(r.location,e)}}}}p()}(n,r,l,m),null!==g&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(g).buffer))},reset:m,resetDefaultState:g,dispose:function(){m();for(const t in i){const e=i[t];for(const t in e){const n=e[t];for(const t in n)l(n[t].object),delete n[t];delete e[t]}delete i[t]}},releaseStatesOfGeometry:function(t){if(void 0===i[t.id])return;const e=i[t.id];for(const t in e){const n=e[t];for(const t in n)l(n[t].object),delete n[t];delete e[t]}delete i[t.id]},releaseStatesOfProgram:function(t){for(const e in i){const n=i[e];if(void 0===n[t.id])continue;const r=n[t.id];for(const t in r)l(r[t].object),delete r[t];delete n[t.id]}},initAttributes:h,enableAttribute:u,disableUnusedAttributes:p}}function jd(t,e,n){let i;function r(e,r,s){0!==s&&(t.drawArraysInstanced(i,e,r,s),n.update(r,i,s))}this.setMode=function(t){i=t},this.render=function(e,r){t.drawArrays(i,e,r),n.update(r,i,1)},this.renderInstances=r,this.renderMultiDraw=function(t,r,s){if(0===s)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i,t,0,r,0,s);let o=0;for(let t=0;t<s;t++)o+=r[t];n.update(o,i,1)},this.renderMultiDrawInstances=function(t,s,o,a){if(0===o)return;const l=e.get("WEBGL_multi_draw");if(null===l)for(let e=0;e<t.length;e++)r(t[e],s[e],a[e]);else{l.multiDrawArraysInstancedWEBGL(i,t,0,s,0,a,0,o);let e=0;for(let t=0;t<o;t++)e+=s[t]*a[t];n.update(e,i,1)}}}function Xd(t,e,n,i){let r;function s(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=void 0!==n.precision?n.precision:"highp";const a=s(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=!0===n.logarithmicDepthBuffer,c=!0===n.reverseDepthBuffer&&e.has("EXT_clip_control"),h=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:s,textureFormatReadable:function(e){return e===Ht||i.convert(e)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(n){const r=n===Ut&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(n!==Rt&&i.convert(n)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==Ot&&!r)},precision:o,logarithmicDepthBuffer:l,reverseDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxCubemapSize:t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:t.getParameter(t.MAX_VERTEX_ATTRIBS),maxVertexUniforms:t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:t.getParameter(t.MAX_VARYING_VECTORS),maxFragmentUniforms:t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:u>0,maxSamples:t.getParameter(t.MAX_SAMPLES)}}function Yd(t){const e=this;let n=null,i=0,r=!1,s=!1;const o=new aa,a=new si,l={value:null,needsUpdate:!1};function c(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;a.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)o.copy(t[e]).applyMatrix4(r,a),o.normal.toArray(c,n),c[n+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const n=0!==t.length||e||0!==i||r;return r=e,i=t.length,n},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(t,e){n=c(t,e,0)},this.setState=function(o,a,h){const u=o.clippingPlanes,d=o.clipIntersection,p=o.clipShadows,f=t.get(o);if(!r||null===u||0===u.length||s&&!p)s?c(null):(l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0);else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=c(u,a,e,h);for(let t=0;t!==e;++t)r[t]=n[t];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function qd(t){let e=new WeakMap;function n(t,e){return e===pt?t.mapping=ut:e===ft&&(t.mapping=dt),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping;if(s===pt||s===ft){if(e.has(r))return n(e.get(r).texture,r.mapping);{const s=r.image;if(s&&s.height>0){const o=new ro(s.height);return o.fromEquirectangularTexture(t,r),e.set(r,o),r.addEventListener("dispose",i),n(o.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}const $d=[.125,.215,.35,.446,.526,.582],Zd=new zh,Jd=new ts;let Kd=null,Qd=0,tp=0,ep=!1;const np=(1+Math.sqrt(5))/2,ip=1/np,rp=[new ni(-np,ip,0),new ni(np,ip,0),new ni(-ip,0,np),new ni(ip,0,np),new ni(0,np,-ip),new ni(0,np,ip),new ni(-1,1,-1),new ni(1,1,-1),new ni(-1,1,1),new ni(1,1,1)],sp=new ni;class op{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100,r={}){const{size:s=256,position:o=sp}=r;Kd=this._renderer.getRenderTarget(),Qd=this._renderer.getActiveCubeFace(),tp=this._renderer.getActiveMipmapLevel(),ep=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(s);const a=this._allocateTargets();return a.depthBuffer=!0,this._sceneToCubeUV(t,n,i,a,o),e>0&&this._blur(a,0,0,e),this._applyPMREM(a),this._cleanup(a),a}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=hp(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=cp(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Kd,Qd,tp),this._renderer.xr.enabled=ep,t.scissorTest=!1,lp(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===ut||t.mapping===dt?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Kd=this._renderer.getRenderTarget(),Qd=this._renderer.getActiveCubeFace(),tp=this._renderer.getActiveMipmapLevel(),ep=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:wt,minFilter:wt,generateMipmaps:!1,type:Ut,format:Ht,colorSpace:Ke,depthBuffer:!1},i=ap(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=ap(t,e,n);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],i=[];let r=t;const s=t-4+1+$d.length;for(let o=0;o<s;o++){const s=Math.pow(2,r);n.push(s);let a=1/s;o>t-4?a=$d[o-t+4-1]:0===o&&(a=0),i.push(a);const l=1/(s-2),c=-l,h=1+l,u=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,p=6,f=3,m=2,g=1,_=new Float32Array(f*p*d),y=new Float32Array(m*p*d),v=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];_.set(i,f*p*t),y.set(u,m*p*t);const r=[t,t,t,t,t,t];v.set(r,g*p*t)}const x=new Ps;x.setAttribute("position",new ps(_,f)),x.setAttribute("uv",new ps(y,m)),x.setAttribute("faceIndex",new ps(v,g)),e.push(x),r>4&&r--}return{lodPlanes:e,sizeLods:n,sigmas:i}}(i)),this._blurMaterial=function(t,e,n){const i=new Float32Array(20),r=new ni(0,1,0);return new $s({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:_,depthTest:!1,depthWrite:!1})}(i,t,e)}return i}_compileMaterial(t){const e=new Gs(this._lodPlanes[0],t);this._renderer.compile(e,Zd)}_sceneToCubeUV(t,e,n,i,r){const s=new to(90,1,e,n),o=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],l=this._renderer,c=l.autoClear,h=l.toneMapping;l.getClearColor(Jd),l.toneMapping=tt,l.autoClear=!1;const u=new rs({name:"PMREM.Background",side:m,depthWrite:!1,depthTest:!1}),d=new Gs(new Ws,u);let p=!1;const f=t.background;f?f.isColor&&(u.color.copy(f),t.background=null,p=!0):(u.color.copy(Jd),p=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(s.up.set(0,o[e],0),s.position.set(r.x,r.y,r.z),s.lookAt(r.x+a[e],r.y,r.z)):1===n?(s.up.set(0,0,o[e]),s.position.set(r.x,r.y,r.z),s.lookAt(r.x,r.y+a[e],r.z)):(s.up.set(0,o[e],0),s.position.set(r.x,r.y,r.z),s.lookAt(r.x,r.y,r.z+a[e]));const c=this._cubeSize;lp(i,n*c,e>2?c:0,c,c),l.setRenderTarget(i),p&&l.render(d,s),l.render(t,s)}d.geometry.dispose(),d.material.dispose(),l.toneMapping=h,l.autoClear=c,t.background=f}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===ut||t.mapping===dt;i?(null===this._cubemapMaterial&&(this._cubemapMaterial=hp()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=cp());const r=i?this._cubemapMaterial:this._equirectMaterial,s=new Gs(this._lodPlanes[0],r);r.uniforms.envMap.value=t;const o=this._cubeSize;lp(e,0,0,3*o,2*o),n.setRenderTarget(e),n.render(s,Zd)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const i=this._lodPlanes.length;for(let e=1;e<i;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),r=rp[(i-e-1)%rp.length];this._blur(t,e-1,e,n,r)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new Gs(this._lodPlanes[i],l),h=l.uniforms,u=this._sizeLods[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<20;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0===t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;h.envMap.value=t.texture,h.samples.value=f,h.weights.value=m,h.latitudinal.value="latitudinal"===s,o&&(h.poleAxis.value=o);const{_lodMax:_}=this;h.dTheta.value=d,h.mipInt.value=_-n;const y=this._sizeLods[i];lp(e,3*y*(i>_-4?i-_+4:0),4*(this._cubeSize-y),3*y,2*y),a.setRenderTarget(e),a.render(c,Zd)}}function ap(t,e,n){const i=new Pi(t,e,n);return i.texture.mapping=mt,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function lp(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function cp(){return new $s({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:_,depthTest:!1,depthWrite:!1})}function hp(){return new $s({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:_,depthTest:!1,depthWrite:!1})}function up(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping,o=s===pt||s===ft,a=s===ut||s===dt;if(o||a){let s=e.get(r);const l=void 0!==s?s.texture.pmremVersion:0;if(r.isRenderTargetTexture&&r.pmremVersion!==l)return null===n&&(n=new op(t)),s=o?n.fromEquirectangular(r,s):n.fromCubemap(r,s),s.texture.pmremVersion=r.pmremVersion,e.set(r,s),s.texture;if(void 0!==s)return s.texture;{const l=r.image;return o&&l&&l.height>0||a&&l&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(l)?(null===n&&(n=new op(t)),s=o?n.fromEquirectangular(r):n.fromCubemap(r),s.texture.pmremVersion=r.pmremVersion,e.set(r,s),r.addEventListener("dispose",i),s.texture):null}}}return r},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function dp(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(t){const e=n(t);return null===e&&pi("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function pp(t,e,n,i){const r={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const t in a.attributes)e.remove(a.attributes[t]);a.removeEventListener("dispose",o),delete r[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),i.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],i=t.index,r=t.attributes.position;let o=0;if(null!==i){const t=i.array;o=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{if(void 0===r)return;{const t=r.array;o=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}}const a=new(ai(n)?xs:ys)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",o),r[e.id]=!0,n.memory.geometries++),e},update:function(n){const i=n.attributes;for(const n in i)e.update(i[n],t.ARRAY_BUFFER)},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function fp(t,e,n){let i,r,s;function o(e,o,a){0!==a&&(t.drawElementsInstanced(i,o,r,e*s,a),n.update(o,i,a))}this.setMode=function(t){i=t},this.setIndex=function(t){r=t.type,s=t.bytesPerElement},this.render=function(e,o){t.drawElements(i,o,r,e*s),n.update(o,i,1)},this.renderInstances=o,this.renderMultiDraw=function(t,s,o){if(0===o)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i,s,0,r,t,0,o);let a=0;for(let t=0;t<o;t++)a+=s[t];n.update(a,i,1)},this.renderMultiDrawInstances=function(t,a,l,c){if(0===l)return;const h=e.get("WEBGL_multi_draw");if(null===h)for(let e=0;e<t.length;e++)o(t[e]/s,a[e],c[e]);else{h.multiDrawElementsInstancedWEBGL(i,a,0,r,t,0,c,0,l);let e=0;for(let t=0;t<l;t++)e+=a[t]*c[t];n.update(e,i,1)}}}function mp(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,i,r){switch(e.calls++,i){case t.TRIANGLES:e.triangles+=r*(n/3);break;case t.LINES:e.lines+=r*(n/2);break;case t.LINE_STRIP:e.lines+=r*(n-1);break;case t.LINE_LOOP:e.lines+=r*n;break;case t.POINTS:e.points+=r*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function gp(t,e,n){const i=new WeakMap,r=new Ci;return{update:function(s,o,a){const l=s.morphTargetInfluences,c=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,h=void 0!==c?c.length:0;let u=i.get(o);if(void 0===u||u.count!==h){void 0!==u&&u.texture.dispose();const d=void 0!==o.morphAttributes.position,p=void 0!==o.morphAttributes.normal,f=void 0!==o.morphAttributes.color,m=o.morphAttributes.position||[],g=o.morphAttributes.normal||[],_=o.morphAttributes.color||[];let y=0;!0===d&&(y=1),!0===p&&(y=2),!0===f&&(y=3);let v=o.attributes.position.count*y,x=1;v>e.maxTextureSize&&(x=Math.ceil(v/e.maxTextureSize),v=e.maxTextureSize);const S=new Float32Array(v*x*4*h),b=new Li(S,v,x,h);b.type=Ot,b.needsUpdate=!0;const M=4*y;for(let E=0;E<h;E++){const T=m[E],A=g[E],C=_[E],R=v*x*4*E;for(let P=0;P<T.count;P++){const L=P*M;!0===d&&(r.fromBufferAttribute(T,P),S[R+L+0]=r.x,S[R+L+1]=r.y,S[R+L+2]=r.z,S[R+L+3]=0),!0===p&&(r.fromBufferAttribute(A,P),S[R+L+4]=r.x,S[R+L+5]=r.y,S[R+L+6]=r.z,S[R+L+7]=0),!0===f&&(r.fromBufferAttribute(C,P),S[R+L+8]=r.x,S[R+L+9]=r.y,S[R+L+10]=r.z,S[R+L+11]=4===C.itemSize?r.w:1)}}function w(){b.dispose(),i.delete(o),o.removeEventListener("dispose",w)}u={count:h,texture:b,size:new ti(v,x)},i.set(o,u),o.addEventListener("dispose",w)}if(!0===s.isInstancedMesh&&null!==s.morphTexture)a.getUniforms().setValue(t,"morphTexture",s.morphTexture,n);else{let I=0;for(let D=0;D<l.length;D++)I+=l[D];const N=o.morphTargetsRelative?1:1-I;a.getUniforms().setValue(t,"morphTargetBaseInfluence",N),a.getUniforms().setValue(t,"morphTargetInfluences",l)}a.getUniforms().setValue(t,"morphTargetsTexture",u.texture,n),a.getUniforms().setValue(t,"morphTargetsTextureSize",u.size)}}}function _p(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(o){const a=i.render.frame,l=o.geometry,c=e.get(o,l);if(r.get(c)!==a&&(e.update(c),r.set(c,a)),o.isInstancedMesh&&(!1===o.hasEventListener("dispose",s)&&o.addEventListener("dispose",s),r.get(o)!==a&&(n.update(o.instanceMatrix,t.ARRAY_BUFFER),null!==o.instanceColor&&n.update(o.instanceColor,t.ARRAY_BUFFER),r.set(o,a))),o.isSkinnedMesh){const t=o.skeleton;r.get(t)!==a&&(t.update(),r.set(t,a))}return c},dispose:function(){r=new WeakMap}}}const yp=new Ai,vp=new ll(1,1),xp=new Li,Sp=new Ni,bp=new io,Mp=[],wp=[],Ep=new Float32Array(16),Tp=new Float32Array(9),Ap=new Float32Array(4);function Cp(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=Mp[r];if(void 0===s&&(s=new Float32Array(r),Mp[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function Rp(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function Pp(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function Lp(t,e){let n=wp[e];void 0===n&&(n=new Int32Array(e),wp[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function Ip(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Np(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Rp(n,e))return;t.uniform2fv(this.addr,e),Pp(n,e)}}function Dp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Rp(n,e))return;t.uniform3fv(this.addr,e),Pp(n,e)}}function Op(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Rp(n,e))return;t.uniform4fv(this.addr,e),Pp(n,e)}}function Up(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Rp(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Pp(n,e)}else{if(Rp(n,i))return;Ap.set(i),t.uniformMatrix2fv(this.addr,!1,Ap),Pp(n,i)}}function Fp(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Rp(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Pp(n,e)}else{if(Rp(n,i))return;Tp.set(i),t.uniformMatrix3fv(this.addr,!1,Tp),Pp(n,i)}}function Bp(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(Rp(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Pp(n,e)}else{if(Rp(n,i))return;Ep.set(i),t.uniformMatrix4fv(this.addr,!1,Ep),Pp(n,i)}}function zp(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Vp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Rp(n,e))return;t.uniform2iv(this.addr,e),Pp(n,e)}}function kp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Rp(n,e))return;t.uniform3iv(this.addr,e),Pp(n,e)}}function Gp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Rp(n,e))return;t.uniform4iv(this.addr,e),Pp(n,e)}}function Hp(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Wp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Rp(n,e))return;t.uniform2uiv(this.addr,e),Pp(n,e)}}function jp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Rp(n,e))return;t.uniform3uiv(this.addr,e),Pp(n,e)}}function Xp(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Rp(n,e))return;t.uniform4uiv(this.addr,e),Pp(n,e)}}function Yp(t,e,n){const i=this.cache,r=n.allocateTextureUnit();let s;i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),this.type===t.SAMPLER_2D_SHADOW?(vp.compareFunction=Sn,s=vp):s=yp,n.setTexture2D(e||s,r)}function qp(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Sp,r)}function $p(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTextureCube(e||bp,r)}function Zp(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||xp,r)}function Jp(t,e){t.uniform1fv(this.addr,e)}function Kp(t,e){const n=Cp(e,this.size,2);t.uniform2fv(this.addr,n)}function Qp(t,e){const n=Cp(e,this.size,3);t.uniform3fv(this.addr,n)}function tf(t,e){const n=Cp(e,this.size,4);t.uniform4fv(this.addr,n)}function ef(t,e){const n=Cp(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function nf(t,e){const n=Cp(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function rf(t,e){const n=Cp(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function sf(t,e){t.uniform1iv(this.addr,e)}function of(t,e){t.uniform2iv(this.addr,e)}function af(t,e){t.uniform3iv(this.addr,e)}function lf(t,e){t.uniform4iv(this.addr,e)}function cf(t,e){t.uniform1uiv(this.addr,e)}function hf(t,e){t.uniform2uiv(this.addr,e)}function uf(t,e){t.uniform3uiv(this.addr,e)}function df(t,e){t.uniform4uiv(this.addr,e)}function pf(t,e,n){const i=this.cache,r=e.length,s=Lp(n,r);Rp(i,s)||(t.uniform1iv(this.addr,s),Pp(i,s));for(let t=0;t!==r;++t)n.setTexture2D(e[t]||yp,s[t])}function ff(t,e,n){const i=this.cache,r=e.length,s=Lp(n,r);Rp(i,s)||(t.uniform1iv(this.addr,s),Pp(i,s));for(let t=0;t!==r;++t)n.setTexture3D(e[t]||Sp,s[t])}function mf(t,e,n){const i=this.cache,r=e.length,s=Lp(n,r);Rp(i,s)||(t.uniform1iv(this.addr,s),Pp(i,s));for(let t=0;t!==r;++t)n.setTextureCube(e[t]||bp,s[t])}function gf(t,e,n){const i=this.cache,r=e.length,s=Lp(n,r);Rp(i,s)||(t.uniform1iv(this.addr,s),Pp(i,s));for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||xp,s[t])}class _f{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=function(t){switch(t){case 5126:return Ip;case 35664:return Np;case 35665:return Dp;case 35666:return Op;case 35674:return Up;case 35675:return Fp;case 35676:return Bp;case 5124:case 35670:return zp;case 35667:case 35671:return Vp;case 35668:case 35672:return kp;case 35669:case 35673:return Gp;case 5125:return Hp;case 36294:return Wp;case 36295:return jp;case 36296:return Xp;case 35678:case 36198:case 36298:case 36306:case 35682:return Yp;case 35679:case 36299:case 36307:return qp;case 35680:case 36300:case 36308:case 36293:return $p;case 36289:case 36303:case 36311:case 36292:return Zp}}(e.type)}}class yf{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Jp;case 35664:return Kp;case 35665:return Qp;case 35666:return tf;case 35674:return ef;case 35675:return nf;case 35676:return rf;case 5124:case 35670:return sf;case 35667:case 35671:return of;case 35668:case 35672:return af;case 35669:case 35673:return lf;case 5125:return cf;case 36294:return hf;case 36295:return uf;case 36296:return df;case 35678:case 36198:case 36298:case 36306:case 35682:return pf;case 35679:case 36299:case 36307:return ff;case 35680:case 36300:case 36308:case 36293:return mf;case 36289:case 36303:case 36311:case 36292:return gf}}(e.type)}}class vf{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}}}const xf=/(\w+)(\])?(\[|\.)?/g;function Sf(t,e){t.seq.push(e),t.map[e.id]=e}function bf(t,e,n){const i=t.name,r=i.length;for(xf.lastIndex=0;;){const s=xf.exec(i),o=xf.lastIndex;let a=s[1];const l="]"===s[2],c=s[3];if(l&&(a|=0),void 0===c||"["===c&&o+2===r){Sf(n,void 0===c?new _f(a,t,e):new yf(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new vf(a),Sf(n,t)),n=t}}}class Mf{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);bf(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n}}function wf(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}let Ef=0;const Tf=new si;function Af(t,e,n){const i=t.getShaderParameter(e,t.COMPILE_STATUS),r=t.getShaderInfoLog(e).trim();if(i&&""===r)return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const i=parseInt(s[1]);return n.toUpperCase()+"\n\n"+r+"\n\n"+function(t,e){const n=t.split("\n"),i=[],r=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let t=r;t<s;t++){const r=t+1;i.push(`${r===e?">":" "} ${r}: ${n[t]}`)}return i.join("\n")}(t.getShaderSource(e),i)}return r}function Cf(t,e){const n=function(t){_i._getMatrix(Tf,_i.workingColorSpace,t);const e=`mat3( ${Tf.elements.map(t=>t.toFixed(4))} )`;switch(_i.getTransfer(t)){case Qe:return[e,"LinearTransferOETF"];case tn:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",t),[e,"LinearTransferOETF"]}}(e);return[`vec4 ${t}( vec4 value ) {`,`\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join("\n")}function Rf(t,e){let n;switch(e){case et:n="Linear";break;case nt:n="Reinhard";break;case it:n="Cineon";break;case rt:n="ACESFilmic";break;case ot:n="AgX";break;case at:n="Neutral";break;case st:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}const Pf=new ni;function Lf(t){return""!==t}function If(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Nf(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Df=/^[ \t]*#include +<([\w\d./]+)>/gm;function Of(t){return t.replace(Df,Ff)}const Uf=new Map;function Ff(t,e){let n=Fd[e];if(void 0===n){const t=Uf.get(e);if(void 0===t)throw new Error("Can not resolve #include <"+e+">");n=Fd[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,t)}return Of(n)}const Bf=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function zf(t){return t.replace(Bf,Vf)}function Vf(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function kf(t){let e=`precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Gf(t,e,n,i){const r=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===u?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===d?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===p&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case ut:case dt:e="ENVMAP_TYPE_CUBE";break;case mt:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),h=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===dt&&(e="ENVMAP_MODE_REFRACTION"),e}(n),f=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case J:e="ENVMAP_BLENDING_MULTIPLY";break;case K:e="ENVMAP_BLENDING_MIX";break;case Q:e="ENVMAP_BLENDING_ADD"}return e}(n),m=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:i,maxMip:n}}(n),g=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Lf).join("\n")}(n),_=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),y=r.createProgram();let v,x,S=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(v=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_].filter(Lf).join("\n"),v.length>0&&(v+="\n"),x=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_].filter(Lf).join("\n"),x.length>0&&(x+="\n")):(v=[kf(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Lf).join("\n"),x=[kf(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+f:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==tt?"#define TONE_MAPPING":"",n.toneMapping!==tt?Fd.tonemapping_pars_fragment:"",n.toneMapping!==tt?Rf("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Fd.colorspace_pars_fragment,Cf("linearToOutputTexel",n.outputColorSpace),(_i.getLuminanceCoefficients(Pf),["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Pf.x.toFixed(4)}, ${Pf.y.toFixed(4)}, ${Pf.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Lf).join("\n")),o=Of(o),o=If(o,n),o=Nf(o,n),a=Of(a),a=If(a,n),a=Nf(a,n),o=zf(o),a=zf(a),!0!==n.isRawShaderMaterial&&(S="#version 300 es\n",v=[g,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+v,x=["#define varying in",n.glslVersion===Un?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===Un?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+x);const b=S+v+o,M=S+x+a,w=wf(r,r.VERTEX_SHADER,b),E=wf(r,r.FRAGMENT_SHADER,M);function T(e){if(t.debug.checkShaderErrors){const n=r.getProgramInfoLog(y).trim(),i=r.getShaderInfoLog(w).trim(),s=r.getShaderInfoLog(E).trim();let o=!0,a=!0;if(!1===r.getProgramParameter(y,r.LINK_STATUS))if(o=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(r,y,w,E);else{const t=Af(r,w,"vertex"),i=Af(r,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(y,r.VALIDATE_STATUS)+"\n\nMaterial Name: "+e.name+"\nMaterial Type: "+e.type+"\n\nProgram Info Log: "+n+"\n"+t+"\n"+i)}else""!==n?console.warn("THREE.WebGLProgram: Program Info Log:",n):""!==i&&""!==s||(a=!1);a&&(e.diagnostics={runnable:o,programLog:n,vertexShader:{log:i,prefix:v},fragmentShader:{log:s,prefix:x}})}r.deleteShader(w),r.deleteShader(E),A=new Mf(r,y),C=function(t,e){const n={},i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),s=i.name;let o=1;i.type===t.FLOAT_MAT2&&(o=2),i.type===t.FLOAT_MAT3&&(o=3),i.type===t.FLOAT_MAT4&&(o=4),n[s]={type:i.type,location:t.getAttribLocation(e,s),locationSize:o}}return n}(r,y)}let A,C;r.attachShader(y,w),r.attachShader(y,E),void 0!==n.index0AttributeName?r.bindAttribLocation(y,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(y,0,"position"),r.linkProgram(y),this.getUniforms=function(){return void 0===A&&T(this),A},this.getAttributes=function(){return void 0===C&&T(this),C};let R=!1===n.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===R&&(R=r.getProgramParameter(y,37297)),R},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(y),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=Ef++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=w,this.fragmentShader=E,this}let Hf=0;class Wf{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(n),s=this._getShaderCacheForMaterial(t);return!1===s.has(i)&&(s.add(i),i.usedTimes++),!1===s.has(r)&&(s.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return void 0===n&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return void 0===n&&(n=new jf(t),e.set(t,n)),n}}class jf{constructor(t){this.id=Hf++,this.code=t,this.usedTimes=0}}function Xf(t,e,n,i,r,s,o){const a=new vr,l=new Wf,c=new Set,h=[],u=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(t){return c.add(t),0===t?"uv":`uv${t}`}return{getParameters:function(s,a,h,v,x){const S=v.fog,b=x.geometry,M=s.isMeshStandardMaterial?v.environment:null,w=(s.isMeshStandardMaterial?n:e).get(s.envMap||M),E=w&&w.mapping===mt?w.image.height:null,T=f[s.type];null!==s.precision&&(p=r.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."));const A=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,C=void 0!==A?A.length:0;let R,P,L,I,N=0;if(void 0!==b.morphAttributes.position&&(N=1),void 0!==b.morphAttributes.normal&&(N=2),void 0!==b.morphAttributes.color&&(N=3),T){const t=zd[T];R=t.vertexShader,P=t.fragmentShader}else R=s.vertexShader,P=s.fragmentShader,l.update(s),L=l.getVertexShaderID(s),I=l.getFragmentShaderID(s);const D=t.getRenderTarget(),O=t.state.buffers.depth.getReversed(),U=!0===x.isInstancedMesh,F=!0===x.isBatchedMesh,B=!!s.map,z=!!s.matcap,V=!!w,k=!!s.aoMap,G=!!s.lightMap,H=!!s.bumpMap,W=!!s.normalMap,j=!!s.displacementMap,X=!!s.emissiveMap,Y=!!s.metalnessMap,q=!!s.roughnessMap,$=s.anisotropy>0,Z=s.clearcoat>0,J=s.dispersion>0,K=s.iridescence>0,Q=s.sheen>0,et=s.transmission>0,nt=$&&!!s.anisotropyMap,it=Z&&!!s.clearcoatMap,rt=Z&&!!s.clearcoatNormalMap,st=Z&&!!s.clearcoatRoughnessMap,ot=K&&!!s.iridescenceMap,at=K&&!!s.iridescenceThicknessMap,lt=Q&&!!s.sheenColorMap,ct=Q&&!!s.sheenRoughnessMap,ht=!!s.specularMap,ut=!!s.specularColorMap,dt=!!s.specularIntensityMap,pt=et&&!!s.transmissionMap,ft=et&&!!s.thicknessMap,gt=!!s.gradientMap,_t=!!s.alphaMap,yt=s.alphaTest>0,vt=!!s.alphaHash,xt=!!s.extensions;let St=tt;s.toneMapped&&(null!==D&&!0!==D.isXRRenderTarget||(St=t.toneMapping));const bt={shaderID:T,shaderType:s.type,shaderName:s.name,vertexShader:R,fragmentShader:P,defines:s.defines,customVertexShaderID:L,customFragmentShaderID:I,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,batching:F,batchingColor:F&&null!==x._colorsTexture,instancing:U,instancingColor:U&&null!==x.instanceColor,instancingMorph:U&&null!==x.morphTexture,supportsVertexTextures:d,outputColorSpace:null===D?t.outputColorSpace:!0===D.isXRRenderTarget?D.texture.colorSpace:Ke,alphaToCoverage:!!s.alphaToCoverage,map:B,matcap:z,envMap:V,envMapMode:V&&w.mapping,envMapCubeUVHeight:E,aoMap:k,lightMap:G,bumpMap:H,normalMap:W,displacementMap:d&&j,emissiveMap:X,normalMapObjectSpace:W&&s.normalMapType===$e,normalMapTangentSpace:W&&s.normalMapType===qe,metalnessMap:Y,roughnessMap:q,anisotropy:$,anisotropyMap:nt,clearcoat:Z,clearcoatMap:it,clearcoatNormalMap:rt,clearcoatRoughnessMap:st,dispersion:J,iridescence:K,iridescenceMap:ot,iridescenceThicknessMap:at,sheen:Q,sheenColorMap:lt,sheenRoughnessMap:ct,specularMap:ht,specularColorMap:ut,specularIntensityMap:dt,transmission:et,transmissionMap:pt,thicknessMap:ft,gradientMap:gt,opaque:!1===s.transparent&&s.blending===y&&!1===s.alphaToCoverage,alphaMap:_t,alphaTest:yt,alphaHash:vt,combine:s.combine,mapUv:B&&_(s.map.channel),aoMapUv:k&&_(s.aoMap.channel),lightMapUv:G&&_(s.lightMap.channel),bumpMapUv:H&&_(s.bumpMap.channel),normalMapUv:W&&_(s.normalMap.channel),displacementMapUv:j&&_(s.displacementMap.channel),emissiveMapUv:X&&_(s.emissiveMap.channel),metalnessMapUv:Y&&_(s.metalnessMap.channel),roughnessMapUv:q&&_(s.roughnessMap.channel),anisotropyMapUv:nt&&_(s.anisotropyMap.channel),clearcoatMapUv:it&&_(s.clearcoatMap.channel),clearcoatNormalMapUv:rt&&_(s.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:st&&_(s.clearcoatRoughnessMap.channel),iridescenceMapUv:ot&&_(s.iridescenceMap.channel),iridescenceThicknessMapUv:at&&_(s.iridescenceThicknessMap.channel),sheenColorMapUv:lt&&_(s.sheenColorMap.channel),sheenRoughnessMapUv:ct&&_(s.sheenRoughnessMap.channel),specularMapUv:ht&&_(s.specularMap.channel),specularColorMapUv:ut&&_(s.specularColorMap.channel),specularIntensityMapUv:dt&&_(s.specularIntensityMap.channel),transmissionMapUv:pt&&_(s.transmissionMap.channel),thicknessMapUv:ft&&_(s.thicknessMap.channel),alphaMapUv:_t&&_(s.alphaMap.channel),vertexTangents:!!b.attributes.tangent&&(W||$),vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,pointsUvs:!0===x.isPoints&&!!b.attributes.uv&&(B||_t),fog:!!S,useFog:!0===s.fog,fogExp2:!!S&&S.isFogExp2,flatShading:!0===s.flatShading&&!1===s.wireframe,sizeAttenuation:!0===s.sizeAttenuation,logarithmicDepthBuffer:u,reverseDepthBuffer:O,skinning:!0===x.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:C,morphTextureStride:N,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numSpotLightMaps:a.spotLightMap.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numSpotLightShadowsWithMaps:a.numSpotLightShadowsWithMaps,numLightProbes:a.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&h.length>0,shadowMapType:t.shadowMap.type,toneMapping:St,decodeVideoTexture:B&&!0===s.map.isVideoTexture&&_i.getTransfer(s.map.colorSpace)===tn,decodeVideoTextureEmissive:X&&!0===s.emissiveMap.isVideoTexture&&_i.getTransfer(s.emissiveMap.colorSpace)===tn,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===g,flipSided:s.side===m,useDepthPacking:s.depthPacking>=0,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionClipCullDistance:xt&&!0===s.extensions.clipCullDistance&&i.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(xt&&!0===s.extensions.multiDraw||F)&&i.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:s.customProgramCacheKey()};return bt.vertexUv1s=c.has(1),bt.vertexUv2s=c.has(2),bt.vertexUv3s=c.has(3),c.clear(),bt},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.numLightProbes),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){a.disableAll(),e.supportsVertexTextures&&a.enable(0),e.instancing&&a.enable(1),e.instancingColor&&a.enable(2),e.instancingMorph&&a.enable(3),e.matcap&&a.enable(4),e.envMap&&a.enable(5),e.normalMapObjectSpace&&a.enable(6),e.normalMapTangentSpace&&a.enable(7),e.clearcoat&&a.enable(8),e.iridescence&&a.enable(9),e.alphaTest&&a.enable(10),e.vertexColors&&a.enable(11),e.vertexAlphas&&a.enable(12),e.vertexUv1s&&a.enable(13),e.vertexUv2s&&a.enable(14),e.vertexUv3s&&a.enable(15),e.vertexTangents&&a.enable(16),e.anisotropy&&a.enable(17),e.alphaHash&&a.enable(18),e.batching&&a.enable(19),e.dispersion&&a.enable(20),e.batchingColor&&a.enable(21),e.gradientMap&&a.enable(22),t.push(a.mask),a.disableAll(),e.fog&&a.enable(0),e.useFog&&a.enable(1),e.flatShading&&a.enable(2),e.logarithmicDepthBuffer&&a.enable(3),e.reverseDepthBuffer&&a.enable(4),e.skinning&&a.enable(5),e.morphTargets&&a.enable(6),e.morphNormals&&a.enable(7),e.morphColors&&a.enable(8),e.premultipliedAlpha&&a.enable(9),e.shadowMapEnabled&&a.enable(10),e.doubleSided&&a.enable(11),e.flipSided&&a.enable(12),e.useDepthPacking&&a.enable(13),e.dithering&&a.enable(14),e.transmission&&a.enable(15),e.sheen&&a.enable(16),e.opaque&&a.enable(17),e.pointsUvs&&a.enable(18),e.decodeVideoTexture&&a.enable(19),e.decodeVideoTextureEmissive&&a.enable(20),e.alphaToCoverage&&a.enable(21),t.push(a.mask)}(n,e),n.push(t.outputColorSpace)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=zd[e];n=qs.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=h.length;t<e;t++){const e=h[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new Gf(t,n,e,s),h.push(i)),i},releaseProgram:function(t){if(0===--t.usedTimes){const e=h.indexOf(t);h[e]=h[h.length-1],h.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:h,dispose:function(){l.dispose()}}}function Yf(){let t=new WeakMap;return{has:function(e){return t.has(e)},get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function qf(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function $f(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Zf(){const t=[];let e=0;const n=[],i=[],r=[];function s(n,i,r,s,o,a){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:i,material:r,groupOrder:s,renderOrder:n.renderOrder,z:o,group:a},t[e]=l):(l.id=n.id,l.object=n,l.geometry=i,l.material=r,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=o,l.group=a),e++,l}return{opaque:n,transmissive:i,transparent:r,init:function(){e=0,n.length=0,i.length=0,r.length=0},push:function(t,e,o,a,l,c){const h=s(t,e,o,a,l,c);o.transmission>0?i.push(h):!0===o.transparent?r.push(h):n.push(h)},unshift:function(t,e,o,a,l,c){const h=s(t,e,o,a,l,c);o.transmission>0?i.unshift(h):!0===o.transparent?r.unshift(h):n.unshift(h)},finish:function(){for(let n=e,i=t.length;n<i;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||qf),i.length>1&&i.sort(e||$f),r.length>1&&r.sort(e||$f)}}}function Jf(){let t=new WeakMap;return{get:function(e,n){const i=t.get(e);let r;return void 0===i?(r=new Zf,t.set(e,[r])):n>=i.length?(r=new Zf,i.push(r)):r=i[n],r},dispose:function(){t=new WeakMap}}}function Kf(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new ni,color:new ts};break;case"SpotLight":n={position:new ni,direction:new ni,color:new ts,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new ni,color:new ts,distance:0,decay:0};break;case"HemisphereLight":n={direction:new ni,skyColor:new ts,groundColor:new ts};break;case"RectAreaLight":n={color:new ts,position:new ni,halfWidth:new ni,halfHeight:new ni}}return t[e.id]=n,n}}}let Qf=0;function tm(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function em(t){const e=new Kf,n=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ti};break;case"PointLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ti,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)i.probe.push(new ni);const r=new ni,s=new lr,o=new lr;return{setup:function(r){let s=0,o=0,a=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let l=0,c=0,h=0,u=0,d=0,p=0,f=0,m=0,g=0,_=0,y=0;r.sort(tm);for(let t=0,v=r.length;t<v;t++){const v=r[t],x=v.color,S=v.intensity,b=v.distance,M=v.shadow&&v.shadow.map?v.shadow.map.texture:null;if(v.isAmbientLight)s+=x.r*S,o+=x.g*S,a+=x.b*S;else if(v.isLightProbe){for(let t=0;t<9;t++)i.probe[t].addScaledVector(v.sh.coefficients[t],S);y++}else if(v.isDirectionalLight){const t=e.get(v);if(t.color.copy(v.color).multiplyScalar(v.intensity),v.castShadow){const t=v.shadow,e=n.get(v);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,i.directionalShadow[l]=e,i.directionalShadowMap[l]=M,i.directionalShadowMatrix[l]=v.shadow.matrix,p++}i.directional[l]=t,l++}else if(v.isSpotLight){const t=e.get(v);t.position.setFromMatrixPosition(v.matrixWorld),t.color.copy(x).multiplyScalar(S),t.distance=b,t.coneCos=Math.cos(v.angle),t.penumbraCos=Math.cos(v.angle*(1-v.penumbra)),t.decay=v.decay,i.spot[h]=t;const r=v.shadow;if(v.map&&(i.spotLightMap[g]=v.map,g++,r.updateMatrices(v),v.castShadow&&_++),i.spotLightMatrix[h]=r.matrix,v.castShadow){const t=n.get(v);t.shadowIntensity=r.intensity,t.shadowBias=r.bias,t.shadowNormalBias=r.normalBias,t.shadowRadius=r.radius,t.shadowMapSize=r.mapSize,i.spotShadow[h]=t,i.spotShadowMap[h]=M,m++}h++}else if(v.isRectAreaLight){const t=e.get(v);t.color.copy(x).multiplyScalar(S),t.halfWidth.set(.5*v.width,0,0),t.halfHeight.set(0,.5*v.height,0),i.rectArea[u]=t,u++}else if(v.isPointLight){const t=e.get(v);if(t.color.copy(v.color).multiplyScalar(v.intensity),t.distance=v.distance,t.decay=v.decay,v.castShadow){const t=v.shadow,e=n.get(v);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,e.shadowCameraNear=t.camera.near,e.shadowCameraFar=t.camera.far,i.pointShadow[c]=e,i.pointShadowMap[c]=M,i.pointShadowMatrix[c]=v.shadow.matrix,f++}i.point[c]=t,c++}else if(v.isHemisphereLight){const t=e.get(v);t.skyColor.copy(v.color).multiplyScalar(S),t.groundColor.copy(v.groundColor).multiplyScalar(S),i.hemi[d]=t,d++}}u>0&&(!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=Bd.LTC_FLOAT_1,i.rectAreaLTC2=Bd.LTC_FLOAT_2):(i.rectAreaLTC1=Bd.LTC_HALF_1,i.rectAreaLTC2=Bd.LTC_HALF_2)),i.ambient[0]=s,i.ambient[1]=o,i.ambient[2]=a;const v=i.hash;v.directionalLength===l&&v.pointLength===c&&v.spotLength===h&&v.rectAreaLength===u&&v.hemiLength===d&&v.numDirectionalShadows===p&&v.numPointShadows===f&&v.numSpotShadows===m&&v.numSpotMaps===g&&v.numLightProbes===y||(i.directional.length=l,i.spot.length=h,i.rectArea.length=u,i.point.length=c,i.hemi.length=d,i.directionalShadow.length=p,i.directionalShadowMap.length=p,i.pointShadow.length=f,i.pointShadowMap.length=f,i.spotShadow.length=m,i.spotShadowMap.length=m,i.directionalShadowMatrix.length=p,i.pointShadowMatrix.length=f,i.spotLightMatrix.length=m+g-_,i.spotLightMap.length=g,i.numSpotLightShadowsWithMaps=_,i.numLightProbes=y,v.directionalLength=l,v.pointLength=c,v.spotLength=h,v.rectAreaLength=u,v.hemiLength=d,v.numDirectionalShadows=p,v.numPointShadows=f,v.numSpotShadows=m,v.numSpotMaps=g,v.numLightProbes=y,i.version=Qf++)},setupView:function(t,e){let n=0,a=0,l=0,c=0,h=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=i.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),r.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=i.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),r.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=i.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),s.copy(d.matrixWorld),s.premultiply(u),o.extractRotation(s),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const t=i.point[a];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),a++}else if(d.isHemisphereLight){const t=i.hemi[h];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),h++}}},state:i}}function nm(t){const e=new em(t),n=[],i=[],r={lightsArray:n,shadowsArray:i,camera:null,lights:e,transmissionRenderTarget:{}};return{init:function(t){r.camera=t,n.length=0,i.length=0},state:r,setupLights:function(){e.setup(n)},setupLightsView:function(t){e.setupView(n,t)},pushLight:function(t){n.push(t)},pushShadow:function(t){i.push(t)}}}function im(t){let e=new WeakMap;return{get:function(n,i=0){const r=e.get(n);let s;return void 0===r?(s=new nm(t),e.set(n,[s])):i>=r.length?(s=new nm(t),r.push(s)):s=r[i],s},dispose:function(){e=new WeakMap}}}function rm(t,e,n){let i=new ua;const r=new ti,s=new ti,o=new Ci,a=new Gc({depthPacking:je}),l=new Hc,c={},h=n.maxTextureSize,d={[f]:m,[m]:f,[g]:g},y=new $s({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ti},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),v=y.clone();v.defines.HORIZONTAL_PASS=1;const x=new Ps;x.setAttribute("position",new ps(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const S=new Gs(x,y),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=u;let M=this.type;function w(n,i){const s=e.update(S);y.defines.VSM_SAMPLES!==n.blurSamples&&(y.defines.VSM_SAMPLES=n.blurSamples,v.defines.VSM_SAMPLES=n.blurSamples,y.needsUpdate=!0,v.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new Pi(r.x,r.y)),y.uniforms.shadow_pass.value=n.map.texture,y.uniforms.resolution.value=n.mapSize,y.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,s,y,S,null),v.uniforms.shadow_pass.value=n.mapPass.texture,v.uniforms.resolution.value=n.mapSize,v.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,s,v,S,null)}function E(e,n,i,r){let s=null;const o=!0===i.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==o)s=o;else if(s=!0===i.isPointLight?l:a,t.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0||!0===n.alphaToCoverage){const t=s.uuid,e=n.uuid;let i=c[t];void 0===i&&(i={},c[t]=i);let r=i[e];void 0===r&&(r=s.clone(),i[e]=r,n.addEventListener("dispose",A)),s=r}return s.visible=n.visible,s.wireframe=n.wireframe,s.side=r===p?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:d[n.side],s.alphaMap=n.alphaMap,s.alphaTest=!0===n.alphaToCoverage?.5:n.alphaTest,s.map=n.map,s.clipShadows=n.clipShadows,s.clippingPlanes=n.clippingPlanes,s.clipIntersection=n.clipIntersection,s.displacementMap=n.displacementMap,s.displacementScale=n.displacementScale,s.displacementBias=n.displacementBias,s.wireframeLinewidth=n.wireframeLinewidth,s.linewidth=n.linewidth,!0===i.isPointLight&&!0===s.isMeshDistanceMaterial&&(t.properties.get(s).light=i),s}function T(n,r,s,o,a){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&a===p)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),l=n.material;if(Array.isArray(l)){const e=i.groups;for(let c=0,h=e.length;c<h;c++){const h=e[c],u=l[h.materialIndex];if(u&&u.visible){const e=E(n,u,o,a);n.onBeforeShadow(t,n,r,s,i,e,h),t.renderBufferDirect(s,null,i,e,n,h),n.onAfterShadow(t,n,r,s,i,e,h)}}}else if(l.visible){const e=E(n,l,o,a);n.onBeforeShadow(t,n,r,s,i,e,null),t.renderBufferDirect(s,null,i,e,n,null),n.onAfterShadow(t,n,r,s,i,e,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)T(l[t],r,s,o,a)}function A(t){t.target.removeEventListener("dispose",A);for(const e in c){const n=c[e],i=t.target.uuid;i in n&&(n[i].dispose(),delete n[i])}}this.render=function(e,n,a){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(_),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);const f=M!==p&&this.type===p,m=M===p&&this.type!==p;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const g=u.getFrameExtents();if(r.multiply(g),s.copy(u.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/g.x),r.x=s.x*g.x,u.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/g.y),r.y=s.y*g.y,u.mapSize.y=s.y)),null===u.map||!0===f||!0===m){const t=this.type!==p?{minFilter:vt,magFilter:vt}:{};null!==u.map&&u.map.dispose(),u.map=new Pi(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const _=u.getViewportCount();for(let t=0;t<_;t++){const e=u.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),u.updateMatrices(c,t),i=u.getFrustum(),T(n,a,u.camera,c,this.type)}!0!==u.isPointLightShadow&&this.type===p&&w(u,a),u.needsUpdate=!1}M=this.type,b.needsUpdate=!1,t.setRenderTarget(l,c,u)}}const sm={[H]:W,[j]:$,[Y]:Z,[X]:q,[W]:H,[$]:j,[Z]:Y,[q]:X};function om(t,e){const n=new function(){let e=!1;const n=new Ci;let i=null;const r=new Ci(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,o,a){!0===a&&(e*=o,i*=o,s*=o),n.set(e,i,s,o),!1===r.equals(n)&&(t.clearColor(e,i,s,o),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},i=new function(){let n=!1,i=!1,r=null,s=null,o=null;return{setReversed:function(t){if(i!==t){const n=e.get("EXT_clip_control");t?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),i=t;const r=o;o=null,this.setClear(r)}},getReversed:function(){return i},setTest:function(e){e?Et(t.DEPTH_TEST):Tt(t.DEPTH_TEST)},setMask:function(e){r===e||n||(t.depthMask(e),r=e)},setFunc:function(e){if(i&&(e=sm[e]),s!==e){switch(e){case H:t.depthFunc(t.NEVER);break;case W:t.depthFunc(t.ALWAYS);break;case j:t.depthFunc(t.LESS);break;case X:t.depthFunc(t.LEQUAL);break;case Y:t.depthFunc(t.EQUAL);break;case q:t.depthFunc(t.GEQUAL);break;case $:t.depthFunc(t.GREATER);break;case Z:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}s=e}},setLocked:function(t){n=t},setClear:function(e){o!==e&&(i&&(e=1-e),t.clearDepth(e),o=e)},reset:function(){n=!1,r=null,s=null,o=null,i=!1}}},r=new function(){let e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(n){e||(n?Et(t.STENCIL_TEST):Tt(t.STENCIL_TEST))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,o){i===e&&r===n&&s===o||(t.stencilFunc(e,n,o),i=e,r=n,s=o)},setOp:function(e,n,i){o===e&&a===n&&l===i||(t.stencilOp(e,n,i),o=e,a=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null}}},s=new WeakMap,c=new WeakMap;let h={},u={},d=new WeakMap,p=[],f=null,J=!1,K=null,Q=null,tt=null,et=null,nt=null,it=null,rt=null,st=new ts(0,0,0),ot=0,at=!1,lt=null,ct=null,ht=null,ut=null,dt=null;const pt=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let ft=!1,mt=0;const gt=t.getParameter(t.VERSION);-1!==gt.indexOf("WebGL")?(mt=parseFloat(/^WebGL (\d)/.exec(gt)[1]),ft=mt>=1):-1!==gt.indexOf("OpenGL ES")&&(mt=parseFloat(/^OpenGL ES (\d)/.exec(gt)[1]),ft=mt>=2);let _t=null,yt={};const vt=t.getParameter(t.SCISSOR_BOX),xt=t.getParameter(t.VIEWPORT),St=(new Ci).fromArray(vt),bt=(new Ci).fromArray(xt);function Mt(e,n,i,r){const s=new Uint8Array(4),o=t.createTexture();t.bindTexture(e,o),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let o=0;o<i;o++)e===t.TEXTURE_3D||e===t.TEXTURE_2D_ARRAY?t.texImage3D(n,0,t.RGBA,1,1,r,0,t.RGBA,t.UNSIGNED_BYTE,s):t.texImage2D(n+o,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,s);return o}const wt={};function Et(e){!0!==h[e]&&(t.enable(e),h[e]=!0)}function Tt(e){!1!==h[e]&&(t.disable(e),h[e]=!1)}wt[t.TEXTURE_2D]=Mt(t.TEXTURE_2D,t.TEXTURE_2D,1),wt[t.TEXTURE_CUBE_MAP]=Mt(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),wt[t.TEXTURE_2D_ARRAY]=Mt(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),wt[t.TEXTURE_3D]=Mt(t.TEXTURE_3D,t.TEXTURE_3D,1,1),n.setClear(0,0,0,1),i.setClear(1),r.setClear(0),Et(t.DEPTH_TEST),i.setFunc(X),Pt(!1),Lt(a),Et(t.CULL_FACE),Rt(_);const At={[M]:t.FUNC_ADD,[w]:t.FUNC_SUBTRACT,[E]:t.FUNC_REVERSE_SUBTRACT};At[T]=t.MIN,At[A]=t.MAX;const Ct={[C]:t.ZERO,[R]:t.ONE,[P]:t.SRC_COLOR,[I]:t.SRC_ALPHA,[B]:t.SRC_ALPHA_SATURATE,[U]:t.DST_COLOR,[D]:t.DST_ALPHA,[L]:t.ONE_MINUS_SRC_COLOR,[N]:t.ONE_MINUS_SRC_ALPHA,[F]:t.ONE_MINUS_DST_COLOR,[O]:t.ONE_MINUS_DST_ALPHA,[z]:t.CONSTANT_COLOR,[V]:t.ONE_MINUS_CONSTANT_COLOR,[k]:t.CONSTANT_ALPHA,[G]:t.ONE_MINUS_CONSTANT_ALPHA};function Rt(e,n,i,r,s,o,a,l,c,h){if(e!==_){if(!1===J&&(Et(t.BLEND),J=!0),e===b)s=s||n,o=o||i,a=a||r,n===Q&&s===nt||(t.blendEquationSeparate(At[n],At[s]),Q=n,nt=s),i===tt&&r===et&&o===it&&a===rt||(t.blendFuncSeparate(Ct[i],Ct[r],Ct[o],Ct[a]),tt=i,et=r,it=o,rt=a),!1!==l.equals(st)&&c===ot||(t.blendColor(l.r,l.g,l.b,c),st.copy(l),ot=c),K=e,at=!1;else if(e!==K||h!==at){if(Q===M&&nt===M||(t.blendEquation(t.FUNC_ADD),Q=M,nt=M),h)switch(e){case y:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case v:t.blendFunc(t.ONE,t.ONE);break;case x:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case S:t.blendFuncSeparate(t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case y:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case v:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE,t.ONE,t.ONE);break;case x:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case S:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}tt=null,et=null,it=null,rt=null,st.set(0,0,0),ot=0,K=e,at=h}}else!0===J&&(Tt(t.BLEND),J=!1)}function Pt(e){lt!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),lt=e)}function Lt(e){e!==o?(Et(t.CULL_FACE),e!==ct&&(e===a?t.cullFace(t.BACK):e===l?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):Tt(t.CULL_FACE),ct=e}function It(e,n,i){e?(Et(t.POLYGON_OFFSET_FILL),ut===n&&dt===i||(t.polygonOffset(n,i),ut=n,dt=i)):Tt(t.POLYGON_OFFSET_FILL)}return{buffers:{color:n,depth:i,stencil:r},enable:Et,disable:Tt,bindFramebuffer:function(e,n){return u[e]!==n&&(t.bindFramebuffer(e,n),u[e]=n,e===t.DRAW_FRAMEBUFFER&&(u[t.FRAMEBUFFER]=n),e===t.FRAMEBUFFER&&(u[t.DRAW_FRAMEBUFFER]=n),!0)},drawBuffers:function(e,n){let i=p,r=!1;if(e){i=d.get(n),void 0===i&&(i=[],d.set(n,i));const s=e.textures;if(i.length!==s.length||i[0]!==t.COLOR_ATTACHMENT0){for(let e=0,n=s.length;e<n;e++)i[e]=t.COLOR_ATTACHMENT0+e;i.length=s.length,r=!0}}else i[0]!==t.BACK&&(i[0]=t.BACK,r=!0);r&&t.drawBuffers(i)},useProgram:function(e){return f!==e&&(t.useProgram(e),f=e,!0)},setBlending:Rt,setMaterial:function(e,s){e.side===g?Tt(t.CULL_FACE):Et(t.CULL_FACE);let o=e.side===m;s&&(o=!o),Pt(o),e.blending===y&&!1===e.transparent?Rt(_):Rt(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.blendColor,e.blendAlpha,e.premultipliedAlpha),i.setFunc(e.depthFunc),i.setTest(e.depthTest),i.setMask(e.depthWrite),n.setMask(e.colorWrite);const a=e.stencilWrite;r.setTest(a),a&&(r.setMask(e.stencilWriteMask),r.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),r.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),It(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?Et(t.SAMPLE_ALPHA_TO_COVERAGE):Tt(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:Pt,setCullFace:Lt,setLineWidth:function(e){e!==ht&&(ft&&t.lineWidth(e),ht=e)},setPolygonOffset:It,setScissorTest:function(e){e?Et(t.SCISSOR_TEST):Tt(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+pt-1),_t!==e&&(t.activeTexture(e),_t=e)},bindTexture:function(e,n,i){void 0===i&&(i=null===_t?t.TEXTURE0+pt-1:_t);let r=yt[i];void 0===r&&(r={type:void 0,texture:void 0},yt[i]=r),r.type===e&&r.texture===n||(_t!==i&&(t.activeTexture(i),_t=i),t.bindTexture(e,n||wt[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=yt[_t];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(e,n){let i=c.get(n);void 0===i&&(i=new WeakMap,c.set(n,i));let r=i.get(e);void 0===r&&(r=t.getUniformBlockIndex(n,e.name),i.set(e,r))},uniformBlockBinding:function(e,n){const i=c.get(n).get(e);s.get(n)!==i&&(t.uniformBlockBinding(n,i,e.__bindingPointIndex),s.set(n,i))},texStorage2D:function(){try{t.texStorage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D(...arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===St.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),St.copy(e))},viewport:function(e){!1===bt.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),bt.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),i.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),h={},_t=null,yt={},u={},d=new WeakMap,p=[],f=null,J=!1,K=null,Q=null,tt=null,et=null,nt=null,it=null,rt=null,st=new ts(0,0,0),ot=0,at=!1,lt=null,ct=null,ht=null,ut=null,dt=null,St.set(0,0,t.canvas.width,t.canvas.height),bt.set(0,0,t.canvas.width,t.canvas.height),n.reset(),i.reset(),r.reset()}}}function am(t,e,n,i,r,s,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),c=new ti,h=new WeakMap;let u;const d=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function f(t,e){return p?new OffscreenCanvas(t,e):hi("canvas")}function m(t,e,n){let i=1;const r=H(t);if((r.width>n||r.height>n)&&(i=n/Math.max(r.width,r.height)),i<1){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&t instanceof VideoFrame){const n=Math.floor(i*r.width),s=Math.floor(i*r.height);void 0===u&&(u=f(n,s));const o=e?f(n,s):u;return o.width=n,o.height=s,o.getContext("2d").drawImage(t,0,0,n,s),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+r.width+"x"+r.height+") to ("+n+"x"+s+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+r.width+"x"+r.height+")."),t}return t}function g(t){return t.generateMipmaps}function _(e){t.generateMipmap(e)}function y(e){return e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:e.isWebGL3DRenderTarget?t.TEXTURE_3D:e.isWebGLArrayRenderTarget||e.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function v(n,i,r,s,o=!1){if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let a=i;if(i===t.RED&&(r===t.FLOAT&&(a=t.R32F),r===t.HALF_FLOAT&&(a=t.R16F),r===t.UNSIGNED_BYTE&&(a=t.R8)),i===t.RED_INTEGER&&(r===t.UNSIGNED_BYTE&&(a=t.R8UI),r===t.UNSIGNED_SHORT&&(a=t.R16UI),r===t.UNSIGNED_INT&&(a=t.R32UI),r===t.BYTE&&(a=t.R8I),r===t.SHORT&&(a=t.R16I),r===t.INT&&(a=t.R32I)),i===t.RG&&(r===t.FLOAT&&(a=t.RG32F),r===t.HALF_FLOAT&&(a=t.RG16F),r===t.UNSIGNED_BYTE&&(a=t.RG8)),i===t.RG_INTEGER&&(r===t.UNSIGNED_BYTE&&(a=t.RG8UI),r===t.UNSIGNED_SHORT&&(a=t.RG16UI),r===t.UNSIGNED_INT&&(a=t.RG32UI),r===t.BYTE&&(a=t.RG8I),r===t.SHORT&&(a=t.RG16I),r===t.INT&&(a=t.RG32I)),i===t.RGB_INTEGER&&(r===t.UNSIGNED_BYTE&&(a=t.RGB8UI),r===t.UNSIGNED_SHORT&&(a=t.RGB16UI),r===t.UNSIGNED_INT&&(a=t.RGB32UI),r===t.BYTE&&(a=t.RGB8I),r===t.SHORT&&(a=t.RGB16I),r===t.INT&&(a=t.RGB32I)),i===t.RGBA_INTEGER&&(r===t.UNSIGNED_BYTE&&(a=t.RGBA8UI),r===t.UNSIGNED_SHORT&&(a=t.RGBA16UI),r===t.UNSIGNED_INT&&(a=t.RGBA32UI),r===t.BYTE&&(a=t.RGBA8I),r===t.SHORT&&(a=t.RGBA16I),r===t.INT&&(a=t.RGBA32I)),i===t.RGB&&r===t.UNSIGNED_INT_5_9_9_9_REV&&(a=t.RGB9_E5),i===t.RGBA){const e=o?Qe:_i.getTransfer(s);r===t.FLOAT&&(a=t.RGBA32F),r===t.HALF_FLOAT&&(a=t.RGBA16F),r===t.UNSIGNED_BYTE&&(a=e===tn?t.SRGB8_ALPHA8:t.RGBA8),r===t.UNSIGNED_SHORT_4_4_4_4&&(a=t.RGBA4),r===t.UNSIGNED_SHORT_5_5_5_1&&(a=t.RGB5_A1)}return a!==t.R16F&&a!==t.R32F&&a!==t.RG16F&&a!==t.RG32F&&a!==t.RGBA16F&&a!==t.RGBA32F||e.get("EXT_color_buffer_float"),a}function x(e,n){let i;return e?null===n||n===Dt||n===zt?i=t.DEPTH24_STENCIL8:n===Ot?i=t.DEPTH32F_STENCIL8:n===It&&(i=t.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===n||n===Dt||n===zt?i=t.DEPTH_COMPONENT24:n===Ot?i=t.DEPTH_COMPONENT32F:n===It&&(i=t.DEPTH_COMPONENT16),i}function S(t,e){return!0===g(t)||t.isFramebufferTexture&&t.minFilter!==vt&&t.minFilter!==wt?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function b(t){const e=t.target;e.removeEventListener("dispose",b),function(t){const e=i.get(t);if(void 0===e.__webglInit)return;const n=t.source,r=d.get(n);if(r){const i=r[e.__cacheKey];i.usedTimes--,0===i.usedTimes&&w(t),0===Object.keys(r).length&&d.delete(n)}i.remove(t)}(e),e.isVideoTexture&&h.delete(e)}function M(e){const n=e.target;n.removeEventListener("dispose",M),function(e){const n=i.get(e);if(e.depthTexture&&(e.depthTexture.dispose(),i.remove(e.depthTexture)),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++){if(Array.isArray(n.__webglFramebuffer[e]))for(let i=0;i<n.__webglFramebuffer[e].length;i++)t.deleteFramebuffer(n.__webglFramebuffer[e][i]);else t.deleteFramebuffer(n.__webglFramebuffer[e]);n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e])}else{if(Array.isArray(n.__webglFramebuffer))for(let e=0;e<n.__webglFramebuffer.length;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer);if(n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let e=0;e<n.__webglColorRenderbuffer.length;e++)n.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer)}const r=e.textures;for(let e=0,n=r.length;e<n;e++){const n=i.get(r[e]);n.__webglTexture&&(t.deleteTexture(n.__webglTexture),o.memory.textures--),i.remove(r[e])}i.remove(e)}(n)}function w(e){const n=i.get(e);t.deleteTexture(n.__webglTexture);const r=e.source;delete d.get(r)[n.__cacheKey],o.memory.textures--}let E=0;function T(e,r){const s=i.get(e);if(e.isVideoTexture&&function(t){const e=o.render.frame;h.get(t)!==e&&(h.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&s.__version!==e.version){const t=e.image;if(null===t)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void N(s,e,r);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.bindTexture(t.TEXTURE_2D,s.__webglTexture,t.TEXTURE0+r)}const A={[gt]:t.REPEAT,[_t]:t.CLAMP_TO_EDGE,[yt]:t.MIRRORED_REPEAT},C={[vt]:t.NEAREST,[xt]:t.NEAREST_MIPMAP_NEAREST,[bt]:t.NEAREST_MIPMAP_LINEAR,[wt]:t.LINEAR,[Et]:t.LINEAR_MIPMAP_NEAREST,[At]:t.LINEAR_MIPMAP_LINEAR},R={[yn]:t.NEVER,[En]:t.ALWAYS,[vn]:t.LESS,[Sn]:t.LEQUAL,[xn]:t.EQUAL,[wn]:t.GEQUAL,[bn]:t.GREATER,[Mn]:t.NOTEQUAL};function P(n,s){if(s.type!==Ot||!1!==e.has("OES_texture_float_linear")||s.magFilter!==wt&&s.magFilter!==Et&&s.magFilter!==bt&&s.magFilter!==At&&s.minFilter!==wt&&s.minFilter!==Et&&s.minFilter!==bt&&s.minFilter!==At||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(n,t.TEXTURE_WRAP_S,A[s.wrapS]),t.texParameteri(n,t.TEXTURE_WRAP_T,A[s.wrapT]),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,A[s.wrapR]),t.texParameteri(n,t.TEXTURE_MAG_FILTER,C[s.magFilter]),t.texParameteri(n,t.TEXTURE_MIN_FILTER,C[s.minFilter]),s.compareFunction&&(t.texParameteri(n,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(n,t.TEXTURE_COMPARE_FUNC,R[s.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){if(s.magFilter===vt)return;if(s.minFilter!==bt&&s.minFilter!==At)return;if(s.type===Ot&&!1===e.has("OES_texture_float_linear"))return;if(s.anisotropy>1||i.get(s).__currentAnisotropy){const o=e.get("EXT_texture_filter_anisotropic");t.texParameterf(n,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy}}}function L(e,n){let i=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",b));const r=n.source;let s=d.get(r);void 0===s&&(s={},d.set(r,s));const a=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(n);if(a!==e.__cacheKey){void 0===s[a]&&(s[a]={texture:t.createTexture(),usedTimes:0},o.memory.textures++,i=!0),s[a].usedTimes++;const r=s[e.__cacheKey];void 0!==r&&(s[e.__cacheKey].usedTimes--,0===r.usedTimes&&w(n)),e.__cacheKey=a,e.__webglTexture=s[a].texture}return i}function I(t,e,n){return Math.floor(Math.floor(t/n)/e)}function N(e,o,a){let l=t.TEXTURE_2D;(o.isDataArrayTexture||o.isCompressedArrayTexture)&&(l=t.TEXTURE_2D_ARRAY),o.isData3DTexture&&(l=t.TEXTURE_3D);const c=L(e,o),h=o.source;n.bindTexture(l,e.__webglTexture,t.TEXTURE0+a);const u=i.get(h);if(h.version!==u.__version||!0===c){n.activeTexture(t.TEXTURE0+a);const e=_i.getPrimaries(_i.workingColorSpace),i=o.colorSpace===Ze?null:_i.getPrimaries(o.colorSpace),d=o.colorSpace===Ze||e===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,o.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,o.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,o.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);let p=m(o.image,!1,r.maxTextureSize);p=G(o,p);const f=s.convert(o.format,o.colorSpace),y=s.convert(o.type);let b,M=v(o.internalFormat,f,y,o.colorSpace,o.isVideoTexture);P(l,o);const w=o.mipmaps,E=!0!==o.isVideoTexture,T=void 0===u.__version||!0===c,A=h.dataReady,C=S(o,p);if(o.isDepthTexture)M=x(o.format===jt,o.type),T&&(E?n.texStorage2D(t.TEXTURE_2D,1,M,p.width,p.height):n.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,f,y,null));else if(o.isDataTexture)if(w.length>0){E&&T&&n.texStorage2D(t.TEXTURE_2D,C,M,w[0].width,w[0].height);for(let e=0,i=w.length;e<i;e++)b=w[e],E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,b.width,b.height,f,y,b.data):n.texImage2D(t.TEXTURE_2D,e,M,b.width,b.height,0,f,y,b.data);o.generateMipmaps=!1}else E?(T&&n.texStorage2D(t.TEXTURE_2D,C,M,p.width,p.height),A&&function(e,i,r,s){const o=e.updateRanges;if(0===o.length)n.texSubImage2D(t.TEXTURE_2D,0,0,0,i.width,i.height,r,s,i.data);else{o.sort((t,e)=>t.start-e.start);let a=0;for(let t=1;t<o.length;t++){const e=o[a],n=o[t],r=e.start+e.count,s=I(n.start,i.width,4),l=I(e.start,i.width,4);n.start<=r+1&&s===l&&I(n.start+n.count-1,i.width,4)===s?e.count=Math.max(e.count,n.start+n.count-e.start):(++a,o[a]=n)}o.length=a+1;const l=t.getParameter(t.UNPACK_ROW_LENGTH),c=t.getParameter(t.UNPACK_SKIP_PIXELS),h=t.getParameter(t.UNPACK_SKIP_ROWS);t.pixelStorei(t.UNPACK_ROW_LENGTH,i.width);for(let e=0,a=o.length;e<a;e++){const a=o[e],l=Math.floor(a.start/4),c=Math.ceil(a.count/4),h=l%i.width,u=Math.floor(l/i.width),d=c,p=1;t.pixelStorei(t.UNPACK_SKIP_PIXELS,h),t.pixelStorei(t.UNPACK_SKIP_ROWS,u),n.texSubImage2D(t.TEXTURE_2D,0,h,u,d,p,r,s,i.data)}e.clearUpdateRanges(),t.pixelStorei(t.UNPACK_ROW_LENGTH,l),t.pixelStorei(t.UNPACK_SKIP_PIXELS,c),t.pixelStorei(t.UNPACK_SKIP_ROWS,h)}}(o,p,f,y)):n.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,f,y,p.data);else if(o.isCompressedTexture)if(o.isCompressedArrayTexture){E&&T&&n.texStorage3D(t.TEXTURE_2D_ARRAY,C,M,w[0].width,w[0].height,p.depth);for(let e=0,i=w.length;e<i;e++)if(b=w[e],o.format!==Ht)if(null!==f)if(E){if(A)if(o.layerUpdates.size>0){const i=Nd(b.width,b.height,o.format,o.type);for(const r of o.layerUpdates){const s=b.data.subarray(r*i/b.data.BYTES_PER_ELEMENT,(r+1)*i/b.data.BYTES_PER_ELEMENT);n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,r,b.width,b.height,1,f,s)}o.clearLayerUpdates()}else n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,b.width,b.height,p.depth,f,b.data)}else n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,M,b.width,b.height,p.depth,0,b.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else E?A&&n.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,b.width,b.height,p.depth,f,y,b.data):n.texImage3D(t.TEXTURE_2D_ARRAY,e,M,b.width,b.height,p.depth,0,f,y,b.data)}else{E&&T&&n.texStorage2D(t.TEXTURE_2D,C,M,w[0].width,w[0].height);for(let e=0,i=w.length;e<i;e++)b=w[e],o.format!==Ht?null!==f?E?A&&n.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,b.width,b.height,f,b.data):n.compressedTexImage2D(t.TEXTURE_2D,e,M,b.width,b.height,0,b.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,b.width,b.height,f,y,b.data):n.texImage2D(t.TEXTURE_2D,e,M,b.width,b.height,0,f,y,b.data)}else if(o.isDataArrayTexture)if(E){if(T&&n.texStorage3D(t.TEXTURE_2D_ARRAY,C,M,p.width,p.height,p.depth),A)if(o.layerUpdates.size>0){const e=Nd(p.width,p.height,o.format,o.type);for(const i of o.layerUpdates){const r=p.data.subarray(i*e/p.data.BYTES_PER_ELEMENT,(i+1)*e/p.data.BYTES_PER_ELEMENT);n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,i,p.width,p.height,1,f,y,r)}o.clearLayerUpdates()}else n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,p.width,p.height,p.depth,f,y,p.data)}else n.texImage3D(t.TEXTURE_2D_ARRAY,0,M,p.width,p.height,p.depth,0,f,y,p.data);else if(o.isData3DTexture)E?(T&&n.texStorage3D(t.TEXTURE_3D,C,M,p.width,p.height,p.depth),A&&n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,p.width,p.height,p.depth,f,y,p.data)):n.texImage3D(t.TEXTURE_3D,0,M,p.width,p.height,p.depth,0,f,y,p.data);else if(o.isFramebufferTexture){if(T)if(E)n.texStorage2D(t.TEXTURE_2D,C,M,p.width,p.height);else{let e=p.width,i=p.height;for(let r=0;r<C;r++)n.texImage2D(t.TEXTURE_2D,r,M,e,i,0,f,y,null),e>>=1,i>>=1}}else if(w.length>0){if(E&&T){const e=H(w[0]);n.texStorage2D(t.TEXTURE_2D,C,M,e.width,e.height)}for(let e=0,i=w.length;e<i;e++)b=w[e],E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,f,y,b):n.texImage2D(t.TEXTURE_2D,e,M,f,y,b);o.generateMipmaps=!1}else if(E){if(T){const e=H(p);n.texStorage2D(t.TEXTURE_2D,C,M,e.width,e.height)}A&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,f,y,p)}else n.texImage2D(t.TEXTURE_2D,0,M,f,y,p);g(o)&&_(l),u.__version=h.version,o.onUpdate&&o.onUpdate(o)}e.__version=o.version}function D(e,r,o,l,c,h){const u=s.convert(o.format,o.colorSpace),d=s.convert(o.type),p=v(o.internalFormat,u,d,o.colorSpace),f=i.get(r),m=i.get(o);if(m.__renderTarget=r,!f.__hasExternalTextures){const e=Math.max(1,r.width>>h),i=Math.max(1,r.height>>h);c===t.TEXTURE_3D||c===t.TEXTURE_2D_ARRAY?n.texImage3D(c,h,p,e,i,r.depth,0,u,d,null):n.texImage2D(c,h,p,e,i,0,u,d,null)}n.bindFramebuffer(t.FRAMEBUFFER,e),k(r)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,l,c,m.__webglTexture,0,V(r)):(c===t.TEXTURE_2D||c>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,l,c,m.__webglTexture,h),n.bindFramebuffer(t.FRAMEBUFFER,null)}function O(e,n,i){if(t.bindRenderbuffer(t.RENDERBUFFER,e),n.depthBuffer){const r=n.depthTexture,s=r&&r.isDepthTexture?r.type:null,o=x(n.stencilBuffer,s),l=n.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,c=V(n);k(n)?a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,c,o,n.width,n.height):i?t.renderbufferStorageMultisample(t.RENDERBUFFER,c,o,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,o,n.width,n.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,l,t.RENDERBUFFER,e)}else{const e=n.textures;for(let r=0;r<e.length;r++){const o=e[r],l=s.convert(o.format,o.colorSpace),c=s.convert(o.type),h=v(o.internalFormat,l,c,o.colorSpace),u=V(n);i&&!1===k(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,u,h,n.width,n.height):k(n)?a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,u,h,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,h,n.width,n.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function U(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const s=i.get(r.depthTexture);s.__renderTarget=r,s.__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),T(r.depthTexture,0);const o=s.__webglTexture,l=V(r);if(r.depthTexture.format===Wt)k(r)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,o,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,o,0);else{if(r.depthTexture.format!==jt)throw new Error("Unknown depthTexture format");k(r)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,o,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,o,0)}}function F(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(r.__boundDepthTexture!==e.depthTexture){const t=e.depthTexture;if(r.__depthDisposeCallback&&r.__depthDisposeCallback(),t){const e=()=>{delete r.__boundDepthTexture,delete r.__depthDisposeCallback,t.removeEventListener("dispose",e)};t.addEventListener("dispose",e),r.__depthDisposeCallback=e}r.__boundDepthTexture=t}if(e.depthTexture&&!r.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");const t=e.texture.mipmaps;t&&t.length>0?U(r.__webglFramebuffer[0],e):U(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)if(n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer[i]),void 0===r.__webglDepthbuffer[i])r.__webglDepthbuffer[i]=t.createRenderbuffer(),O(r.__webglDepthbuffer[i],e,!1);else{const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,s=r.__webglDepthbuffer[i];t.bindRenderbuffer(t.RENDERBUFFER,s),t.framebufferRenderbuffer(t.FRAMEBUFFER,n,t.RENDERBUFFER,s)}}else{const i=e.texture.mipmaps;if(i&&i.length>0?n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer[0]):n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer),void 0===r.__webglDepthbuffer)r.__webglDepthbuffer=t.createRenderbuffer(),O(r.__webglDepthbuffer,e,!1);else{const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,i=r.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,i),t.framebufferRenderbuffer(t.FRAMEBUFFER,n,t.RENDERBUFFER,i)}}n.bindFramebuffer(t.FRAMEBUFFER,null)}const B=[],z=[];function V(t){return Math.min(r.maxSamples,t.samples)}function k(t){const n=i.get(t);return t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function G(t,e){const n=t.colorSpace,i=t.format,r=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||n!==Ke&&n!==Ze&&(_i.getTransfer(n)===tn?i===Ht&&r===Rt||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",n)),e}function H(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?(c.width=t.naturalWidth||t.width,c.height=t.naturalHeight||t.height):"undefined"!=typeof VideoFrame&&t instanceof VideoFrame?(c.width=t.displayWidth,c.height=t.displayHeight):(c.width=t.width,c.height=t.height),c}this.allocateTextureUnit=function(){const t=E;return t>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+r.maxTextures),E+=1,t},this.resetTextureUnits=function(){E=0},this.setTexture2D=T,this.setTexture2DArray=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?N(s,e,r):n.bindTexture(t.TEXTURE_2D_ARRAY,s.__webglTexture,t.TEXTURE0+r)},this.setTexture3D=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?N(s,e,r):n.bindTexture(t.TEXTURE_3D,s.__webglTexture,t.TEXTURE0+r)},this.setTextureCube=function(e,o){const a=i.get(e);e.version>0&&a.__version!==e.version?function(e,o,a){if(6!==o.image.length)return;const l=L(e,o),c=o.source;n.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+a);const h=i.get(c);if(c.version!==h.__version||!0===l){n.activeTexture(t.TEXTURE0+a);const e=_i.getPrimaries(_i.workingColorSpace),i=o.colorSpace===Ze?null:_i.getPrimaries(o.colorSpace),u=o.colorSpace===Ze||e===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,o.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,o.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,o.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,u);const d=o.isCompressedTexture||o.image[0].isCompressedTexture,p=o.image[0]&&o.image[0].isDataTexture,f=[];for(let t=0;t<6;t++)f[t]=d||p?p?o.image[t].image:o.image[t]:m(o.image[t],!0,r.maxCubemapSize),f[t]=G(o,f[t]);const y=f[0],x=s.convert(o.format,o.colorSpace),b=s.convert(o.type),M=v(o.internalFormat,x,b,o.colorSpace),w=!0!==o.isVideoTexture,E=void 0===h.__version||!0===l,T=c.dataReady;let A,C=S(o,y);if(P(t.TEXTURE_CUBE_MAP,o),d){w&&E&&n.texStorage2D(t.TEXTURE_CUBE_MAP,C,M,y.width,y.height);for(let e=0;e<6;e++){A=f[e].mipmaps;for(let i=0;i<A.length;i++){const r=A[i];o.format!==Ht?null!==x?w?T&&n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,r.width,r.height,x,r.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,M,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):w?T&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,r.width,r.height,x,b,r.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,M,r.width,r.height,0,x,b,r.data)}}}else{if(A=o.mipmaps,w&&E){A.length>0&&C++;const e=H(f[0]);n.texStorage2D(t.TEXTURE_CUBE_MAP,C,M,e.width,e.height)}for(let e=0;e<6;e++)if(p){w?T&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,f[e].width,f[e].height,x,b,f[e].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,f[e].width,f[e].height,0,x,b,f[e].data);for(let i=0;i<A.length;i++){const r=A[i].image[e].image;w?T&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,r.width,r.height,x,b,r.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,M,r.width,r.height,0,x,b,r.data)}}else{w?T&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,x,b,f[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,x,b,f[e]);for(let i=0;i<A.length;i++){const r=A[i];w?T&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,x,b,r.image[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,M,x,b,r.image[e])}}}g(o)&&_(t.TEXTURE_CUBE_MAP),h.__version=c.version,o.onUpdate&&o.onUpdate(o)}e.__version=o.version}(a,e,o):n.bindTexture(t.TEXTURE_CUBE_MAP,a.__webglTexture,t.TEXTURE0+o)},this.rebindTextures=function(e,n,r){const s=i.get(e);void 0!==n&&D(s.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==r&&F(e)},this.setupRenderTarget=function(e){const r=e.texture,a=i.get(e),l=i.get(r);e.addEventListener("dispose",M);const c=e.textures,h=!0===e.isWebGLCubeRenderTarget,u=c.length>1;if(u||(void 0===l.__webglTexture&&(l.__webglTexture=t.createTexture()),l.__version=r.version,o.memory.textures++),h){a.__webglFramebuffer=[];for(let e=0;e<6;e++)if(r.mipmaps&&r.mipmaps.length>0){a.__webglFramebuffer[e]=[];for(let n=0;n<r.mipmaps.length;n++)a.__webglFramebuffer[e][n]=t.createFramebuffer()}else a.__webglFramebuffer[e]=t.createFramebuffer()}else{if(r.mipmaps&&r.mipmaps.length>0){a.__webglFramebuffer=[];for(let e=0;e<r.mipmaps.length;e++)a.__webglFramebuffer[e]=t.createFramebuffer()}else a.__webglFramebuffer=t.createFramebuffer();if(u)for(let e=0,n=c.length;e<n;e++){const n=i.get(c[e]);void 0===n.__webglTexture&&(n.__webglTexture=t.createTexture(),o.memory.textures++)}if(e.samples>0&&!1===k(e)){a.__webglMultisampledFramebuffer=t.createFramebuffer(),a.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,a.__webglMultisampledFramebuffer);for(let n=0;n<c.length;n++){const i=c[n];a.__webglColorRenderbuffer[n]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,a.__webglColorRenderbuffer[n]);const r=s.convert(i.format,i.colorSpace),o=s.convert(i.type),l=v(i.internalFormat,r,o,i.colorSpace,!0===e.isXRRenderTarget),h=V(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,h,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+n,t.RENDERBUFFER,a.__webglColorRenderbuffer[n])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(a.__webglDepthRenderbuffer=t.createRenderbuffer(),O(a.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if(h){n.bindTexture(t.TEXTURE_CUBE_MAP,l.__webglTexture),P(t.TEXTURE_CUBE_MAP,r);for(let n=0;n<6;n++)if(r.mipmaps&&r.mipmaps.length>0)for(let i=0;i<r.mipmaps.length;i++)D(a.__webglFramebuffer[n][i],e,r,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,i);else D(a.__webglFramebuffer[n],e,r,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,0);g(r)&&_(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(u){for(let r=0,s=c.length;r<s;r++){const s=c[r],o=i.get(s);n.bindTexture(t.TEXTURE_2D,o.__webglTexture),P(t.TEXTURE_2D,s),D(a.__webglFramebuffer,e,s,t.COLOR_ATTACHMENT0+r,t.TEXTURE_2D,0),g(s)&&_(t.TEXTURE_2D)}n.unbindTexture()}else{let i=t.TEXTURE_2D;if((e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(i=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),n.bindTexture(i,l.__webglTexture),P(i,r),r.mipmaps&&r.mipmaps.length>0)for(let n=0;n<r.mipmaps.length;n++)D(a.__webglFramebuffer[n],e,r,t.COLOR_ATTACHMENT0,i,n);else D(a.__webglFramebuffer,e,r,t.COLOR_ATTACHMENT0,i,0);g(r)&&_(i),n.unbindTexture()}e.depthBuffer&&F(e)},this.updateRenderTargetMipmap=function(t){const e=t.textures;for(let r=0,s=e.length;r<s;r++){const s=e[r];if(g(s)){const e=y(t),r=i.get(s).__webglTexture;n.bindTexture(e,r),_(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.samples>0)if(!1===k(e)){const r=e.textures,s=e.width,o=e.height;let a=t.COLOR_BUFFER_BIT;const c=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,h=i.get(e),u=r.length>1;if(u)for(let e=0;e<r.length;e++)n.bindFramebuffer(t.FRAMEBUFFER,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,h.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,h.__webglMultisampledFramebuffer);const d=e.texture.mipmaps;d&&d.length>0?n.bindFramebuffer(t.DRAW_FRAMEBUFFER,h.__webglFramebuffer[0]):n.bindFramebuffer(t.DRAW_FRAMEBUFFER,h.__webglFramebuffer);for(let n=0;n<r.length;n++){if(e.resolveDepthBuffer&&(e.depthBuffer&&(a|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&e.resolveStencilBuffer&&(a|=t.STENCIL_BUFFER_BIT)),u){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,h.__webglColorRenderbuffer[n]);const e=i.get(r[n]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,s,o,0,0,s,o,a,t.NEAREST),!0===l&&(B.length=0,z.length=0,B.push(t.COLOR_ATTACHMENT0+n),e.depthBuffer&&!1===e.resolveDepthBuffer&&(B.push(c),z.push(c),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,z)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,B))}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),u)for(let e=0;e<r.length;e++){n.bindFramebuffer(t.FRAMEBUFFER,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,h.__webglColorRenderbuffer[e]);const s=i.get(r[e]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,h.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,s,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,h.__webglMultisampledFramebuffer)}else if(e.depthBuffer&&!1===e.resolveDepthBuffer&&l){const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[n])}},this.setupDepthRenderbuffer=F,this.setupFrameBufferTexture=D,this.useMultisampledRTT=k}function lm(t,e){return{convert:function(n,i=Ze){let r;const s=_i.getTransfer(i);if(n===Rt)return t.UNSIGNED_BYTE;if(n===Ft)return t.UNSIGNED_SHORT_4_4_4_4;if(n===Bt)return t.UNSIGNED_SHORT_5_5_5_1;if(n===Vt)return t.UNSIGNED_INT_5_9_9_9_REV;if(n===Pt)return t.BYTE;if(n===Lt)return t.SHORT;if(n===It)return t.UNSIGNED_SHORT;if(n===Nt)return t.INT;if(n===Dt)return t.UNSIGNED_INT;if(n===Ot)return t.FLOAT;if(n===Ut)return t.HALF_FLOAT;if(n===kt)return t.ALPHA;if(n===Gt)return t.RGB;if(n===Ht)return t.RGBA;if(n===Wt)return t.DEPTH_COMPONENT;if(n===jt)return t.DEPTH_STENCIL;if(n===Xt)return t.RED;if(n===Yt)return t.RED_INTEGER;if(n===qt)return t.RG;if(n===$t)return t.RG_INTEGER;if(n===Jt)return t.RGBA_INTEGER;if(n===Kt||n===Qt||n===te||n===ee)if(s===tn){if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===r)return null;if(n===Kt)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Qt)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===te)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===ee)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(r=e.get("WEBGL_compressed_texture_s3tc"),null===r)return null;if(n===Kt)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Qt)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===te)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===ee)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===ne||n===ie||n===re||n===se){if(r=e.get("WEBGL_compressed_texture_pvrtc"),null===r)return null;if(n===ne)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===ie)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===re)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===se)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===oe||n===ae||n===le){if(r=e.get("WEBGL_compressed_texture_etc"),null===r)return null;if(n===oe||n===ae)return s===tn?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(n===le)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}if(n===ce||n===he||n===ue||n===de||n===pe||n===fe||n===me||n===ge||n===_e||n===ye||n===ve||n===xe||n===Se||n===be){if(r=e.get("WEBGL_compressed_texture_astc"),null===r)return null;if(n===ce)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===he)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===ue)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===de)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===pe)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===fe)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===me)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===ge)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===_e)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===ye)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===ve)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===xe)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Se)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===be)return s===tn?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===Me||n===we||n===Ee){if(r=e.get("EXT_texture_compression_bptc"),null===r)return null;if(n===Me)return s===tn?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===we)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===Ee)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(n===Te||n===Ae||n===Ce||n===Re){if(r=e.get("EXT_texture_compression_rgtc"),null===r)return null;if(n===Me)return r.COMPRESSED_RED_RGTC1_EXT;if(n===Ae)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Ce)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Re)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===zt?t.UNSIGNED_INT_24_8:void 0!==t[n]?t[n]:null}}}class cm{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,n){if(null===this.texture){const i=new Ai;t.properties.get(i).__webglTexture=e.texture,e.depthNear===n.depthNear&&e.depthFar===n.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=i}}getMesh(t){if(null!==this.texture&&null===this.mesh){const e=t.cameras[0].viewport,n=new $s({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new Gs(new Mc(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class hm extends Gn{constructor(t,e){super();const n=this;let i=null,r=1,s=null,o="local-floor",a=1,l=null,c=null,h=null,u=null,d=null,p=null;const f=new cm,m=e.getContextAttributes();let g=null,_=null;const y=[],v=[],x=new ti;let S=null;const b=new to;b.viewport=new Ci;const M=new to;M.viewport=new Ci;const w=[b,M],E=new cu;let T=null,A=null;function C(t){const e=v.indexOf(t.inputSource);if(-1===e)return;const n=y[e];void 0!==n&&(n.update(t.inputSource,t.frame,l||s),n.dispatchEvent({type:t.type,data:t.inputSource}))}function R(){i.removeEventListener("select",C),i.removeEventListener("selectstart",C),i.removeEventListener("selectend",C),i.removeEventListener("squeeze",C),i.removeEventListener("squeezestart",C),i.removeEventListener("squeezeend",C),i.removeEventListener("end",R),i.removeEventListener("inputsourceschange",P);for(let t=0;t<y.length;t++){const e=v[t];null!==e&&(v[t]=null,y[t].disconnect(e))}T=null,A=null,f.reset(),t.setRenderTarget(g),d=null,u=null,h=null,i=null,_=null,O.stop(),n.isPresenting=!1,t.setPixelRatio(S),t.setSize(x.width,x.height,!1),n.dispatchEvent({type:"sessionend"})}function P(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=v.indexOf(n);i>=0&&(v[i]=null,y[i].disconnect(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let i=v.indexOf(n);if(-1===i){for(let t=0;t<y.length;t++){if(t>=v.length){v.push(n),i=t;break}if(null===v[t]){v[t]=n,i=t;break}}if(-1===i)break}const r=y[i];r&&r.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=y[t];return void 0===e&&(e=new ao,y[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=y[t];return void 0===e&&(e=new ao,y[t]=e),e.getGripSpace()},this.getHand=function(t){let e=y[t];return void 0===e&&(e=new ao,y[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||s},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(c){if(i=c,null!==i){if(g=t.getRenderTarget(),i.addEventListener("select",C),i.addEventListener("selectstart",C),i.addEventListener("selectend",C),i.addEventListener("squeeze",C),i.addEventListener("squeezestart",C),i.addEventListener("squeezeend",C),i.addEventListener("end",R),i.addEventListener("inputsourceschange",P),!0!==m.xrCompatible&&await e.makeXRCompatible(),S=t.getPixelRatio(),t.getSize(x),"undefined"!=typeof XRWebGLBinding&&"createProjectionLayer"in XRWebGLBinding.prototype){let n=null,s=null,o=null;m.depth&&(o=m.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,n=m.stencil?jt:Wt,s=m.stencil?zt:Dt);const a={colorFormat:e.RGBA8,depthFormat:o,scaleFactor:r};h=new XRWebGLBinding(i,e),u=h.createProjectionLayer(a),i.updateRenderState({layers:[u]}),t.setPixelRatio(1),t.setSize(u.textureWidth,u.textureHeight,!1),_=new Pi(u.textureWidth,u.textureHeight,{format:Ht,type:Rt,depthTexture:new ll(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:m.stencil,colorSpace:t.outputColorSpace,samples:m.antialias?4:0,resolveDepthBuffer:!1===u.ignoreDepthValues,resolveStencilBuffer:!1===u.ignoreDepthValues})}else{const n={antialias:m.antialias,alpha:!0,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,e,n),i.updateRenderState({baseLayer:d}),t.setPixelRatio(1),t.setSize(d.framebufferWidth,d.framebufferHeight,!1),_=new Pi(d.framebufferWidth,d.framebufferHeight,{format:Ht,type:Rt,colorSpace:t.outputColorSpace,stencilBuffer:m.stencil,resolveDepthBuffer:!1===d.ignoreDepthValues,resolveStencilBuffer:!1===d.ignoreDepthValues})}_.isXRRenderTarget=!0,this.setFoveation(a),l=null,s=await i.requestReferenceSpace(o),O.setContext(i),O.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==i)return i.environmentBlendMode},this.getDepthTexture=function(){return f.getDepthTexture()};const L=new ni,I=new ni;function N(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===i)return;let e=t.near,n=t.far;null!==f.texture&&(f.depthNear>0&&(e=f.depthNear),f.depthFar>0&&(n=f.depthFar)),E.near=M.near=b.near=e,E.far=M.far=b.far=n,T===E.near&&A===E.far||(i.updateRenderState({depthNear:E.near,depthFar:E.far}),T=E.near,A=E.far),b.layers.mask=2|t.layers.mask,M.layers.mask=4|t.layers.mask,E.layers.mask=b.layers.mask|M.layers.mask;const r=t.parent,s=E.cameras;N(E,r);for(let t=0;t<s.length;t++)N(s[t],r);2===s.length?function(t,e,n){L.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(n.matrixWorld);const i=L.distanceTo(I),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],h=(r[8]-1)/r[0],u=(s[8]+1)/s[0],d=o*h,p=o*u,f=i/(-h+u),m=f*-h;if(e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert(),-1===r[10])t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse);else{const e=o+f,n=a+f,r=d-m,s=p+(i-m),h=l*a/n*e,u=c*a/n*e;t.projectionMatrix.makePerspective(r,s,h,u,e,n),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}}(E,b,M):E.projectionMatrix.copy(b.projectionMatrix),function(t,e,n){null===n?t.matrix.copy(e.matrixWorld):(t.matrix.copy(n.matrixWorld),t.matrix.invert(),t.matrix.multiply(e.matrixWorld)),t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*Xn*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,E,r)},this.getCamera=function(){return E},this.getFoveation=function(){if(null!==u||null!==d)return a},this.setFoveation=function(t){a=t,null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)},this.hasDepthSensing=function(){return null!==f.texture},this.getDepthSensingMesh=function(){return f.getMesh(E)};let D=null;const O=new Od;O.setAnimationLoop(function(e,r){if(c=r.getViewerPose(l||s),p=r,null!==c){const e=c.views;null!==d&&(t.setRenderTargetFramebuffer(_,d.framebuffer),t.setRenderTarget(_));let n=!1;e.length!==E.cameras.length&&(E.cameras.length=0,n=!0);for(let i=0;i<e.length;i++){const r=e[i];let s=null;if(null!==d)s=d.getViewport(r);else{const e=h.getViewSubImage(u,r);s=e.viewport,0===i&&(t.setRenderTargetTextures(_,e.colorTexture,e.depthStencilTexture),t.setRenderTarget(_))}let o=w[i];void 0===o&&(o=new to,o.layers.enable(i),o.viewport=new Ci,w[i]=o),o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.quaternion,o.scale),o.projectionMatrix.fromArray(r.projectionMatrix),o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),o.viewport.set(s.x,s.y,s.width,s.height),0===i&&(E.matrix.copy(o.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale)),!0===n&&E.cameras.push(o)}const r=i.enabledFeatures;if(r&&r.includes("depth-sensing")&&"gpu-optimized"==i.depthUsage&&h){const n=h.getDepthInformation(e[0]);n&&n.isValid&&n.texture&&f.init(t,n,i.renderState)}}for(let t=0;t<y.length;t++){const e=v[t],n=y[t];null!==e&&void 0!==n&&n.update(e,r,l||s)}D&&D(e,r),r.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:r}),p=null}),this.setAnimationLoop=function(t){D=t},this.dispose=function(){}}}const um=new yr,dm=new lr;function pm(t,e){function n(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function i(t,i){t.opacity.value=i.opacity,i.color&&t.diffuse.value.copy(i.color),i.emissive&&t.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(t.map.value=i.map,n(i.map,t.mapTransform)),i.alphaMap&&(t.alphaMap.value=i.alphaMap,n(i.alphaMap,t.alphaMapTransform)),i.bumpMap&&(t.bumpMap.value=i.bumpMap,n(i.bumpMap,t.bumpMapTransform),t.bumpScale.value=i.bumpScale,i.side===m&&(t.bumpScale.value*=-1)),i.normalMap&&(t.normalMap.value=i.normalMap,n(i.normalMap,t.normalMapTransform),t.normalScale.value.copy(i.normalScale),i.side===m&&t.normalScale.value.negate()),i.displacementMap&&(t.displacementMap.value=i.displacementMap,n(i.displacementMap,t.displacementMapTransform),t.displacementScale.value=i.displacementScale,t.displacementBias.value=i.displacementBias),i.emissiveMap&&(t.emissiveMap.value=i.emissiveMap,n(i.emissiveMap,t.emissiveMapTransform)),i.specularMap&&(t.specularMap.value=i.specularMap,n(i.specularMap,t.specularMapTransform)),i.alphaTest>0&&(t.alphaTest.value=i.alphaTest);const r=e.get(i),s=r.envMap,o=r.envMapRotation;s&&(t.envMap.value=s,um.copy(o),um.x*=-1,um.y*=-1,um.z*=-1,s.isCubeTexture&&!1===s.isRenderTargetTexture&&(um.y*=-1,um.z*=-1),t.envMapRotation.value.setFromMatrix4(dm.makeRotationFromEuler(um)),t.flipEnvMap.value=s.isCubeTexture&&!1===s.isRenderTargetTexture?-1:1,t.reflectivity.value=i.reflectivity,t.ior.value=i.ior,t.refractionRatio.value=i.refractionRatio),i.lightMap&&(t.lightMap.value=i.lightMap,t.lightMapIntensity.value=i.lightMapIntensity,n(i.lightMap,t.lightMapTransform)),i.aoMap&&(t.aoMap.value=i.aoMap,t.aoMapIntensity.value=i.aoMapIntensity,n(i.aoMap,t.aoMapTransform))}return{refreshFogUniforms:function(e,n){n.color.getRGB(e.fogColor.value,Ys(t)),n.isFog?(e.fogNear.value=n.near,e.fogFar.value=n.far):n.isFogExp2&&(e.fogDensity.value=n.density)},refreshMaterialUniforms:function(t,r,s,o,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?i(t,r):r.isMeshToonMaterial?(i(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,r)):r.isMeshPhongMaterial?(i(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,r)):r.isMeshStandardMaterial?(i(t,r),function(t,e){t.metalness.value=e.metalness,e.metalnessMap&&(t.metalnessMap.value=e.metalnessMap,n(e.metalnessMap,t.metalnessMapTransform)),t.roughness.value=e.roughness,e.roughnessMap&&(t.roughnessMap.value=e.roughnessMap,n(e.roughnessMap,t.roughnessMapTransform)),e.envMap&&(t.envMapIntensity.value=e.envMapIntensity)}(t,r),r.isMeshPhysicalMaterial&&function(t,e,i){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,n(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,n(e.sheenRoughnessMap,t.sheenRoughnessMapTransform))),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,n(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,n(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,n(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),e.side===m&&t.clearcoatNormalScale.value.negate())),e.dispersion>0&&(t.dispersion.value=e.dispersion),e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,n(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,n(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform))),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,n(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,n(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,n(e.anisotropyMap,t.anisotropyMapTransform))),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,n(e.specularColorMap,t.specularColorMapTransform)),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,n(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,r,a)):r.isMeshMatcapMaterial?(i(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,r)):r.isMeshDepthMaterial?i(t,r):r.isMeshDistanceMaterial?(i(t,r),function(t,n){const i=e.get(n).light;t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),t.nearDistance.value=i.shadow.camera.near,t.farDistance.value=i.shadow.camera.far}(t,r)):r.isMeshNormalMaterial?i(t,r):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform))}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,i,r){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*i,t.scale.value=.5*r,e.map&&(t.map.value=e.map,n(e.map,t.uvTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r,s,o):r.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function fm(t,e,n,i){let r={},s={},o=[];const a=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(t,e,n,i){const r=t.value,s=e+"_"+n;if(void 0===i[s])return i[s]="number"==typeof r||"boolean"==typeof r?r:r.clone(),!0;{const t=i[s];if("number"==typeof r||"boolean"==typeof r){if(t!==r)return i[s]=r,!0}else if(!1===t.equals(r))return t.copy(r),!0}return!1}function c(t){const e={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),e}function h(e){const n=e.target;n.removeEventListener("dispose",h);const i=o.indexOf(n.__bindingPointIndex);o.splice(i,1),t.deleteBuffer(r[n.id]),delete r[n.id],delete s[n.id]}return{bind:function(t,e){const n=e.program;i.uniformBlockBinding(t,n)},update:function(n,u){let d=r[n.id];void 0===d&&(function(t){const e=t.uniforms;let n=0;for(let t=0,i=e.length;t<i;t++){const i=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0,e=i.length;t<e;t++){const e=i[t],r=Array.isArray(e.value)?e.value:[e.value];for(let t=0,i=r.length;t<i;t++){const i=c(r[t]),s=n%16,o=s%i.boundary,a=s+o;n+=o,0!==a&&16-a<i.storage&&(n+=16-a),e.__data=new Float32Array(i.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=n,n+=i.storage}}}const i=n%16;i>0&&(n+=16-i),t.__size=n,t.__cache={}}(n),d=function(e){const n=function(){for(let t=0;t<a;t++)if(-1===o.indexOf(t))return o.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=n;const i=t.createBuffer(),r=e.__size,s=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,i),t.bufferData(t.UNIFORM_BUFFER,r,s),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,n,i),i}(n),r[n.id]=d,n.addEventListener("dispose",h));const p=u.program;i.updateUBOMapping(n,p);const f=e.render.frame;s[n.id]!==f&&(function(e){const n=r[e.id],i=e.uniforms,s=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,n);for(let e=0,n=i.length;e<n;e++){const n=Array.isArray(i[e])?i[e]:[i[e]];for(let i=0,r=n.length;i<r;i++){const r=n[i];if(!0===l(r,e,i,s)){const e=r.__offset,n=Array.isArray(r.value)?r.value:[r.value];let i=0;for(let s=0;s<n.length;s++){const o=n[s],a=c(o);"number"==typeof o||"boolean"==typeof o?(r.__data[0]=o,t.bufferSubData(t.UNIFORM_BUFFER,e+i,r.__data)):o.isMatrix3?(r.__data[0]=o.elements[0],r.__data[1]=o.elements[1],r.__data[2]=o.elements[2],r.__data[3]=0,r.__data[4]=o.elements[3],r.__data[5]=o.elements[4],r.__data[6]=o.elements[5],r.__data[7]=0,r.__data[8]=o.elements[6],r.__data[9]=o.elements[7],r.__data[10]=o.elements[8],r.__data[11]=0):(o.toArray(r.__data,i),i+=a.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,r.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(n),s[n.id]=f)},dispose:function(){for(const e in r)t.deleteBuffer(r[e]);o=[],r={},s={}}}}class mm{constructor(t={}){const{canvas:e=ui(),context:n=null,depth:r=!0,stencil:s=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:u=!1,reverseDepthBuffer:d=!1}=t;let p;if(this.isWebGLRenderer=!0,null!==n){if("undefined"!=typeof WebGLRenderingContext&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=n.getContextAttributes().alpha}else p=o;const _=new Uint32Array(4),y=new Int32Array(4);let v=null,x=null;const S=[],b=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=tt,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const M=this;let w=!1;this._outputColorSpace=Je;let E=0,T=0,A=null,C=-1,R=null;const P=new Ci,L=new Ci;let I=null;const N=new ts(0);let D=0,O=e.width,U=e.height,F=1,B=null,z=null;const V=new Ci(0,0,O,U),k=new Ci(0,0,O,U);let G=!1;const H=new ua;let W=!1,j=!1;const X=new lr,Y=new lr,q=new ni,$=new Ci,Z={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let J=!1;function K(){return null===A?F:1}let Q,et,nt,it,rt,st,ot,at,lt,ct,ht,ut,dt,pt,ft,mt,gt,_t,yt,vt,xt,St,bt,Mt,wt=n;function Et(t,n){return e.getContext(t,n)}try{const t={alpha:!0,depth:r,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${i}`),e.addEventListener("webglcontextlost",Pt,!1),e.addEventListener("webglcontextrestored",Lt,!1),e.addEventListener("webglcontextcreationerror",Nt,!1),null===wt){const e="webgl2";if(wt=Et(e,t),null===wt)throw Et(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function Tt(){Q=new dp(wt),Q.init(),St=new lm(wt,Q),et=new Xd(wt,Q,t,St),nt=new om(wt,Q),et.reverseDepthBuffer&&d&&nt.buffers.depth.setReversed(!0),it=new mp(wt),rt=new Yf,st=new am(wt,Q,nt,rt,et,St,it),ot=new qd(M),at=new up(M),lt=new Ud(wt),bt=new Wd(wt,lt),ct=new pp(wt,lt,it,bt),ht=new _p(wt,ct,lt,it),yt=new gp(wt,et,st),mt=new Yd(rt),ut=new Xf(M,ot,at,Q,et,bt,mt),dt=new pm(M,rt),pt=new Jf,ft=new im(Q),_t=new Hd(M,ot,at,nt,ht,p,l),gt=new rm(M,ht,et),Mt=new fm(wt,it,et,nt),vt=new jd(wt,Q,it),xt=new fp(wt,Q,it),it.programs=ut.programs,M.capabilities=et,M.extensions=Q,M.properties=rt,M.renderLists=pt,M.shadowMap=gt,M.state=nt,M.info=it}Tt();const Ct=new hm(M,wt);function Pt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function Lt(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const t=it.autoReset,e=gt.enabled,n=gt.autoUpdate,i=gt.needsUpdate,r=gt.type;Tt(),it.autoReset=t,gt.enabled=e,gt.autoUpdate=n,gt.needsUpdate=i,gt.type=r}function Nt(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function Ot(t){const e=t.target;e.removeEventListener("dispose",Ot),function(t){(function(t){const e=rt.get(t).programs;void 0!==e&&(e.forEach(function(t){ut.releaseProgram(t)}),t.isShaderMaterial&&ut.releaseShaderCache(t))})(t),rt.remove(t)}(e)}function Vt(t,e,n){!0===t.transparent&&t.side===g&&!1===t.forceSinglePass?(t.side=m,t.needsUpdate=!0,Qt(t,e,n),t.side=f,t.needsUpdate=!0,Qt(t,e,n),t.side=g):Qt(t,e,n)}this.xr=Ct,this.getContext=function(){return wt},this.getContextAttributes=function(){return wt.getContextAttributes()},this.forceContextLoss=function(){const t=Q.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=Q.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(t){void 0!==t&&(F=t,this.setSize(O,U,!1))},this.getSize=function(t){return t.set(O,U)},this.setSize=function(t,n,i=!0){Ct.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(O=t,U=n,e.width=Math.floor(t*F),e.height=Math.floor(n*F),!0===i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(O*F,U*F).floor()},this.setDrawingBufferSize=function(t,n,i){O=t,U=n,F=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(P)},this.getViewport=function(t){return t.copy(V)},this.setViewport=function(t,e,n,i){t.isVector4?V.set(t.x,t.y,t.z,t.w):V.set(t,e,n,i),nt.viewport(P.copy(V).multiplyScalar(F).round())},this.getScissor=function(t){return t.copy(k)},this.setScissor=function(t,e,n,i){t.isVector4?k.set(t.x,t.y,t.z,t.w):k.set(t,e,n,i),nt.scissor(L.copy(k).multiplyScalar(F).round())},this.getScissorTest=function(){return G},this.setScissorTest=function(t){nt.setScissorTest(G=t)},this.setOpaqueSort=function(t){B=t},this.setTransparentSort=function(t){z=t},this.getClearColor=function(t){return t.copy(_t.getClearColor())},this.setClearColor=function(){_t.setClearColor(...arguments)},this.getClearAlpha=function(){return _t.getClearAlpha()},this.setClearAlpha=function(){_t.setClearAlpha(...arguments)},this.clear=function(t=!0,e=!0,n=!0){let i=0;if(t){let t=!1;if(null!==A){const e=A.texture.format;t=e===Jt||e===$t||e===Yt}if(t){const t=A.texture.type,e=t===Rt||t===Dt||t===It||t===zt||t===Ft||t===Bt,n=_t.getClearColor(),i=_t.getClearAlpha(),r=n.r,s=n.g,o=n.b;e?(_[0]=r,_[1]=s,_[2]=o,_[3]=i,wt.clearBufferuiv(wt.COLOR,0,_)):(y[0]=r,y[1]=s,y[2]=o,y[3]=i,wt.clearBufferiv(wt.COLOR,0,y))}else i|=wt.COLOR_BUFFER_BIT}e&&(i|=wt.DEPTH_BUFFER_BIT),n&&(i|=wt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),wt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Pt,!1),e.removeEventListener("webglcontextrestored",Lt,!1),e.removeEventListener("webglcontextcreationerror",Nt,!1),_t.dispose(),pt.dispose(),ft.dispose(),rt.dispose(),ot.dispose(),at.dispose(),ht.dispose(),bt.dispose(),Mt.dispose(),ut.dispose(),Ct.dispose(),Ct.removeEventListener("sessionstart",Gt),Ct.removeEventListener("sessionend",Ht),Wt.stop()},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=Z);const o=r.isMesh&&r.matrixWorld.determinant()<0,a=function(t,e,n,i,r){!0!==e.isScene&&(e=Z),st.resetTextureUnits();const s=e.fog,o=i.isMeshStandardMaterial?e.environment:null,a=null===A?M.outputColorSpace:!0===A.isXRRenderTarget?A.texture.colorSpace:Ke,l=(i.isMeshStandardMaterial?at:ot).get(i.envMap||o),c=!0===i.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!n.attributes.tangent&&(!!i.normalMap||i.anisotropy>0),u=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=!!n.morphAttributes.color;let f=tt;i.toneMapped&&(null!==A&&!0!==A.isXRRenderTarget||(f=M.toneMapping));const m=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,g=void 0!==m?m.length:0,_=rt.get(i),y=x.state.lights;if(!0===W&&(!0===j||t!==R)){const e=t===R&&i.id===C;mt.setState(i,t,e)}let v=!1;i.version===_.__version?_.needsLights&&_.lightsStateVersion!==y.state.version||_.outputColorSpace!==a||r.isBatchedMesh&&!1===_.batching?v=!0:r.isBatchedMesh||!0!==_.batching?r.isBatchedMesh&&!0===_.batchingColor&&null===r.colorTexture||r.isBatchedMesh&&!1===_.batchingColor&&null!==r.colorTexture||r.isInstancedMesh&&!1===_.instancing?v=!0:r.isInstancedMesh||!0!==_.instancing?r.isSkinnedMesh&&!1===_.skinning?v=!0:r.isSkinnedMesh||!0!==_.skinning?r.isInstancedMesh&&!0===_.instancingColor&&null===r.instanceColor||r.isInstancedMesh&&!1===_.instancingColor&&null!==r.instanceColor||r.isInstancedMesh&&!0===_.instancingMorph&&null===r.morphTexture||r.isInstancedMesh&&!1===_.instancingMorph&&null!==r.morphTexture||_.envMap!==l||!0===i.fog&&_.fog!==s?v=!0:void 0===_.numClippingPlanes||_.numClippingPlanes===mt.numPlanes&&_.numIntersection===mt.numIntersection?(_.vertexAlphas!==c||_.vertexTangents!==h||_.morphTargets!==u||_.morphNormals!==d||_.morphColors!==p||_.toneMapping!==f||_.morphTargetsCount!==g)&&(v=!0):v=!0:v=!0:v=!0:v=!0:(v=!0,_.__version=i.version);let S=_.currentProgram;!0===v&&(S=Qt(i,e,r));let b=!1,w=!1,E=!1;const T=S.getUniforms(),P=_.uniforms;if(nt.useProgram(S.program)&&(b=!0,w=!0,E=!0),i.id!==C&&(C=i.id,w=!0),b||R!==t){nt.buffers.depth.getReversed()?(X.copy(t.projectionMatrix),function(t){const e=t.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}(X),function(t){const e=t.elements;-1===e[11]?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=1-e[14])}(X),T.setValue(wt,"projectionMatrix",X)):T.setValue(wt,"projectionMatrix",t.projectionMatrix),T.setValue(wt,"viewMatrix",t.matrixWorldInverse);const e=T.map.cameraPosition;void 0!==e&&e.setValue(wt,q.setFromMatrixPosition(t.matrixWorld)),et.logarithmicDepthBuffer&&T.setValue(wt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial)&&T.setValue(wt,"isOrthographic",!0===t.isOrthographicCamera),R!==t&&(R=t,w=!0,E=!0)}if(r.isSkinnedMesh){T.setOptional(wt,r,"bindMatrix"),T.setOptional(wt,r,"bindMatrixInverse");const t=r.skeleton;t&&(null===t.boneTexture&&t.computeBoneTexture(),T.setValue(wt,"boneTexture",t.boneTexture,st))}r.isBatchedMesh&&(T.setOptional(wt,r,"batchingTexture"),T.setValue(wt,"batchingTexture",r._matricesTexture,st),T.setOptional(wt,r,"batchingIdTexture"),T.setValue(wt,"batchingIdTexture",r._indirectTexture,st),T.setOptional(wt,r,"batchingColorTexture"),null!==r._colorsTexture&&T.setValue(wt,"batchingColorTexture",r._colorsTexture,st));const L=n.morphAttributes;var I,N;if(void 0===L.position&&void 0===L.normal&&void 0===L.color||yt.update(r,n,S),(w||_.receiveShadow!==r.receiveShadow)&&(_.receiveShadow=r.receiveShadow,T.setValue(wt,"receiveShadow",r.receiveShadow)),i.isMeshGouraudMaterial&&null!==i.envMap&&(P.envMap.value=l,P.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1),i.isMeshStandardMaterial&&null===i.envMap&&null!==e.environment&&(P.envMapIntensity.value=e.environmentIntensity),w&&(T.setValue(wt,"toneMappingExposure",M.toneMappingExposure),_.needsLights&&(N=E,(I=P).ambientLightColor.needsUpdate=N,I.lightProbe.needsUpdate=N,I.directionalLights.needsUpdate=N,I.directionalLightShadows.needsUpdate=N,I.pointLights.needsUpdate=N,I.pointLightShadows.needsUpdate=N,I.spotLights.needsUpdate=N,I.spotLightShadows.needsUpdate=N,I.rectAreaLights.needsUpdate=N,I.hemisphereLights.needsUpdate=N),s&&!0===i.fog&&dt.refreshFogUniforms(P,s),dt.refreshMaterialUniforms(P,i,F,U,x.state.transmissionRenderTarget[t.id]),Mf.upload(wt,te(_),P,st)),i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(Mf.upload(wt,te(_),P,st),i.uniformsNeedUpdate=!1),i.isSpriteMaterial&&T.setValue(wt,"center",r.center),T.setValue(wt,"modelViewMatrix",r.modelViewMatrix),T.setValue(wt,"normalMatrix",r.normalMatrix),T.setValue(wt,"modelMatrix",r.matrixWorld),i.isShaderMaterial||i.isRawShaderMaterial){const t=i.uniformsGroups;for(let e=0,n=t.length;e<n;e++){const n=t[e];Mt.update(n,S),Mt.bind(n,S)}}return S}(t,e,n,i,r);nt.setMaterial(i,o);let l=n.index,c=1;if(!0===i.wireframe){if(l=ct.getWireframeAttribute(n),void 0===l)return;c=2}const h=n.drawRange,u=n.attributes.position;let d=h.start*c,p=(h.start+h.count)*c;null!==s&&(d=Math.max(d,s.start*c),p=Math.min(p,(s.start+s.count)*c)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=u&&(d=Math.max(d,0),p=Math.min(p,u.count));const f=p-d;if(f<0||f===1/0)return;let m;bt.setup(r,i,a,n,l);let g=vt;if(null!==l&&(m=lt.get(l),g=xt,g.setIndex(m)),r.isMesh)!0===i.wireframe?(nt.setLineWidth(i.wireframeLinewidth*K()),g.setMode(wt.LINES)):g.setMode(wt.TRIANGLES);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),nt.setLineWidth(t*K()),r.isLineSegments?g.setMode(wt.LINES):r.isLineLoop?g.setMode(wt.LINE_LOOP):g.setMode(wt.LINE_STRIP)}else r.isPoints?g.setMode(wt.POINTS):r.isSprite&&g.setMode(wt.TRIANGLES);if(r.isBatchedMesh)if(null!==r._multiDrawInstances)pi("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),g.renderMultiDrawInstances(r._multiDrawStarts,r._multiDrawCounts,r._multiDrawCount,r._multiDrawInstances);else if(Q.get("WEBGL_multi_draw"))g.renderMultiDraw(r._multiDrawStarts,r._multiDrawCounts,r._multiDrawCount);else{const t=r._multiDrawStarts,e=r._multiDrawCounts,n=r._multiDrawCount,s=l?lt.get(l).bytesPerElement:1,o=rt.get(i).currentProgram.getUniforms();for(let i=0;i<n;i++)o.setValue(wt,"_gl_DrawID",i),g.render(t[i]/s,e[i])}else if(r.isInstancedMesh)g.renderInstances(d,f,r.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,e=Math.min(n.instanceCount,t);g.renderInstances(d,f,e)}else g.render(d,f)},this.compile=function(t,e,n=null){null===n&&(n=t),x=ft.get(n),x.init(e),b.push(x),n.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))}),t!==n&&t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))}),x.setupLights();const i=new Set;return t.traverse(function(t){if(!(t.isMesh||t.isPoints||t.isLine||t.isSprite))return;const e=t.material;if(e)if(Array.isArray(e))for(let r=0;r<e.length;r++){const s=e[r];Vt(s,n,t),i.add(s)}else Vt(e,n,t),i.add(e)}),x=b.pop(),i},this.compileAsync=function(t,e,n=null){const i=this.compile(t,e,n);return new Promise(e=>{function n(){i.forEach(function(t){rt.get(t).currentProgram.isReady()&&i.delete(t)}),0!==i.size?setTimeout(n,10):e(t)}null!==Q.get("KHR_parallel_shader_compile")?n():setTimeout(n,10)})};let kt=null;function Gt(){Wt.stop()}function Ht(){Wt.start()}const Wt=new Od;function jt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)x.pushLight(t),t.castShadow&&x.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||H.intersectsSprite(t)){i&&$.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Y);const e=ht.update(t),r=t.material;r.visible&&v.push(t,e,r,n,$.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||H.intersectsObject(t))){const e=ht.update(t),r=t.material;if(i&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),$.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),$.copy(e.boundingSphere.center)),$.applyMatrix4(t.matrixWorld).applyMatrix4(Y)),Array.isArray(r)){const i=e.groups;for(let s=0,o=i.length;s<o;s++){const o=i[s],a=r[o.materialIndex];a&&a.visible&&v.push(t,e,a,n,$.z,o)}}else r.visible&&v.push(t,e,r,n,$.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)jt(r[t],e,n,i)}function Xt(t,e,n,i){const r=t.opaque,s=t.transmissive,o=t.transparent;x.setupLightsView(n),!0===W&&mt.setGlobalState(M.clippingPlanes,n),i&&nt.viewport(P.copy(i)),r.length>0&&Zt(r,e,n),s.length>0&&Zt(s,e,n),o.length>0&&Zt(o,e,n),nt.buffers.depth.setTest(!0),nt.buffers.depth.setMask(!0),nt.buffers.color.setMask(!0),nt.setPolygonOffset(!1)}function qt(t,e,n,i){if(null!==(!0===n.isScene?n.overrideMaterial:null))return;void 0===x.state.transmissionRenderTarget[i.id]&&(x.state.transmissionRenderTarget[i.id]=new Pi(1,1,{generateMipmaps:!0,type:Q.has("EXT_color_buffer_half_float")||Q.has("EXT_color_buffer_float")?Ut:Rt,minFilter:At,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:_i.workingColorSpace}));const r=x.state.transmissionRenderTarget[i.id],o=i.viewport||P;r.setSize(o.z*M.transmissionResolutionScale,o.w*M.transmissionResolutionScale);const a=M.getRenderTarget(),l=M.getActiveCubeFace(),c=M.getActiveMipmapLevel();M.setRenderTarget(r),M.getClearColor(N),D=M.getClearAlpha(),D<1&&M.setClearColor(16777215,.5),M.clear(),J&&_t.render(n);const h=M.toneMapping;M.toneMapping=tt;const u=i.viewport;if(void 0!==i.viewport&&(i.viewport=void 0),x.setupLightsView(i),!0===W&&mt.setGlobalState(M.clippingPlanes,i),Zt(t,n,i),st.updateMultisampleRenderTarget(r),st.updateRenderTargetMipmap(r),!1===Q.has("WEBGL_multisampled_render_to_texture")){let t=!1;for(let r=0,s=e.length;r<s;r++){const s=e[r],o=s.object,a=s.geometry,l=s.material,c=s.group;if(l.side===g&&o.layers.test(i.layers)){const e=l.side;l.side=m,l.needsUpdate=!0,Kt(o,n,i,a,l,c),l.side=e,l.needsUpdate=!0,t=!0}}!0===t&&(st.updateMultisampleRenderTarget(r),st.updateRenderTargetMipmap(r))}M.setRenderTarget(a,l,c),M.setClearColor(N,D),void 0!==u&&(i.viewport=u),M.toneMapping=h}function Zt(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],o=s.object,a=s.geometry,l=s.group;let c=s.material;!0===c.allowOverride&&null!==i&&(c=i),o.layers.test(n.layers)&&Kt(o,e,n,a,c,l)}}function Kt(t,e,n,i,r,s){t.onBeforeRender(M,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),r.onBeforeRender(M,e,n,i,t,s),!0===r.transparent&&r.side===g&&!1===r.forceSinglePass?(r.side=m,r.needsUpdate=!0,M.renderBufferDirect(n,e,i,r,t,s),r.side=f,r.needsUpdate=!0,M.renderBufferDirect(n,e,i,r,t,s),r.side=g):M.renderBufferDirect(n,e,i,r,t,s),t.onAfterRender(M,e,n,i,r,s)}function Qt(t,e,n){!0!==e.isScene&&(e=Z);const i=rt.get(t),r=x.state.lights,s=x.state.shadowsArray,o=r.state.version,a=ut.getParameters(t,r.state,s,e,n),l=ut.getProgramCacheKey(a);let c=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?at:ot).get(t.envMap||i.environment),i.envMapRotation=null!==i.environment&&null===t.envMap?e.environmentRotation:t.envMapRotation,void 0===c&&(t.addEventListener("dispose",Ot),c=new Map,i.programs=c);let h=c.get(l);if(void 0!==h){if(i.currentProgram===h&&i.lightsStateVersion===o)return ee(t,a),h}else a.uniforms=ut.getUniforms(t),t.onBeforeCompile(a,M),h=ut.acquireProgram(a,l),c.set(l,h),i.uniforms=a.uniforms;const u=i.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=mt.uniform),ee(t,a),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=o,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotLightMatrix.value=r.state.spotLightMatrix,u.spotLightMap.value=r.state.spotLightMap,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix),i.currentProgram=h,i.uniformsList=null,h}function te(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=Mf.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function ee(t,e){const n=rt.get(t);n.outputColorSpace=e.outputColorSpace,n.batching=e.batching,n.batchingColor=e.batchingColor,n.instancing=e.instancing,n.instancingColor=e.instancingColor,n.instancingMorph=e.instancingMorph,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}Wt.setAnimationLoop(function(t){kt&&kt(t)}),"undefined"!=typeof self&&Wt.setContext(self),this.setAnimationLoop=function(t){kt=t,Ct.setAnimationLoop(t),null===t?Wt.stop():Wt.start()},Ct.addEventListener("sessionstart",Gt),Ct.addEventListener("sessionend",Ht),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===w)return;if(!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Ct.enabled&&!0===Ct.isPresenting&&(!0===Ct.cameraAutoUpdate&&Ct.updateCamera(e),e=Ct.getCamera()),!0===t.isScene&&t.onBeforeRender(M,t,e,A),x=ft.get(t,b.length),x.init(e),b.push(x),Y.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),H.setFromProjectionMatrix(Y),j=this.localClippingEnabled,W=mt.init(this.clippingPlanes,j),v=pt.get(t,S.length),v.init(),S.push(v),!0===Ct.enabled&&!0===Ct.isPresenting){const t=M.xr.getDepthSensingMesh();null!==t&&jt(t,e,-1/0,M.sortObjects)}jt(t,e,0,M.sortObjects),v.finish(),!0===M.sortObjects&&v.sort(B,z),J=!1===Ct.enabled||!1===Ct.isPresenting||!1===Ct.hasDepthSensing(),J&&_t.addToRenderList(v,t),this.info.render.frame++,!0===W&&mt.beginShadows();const n=x.state.shadowsArray;gt.render(n,t,e),!0===W&&mt.endShadows(),!0===this.info.autoReset&&this.info.reset();const i=v.opaque,r=v.transmissive;if(x.setupLights(),e.isArrayCamera){const n=e.cameras;if(r.length>0)for(let e=0,s=n.length;e<s;e++)qt(i,r,t,n[e]);J&&_t.render(t);for(let e=0,i=n.length;e<i;e++){const i=n[e];Xt(v,t,i,i.viewport)}}else r.length>0&&qt(i,r,t,e),J&&_t.render(t),Xt(v,t,e);null!==A&&0===T&&(st.updateMultisampleRenderTarget(A),st.updateRenderTargetMipmap(A)),!0===t.isScene&&t.onAfterRender(M,t,e),bt.resetDefaultState(),C=-1,R=null,b.pop(),b.length>0?(x=b[b.length-1],!0===W&&mt.setGlobalState(M.clippingPlanes,x.state.camera)):x=null,S.pop(),v=S.length>0?S[S.length-1]:null},this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return T},this.getRenderTarget=function(){return A},this.setRenderTargetTextures=function(t,e,n){const i=rt.get(t);i.__autoAllocateDepthBuffer=!1===t.resolveDepthBuffer,!1===i.__autoAllocateDepthBuffer&&(i.__useRenderToTexture=!1),rt.get(t.texture).__webglTexture=e,rt.get(t.depthTexture).__webglTexture=i.__autoAllocateDepthBuffer?void 0:n,i.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(t,e){const n=rt.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e};const ne=wt.createFramebuffer();this.setRenderTarget=function(t,e=0,n=0){A=t,E=e,T=n;let i=!0,r=null,s=!1,o=!1;if(t){const a=rt.get(t);if(void 0!==a.__useDefaultFramebuffer)nt.bindFramebuffer(wt.FRAMEBUFFER,null),i=!1;else if(void 0===a.__webglFramebuffer)st.setupRenderTarget(t);else if(a.__hasExternalTextures)st.rebindTextures(t,rt.get(t.texture).__webglTexture,rt.get(t.depthTexture).__webglTexture);else if(t.depthBuffer){const e=t.depthTexture;if(a.__boundDepthTexture!==e){if(null!==e&&rt.has(e)&&(t.width!==e.image.width||t.height!==e.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");st.setupDepthRenderbuffer(t)}}const l=t.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(o=!0);const c=rt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(r=Array.isArray(c[e])?c[e][n]:c[e],s=!0):r=t.samples>0&&!1===st.useMultisampledRTT(t)?rt.get(t).__webglMultisampledFramebuffer:Array.isArray(c)?c[n]:c,P.copy(t.viewport),L.copy(t.scissor),I=t.scissorTest}else P.copy(V).multiplyScalar(F).floor(),L.copy(k).multiplyScalar(F).floor(),I=G;if(0!==n&&(r=ne),nt.bindFramebuffer(wt.FRAMEBUFFER,r)&&i&&nt.drawBuffers(t,r),nt.viewport(P),nt.scissor(L),nt.setScissorTest(I),s){const i=rt.get(t.texture);wt.framebufferTexture2D(wt.FRAMEBUFFER,wt.COLOR_ATTACHMENT0,wt.TEXTURE_CUBE_MAP_POSITIVE_X+e,i.__webglTexture,n)}else if(o){const i=rt.get(t.texture),r=e;wt.framebufferTextureLayer(wt.FRAMEBUFFER,wt.COLOR_ATTACHMENT0,i.__webglTexture,n,r)}else if(null!==t&&0!==n){const e=rt.get(t.texture);wt.framebufferTexture2D(wt.FRAMEBUFFER,wt.COLOR_ATTACHMENT0,wt.TEXTURE_2D,e.__webglTexture,n)}C=-1},this.readRenderTargetPixels=function(t,e,n,i,r,s,o,a=0){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=rt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(l=l[o]),l){nt.bindFramebuffer(wt.FRAMEBUFFER,l);try{const o=t.textures[a],l=o.format,c=o.type;if(!et.textureFormatReadable(l))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!et.textureTypeReadable(c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&(t.textures.length>1&&wt.readBuffer(wt.COLOR_ATTACHMENT0+a),wt.readPixels(e,n,i,r,St.convert(l),St.convert(c),s))}finally{const t=null!==A?rt.get(A).__webglFramebuffer:null;nt.bindFramebuffer(wt.FRAMEBUFFER,t)}}},this.readRenderTargetPixelsAsync=async function(t,e,n,i,r,s,o,a=0){if(!t||!t.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=rt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(l=l[o]),l){if(e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r){nt.bindFramebuffer(wt.FRAMEBUFFER,l);const o=t.textures[a],c=o.format,h=o.type;if(!et.textureFormatReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!et.textureTypeReadable(h))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const u=wt.createBuffer();wt.bindBuffer(wt.PIXEL_PACK_BUFFER,u),wt.bufferData(wt.PIXEL_PACK_BUFFER,s.byteLength,wt.STREAM_READ),t.textures.length>1&&wt.readBuffer(wt.COLOR_ATTACHMENT0+a),wt.readPixels(e,n,i,r,St.convert(c),St.convert(h),0);const d=null!==A?rt.get(A).__webglFramebuffer:null;nt.bindFramebuffer(wt.FRAMEBUFFER,d);const p=wt.fenceSync(wt.SYNC_GPU_COMMANDS_COMPLETE,0);return wt.flush(),await function(t,e){return new Promise(function(n,i){setTimeout(function r(){switch(t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:i();break;case t.TIMEOUT_EXPIRED:setTimeout(r,4);break;default:n()}},4)})}(wt,p),wt.bindBuffer(wt.PIXEL_PACK_BUFFER,u),wt.getBufferSubData(wt.PIXEL_PACK_BUFFER,0,s),wt.deleteBuffer(u),wt.deleteSync(p),s}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,e=null,n=0){const i=Math.pow(2,-n),r=Math.floor(t.image.width*i),s=Math.floor(t.image.height*i),o=null!==e?e.x:0,a=null!==e?e.y:0;st.setTexture2D(t,0),wt.copyTexSubImage2D(wt.TEXTURE_2D,n,0,0,o,a,r,s),nt.unbindTexture()};const ie=wt.createFramebuffer(),re=wt.createFramebuffer();this.copyTextureToTexture=function(t,e,n=null,i=null,r=0,s=null){let o,a,l,c,h,u,d,p,f;null===s&&(0!==r?(pi("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),s=r,r=0):s=0);const m=t.isCompressedTexture?t.mipmaps[s]:t.image;if(null!==n)o=n.max.x-n.min.x,a=n.max.y-n.min.y,l=n.isBox3?n.max.z-n.min.z:1,c=n.min.x,h=n.min.y,u=n.isBox3?n.min.z:0;else{const e=Math.pow(2,-r);o=Math.floor(m.width*e),a=Math.floor(m.height*e),l=t.isDataArrayTexture?m.depth:t.isData3DTexture?Math.floor(m.depth*e):1,c=0,h=0,u=0}null!==i?(d=i.x,p=i.y,f=i.z):(d=0,p=0,f=0);const g=St.convert(e.format),_=St.convert(e.type);let y;e.isData3DTexture?(st.setTexture3D(e,0),y=wt.TEXTURE_3D):e.isDataArrayTexture||e.isCompressedArrayTexture?(st.setTexture2DArray(e,0),y=wt.TEXTURE_2D_ARRAY):(st.setTexture2D(e,0),y=wt.TEXTURE_2D),wt.pixelStorei(wt.UNPACK_FLIP_Y_WEBGL,e.flipY),wt.pixelStorei(wt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),wt.pixelStorei(wt.UNPACK_ALIGNMENT,e.unpackAlignment);const v=wt.getParameter(wt.UNPACK_ROW_LENGTH),x=wt.getParameter(wt.UNPACK_IMAGE_HEIGHT),S=wt.getParameter(wt.UNPACK_SKIP_PIXELS),b=wt.getParameter(wt.UNPACK_SKIP_ROWS),M=wt.getParameter(wt.UNPACK_SKIP_IMAGES);wt.pixelStorei(wt.UNPACK_ROW_LENGTH,m.width),wt.pixelStorei(wt.UNPACK_IMAGE_HEIGHT,m.height),wt.pixelStorei(wt.UNPACK_SKIP_PIXELS,c),wt.pixelStorei(wt.UNPACK_SKIP_ROWS,h),wt.pixelStorei(wt.UNPACK_SKIP_IMAGES,u);const w=t.isDataArrayTexture||t.isData3DTexture,E=e.isDataArrayTexture||e.isData3DTexture;if(t.isDepthTexture){const n=rt.get(t),i=rt.get(e),m=rt.get(n.__renderTarget),g=rt.get(i.__renderTarget);nt.bindFramebuffer(wt.READ_FRAMEBUFFER,m.__webglFramebuffer),nt.bindFramebuffer(wt.DRAW_FRAMEBUFFER,g.__webglFramebuffer);for(let n=0;n<l;n++)w&&(wt.framebufferTextureLayer(wt.READ_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,rt.get(t).__webglTexture,r,u+n),wt.framebufferTextureLayer(wt.DRAW_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,rt.get(e).__webglTexture,s,f+n)),wt.blitFramebuffer(c,h,o,a,d,p,o,a,wt.DEPTH_BUFFER_BIT,wt.NEAREST);nt.bindFramebuffer(wt.READ_FRAMEBUFFER,null),nt.bindFramebuffer(wt.DRAW_FRAMEBUFFER,null)}else if(0!==r||t.isRenderTargetTexture||rt.has(t)){const n=rt.get(t),i=rt.get(e);nt.bindFramebuffer(wt.READ_FRAMEBUFFER,ie),nt.bindFramebuffer(wt.DRAW_FRAMEBUFFER,re);for(let t=0;t<l;t++)w?wt.framebufferTextureLayer(wt.READ_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,n.__webglTexture,r,u+t):wt.framebufferTexture2D(wt.READ_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,wt.TEXTURE_2D,n.__webglTexture,r),E?wt.framebufferTextureLayer(wt.DRAW_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,i.__webglTexture,s,f+t):wt.framebufferTexture2D(wt.DRAW_FRAMEBUFFER,wt.COLOR_ATTACHMENT0,wt.TEXTURE_2D,i.__webglTexture,s),0!==r?wt.blitFramebuffer(c,h,o,a,d,p,o,a,wt.COLOR_BUFFER_BIT,wt.NEAREST):E?wt.copyTexSubImage3D(y,s,d,p,f+t,c,h,o,a):wt.copyTexSubImage2D(y,s,d,p,c,h,o,a);nt.bindFramebuffer(wt.READ_FRAMEBUFFER,null),nt.bindFramebuffer(wt.DRAW_FRAMEBUFFER,null)}else E?t.isDataTexture||t.isData3DTexture?wt.texSubImage3D(y,s,d,p,f,o,a,l,g,_,m.data):e.isCompressedArrayTexture?wt.compressedTexSubImage3D(y,s,d,p,f,o,a,l,g,m.data):wt.texSubImage3D(y,s,d,p,f,o,a,l,g,_,m):t.isDataTexture?wt.texSubImage2D(wt.TEXTURE_2D,s,d,p,o,a,g,_,m.data):t.isCompressedTexture?wt.compressedTexSubImage2D(wt.TEXTURE_2D,s,d,p,m.width,m.height,g,m.data):wt.texSubImage2D(wt.TEXTURE_2D,s,d,p,o,a,g,_,m);wt.pixelStorei(wt.UNPACK_ROW_LENGTH,v),wt.pixelStorei(wt.UNPACK_IMAGE_HEIGHT,x),wt.pixelStorei(wt.UNPACK_SKIP_PIXELS,S),wt.pixelStorei(wt.UNPACK_SKIP_ROWS,b),wt.pixelStorei(wt.UNPACK_SKIP_IMAGES,M),0===s&&e.generateMipmaps&&wt.generateMipmap(y),nt.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n=null,i=null,r=0){return pi('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(t,e,n,i,r)},this.initRenderTarget=function(t){void 0===rt.get(t).__webglFramebuffer&&st.setupRenderTarget(t)},this.initTexture=function(t){t.isCubeTexture?st.setTextureCube(t,0):t.isData3DTexture?st.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?st.setTexture2DArray(t,0):st.setTexture2D(t,0),nt.unbindTexture()},this.resetState=function(){E=0,T=0,A=null,nt.reset(),bt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Fn}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorSpace=_i._getDrawingBufferColorSpace(t),e.unpackColorSpace=_i._getUnpackColorSpace()}}var gm=n(543),_m=n.n(gm);const ym="153",vm={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},xm={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Sm=0,bm=1,Mm=2,wm=3,Em=0,Tm=1,Am=2,Cm=3,Rm=0,Pm=1,Lm=2,Im=2,Nm=0,Dm=1,Om=2,Um=3,Fm=4,Bm=5,zm=100,Vm=101,km=102,Gm=103,Hm=104,Wm=200,jm=201,Xm=202,Ym=203,qm=204,$m=205,Zm=206,Jm=207,Km=208,Qm=209,tg=210,eg=0,ng=1,ig=2,rg=3,sg=4,og=5,ag=6,lg=7,cg=0,hg=1,ug=2,dg=0,pg=1,fg=2,mg=3,gg=4,_g=5,yg=300,vg=301,xg=302,Sg=303,bg=304,Mg=306,wg=1e3,Eg=1001,Tg=1002,Ag=1003,Cg=1004,Rg=1004,Pg=1005,Lg=1005,Ig=1006,Ng=1007,Dg=1007,Og=1008,Ug=1008,Fg=1009,Bg=1010,zg=1011,Vg=1012,kg=1013,Gg=1014,Hg=1015,Wg=1016,jg=1017,Xg=1018,Yg=1020,qg=1021,$g=1023,Zg=1024,Jg=1025,Kg=1026,Qg=1027,t_=1028,e_=1029,n_=1030,i_=1031,r_=1033,s_=33776,o_=33777,a_=33778,l_=33779,c_=35840,h_=35841,u_=35842,d_=35843,p_=36196,f_=37492,m_=37496,g_=37808,__=37809,y_=37810,v_=37811,x_=37812,S_=37813,b_=37814,M_=37815,w_=37816,E_=37817,T_=37818,A_=37819,C_=37820,R_=37821,P_=36492,L_=36283,I_=36284,N_=36285,D_=36286,O_=2200,U_=2201,F_=2202,B_=2300,z_=2301,V_=2302,k_=2400,G_=2401,H_=2402,W_=2500,j_=2501,X_=0,Y_=1,q_=2,$_=3e3,Z_=3001,J_=3200,K_=3201,Q_=0,ty=1,ey="",ny="srgb",iy="srgb-linear",ry="display-p3",sy=0,oy=7680,ay=7681,ly=7682,cy=7683,hy=34055,uy=34056,dy=5386,py=512,fy=513,my=514,gy=515,_y=516,yy=517,vy=518,xy=519,Sy=512,by=513,My=514,wy=515,Ey=516,Ty=517,Ay=518,Cy=519,Ry=35044,Py=35048,Ly=35040,Iy=35045,Ny=35049,Dy=35041,Oy=35046,Uy=35050,Fy=35042,By="100",zy="300 es",Vy=1035,ky=2e3,Gy=2001;class Hy{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}const Wy=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let jy=1234567;const Xy=Math.PI/180,Yy=180/Math.PI;function qy(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Wy[255&t]+Wy[t>>8&255]+Wy[t>>16&255]+Wy[t>>24&255]+"-"+Wy[255&e]+Wy[e>>8&255]+"-"+Wy[e>>16&15|64]+Wy[e>>24&255]+"-"+Wy[63&n|128]+Wy[n>>8&255]+"-"+Wy[n>>16&255]+Wy[n>>24&255]+Wy[255&i]+Wy[i>>8&255]+Wy[i>>16&255]+Wy[i>>24&255]).toLowerCase()}function $y(t,e,n){return Math.max(e,Math.min(n,t))}function Zy(t,e){return(t%e+e)%e}function Jy(t,e,n){return(1-n)*t+n*e}function Ky(t){return!(t&t-1)&&0!==t}function Qy(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function tv(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function ev(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function nv(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const iv={DEG2RAD:Xy,RAD2DEG:Yy,generateUUID:qy,clamp:$y,euclideanModulo:Zy,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Jy,damp:function(t,e,n,i){return Jy(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(Zy(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(jy=t);let e=jy+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Xy},radToDeg:function(t){return t*Yy},isPowerOfTwo:Ky,ceilPowerOfTwo:Qy,floorPowerOfTwo:tv,setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+i)/2),h=o((e+i)/2),u=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":t.set(a*h,l*u,l*d,a*c);break;case"YZY":t.set(l*d,a*h,l*u,a*c);break;case"ZXZ":t.set(l*u,l*d,a*h,a*c);break;case"XZX":t.set(a*h,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*h,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:nv,denormalize:ev};class rv{constructor(t=0,e=0){rv.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos($y(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class sv{constructor(t,e,n,i,r,s,o,a,l){sv.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,o,a,l)}set(t,e,n,i,r,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],_=i[1],y=i[4],v=i[7],x=i[2],S=i[5],b=i[8];return r[0]=s*f+o*_+a*x,r[3]=s*m+o*y+a*S,r[6]=s*g+o*v+a*b,r[1]=l*f+c*_+h*x,r[4]=l*m+c*y+h*S,r[7]=l*g+c*v+h*b,r[2]=u*f+d*_+p*x,r[5]=u*m+d*y+p*S,r[8]=u*g+d*v+p*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*r*c+n*o*a+i*r*l-i*s*a}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],h=c*s-o*l,u=o*a-c*r,d=l*r-s*a,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=h*f,t[1]=(i*l-c*n)*f,t[2]=(o*n-i*s)*f,t[3]=u*f,t[4]=(c*e-i*a)*f,t[5]=(i*r-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-i*l,i*a,-i*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(ov.makeScale(t,e)),this}rotate(t){return this.premultiply(ov.makeRotation(-t)),this}translate(t,e){return this.premultiply(ov.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const ov=new sv;function av(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const lv={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function cv(t,e){return new lv[t](e)}function hv(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}const uv={};function dv(t){t in uv||(uv[t]=!0,console.warn(t))}function pv(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function fv(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const mv=(new sv).fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-1e-7,1e-7,.9105199]),gv=(new sv).fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]),_v={[iy]:t=>t,[ny]:t=>t.convertSRGBToLinear(),[ry]:function(t){return t.convertSRGBToLinear().applyMatrix3(gv)}},yv={[iy]:t=>t,[ny]:t=>t.convertLinearToSRGB(),[ry]:function(t){return t.applyMatrix3(mv).convertLinearToSRGB()}},vv={enabled:!0,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(t){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!t},get workingColorSpace(){return iy},set workingColorSpace(t){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(t,e,n){if(!1===this.enabled||e===n||!e||!n)return t;const i=_v[e],r=yv[n];if(void 0===i||void 0===r)throw new Error(`Unsupported color space conversion, "${e}" to "${n}".`);return r(i(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)}};let xv;class Sv{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===xv&&(xv=hv("canvas")),xv.width=t.width,xv.height=t.height;const n=xv.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=xv}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=hv("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t<r.length;t++)r[t]=255*pv(r[t]/255);return n.putImageData(i,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*pv(e[t]/255)):e[t]=pv(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let bv=0;class Mv{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:bv++}),this.uuid=qy(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(null!==i){let t;if(Array.isArray(i)){t=[];for(let e=0,n=i.length;e<n;e++)i[e].isDataTexture?t.push(wv(i[e].image)):t.push(wv(i[e]))}else t=wv(i);n.url=t}return e||(t.images[this.uuid]=n),n}}function wv(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Sv.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Ev=0;class Tv extends Hy{constructor(t=Tv.DEFAULT_IMAGE,e=Tv.DEFAULT_MAPPING,n=Eg,i=Eg,r=Ig,s=Og,o=$g,a=Fg,l=Tv.DEFAULT_ANISOTROPY,c=ey){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Ev++}),this.uuid=qy(),this.name="",this.source=new Mv(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new rv(0,0),this.repeat=new rv(1,1),this.center=new rv(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new sv,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,"string"==typeof c?this.colorSpace=c:(dv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===Z_?ny:ey),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==yg)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case wg:t.x=t.x-Math.floor(t.x);break;case Eg:t.x=t.x<0?0:1;break;case Tg:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case wg:t.y=t.y-Math.floor(t.y);break;case Eg:t.y=t.y<0?0:1;break;case Tg:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return dv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===ny?Z_:$_}set encoding(t){dv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=t===Z_?ny:ey}}Tv.DEFAULT_IMAGE=null,Tv.DEFAULT_MAPPING=yg,Tv.DEFAULT_ANISOTROPY=1;class Av{constructor(t=0,e=0,n=0,i=1){Av.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],h=a[8],u=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-u)<s&&Math.abs(h-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+u)<o&&Math.abs(h+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,_=(g+1)/2,y=(c+u)/4,v=(h+f)/4,x=(p+m)/4;return t>a&&t>_?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=y/n,r=v/n):a>_?a<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(a),n=y/i,r=x/i):_<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(_),n=v/r,i=x/r),this.set(n,i,r,e),this}let _=Math.sqrt((m-p)*(m-p)+(h-f)*(h-f)+(u-c)*(u-c));return Math.abs(_)<.001&&(_=1),this.x=(m-p)/_,this.y=(h-f)/_,this.z=(u-c)/_,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Cv extends Hy{constructor(t=1,e=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new Av(0,0,t,e),this.scissorTest=!1,this.viewport=new Av(0,0,t,e);const i={width:t,height:e,depth:1};void 0!==n.encoding&&(dv("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===Z_?ny:ey),this.texture=new Tv(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Ig,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Mv(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Rv extends Tv{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Ag,this.minFilter=Ag,this.wrapR=Eg,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Pv extends Cv{constructor(t=1,e=1,n=1){super(t,e),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new Rv(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class Lv extends Tv{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=Ag,this.minFilter=Ag,this.wrapR=Eg,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Iv extends Cv{constructor(t=1,e=1,n=1){super(t,e),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new Lv(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class Nv extends Cv{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGLMultipleRenderTargets=!0;const r=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=r.clone(),this.texture[t].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}class Dv{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,s,o){let a=n[i+0],l=n[i+1],c=n[i+2],h=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===o)return t[e+0]=a,t[e+1]=l,t[e+2]=c,void(t[e+3]=h);if(1===o)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(h!==f||a!==u||l!==d||c!==p){let t=1-o;const e=a*u+l*d+c*p+h*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,o=Math.sin(o*s)/r}const r=o*n;if(a=a*t+u*r,l=l*t+d*r,c=c*t+p*r,h=h*t+f*r,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+h*h);a*=t,l*=t,c*=t,h*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],a=n[i+1],l=n[i+2],c=n[i+3],h=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=o*p+c*h+a*d-l*u,t[e+1]=a*p+c*u+l*h-o*d,t[e+2]=l*p+c*d+o*u-a*h,t[e+3]=c*p-o*h-a*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(i/2),h=o(r/2),u=a(n/2),d=a(i/2),p=a(r/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],h=e[10],u=n+o+h;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>o&&n>h){const t=2*Math.sqrt(1+n-o-h);this._w=(c-a)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(o>h){const t=2*Math.sqrt(1+o-n-h);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+h-n-o);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs($y(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+i*l-r*a,this._y=i*c+s*a+r*o-n*l,this._z=r*c+s*l+n*a-i*o,this._w=s*c-n*o-i*a-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),h=Math.sin((1-e)*c)/l,u=Math.sin(e*c)/l;return this._w=s*h+this._w*u,this._x=n*h+this._x*u,this._y=i*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(r),n*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Ov{constructor(t=0,e=0,n=0){Ov.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Fv.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Fv.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,a=t.w,l=a*e+s*i-o*n,c=a*n+o*e-r*i,h=a*i+r*n-s*e,u=-r*e-s*n-o*i;return this.x=l*a+u*-r+c*-o-h*-s,this.y=c*a+u*-s+h*-r-l*-o,this.z=h*a+u*-o+l*-s-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*s-n*a,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Uv.copy(this).projectOnVector(t),this.sub(Uv)}reflect(t){return this.sub(Uv.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos($y(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Uv=new Ov,Fv=new Dv;class Bv{constructor(t=new Ov(1/0,1/0,1/0),e=new Ov(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(Vv.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(Vv.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Vv.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){if(t.updateWorldMatrix(!1,!1),void 0!==t.boundingBox)null===t.boundingBox&&t.computeBoundingBox(),kv.copy(t.boundingBox),kv.applyMatrix4(t.matrixWorld),this.union(kv);else{const n=t.geometry;if(void 0!==n)if(e&&void 0!==n.attributes&&void 0!==n.attributes.position){const e=n.attributes.position;for(let n=0,i=e.count;n<i;n++)Vv.fromBufferAttribute(e,n).applyMatrix4(t.matrixWorld),this.expandByPoint(Vv)}else null===n.boundingBox&&n.computeBoundingBox(),kv.copy(n.boundingBox),kv.applyMatrix4(t.matrixWorld),this.union(kv)}const n=t.children;for(let t=0,i=n.length;t<i;t++)this.expandByObject(n[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Vv),Vv.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(qv),$v.subVectors(this.max,qv),Gv.subVectors(t.a,qv),Hv.subVectors(t.b,qv),Wv.subVectors(t.c,qv),jv.subVectors(Hv,Gv),Xv.subVectors(Wv,Hv),Yv.subVectors(Gv,Wv);let e=[0,-jv.z,jv.y,0,-Xv.z,Xv.y,0,-Yv.z,Yv.y,jv.z,0,-jv.x,Xv.z,0,-Xv.x,Yv.z,0,-Yv.x,-jv.y,jv.x,0,-Xv.y,Xv.x,0,-Yv.y,Yv.x,0];return!!Kv(e,Gv,Hv,Wv,$v)&&(e=[1,0,0,0,1,0,0,0,1],!!Kv(e,Gv,Hv,Wv,$v)&&(Zv.crossVectors(jv,Xv),e=[Zv.x,Zv.y,Zv.z],Kv(e,Gv,Hv,Wv,$v)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Vv).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(Vv).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(zv[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),zv[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),zv[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),zv[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),zv[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),zv[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),zv[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),zv[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(zv)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const zv=[new Ov,new Ov,new Ov,new Ov,new Ov,new Ov,new Ov,new Ov],Vv=new Ov,kv=new Bv,Gv=new Ov,Hv=new Ov,Wv=new Ov,jv=new Ov,Xv=new Ov,Yv=new Ov,qv=new Ov,$v=new Ov,Zv=new Ov,Jv=new Ov;function Kv(t,e,n,i,r){for(let s=0,o=t.length-3;s<=o;s+=3){Jv.fromArray(t,s);const o=r.x*Math.abs(Jv.x)+r.y*Math.abs(Jv.y)+r.z*Math.abs(Jv.z),a=e.dot(Jv),l=n.dot(Jv),c=i.dot(Jv);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const Qv=new Bv,tx=new Ov,ex=new Ov;class nx{constructor(t=new Ov,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Qv.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;tx.subVectors(t,this.center);const e=tx.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(tx,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(ex.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(tx.copy(t.center).add(ex)),this.expandByPoint(tx.copy(t.center).sub(ex))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const ix=new Ov,rx=new Ov,sx=new Ov,ox=new Ov,ax=new Ov,lx=new Ov,cx=new Ov;class hx{constructor(t=new Ov,e=new Ov(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,ix)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=ix.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(ix.copy(this.origin).addScaledVector(this.direction,e),ix.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){rx.copy(t).add(e).multiplyScalar(.5),sx.copy(e).sub(t).normalize(),ox.copy(this.origin).sub(rx);const r=.5*t.distanceTo(e),s=-this.direction.dot(sx),o=ox.dot(this.direction),a=-ox.dot(sx),l=ox.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*a-o,u=s*o-a,p=r*c,h>=0)if(u>=-p)if(u<=p){const t=1/c;h*=t,u*=t,d=h*(h+s*u+2*o)+u*(s*h+u+2*a)+l}else u=r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u=-r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;else u<=-p?(h=Math.max(0,-(-s*r+o)),u=h>0?-r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l):u<=p?(h=0,u=Math.min(Math.max(-r,-a),r),d=u*(u+2*a)+l):(h=Math.max(0,-(s*r+o)),u=h>0?r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l);else u=s>0?-r:r,h=Math.max(0,-(s*u+o)),d=-h*h+u*(u+2*a)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(rx).addScaledVector(sx,u),d}intersectSphere(t,e){ix.subVectors(t.center,this.origin);const n=ix.dot(this.direction),i=ix.dot(ix)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,a=n+s;return a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),c>=0?(r=(t.min.y-u.y)*c,s=(t.max.y-u.y)*c):(r=(t.max.y-u.y)*c,s=(t.min.y-u.y)*c),n>s||r>i?null:((r>n||isNaN(n))&&(n=r),(s<i||isNaN(i))&&(i=s),h>=0?(o=(t.min.z-u.z)*h,a=(t.max.z-u.z)*h):(o=(t.max.z-u.z)*h,a=(t.min.z-u.z)*h),n>a||o>i?null:((o>n||n!=n)&&(n=o),(a<i||i!=i)&&(i=a),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,ix)}intersectTriangle(t,e,n,i,r){ax.subVectors(e,t),lx.subVectors(n,t),cx.crossVectors(ax,lx);let s,o=this.direction.dot(cx);if(o>0){if(i)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}ox.subVectors(this.origin,t);const a=s*this.direction.dot(lx.crossVectors(ox,lx));if(a<0)return null;const l=s*this.direction.dot(ax.cross(ox));if(l<0)return null;if(a+l>o)return null;const c=-s*ox.dot(cx);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class ux{constructor(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m){ux.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m)}set(t,e,n,i,r,s,o,a,l,c,h,u,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new ux).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/dx.setFromMatrixColumn(t,0).length(),r=1/dx.setFromMatrixColumn(t,1).length(),s=1/dx.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(i),l=Math.sin(i),c=Math.cos(r),h=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*h,i=o*c,r=o*h;e[0]=a*c,e[4]=-a*h,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-o*a,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*h,i=l*c,r=l*h;e[0]=t+r*o,e[4]=i*o-n,e[8]=s*l,e[1]=s*h,e[5]=s*c,e[9]=-o,e[2]=n*o-i,e[6]=r+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*h,i=l*c,r=l*h;e[0]=t-r*o,e[4]=-s*h,e[8]=i+n*o,e[1]=n+i*o,e[5]=s*c,e[9]=r-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*h,i=o*c,r=o*h;e[0]=a*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=a*h,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=r-t*h,e[8]=i*h+n,e[1]=h,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*h+i,e[10]=t-r*h}else if("XZY"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=-h,e[8]=l*c,e[1]=t*h+r,e[5]=s*c,e[9]=n*h-i,e[2]=i*h-n,e[6]=o*c,e[10]=r*h+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(fx,t,mx)}lookAt(t,e,n){const i=this.elements;return yx.subVectors(t,e),0===yx.lengthSq()&&(yx.z=1),yx.normalize(),gx.crossVectors(n,yx),0===gx.lengthSq()&&(1===Math.abs(n.z)?yx.x+=1e-4:yx.z+=1e-4,yx.normalize(),gx.crossVectors(n,yx)),gx.normalize(),_x.crossVectors(yx,gx),i[0]=gx.x,i[4]=_x.x,i[8]=yx.x,i[1]=gx.y,i[5]=_x.y,i[9]=yx.y,i[2]=gx.z,i[6]=_x.z,i[10]=yx.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],_=n[3],y=n[7],v=n[11],x=n[15],S=i[0],b=i[4],M=i[8],w=i[12],E=i[1],T=i[5],A=i[9],C=i[13],R=i[2],P=i[6],L=i[10],I=i[14],N=i[3],D=i[7],O=i[11],U=i[15];return r[0]=s*S+o*E+a*R+l*N,r[4]=s*b+o*T+a*P+l*D,r[8]=s*M+o*A+a*L+l*O,r[12]=s*w+o*C+a*I+l*U,r[1]=c*S+h*E+u*R+d*N,r[5]=c*b+h*T+u*P+d*D,r[9]=c*M+h*A+u*L+d*O,r[13]=c*w+h*C+u*I+d*U,r[2]=p*S+f*E+m*R+g*N,r[6]=p*b+f*T+m*P+g*D,r[10]=p*M+f*A+m*L+g*O,r[14]=p*w+f*C+m*I+g*U,r[3]=_*S+y*E+v*R+x*N,r[7]=_*b+y*T+v*P+x*D,r[11]=_*M+y*A+v*L+x*O,r[15]=_*w+y*C+v*I+x*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],h=t[6],u=t[10],d=t[14];return t[3]*(+r*a*h-i*l*h-r*o*u+n*l*u+i*o*d-n*a*d)+t[7]*(+e*a*d-e*l*u+r*s*u-i*s*d+i*l*c-r*a*c)+t[11]*(+e*l*h-e*o*d-r*s*h+n*s*d+r*o*c-n*l*c)+t[15]*(-i*o*c-e*a*h+e*o*u+i*s*h-n*s*u+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],_=h*m*l-f*u*l+f*a*d-o*m*d-h*a*g+o*u*g,y=p*u*l-c*m*l-p*a*d+s*m*d+c*a*g-s*u*g,v=c*f*l-p*h*l+p*o*d-s*f*d-c*o*g+s*h*g,x=p*h*a-c*f*a-p*o*u+s*f*u+c*o*m-s*h*m,S=e*_+n*y+i*v+r*x;if(0===S)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/S;return t[0]=_*b,t[1]=(f*u*r-h*m*r-f*i*d+n*m*d+h*i*g-n*u*g)*b,t[2]=(o*m*r-f*a*r+f*i*l-n*m*l-o*i*g+n*a*g)*b,t[3]=(h*a*r-o*u*r-h*i*l+n*u*l+o*i*d-n*a*d)*b,t[4]=y*b,t[5]=(c*m*r-p*u*r+p*i*d-e*m*d-c*i*g+e*u*g)*b,t[6]=(p*a*r-s*m*r-p*i*l+e*m*l+s*i*g-e*a*g)*b,t[7]=(s*u*r-c*a*r+c*i*l-e*u*l-s*i*d+e*a*d)*b,t[8]=v*b,t[9]=(p*h*r-c*f*r-p*n*d+e*f*d+c*n*g-e*h*g)*b,t[10]=(s*f*r-p*o*r+p*n*l-e*f*l-s*n*g+e*o*g)*b,t[11]=(c*o*r-s*h*r-c*n*l+e*h*l+s*n*d-e*o*d)*b,t[12]=x*b,t[13]=(c*f*i-p*h*i+p*n*u-e*f*u-c*n*m+e*h*m)*b,t[14]=(p*o*i-s*f*i-p*n*a+e*f*a+s*n*m-e*o*m)*b,t[15]=(s*h*i-c*o*i+c*n*a-e*h*a-s*n*u+e*o*u)*b,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,a=t.z,l=r*s,c=r*o;return this.set(l*s+n,l*o-i*a,l*a+i*o,0,l*o+i*a,c*o+n,c*a-i*s,0,l*a-i*o,c*a+i*s,r*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,a=e._w,l=r+r,c=s+s,h=o+o,u=r*l,d=r*c,p=r*h,f=s*c,m=s*h,g=o*h,_=a*l,y=a*c,v=a*h,x=n.x,S=n.y,b=n.z;return i[0]=(1-(f+g))*x,i[1]=(d+v)*x,i[2]=(p-y)*x,i[3]=0,i[4]=(d-v)*S,i[5]=(1-(u+g))*S,i[6]=(m+_)*S,i[7]=0,i[8]=(p+y)*b,i[9]=(m-_)*b,i[10]=(1-(u+f))*b,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=dx.set(i[0],i[1],i[2]).length();const s=dx.set(i[4],i[5],i[6]).length(),o=dx.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],px.copy(this);const a=1/r,l=1/s,c=1/o;return px.elements[0]*=a,px.elements[1]*=a,px.elements[2]*=a,px.elements[4]*=l,px.elements[5]*=l,px.elements[6]*=l,px.elements[8]*=c,px.elements[9]*=c,px.elements[10]*=c,e.setFromRotationMatrix(px),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s,o=ky){const a=this.elements,l=2*r/(e-t),c=2*r/(n-i),h=(e+t)/(e-t),u=(n+i)/(n-i);let d,p;if(o===ky)d=-(s+r)/(s-r),p=-2*s*r/(s-r);else{if(o!==Gy)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);d=-s/(s-r),p=-s*r/(s-r)}return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,r,s,o=ky){const a=this.elements,l=1/(e-t),c=1/(n-i),h=1/(s-r),u=(e+t)*l,d=(n+i)*c;let p,f;if(o===ky)p=(s+r)*h,f=-2*h;else{if(o!==Gy)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);p=r*h,f=-1*h}return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=f,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const dx=new Ov,px=new ux,fx=new Ov(0,0,0),mx=new Ov(1,1,1),gx=new Ov,_x=new Ov,yx=new Ov,vx=new ux,xx=new Dv;class Sx{constructor(t=0,e=0,n=0,i=Sx.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],o=i[8],a=i[1],l=i[5],c=i[9],h=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin($y(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-$y(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin($y(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-$y(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin($y(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-$y(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return vx.makeRotationFromQuaternion(t),this.setFromRotationMatrix(vx,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return xx.setFromEuler(this),this.setFromQuaternion(xx,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Sx.DEFAULT_ORDER="XYZ";class bx{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let Mx=0;const wx=new Ov,Ex=new Dv,Tx=new ux,Ax=new Ov,Cx=new Ov,Rx=new Ov,Px=new Dv,Lx=new Ov(1,0,0),Ix=new Ov(0,1,0),Nx=new Ov(0,0,1),Dx={type:"added"},Ox={type:"removed"};class Ux extends Hy{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Mx++}),this.uuid=qy(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ux.DEFAULT_UP.clone();const t=new Ov,e=new Sx,n=new Dv,i=new Ov(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ux},normalMatrix:{value:new sv}}),this.matrix=new ux,this.matrixWorld=new ux,this.matrixAutoUpdate=Ux.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=Ux.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new bx,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Ex.setFromAxisAngle(t,e),this.quaternion.multiply(Ex),this}rotateOnWorldAxis(t,e){return Ex.setFromAxisAngle(t,e),this.quaternion.premultiply(Ex),this}rotateX(t){return this.rotateOnAxis(Lx,t)}rotateY(t){return this.rotateOnAxis(Ix,t)}rotateZ(t){return this.rotateOnAxis(Nx,t)}translateOnAxis(t,e){return wx.copy(t).applyQuaternion(this.quaternion),this.position.add(wx.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Lx,t)}translateY(t){return this.translateOnAxis(Ix,t)}translateZ(t){return this.translateOnAxis(Nx,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Tx.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Ax.copy(t):Ax.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Cx.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Tx.lookAt(Cx,Ax,this.up):Tx.lookAt(Ax,Cx,this.up),this.quaternion.setFromRotationMatrix(Tx),i&&(Tx.extractRotation(i.matrixWorld),Ex.setFromRotationMatrix(Tx),this.quaternion.premultiply(Ex.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Dx)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Ox)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Ox)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Tx.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),Tx.multiply(t.parent.matrixWorld)),t.applyMatrix4(Tx),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getObjectsByProperty(t,e){let n=[];this[t]===e&&n.push(this);for(let i=0,r=this.children.length;i<r;i++){const r=this.children[i].getObjectsByProperty(t,e);r.length>0&&(n=n.concat(r))}return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Cx,t,Rx),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Cx,Px,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++){const i=e[n];!0!==i.matrixWorldAutoUpdate&&!0!==t||i.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&!0===n.matrixWorldAutoUpdate&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++){const n=t[e];!0===n.matrixWorldAutoUpdate&&n.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations),h=s(t.nodes);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),h.length>0&&(n.nodes=h)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}Ux.DEFAULT_UP=new Ov(0,1,0),Ux.DEFAULT_MATRIX_AUTO_UPDATE=!0,Ux.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Fx=new Ov,Bx=new Ov,zx=new Ov,Vx=new Ov,kx=new Ov,Gx=new Ov,Hx=new Ov,Wx=new Ov,jx=new Ov,Xx=new Ov;let Yx=!1;class qx{constructor(t=new Ov,e=new Ov,n=new Ov){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Fx.subVectors(t,e),i.cross(Fx);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){Fx.subVectors(i,e),Bx.subVectors(n,e),zx.subVectors(t,e);const s=Fx.dot(Fx),o=Fx.dot(Bx),a=Fx.dot(zx),l=Bx.dot(Bx),c=Bx.dot(zx),h=s*l-o*o;if(0===h)return r.set(-2,-1,-1);const u=1/h,d=(l*a-o*c)*u,p=(s*c-o*a)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Vx),Vx.x>=0&&Vx.y>=0&&Vx.x+Vx.y<=1}static getUV(t,e,n,i,r,s,o,a){return!1===Yx&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Yx=!0),this.getInterpolation(t,e,n,i,r,s,o,a)}static getInterpolation(t,e,n,i,r,s,o,a){return this.getBarycoord(t,e,n,i,Vx),a.setScalar(0),a.addScaledVector(r,Vx.x),a.addScaledVector(s,Vx.y),a.addScaledVector(o,Vx.z),a}static isFrontFacing(t,e,n,i){return Fx.subVectors(n,e),Bx.subVectors(t,e),Fx.cross(Bx).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Fx.subVectors(this.c,this.b),Bx.subVectors(this.a,this.b),.5*Fx.cross(Bx).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return qx.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return qx.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return!1===Yx&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Yx=!0),qx.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}getInterpolation(t,e,n,i,r){return qx.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return qx.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return qx.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,o;kx.subVectors(i,n),Gx.subVectors(r,n),Wx.subVectors(t,n);const a=kx.dot(Wx),l=Gx.dot(Wx);if(a<=0&&l<=0)return e.copy(n);jx.subVectors(t,i);const c=kx.dot(jx),h=Gx.dot(jx);if(c>=0&&h<=c)return e.copy(i);const u=a*h-c*l;if(u<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(kx,s);Xx.subVectors(t,r);const d=kx.dot(Xx),p=Gx.dot(Xx);if(p>=0&&d<=p)return e.copy(r);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(Gx,o);const m=c*p-d*h;if(m<=0&&h-c>=0&&d-p>=0)return Hx.subVectors(r,i),o=(h-c)/(h-c+(d-p)),e.copy(i).addScaledVector(Hx,o);const g=1/(m+f+u);return s=f*g,o=u*g,e.copy(n).addScaledVector(kx,s).addScaledVector(Gx,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let $x=0;class Zx extends Hy{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:$x++}),this.uuid=qy(),this.name="",this.type="Material",this.blending=Dm,this.side=Rm,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=qm,this.blendDst=$m,this.blendEquation=zm,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=rg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=xy,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=oy,this.stencilZFail=oy,this.stencilZPass=oy,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(n.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Dm&&(n.blending=this.blending),this.side!==Rm&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.forceSinglePass&&(n.forceSinglePass=this.forceSinglePass),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}const Jx={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Kx={h:0,s:0,l:0},Qx={h:0,s:0,l:0};function tS(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}class eS{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(void 0===e&&void 0===n){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=ny){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,vv.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=vv.workingColorSpace){return this.r=t,this.g=e,this.b=n,vv.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=vv.workingColorSpace){if(t=Zy(t,1),e=$y(e,0,1),n=$y(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=tS(r,i,t+1/3),this.g=tS(r,i,t),this.b=tS(r,i,t-1/3)}return vv.toWorkingColorSpace(this,i),this}setStyle(t,e=ny){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=i[1],r=n.length;if(3===r)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(6===r)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=ny){const n=Jx[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=pv(t.r),this.g=pv(t.g),this.b=pv(t.b),this}copyLinearToSRGB(t){return this.r=fv(t.r),this.g=fv(t.g),this.b=fv(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ny){return vv.fromWorkingColorSpace(nS.copy(this),t),65536*Math.round($y(255*nS.r,0,255))+256*Math.round($y(255*nS.g,0,255))+Math.round($y(255*nS.b,0,255))}getHexString(t=ny){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=vv.workingColorSpace){vv.fromWorkingColorSpace(nS.copy(this),e);const n=nS.r,i=nS.g,r=nS.b,s=Math.max(n,i,r),o=Math.min(n,i,r);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const t=s-o;switch(l=c<=.5?t/(s+o):t/(2-s-o),s){case n:a=(i-r)/t+(i<r?6:0);break;case i:a=(r-n)/t+2;break;case r:a=(n-i)/t+4}a/=6}return t.h=a,t.s=l,t.l=c,t}getRGB(t,e=vv.workingColorSpace){return vv.fromWorkingColorSpace(nS.copy(this),e),t.r=nS.r,t.g=nS.g,t.b=nS.b,t}getStyle(t=ny){vv.fromWorkingColorSpace(nS.copy(this),t);const e=nS.r,n=nS.g,i=nS.b;return t!==ny?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`}offsetHSL(t,e,n){return this.getHSL(Kx),Kx.h+=t,Kx.s+=e,Kx.l+=n,this.setHSL(Kx.h,Kx.s,Kx.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Kx),t.getHSL(Qx);const n=Jy(Kx.h,Qx.h,e),i=Jy(Kx.s,Qx.s,e),r=Jy(Kx.l,Qx.l,e);return this.setHSL(n,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*n+r[6]*i,this.g=r[1]*e+r[4]*n+r[7]*i,this.b=r[2]*e+r[5]*n+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const nS=new eS;eS.NAMES=Jx;class iS extends Zx{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new eS(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const rS=sS();function sS(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),i=new Uint32Array(512),r=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(i[t]=0,i[256|t]=32768,r[t]=24,r[256|t]=24):e<-14?(i[t]=1024>>-e-14,i[256|t]=1024>>-e-14|32768,r[t]=-e-1,r[256|t]=-e-1):e<=15?(i[t]=e+15<<10,i[256|t]=e+15<<10|32768,r[t]=13,r[256|t]=13):e<128?(i[t]=31744,i[256|t]=64512,r[t]=24,r[256|t]=24):(i[t]=31744,i[256|t]=64512,r[t]=13,r[256|t]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,s[t]=e|n}for(let t=1024;t<2048;++t)s[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)o[t]=t<<23;o[31]=1199570944,o[32]=2147483648;for(let t=33;t<63;++t)o[t]=2147483648+(t-32<<23);o[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(a[t]=1024);return{floatView:e,uint32View:n,baseTable:i,shiftTable:r,mantissaTable:s,exponentTable:o,offsetTable:a}}function oS(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=$y(t,-65504,65504),rS.floatView[0]=t;const e=rS.uint32View[0],n=e>>23&511;return rS.baseTable[n]+((8388607&e)>>rS.shiftTable[n])}function aS(t){const e=t>>10;return rS.uint32View[0]=rS.mantissaTable[rS.offsetTable[e]+(1023&t)]+rS.exponentTable[e],rS.floatView[0]}const lS={toHalfFloat:oS,fromHalfFloat:aS},cS=new Ov,hS=new rv;class uS{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=n,this.usage=Ry,this.updateRange={offset:0,count:-1},this.gpuType=Hg,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)hS.fromBufferAttribute(this,e),hS.applyMatrix3(t),this.setXY(e,hS.x,hS.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)cS.fromBufferAttribute(this,e),cS.applyMatrix3(t),this.setXYZ(e,cS.x,cS.y,cS.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)cS.fromBufferAttribute(this,e),cS.applyMatrix4(t),this.setXYZ(e,cS.x,cS.y,cS.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)cS.fromBufferAttribute(this,e),cS.applyNormalMatrix(t),this.setXYZ(e,cS.x,cS.y,cS.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)cS.fromBufferAttribute(this,e),cS.transformDirection(t),this.setXYZ(e,cS.x,cS.y,cS.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=ev(e,this.array)),e}setX(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=ev(e,this.array)),e}setY(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=ev(e,this.array)),e}setZ(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=ev(e,this.array)),e}setW(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array),r=nv(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==Ry&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class dS extends uS{constructor(t,e,n){super(new Int8Array(t),e,n)}}class pS extends uS{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class fS extends uS{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class mS extends uS{constructor(t,e,n){super(new Int16Array(t),e,n)}}class gS extends uS{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class _S extends uS{constructor(t,e,n){super(new Int32Array(t),e,n)}}class yS extends uS{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class vS extends uS{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}getX(t){let e=aS(this.array[t*this.itemSize]);return this.normalized&&(e=ev(e,this.array)),e}setX(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize]=oS(e),this}getY(t){let e=aS(this.array[t*this.itemSize+1]);return this.normalized&&(e=ev(e,this.array)),e}setY(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+1]=oS(e),this}getZ(t){let e=aS(this.array[t*this.itemSize+2]);return this.normalized&&(e=ev(e,this.array)),e}setZ(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+2]=oS(e),this}getW(t){let e=aS(this.array[t*this.itemSize+3]);return this.normalized&&(e=ev(e,this.array)),e}setW(t,e){return this.normalized&&(e=nv(e,this.array)),this.array[t*this.itemSize+3]=oS(e),this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array)),this.array[t+0]=oS(e),this.array[t+1]=oS(n),this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array)),this.array[t+0]=oS(e),this.array[t+1]=oS(n),this.array[t+2]=oS(i),this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array),r=nv(r,this.array)),this.array[t+0]=oS(e),this.array[t+1]=oS(n),this.array[t+2]=oS(i),this.array[t+3]=oS(r),this}}class xS extends uS{constructor(t,e,n){super(new Float32Array(t),e,n)}}class SS extends uS{constructor(t,e,n){super(new Float64Array(t),e,n)}}let bS=0;const MS=new ux,wS=new Ux,ES=new Ov,TS=new Bv,AS=new Bv,CS=new Ov;class RS extends Hy{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:bS++}),this.uuid=qy(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(av(t)?yS:gS)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new sv).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return MS.makeRotationFromQuaternion(t),this.applyMatrix4(MS),this}rotateX(t){return MS.makeRotationX(t),this.applyMatrix4(MS),this}rotateY(t){return MS.makeRotationY(t),this.applyMatrix4(MS),this}rotateZ(t){return MS.makeRotationZ(t),this.applyMatrix4(MS),this}translate(t,e,n){return MS.makeTranslation(t,e,n),this.applyMatrix4(MS),this}scale(t,e,n){return MS.makeScale(t,e,n),this.applyMatrix4(MS),this}lookAt(t){return wS.lookAt(t),wS.updateMatrix(),this.applyMatrix4(wS.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ES).negate(),this.translate(ES.x,ES.y,ES.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new xS(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Bv);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Ov(-1/0,-1/0,-1/0),new Ov(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];TS.setFromBufferAttribute(n),this.morphTargetsRelative?(CS.addVectors(this.boundingBox.min,TS.min),this.boundingBox.expandByPoint(CS),CS.addVectors(this.boundingBox.max,TS.max),this.boundingBox.expandByPoint(CS)):(this.boundingBox.expandByPoint(TS.min),this.boundingBox.expandByPoint(TS.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new nx);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Ov,1/0);if(t){const n=this.boundingSphere.center;if(TS.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];AS.setFromBufferAttribute(n),this.morphTargetsRelative?(CS.addVectors(TS.min,AS.min),TS.expandByPoint(CS),CS.addVectors(TS.max,AS.max),TS.expandByPoint(CS)):(TS.expandByPoint(AS.min),TS.expandByPoint(AS.max))}TS.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)CS.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(CS));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],o=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)CS.fromBufferAttribute(s,e),o&&(ES.fromBufferAttribute(t,e),CS.add(ES)),i=Math.max(i,n.distanceToSquared(CS))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new uS(new Float32Array(4*o),4));const a=this.getAttribute("tangent").array,l=[],c=[];for(let t=0;t<o;t++)l[t]=new Ov,c[t]=new Ov;const h=new Ov,u=new Ov,d=new Ov,p=new rv,f=new rv,m=new rv,g=new Ov,_=new Ov;function y(t,e,n){h.fromArray(i,3*t),u.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),u.sub(h),d.sub(h),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(u).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),_.copy(d).multiplyScalar(f.x).addScaledVector(u,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(_),c[e].add(_),c[n].add(_))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let t=0,e=v.length;t<e;++t){const e=v[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)y(n[t+0],n[t+1],n[t+2])}const x=new Ov,S=new Ov,b=new Ov,M=new Ov;function w(t){b.fromArray(r,3*t),M.copy(b);const e=l[t];x.copy(e),x.sub(b.multiplyScalar(b.dot(e))).normalize(),S.crossVectors(M,e);const n=S.dot(c[t])<0?-1:1;a[4*t]=x.x,a[4*t+1]=x.y,a[4*t+2]=x.z,a[4*t+3]=n}for(let t=0,e=v.length;t<e;++t){const e=v[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)w(n[t+0]),w(n[t+1]),w(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new uS(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new Ov,r=new Ov,s=new Ov,o=new Ov,a=new Ov,l=new Ov,c=new Ov,h=new Ov;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),f=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,o=e.count;t<o;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)CS.fromBufferAttribute(t,e),CS.normalize(),t.setXYZ(e,CS.x,CS.y,CS.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let o=0,a=0;for(let r=0,l=e.length;r<l;r++){o=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)s[a++]=n[o++]}return new uS(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new RS,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],o=r[i];for(let e=0,i=o.length;e<i;e++){const i=t(o[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];s.push(i.toJSON(t.data))}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const PS=new ux,LS=new hx,IS=new nx,NS=new Ov,DS=new Ov,OS=new Ov,US=new Ov,FS=new Ov,BS=new Ov,zS=new rv,VS=new rv,kS=new rv,GS=new Ov,HS=new Ov,WS=new Ov,jS=new Ov,XS=new Ov;class YS extends Ux{constructor(t=new RS,e=new iS){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,s=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const o=this.morphTargetInfluences;if(r&&o){BS.set(0,0,0);for(let n=0,i=r.length;n<i;n++){const i=o[n],a=r[n];0!==i&&(FS.fromBufferAttribute(a,t),s?BS.addScaledVector(FS,i):BS.addScaledVector(FS.sub(e),i))}e.add(BS)}return e}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0!==i){if(null===n.boundingSphere&&n.computeBoundingSphere(),IS.copy(n.boundingSphere),IS.applyMatrix4(r),LS.copy(t.ray).recast(t.near),!1===IS.containsPoint(LS.origin)){if(null===LS.intersectSphere(IS,NS))return;if(LS.origin.distanceToSquared(NS)>(t.far-t.near)**2)return}PS.copy(r).invert(),LS.copy(t.ray).applyMatrix4(PS),null!==n.boundingBox&&!1===LS.intersectsBox(n.boundingBox)||this._computeIntersections(t,e,LS)}}_computeIntersections(t,e,n){let i;const r=this.geometry,s=this.material,o=r.index,a=r.attributes.position,l=r.attributes.uv,c=r.attributes.uv1,h=r.attributes.normal,u=r.groups,d=r.drawRange;if(null!==o)if(Array.isArray(s))for(let r=0,a=u.length;r<a;r++){const a=u[r],p=s[a.materialIndex];for(let r=Math.max(a.start,d.start),s=Math.min(o.count,Math.min(a.start+a.count,d.start+d.count));r<s;r+=3)i=qS(this,p,t,n,l,c,h,o.getX(r),o.getX(r+1),o.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=a.materialIndex,e.push(i))}else for(let r=Math.max(0,d.start),a=Math.min(o.count,d.start+d.count);r<a;r+=3)i=qS(this,s,t,n,l,c,h,o.getX(r),o.getX(r+1),o.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),e.push(i));else if(void 0!==a)if(Array.isArray(s))for(let r=0,o=u.length;r<o;r++){const o=u[r],p=s[o.materialIndex];for(let r=Math.max(o.start,d.start),s=Math.min(a.count,Math.min(o.start+o.count,d.start+d.count));r<s;r+=3)i=qS(this,p,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=o.materialIndex,e.push(i))}else for(let r=Math.max(0,d.start),o=Math.min(a.count,d.start+d.count);r<o;r+=3)i=qS(this,s,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}function qS(t,e,n,i,r,s,o,a,l,c){t.getVertexPosition(a,DS),t.getVertexPosition(l,OS),t.getVertexPosition(c,US);const h=function(t,e,n,i,r,s,o,a){let l;if(l=e.side===Pm?i.intersectTriangle(o,s,r,!0,a):i.intersectTriangle(r,s,o,e.side===Rm,a),null===l)return null;XS.copy(a),XS.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(XS);return c<n.near||c>n.far?null:{distance:c,point:XS.clone(),object:t}}(t,e,n,i,DS,OS,US,jS);if(h){r&&(zS.fromBufferAttribute(r,a),VS.fromBufferAttribute(r,l),kS.fromBufferAttribute(r,c),h.uv=qx.getInterpolation(jS,DS,OS,US,zS,VS,kS,new rv)),s&&(zS.fromBufferAttribute(s,a),VS.fromBufferAttribute(s,l),kS.fromBufferAttribute(s,c),h.uv1=qx.getInterpolation(jS,DS,OS,US,zS,VS,kS,new rv),h.uv2=h.uv1),o&&(GS.fromBufferAttribute(o,a),HS.fromBufferAttribute(o,l),WS.fromBufferAttribute(o,c),h.normal=qx.getInterpolation(jS,DS,OS,US,GS,HS,WS,new Ov),h.normal.dot(i.direction)>0&&h.normal.multiplyScalar(-1));const t={a,b:l,c,normal:new Ov,materialIndex:0};qx.getNormal(DS,OS,US,t.normal),h.face=t}return h}class $S extends RS{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],h=[];let u=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,_){const y=s/m,v=p/g,x=s/2,S=p/2,b=f/2,M=m+1,w=g+1;let E=0,T=0;const A=new Ov;for(let s=0;s<w;s++){const o=s*v-S;for(let a=0;a<M;a++){const u=a*y-x;A[t]=u*i,A[e]=o*r,A[n]=b,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),h.push(a/m),h.push(1-s/g),E+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=u+e+M*t,i=u+e+M*(t+1),r=u+(e+1)+M*(t+1),s=u+(e+1)+M*t;a.push(n,i,s),a.push(i,r,s),T+=6}o.addGroup(d,T,_),d+=T,u+=E}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(a),this.setAttribute("position",new xS(l,3)),this.setAttribute("normal",new xS(c,3)),this.setAttribute("uv",new xS(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new $S(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ZS(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][i]=null):e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function JS(t){const e={};for(let n=0;n<t.length;n++){const i=ZS(t[n]);for(const t in i)e[t]=i[t]}return e}function KS(t){return null===t.getRenderTarget()?t.outputColorSpace:iy}const QS={clone:ZS,merge:JS};class tb extends Zx{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ZS(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class eb extends Ux{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ux,this.projectionMatrix=new ux,this.projectionMatrixInverse=new ux,this.coordinateSystem=ky}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class nb extends eb{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*Yy*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Xy*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*Yy*Math.atan(Math.tan(.5*Xy*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Xy*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/o,i*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const ib=-90;class rb extends Ux{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null;const i=new nb(ib,1,t,e);i.layers=this.layers,this.add(i);const r=new nb(ib,1,t,e);r.layers=this.layers,this.add(r);const s=new nb(ib,1,t,e);s.layers=this.layers,this.add(s);const o=new nb(ib,1,t,e);o.layers=this.layers,this.add(o);const a=new nb(ib,1,t,e);a.layers=this.layers,this.add(a);const l=new nb(ib,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,r,s,o,a]=e;for(const t of e)this.remove(t);if(t===ky)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),s.up.set(0,0,1),s.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),a.up.set(0,1,0),a.lookAt(0,0,-1);else{if(t!==Gy)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),s.up.set(0,0,-1),s.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),a.up.set(0,-1,0),a.lookAt(0,0,-1)}for(const t of e)this.add(t),t.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[i,r,s,o,a,l]=this.children,c=t.getRenderTarget(),h=t.toneMapping,u=t.xr.enabled;t.toneMapping=dg,t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(c),t.toneMapping=h,t.xr.enabled=u,n.texture.needsPMREMUpdate=!0}}class sb extends Tv{constructor(t,e,n,i,r,s,o,a,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:vg,n,i,r,s,o,a,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class ob extends Cv{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];void 0!==e.encoding&&(dv("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),e.colorSpace=e.encoding===Z_?ny:ey),this.texture=new sb(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:Ig}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},i="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",r="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new $S(5,5,5),o=new tb({name:"CubemapFromEquirect",uniforms:ZS(n),vertexShader:i,fragmentShader:r,side:Pm,blending:Nm});o.uniforms.tEquirect.value=e;const a=new YS(s,o),l=e.minFilter;return e.minFilter===Og&&(e.minFilter=Ig),new rb(1,10,this).update(t,a),e.minFilter=l,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}const ab=new Ov,lb=new Ov,cb=new sv;class hb{constructor(t=new Ov(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=ab.subVectors(n,e).cross(lb.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(ab),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(n,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||cb.getNormalMatrix(t),i=this.coplanarPoint(ab).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const ub=new nx,db=new Ov;class pb{constructor(t=new hb,e=new hb,n=new hb,i=new hb,r=new hb,s=new hb){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=ky){const n=this.planes,i=t.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],h=i[6],u=i[7],d=i[8],p=i[9],f=i[10],m=i[11],g=i[12],_=i[13],y=i[14],v=i[15];if(n[0].setComponents(a-r,u-l,m-d,v-g).normalize(),n[1].setComponents(a+r,u+l,m+d,v+g).normalize(),n[2].setComponents(a+s,u+c,m+p,v+_).normalize(),n[3].setComponents(a-s,u-c,m-p,v-_).normalize(),n[4].setComponents(a-o,u-h,m-f,v-y).normalize(),e===ky)n[5].setComponents(a+o,u+h,m+f,v+y).normalize();else{if(e!==Gy)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);n[5].setComponents(o,h,f,y).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),ub.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),ub.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(ub)}intersectsSprite(t){return ub.center.set(0,0,0),ub.radius=.7071067811865476,ub.applyMatrix4(t.matrixWorld),this.intersectsSphere(ub)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(db.x=i.normal.x>0?t.max.x:t.min.x,db.y=i.normal.y>0?t.max.y:t.min.y,db.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(db)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function fb(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function mb(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,o=t.createBuffer();let a;if(t.bindBuffer(i,o),t.bufferData(i,r,s),e.onUploadCallback(),r instanceof Float32Array)a=t.FLOAT;else if(r instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");a=t.HALF_FLOAT}else a=t.UNSIGNED_SHORT;else if(r instanceof Int16Array)a=t.SHORT;else if(r instanceof Uint32Array)a=t.UNSIGNED_INT;else if(r instanceof Int32Array)a=t.INT;else if(r instanceof Int8Array)a=t.BYTE;else if(r instanceof Uint8Array)a=t.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);a=t.UNSIGNED_BYTE}return{buffer:o,type:a,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(function(e,i,r){const s=i.array,o=i.updateRange;t.bindBuffer(r,e),-1===o.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1),i.onUploadCallback()}(s.buffer,e,r),s.version=e.version)}}}class gb extends RS{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),a=Math.floor(i),l=o+1,c=a+1,h=t/o,u=e/a,d=[],p=[],f=[],m=[];for(let t=0;t<c;t++){const e=t*u-s;for(let n=0;n<l;n++){const i=n*h-r;p.push(i,-e,0),f.push(0,0,1),m.push(n/o),m.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<o;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new xS(p,3)),this.setAttribute("normal",new xS(f,3)),this.setAttribute("uv",new xS(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new gb(t.width,t.height,t.widthSegments,t.heightSegments)}}const _b={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},yb={common:{diffuse:{value:new eS(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new sv},alphaMap:{value:null},alphaMapTransform:{value:new sv},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new sv}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new sv}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new sv}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new sv},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new sv},normalScale:{value:new rv(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new sv},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new sv}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new sv}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new sv}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new eS(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new eS(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new sv},alphaTest:{value:0},uvTransform:{value:new sv}},sprite:{diffuse:{value:new eS(16777215)},opacity:{value:1},center:{value:new rv(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new sv},alphaMap:{value:null},alphaMapTransform:{value:new sv},alphaTest:{value:0}}},vb={basic:{uniforms:JS([yb.common,yb.specularmap,yb.envmap,yb.aomap,yb.lightmap,yb.fog]),vertexShader:_b.meshbasic_vert,fragmentShader:_b.meshbasic_frag},lambert:{uniforms:JS([yb.common,yb.specularmap,yb.envmap,yb.aomap,yb.lightmap,yb.emissivemap,yb.bumpmap,yb.normalmap,yb.displacementmap,yb.fog,yb.lights,{emissive:{value:new eS(0)}}]),vertexShader:_b.meshlambert_vert,fragmentShader:_b.meshlambert_frag},phong:{uniforms:JS([yb.common,yb.specularmap,yb.envmap,yb.aomap,yb.lightmap,yb.emissivemap,yb.bumpmap,yb.normalmap,yb.displacementmap,yb.fog,yb.lights,{emissive:{value:new eS(0)},specular:{value:new eS(1118481)},shininess:{value:30}}]),vertexShader:_b.meshphong_vert,fragmentShader:_b.meshphong_frag},standard:{uniforms:JS([yb.common,yb.envmap,yb.aomap,yb.lightmap,yb.emissivemap,yb.bumpmap,yb.normalmap,yb.displacementmap,yb.roughnessmap,yb.metalnessmap,yb.fog,yb.lights,{emissive:{value:new eS(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:_b.meshphysical_vert,fragmentShader:_b.meshphysical_frag},toon:{uniforms:JS([yb.common,yb.aomap,yb.lightmap,yb.emissivemap,yb.bumpmap,yb.normalmap,yb.displacementmap,yb.gradientmap,yb.fog,yb.lights,{emissive:{value:new eS(0)}}]),vertexShader:_b.meshtoon_vert,fragmentShader:_b.meshtoon_frag},matcap:{uniforms:JS([yb.common,yb.bumpmap,yb.normalmap,yb.displacementmap,yb.fog,{matcap:{value:null}}]),vertexShader:_b.meshmatcap_vert,fragmentShader:_b.meshmatcap_frag},points:{uniforms:JS([yb.points,yb.fog]),vertexShader:_b.points_vert,fragmentShader:_b.points_frag},dashed:{uniforms:JS([yb.common,yb.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:_b.linedashed_vert,fragmentShader:_b.linedashed_frag},depth:{uniforms:JS([yb.common,yb.displacementmap]),vertexShader:_b.depth_vert,fragmentShader:_b.depth_frag},normal:{uniforms:JS([yb.common,yb.bumpmap,yb.normalmap,yb.displacementmap,{opacity:{value:1}}]),vertexShader:_b.meshnormal_vert,fragmentShader:_b.meshnormal_frag},sprite:{uniforms:JS([yb.sprite,yb.fog]),vertexShader:_b.sprite_vert,fragmentShader:_b.sprite_frag},background:{uniforms:{uvTransform:{value:new sv},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:_b.background_vert,fragmentShader:_b.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:_b.backgroundCube_vert,fragmentShader:_b.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:_b.cube_vert,fragmentShader:_b.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:_b.equirect_vert,fragmentShader:_b.equirect_frag},distanceRGBA:{uniforms:JS([yb.common,yb.displacementmap,{referencePosition:{value:new Ov},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:_b.distanceRGBA_vert,fragmentShader:_b.distanceRGBA_frag},shadow:{uniforms:JS([yb.lights,yb.fog,{color:{value:new eS(0)},opacity:{value:1}}]),vertexShader:_b.shadow_vert,fragmentShader:_b.shadow_frag}};vb.physical={uniforms:JS([vb.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new sv},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new sv},clearcoatNormalScale:{value:new rv(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new sv},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new sv},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new sv},sheen:{value:0},sheenColor:{value:new eS(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new sv},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new sv},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new sv},transmissionSamplerSize:{value:new rv},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new sv},attenuationDistance:{value:0},attenuationColor:{value:new eS(0)},specularColor:{value:new eS(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new sv},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new sv},anisotropyVector:{value:new rv},anisotropyMap:{value:null},anisotropyMapTransform:{value:new sv}}]),vertexShader:_b.meshphysical_vert,fragmentShader:_b.meshphysical_frag};const xb={r:0,b:0,g:0};function Sb(t,e,n,i,r,s,o){const a=new eS(0);let l,c,h=!0===s?0:1,u=null,d=0,p=null;function f(e,n){e.getRGB(xb,KS(t)),i.buffers.color.setClear(xb.r,xb.g,xb.b,n,o)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),h=e,f(a,h)},getClearAlpha:function(){return h},setClearAlpha:function(t){h=t,f(a,h)},render:function(s,m){let g=!1,_=!0===m.isScene?m.background:null;switch(_&&_.isTexture&&(_=(m.backgroundBlurriness>0?n:e).get(_)),null===_?f(a,h):_&&_.isColor&&(f(_,1),g=!0),t.xr.getEnvironmentBlendMode()){case"opaque":g=!0;break;case"additive":i.buffers.color.setClear(0,0,0,1,o),g=!0;break;case"alpha-blend":i.buffers.color.setClear(0,0,0,0,o),g=!0}(t.autoClear||g)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),_&&(_.isCubeTexture||_.mapping===Mg)?(void 0===c&&(c=new YS(new $S(1,1,1),new tb({name:"BackgroundCubeMaterial",uniforms:ZS(vb.backgroundCube.uniforms),vertexShader:vb.backgroundCube.vertexShader,fragmentShader:vb.backgroundCube.fragmentShader,side:Pm,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=_,c.material.uniforms.flipEnvMap.value=_.isCubeTexture&&!1===_.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=m.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,c.material.toneMapped=_.colorSpace!==ny,u===_&&d===_.version&&p===t.toneMapping||(c.material.needsUpdate=!0,u=_,d=_.version,p=t.toneMapping),c.layers.enableAll(),s.unshift(c,c.geometry,c.material,0,0,null)):_&&_.isTexture&&(void 0===l&&(l=new YS(new gb(2,2),new tb({name:"BackgroundMaterial",uniforms:ZS(vb.background.uniforms),vertexShader:vb.background.vertexShader,fragmentShader:vb.background.fragmentShader,side:Rm,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(l)),l.material.uniforms.t2D.value=_,l.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,l.material.toneMapped=_.colorSpace!==ny,!0===_.matrixAutoUpdate&&_.updateMatrix(),l.material.uniforms.uvTransform.value.copy(_.matrix),u===_&&d===_.version&&p===t.toneMapping||(l.material.needsUpdate=!0,u=_,d=_.version,p=t.toneMapping),l.layers.enableAll(),s.unshift(l,l.geometry,l.material,0,0,null))}}}function bb(t,e,n,i){const r=t.getParameter(t.MAX_VERTEX_ATTRIBS),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||null!==s,a={},l=p(null);let c=l,h=!1;function u(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function d(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function p(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function f(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function m(t){g(t,0)}function g(n,r){const s=c.newAttributes,o=c.enabledAttributes,a=c.attributeDivisors;s[n]=1,0===o[n]&&(t.enableVertexAttribArray(n),o[n]=1),a[n]!==r&&((i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),a[n]=r)}function _(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function y(e,n,i,r,s,o,a){!0===a?t.vertexAttribIPointer(e,n,i,s,o):t.vertexAttribPointer(e,n,i,r,s,o)}function v(){x(),h=!0,c!==l&&(c=l,u(c.object))}function x(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,d,v,x){let S=!1;if(o){const e=function(e,n,r){const o=!0===r.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let h=c[o];return void 0===h&&(h=p(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[o]=h),h}(v,d,l);c!==e&&(c=e,u(c.object)),S=function(t,e,n,i){const r=c.attributes,s=e.attributes;let o=0;const a=n.getAttributes();for(const e in a)if(a[e].location>=0){const n=r[e];let i=s[e];if(void 0===i&&("instanceMatrix"===e&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(i=t.instanceColor)),void 0===n)return!0;if(n.attribute!==i)return!0;if(i&&n.data!==i.data)return!0;o++}return c.attributesNum!==o||c.index!==i}(r,v,d,x),S&&function(t,e,n,i){const r={},s=e.attributes;let o=0;const a=n.getAttributes();for(const e in a)if(a[e].location>=0){let n=s[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const i={};i.attribute=n,n&&n.data&&(i.data=n.data),r[e]=i,o++}c.attributes=r,c.attributesNum=o,c.index=i}(r,v,d,x)}else{const t=!0===l.wireframe;c.geometry===v.id&&c.program===d.id&&c.wireframe===t||(c.geometry=v.id,c.program=d.id,c.wireframe=t,S=!0)}null!==x&&n.update(x,t.ELEMENT_ARRAY_BUFFER),(S||h)&&(h=!1,function(r,s,o,a){if(!1===i.isWebGL2&&(r.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;f();const l=a.attributes,c=o.getAttributes(),h=s.defaultAttributeValues;for(const e in c){const s=c[e];if(s.location>=0){let o=l[e];if(void 0===o&&("instanceMatrix"===e&&r.instanceMatrix&&(o=r.instanceMatrix),"instanceColor"===e&&r.instanceColor&&(o=r.instanceColor)),void 0!==o){const e=o.normalized,l=o.itemSize,c=n.get(o);if(void 0===c)continue;const h=c.buffer,u=c.type,d=c.bytesPerElement,p=!0===i.isWebGL2&&(u===t.INT||u===t.UNSIGNED_INT||o.gpuType===kg);if(o.isInterleavedBufferAttribute){const n=o.data,i=n.stride,c=o.offset;if(n.isInstancedInterleavedBuffer){for(let t=0;t<s.locationSize;t++)g(s.location+t,n.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<s.locationSize;t++)m(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<s.locationSize;t++)y(s.location+t,l/s.locationSize,u,e,i*d,(c+l/s.locationSize*t)*d,p)}else{if(o.isInstancedBufferAttribute){for(let t=0;t<s.locationSize;t++)g(s.location+t,o.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=o.meshPerAttribute*o.count)}else for(let t=0;t<s.locationSize;t++)m(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<s.locationSize;t++)y(s.location+t,l/s.locationSize,u,e,l*d,l/s.locationSize*t*d,p)}}else if(void 0!==h){const n=h[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(s.location,n);break;case 3:t.vertexAttrib3fv(s.location,n);break;case 4:t.vertexAttrib4fv(s.location,n);break;default:t.vertexAttrib1fv(s.location,n)}}}}_()}(r,l,d,v),null!==x&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n.get(x).buffer))},reset:v,resetDefaultState:x,dispose:function(){v();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)d(i[t].object),delete i[t];delete n[t.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:_}}function Mb(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,o,a){if(0===a)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,i,o,a),n.update(o,s,a)}}function wb(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===t.constructor.name;let o=void 0!==n.precision?n.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=s||e.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=t.getParameter(t.MAX_TEXTURE_SIZE),p=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),f=t.getParameter(t.MAX_VERTEX_ATTRIBS),m=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),g=t.getParameter(t.MAX_VARYING_VECTORS),_=t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),y=u>0,v=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:_,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:s?t.getParameter(t.MAX_SAMPLES):0}}function Eb(t){const e=this;let n=null,i=0,r=!1,s=!1;const o=new hb,a=new sv,l={value:null,needsUpdate:!1};function c(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;a.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)o.copy(t[e]).applyMatrix4(r,a),o.normal.toArray(c,n),c[n+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const n=0!==t.length||e||0!==i||r;return r=e,i=t.length,n},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(t,e){n=c(t,e,0)},this.setState=function(o,a,h){const u=o.clippingPlanes,d=o.clipIntersection,p=o.clipShadows,f=t.get(o);if(!r||null===u||0===u.length||s&&!p)s?c(null):(l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0);else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=c(u,a,e,h);for(let t=0;t!==e;++t)r[t]=n[t];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Tb(t){let e=new WeakMap;function n(t,e){return e===Sg?t.mapping=vg:e===bg&&(t.mapping=xg),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){const s=r.mapping;if(s===Sg||s===bg){if(e.has(r))return n(e.get(r).texture,r.mapping);{const s=r.image;if(s&&s.height>0){const o=new ob(s.height/2);return o.fromEquirectangularTexture(t,r),e.set(r,o),r.addEventListener("dispose",i),n(o.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}class Ab extends eb{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,a=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}const Cb=[.125,.215,.35,.446,.526,.582],Rb=new Ab,Pb=new eS;let Lb=null;const Ib=(1+Math.sqrt(5))/2,Nb=1/Ib,Db=[new Ov(1,1,1),new Ov(-1,1,1),new Ov(1,1,-1),new Ov(-1,1,-1),new Ov(0,Ib,Nb),new Ov(0,Ib,-Nb),new Ov(Nb,0,Ib),new Ov(-Nb,0,Ib),new Ov(Ib,Nb,0),new Ov(-Ib,Nb,0)];class Ob{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Lb=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=zb(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Bb(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Lb),t.scissorTest=!1,Fb(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===vg||t.mapping===xg?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Lb=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:Ig,minFilter:Ig,generateMipmaps:!1,type:Wg,format:$g,colorSpace:iy,depthBuffer:!1},i=Ub(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Ub(t,e,n);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],i=[];let r=t;const s=t-4+1+Cb.length;for(let o=0;o<s;o++){const s=Math.pow(2,r);n.push(s);let a=1/s;o>t-4?a=Cb[o-t+4-1]:0===o&&(a=0),i.push(a);const l=1/(s-2),c=-l,h=1+l,u=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,p=6,f=3,m=2,g=1,_=new Float32Array(f*p*d),y=new Float32Array(m*p*d),v=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];_.set(i,f*p*t),y.set(u,m*p*t);const r=[t,t,t,t,t,t];v.set(r,g*p*t)}const x=new RS;x.setAttribute("position",new uS(_,f)),x.setAttribute("uv",new uS(y,m)),x.setAttribute("faceIndex",new uS(v,g)),e.push(x),r>4&&r--}return{lodPlanes:e,sizeLods:n,sigmas:i}}(i)),this._blurMaterial=function(t,e,n){const i=new Float32Array(20),r=new Ov(0,1,0);return new tb({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:Nm,depthTest:!1,depthWrite:!1})}(i,t,e)}return i}_compileMaterial(t){const e=new YS(this._lodPlanes[0],t);this._renderer.compile(e,Rb)}_sceneToCubeUV(t,e,n,i){const r=new nb(90,1,e,n),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,c=a.toneMapping;a.getClearColor(Pb),a.toneMapping=dg,a.autoClear=!1;const h=new iS({name:"PMREM.Background",side:Pm,depthWrite:!1,depthTest:!1}),u=new YS(new $S,h);let d=!1;const p=t.background;p?p.isColor&&(h.color.copy(p),t.background=null,d=!0):(h.color.copy(Pb),d=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(r.up.set(0,s[e],0),r.lookAt(o[e],0,0)):1===n?(r.up.set(0,0,s[e]),r.lookAt(0,o[e],0)):(r.up.set(0,s[e],0),r.lookAt(0,0,o[e]));const l=this._cubeSize;Fb(i,n*l,e>2?l:0,l,l),a.setRenderTarget(i),d&&a.render(u,r),a.render(t,r)}u.geometry.dispose(),u.material.dispose(),a.toneMapping=c,a.autoClear=l,t.background=p}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===vg||t.mapping===xg;i?(null===this._cubemapMaterial&&(this._cubemapMaterial=zb()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Bb());const r=i?this._cubemapMaterial:this._equirectMaterial,s=new YS(this._lodPlanes[0],r);r.uniforms.envMap.value=t;const o=this._cubeSize;Fb(e,0,0,3*o,2*o),n.setRenderTarget(e),n.render(s,Rb)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<this._lodPlanes.length;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),i=Db[(e-1)%Db.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new YS(this._lodPlanes[i],l),h=l.uniforms,u=this._sizeLods[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<20;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0===t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;h.envMap.value=t.texture,h.samples.value=f,h.weights.value=m,h.latitudinal.value="latitudinal"===s,o&&(h.poleAxis.value=o);const{_lodMax:_}=this;h.dTheta.value=d,h.mipInt.value=_-n;const y=this._sizeLods[i];Fb(e,3*y*(i>_-4?i-_+4:0),4*(this._cubeSize-y),3*y,2*y),a.setRenderTarget(e),a.render(c,Rb)}}function Ub(t,e,n){const i=new Cv(t,e,n);return i.texture.mapping=Mg,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function Fb(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function Bb(){return new tb({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:Nm,depthTest:!1,depthWrite:!1})}function zb(){return new tb({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:Nm,depthTest:!1,depthWrite:!1})}function Vb(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping,o=s===Sg||s===bg,a=s===vg||s===xg;if(o||a){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;let i=e.get(r);return null===n&&(n=new Ob(t)),i=o?n.fromEquirectangular(r,i):n.fromCubemap(r,i),e.set(r,i),i.texture}if(e.has(r))return e.get(r).texture;{const s=r.image;if(o&&s&&s.height>0||a&&s&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(s)){null===n&&(n=new Ob(t));const s=o?n.fromEquirectangular(r):n.fromCubemap(r);return e.set(r,s),r.addEventListener("dispose",i),s.texture}return null}}}return r},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function kb(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function Gb(t,e,n,i){const r={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const t in a.attributes)e.remove(a.attributes[t]);for(const t in a.morphAttributes){const n=a.morphAttributes[t];for(let t=0,i=n.length;t<i;t++)e.remove(n[t])}a.removeEventListener("dispose",o),delete r[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),i.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],i=t.index,r=t.attributes.position;let o=0;if(null!==i){const t=i.array;o=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{const t=r.array;o=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}const a=new(av(n)?yS:gS)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",o),r[e.id]=!0,n.memory.geometries++),e},update:function(n){const i=n.attributes;for(const n in i)e.update(i[n],t.ARRAY_BUFFER);const r=n.morphAttributes;for(const n in r){const i=r[n];for(let n=0,r=i.length;n<r;n++)e.update(i[n],t.ARRAY_BUFFER)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function Hb(t,e,n,i){const r=i.isWebGL2;let s,o,a;this.setMode=function(t){s=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,o,e*a),n.update(i,s,1)},this.renderInstances=function(i,l,c){if(0===c)return;let h,u;if(r)h=t,u="drawElementsInstanced";else if(h=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](s,l,o,i*a,c),n.update(l,s,c)}}function Wb(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,i,r){switch(e.calls++,i){case t.TRIANGLES:e.triangles+=r*(n/3);break;case t.LINES:e.lines+=r*(n/2);break;case t.LINE_STRIP:e.lines+=r*(n-1);break;case t.LINE_LOOP:e.lines+=r*n;break;case t.POINTS:e.points+=r*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function jb(t,e){return t[0]-e[0]}function Xb(t,e){return Math.abs(e[1])-Math.abs(t[1])}function Yb(t,e,n){const i={},r=new Float32Array(8),s=new WeakMap,o=new Av,a=[];for(let t=0;t<8;t++)a[t]=[t,0];return{update:function(l,c,h){const u=l.morphTargetInfluences;if(!0===e.isWebGL2){const d=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,p=void 0!==d?d.length:0;let f=s.get(c);if(void 0===f||f.count!==p){void 0!==f&&f.texture.dispose();const _=void 0!==c.morphAttributes.position,y=void 0!==c.morphAttributes.normal,v=void 0!==c.morphAttributes.color,x=c.morphAttributes.position||[],S=c.morphAttributes.normal||[],b=c.morphAttributes.color||[];let M=0;!0===_&&(M=1),!0===y&&(M=2),!0===v&&(M=3);let w=c.attributes.position.count*M,E=1;w>e.maxTextureSize&&(E=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);const T=new Float32Array(w*E*4*p),A=new Rv(T,w,E,p);A.type=Hg,A.needsUpdate=!0;const C=4*M;for(let P=0;P<p;P++){const L=x[P],I=S[P],N=b[P],D=w*E*4*P;for(let O=0;O<L.count;O++){const U=O*C;!0===_&&(o.fromBufferAttribute(L,O),T[D+U+0]=o.x,T[D+U+1]=o.y,T[D+U+2]=o.z,T[D+U+3]=0),!0===y&&(o.fromBufferAttribute(I,O),T[D+U+4]=o.x,T[D+U+5]=o.y,T[D+U+6]=o.z,T[D+U+7]=0),!0===v&&(o.fromBufferAttribute(N,O),T[D+U+8]=o.x,T[D+U+9]=o.y,T[D+U+10]=o.z,T[D+U+11]=4===N.itemSize?o.w:1)}}function R(){A.dispose(),s.delete(c),c.removeEventListener("dispose",R)}f={count:p,texture:A,size:new rv(w,E)},s.set(c,f),c.addEventListener("dispose",R)}let m=0;for(let F=0;F<u.length;F++)m+=u[F];const g=c.morphTargetsRelative?1:1-m;h.getUniforms().setValue(t,"morphTargetBaseInfluence",g),h.getUniforms().setValue(t,"morphTargetInfluences",u),h.getUniforms().setValue(t,"morphTargetsTexture",f.texture,n),h.getUniforms().setValue(t,"morphTargetsTextureSize",f.size)}else{const B=void 0===u?0:u.length;let z=i[c.id];if(void 0===z||z.length!==B){z=[];for(let W=0;W<B;W++)z[W]=[W,0];i[c.id]=z}for(let j=0;j<B;j++){const X=z[j];X[0]=j,X[1]=u[j]}z.sort(Xb);for(let Y=0;Y<8;Y++)Y<B&&z[Y][1]?(a[Y][0]=z[Y][0],a[Y][1]=z[Y][1]):(a[Y][0]=Number.MAX_SAFE_INTEGER,a[Y][1]=0);a.sort(jb);const V=c.morphAttributes.position,k=c.morphAttributes.normal;let G=0;for(let q=0;q<8;q++){const $=a[q],Z=$[0],J=$[1];Z!==Number.MAX_SAFE_INTEGER&&J?(V&&c.getAttribute("morphTarget"+q)!==V[Z]&&c.setAttribute("morphTarget"+q,V[Z]),k&&c.getAttribute("morphNormal"+q)!==k[Z]&&c.setAttribute("morphNormal"+q,k[Z]),r[q]=J,G+=J):(V&&!0===c.hasAttribute("morphTarget"+q)&&c.deleteAttribute("morphTarget"+q),k&&!0===c.hasAttribute("morphNormal"+q)&&c.deleteAttribute("morphNormal"+q),r[q]=0)}const H=c.morphTargetsRelative?1:1-G;h.getUniforms().setValue(t,"morphTargetBaseInfluence",H),h.getUniforms().setValue(t,"morphTargetInfluences",r)}}}}function qb(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(o){const a=i.render.frame,l=o.geometry,c=e.get(o,l);return r.get(c)!==a&&(e.update(c),r.set(c,a)),o.isInstancedMesh&&(!1===o.hasEventListener("dispose",s)&&o.addEventListener("dispose",s),n.update(o.instanceMatrix,t.ARRAY_BUFFER),null!==o.instanceColor&&n.update(o.instanceColor,t.ARRAY_BUFFER)),c},dispose:function(){r=new WeakMap}}}const $b=new Tv,Zb=new Rv,Jb=new Lv,Kb=new sb,Qb=[],tM=[],eM=new Float32Array(16),nM=new Float32Array(9),iM=new Float32Array(4);function rM(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=Qb[r];if(void 0===s&&(s=new Float32Array(r),Qb[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function sM(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function oM(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function aM(t,e){let n=tM[e];void 0===n&&(n=new Int32Array(e),tM[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function lM(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function cM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(sM(n,e))return;t.uniform2fv(this.addr,e),oM(n,e)}}function hM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(sM(n,e))return;t.uniform3fv(this.addr,e),oM(n,e)}}function uM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(sM(n,e))return;t.uniform4fv(this.addr,e),oM(n,e)}}function dM(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(sM(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),oM(n,e)}else{if(sM(n,i))return;iM.set(i),t.uniformMatrix2fv(this.addr,!1,iM),oM(n,i)}}function pM(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(sM(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),oM(n,e)}else{if(sM(n,i))return;nM.set(i),t.uniformMatrix3fv(this.addr,!1,nM),oM(n,i)}}function fM(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(sM(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),oM(n,e)}else{if(sM(n,i))return;eM.set(i),t.uniformMatrix4fv(this.addr,!1,eM),oM(n,i)}}function mM(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function gM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(sM(n,e))return;t.uniform2iv(this.addr,e),oM(n,e)}}function _M(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(sM(n,e))return;t.uniform3iv(this.addr,e),oM(n,e)}}function yM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(sM(n,e))return;t.uniform4iv(this.addr,e),oM(n,e)}}function vM(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function xM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(sM(n,e))return;t.uniform2uiv(this.addr,e),oM(n,e)}}function SM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(sM(n,e))return;t.uniform3uiv(this.addr,e),oM(n,e)}}function bM(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(sM(n,e))return;t.uniform4uiv(this.addr,e),oM(n,e)}}function MM(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2D(e||$b,r)}function wM(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Jb,r)}function EM(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTextureCube(e||Kb,r)}function TM(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||Zb,r)}function AM(t,e){t.uniform1fv(this.addr,e)}function CM(t,e){const n=rM(e,this.size,2);t.uniform2fv(this.addr,n)}function RM(t,e){const n=rM(e,this.size,3);t.uniform3fv(this.addr,n)}function PM(t,e){const n=rM(e,this.size,4);t.uniform4fv(this.addr,n)}function LM(t,e){const n=rM(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function IM(t,e){const n=rM(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function NM(t,e){const n=rM(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function DM(t,e){t.uniform1iv(this.addr,e)}function OM(t,e){t.uniform2iv(this.addr,e)}function UM(t,e){t.uniform3iv(this.addr,e)}function FM(t,e){t.uniform4iv(this.addr,e)}function BM(t,e){t.uniform1uiv(this.addr,e)}function zM(t,e){t.uniform2uiv(this.addr,e)}function VM(t,e){t.uniform3uiv(this.addr,e)}function kM(t,e){t.uniform4uiv(this.addr,e)}function GM(t,e,n){const i=this.cache,r=e.length,s=aM(n,r);sM(i,s)||(t.uniform1iv(this.addr,s),oM(i,s));for(let t=0;t!==r;++t)n.setTexture2D(e[t]||$b,s[t])}function HM(t,e,n){const i=this.cache,r=e.length,s=aM(n,r);sM(i,s)||(t.uniform1iv(this.addr,s),oM(i,s));for(let t=0;t!==r;++t)n.setTexture3D(e[t]||Jb,s[t])}function WM(t,e,n){const i=this.cache,r=e.length,s=aM(n,r);sM(i,s)||(t.uniform1iv(this.addr,s),oM(i,s));for(let t=0;t!==r;++t)n.setTextureCube(e[t]||Kb,s[t])}function jM(t,e,n){const i=this.cache,r=e.length,s=aM(n,r);sM(i,s)||(t.uniform1iv(this.addr,s),oM(i,s));for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||Zb,s[t])}class XM{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return lM;case 35664:return cM;case 35665:return hM;case 35666:return uM;case 35674:return dM;case 35675:return pM;case 35676:return fM;case 5124:case 35670:return mM;case 35667:case 35671:return gM;case 35668:case 35672:return _M;case 35669:case 35673:return yM;case 5125:return vM;case 36294:return xM;case 36295:return SM;case 36296:return bM;case 35678:case 36198:case 36298:case 36306:case 35682:return MM;case 35679:case 36299:case 36307:return wM;case 35680:case 36300:case 36308:case 36293:return EM;case 36289:case 36303:case 36311:case 36292:return TM}}(e.type)}}class YM{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return AM;case 35664:return CM;case 35665:return RM;case 35666:return PM;case 35674:return LM;case 35675:return IM;case 35676:return NM;case 5124:case 35670:return DM;case 35667:case 35671:return OM;case 35668:case 35672:return UM;case 35669:case 35673:return FM;case 5125:return BM;case 36294:return zM;case 36295:return VM;case 36296:return kM;case 35678:case 36198:case 36298:case 36306:case 35682:return GM;case 35679:case 36299:case 36307:return HM;case 35680:case 36300:case 36308:case 36293:return WM;case 36289:case 36303:case 36311:case 36292:return jM}}(e.type)}}class qM{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}}}const $M=/(\w+)(\])?(\[|\.)?/g;function ZM(t,e){t.seq.push(e),t.map[e.id]=e}function JM(t,e,n){const i=t.name,r=i.length;for($M.lastIndex=0;;){const s=$M.exec(i),o=$M.lastIndex;let a=s[1];const l="]"===s[2],c=s[3];if(l&&(a|=0),void 0===c||"["===c&&o+2===r){ZM(n,void 0===c?new XM(a,t,e):new YM(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new qM(a),ZM(n,t)),n=t}}}class KM{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);JM(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n}}function QM(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}let tw=0;function ew(t,e,n){const i=t.getShaderParameter(e,t.COMPILE_STATUS),r=t.getShaderInfoLog(e).trim();if(i&&""===r)return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const i=parseInt(s[1]);return n.toUpperCase()+"\n\n"+r+"\n\n"+function(t,e){const n=t.split("\n"),i=[],r=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let t=r;t<s;t++){const r=t+1;i.push(`${r===e?">":" "} ${r}: ${n[t]}`)}return i.join("\n")}(t.getShaderSource(e),i)}return r}function nw(t,e){const n=function(t){switch(t){case iy:return["Linear","( value )"];case ny:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",t),["Linear","( value )"]}}(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function iw(t,e){let n;switch(e){case pg:n="Linear";break;case fg:n="Reinhard";break;case mg:n="OptimizedCineon";break;case gg:n="ACESFilmic";break;case _g:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function rw(t){return""!==t}function sw(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function ow(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const aw=/^[ \t]*#include +<([\w\d./]+)>/gm;function lw(t){return t.replace(aw,cw)}function cw(t,e){const n=_b[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return lw(n)}const hw=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function uw(t){return t.replace(hw,dw)}function dw(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function pw(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function fw(t,e,n,i){const r=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===Tm?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===Am?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===Cm&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case vg:case xg:e="ENVMAP_TYPE_CUBE";break;case Mg:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),h=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===xg&&(e="ENVMAP_MODE_REFRACTION"),e}(n),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case cg:e="ENVMAP_BLENDING_MULTIPLY";break;case hg:e="ENVMAP_BLENDING_MIX";break;case ug:e="ENVMAP_BLENDING_ADD"}return e}(n),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:i,maxMip:n}}(n),p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUVHeight||t.bumpMap||t.normalMapTangentSpace||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(rw).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,_,y=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(rw).join("\n"),g.length>0&&(g+="\n"),_=[p,"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(rw).join("\n"),_.length>0&&(_+="\n")):(g=[pw(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(rw).join("\n"),_=[p,pw(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==dg?"#define TONE_MAPPING":"",n.toneMapping!==dg?_b.tonemapping_pars_fragment:"",n.toneMapping!==dg?iw("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",_b.encodings_pars_fragment,nw("linearToOutputTexel",n.outputColorSpace),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(rw).join("\n")),o=lw(o),o=sw(o,n),o=ow(o,n),a=lw(a),a=sw(a,n),a=ow(a,n),o=uw(o),a=uw(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(y="#version 300 es\n",g=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,_=["#define varying in",n.glslVersion===zy?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===zy?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+_);const v=y+g+o,x=y+_+a,S=QM(r,r.VERTEX_SHADER,v),b=QM(r,r.FRAGMENT_SHADER,x);if(r.attachShader(m,S),r.attachShader(m,b),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const e=r.getProgramInfoLog(m).trim(),n=r.getShaderInfoLog(S).trim(),i=r.getShaderInfoLog(b).trim();let s=!0,o=!0;if(!1===r.getProgramParameter(m,r.LINK_STATUS))if(s=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(r,m,S,b);else{const t=ew(r,S,"vertex"),n=ew(r,b,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,r.VALIDATE_STATUS)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==n&&""!==i||(o=!1);o&&(this.diagnostics={runnable:s,programLog:e,vertexShader:{log:n,prefix:g},fragmentShader:{log:i,prefix:_}})}let M,w;return r.deleteShader(S),r.deleteShader(b),this.getUniforms=function(){return void 0===M&&(M=new KM(r,m)),M},this.getAttributes=function(){return void 0===w&&(w=function(t,e){const n={},i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),s=i.name;let o=1;i.type===t.FLOAT_MAT2&&(o=2),i.type===t.FLOAT_MAT3&&(o=3),i.type===t.FLOAT_MAT4&&(o=4),n[s]={type:i.type,location:t.getAttribLocation(e,s),locationSize:o}}return n}(r,m)),w},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=tw++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=b,this}let mw=0;class gw{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(n),s=this._getShaderCacheForMaterial(t);return!1===s.has(i)&&(s.add(i),i.usedTimes++),!1===s.has(r)&&(s.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return void 0===n&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return void 0===n&&(n=new _w(t),e.set(t,n)),n}}class _w{constructor(t){this.id=mw++,this.code=t,this.usedTimes=0}}function yw(t,e,n,i,r,s,o){const a=new bx,l=new gw,c=[],h=r.isWebGL2,u=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(t){return 0===t?"uv":`uv${t}`}return{getParameters:function(s,a,c,g,_){const y=g.fog,v=_.geometry,x=s.isMeshStandardMaterial?g.environment:null,S=(s.isMeshStandardMaterial?n:e).get(s.envMap||x),b=S&&S.mapping===Mg?S.image.height:null,M=f[s.type];null!==s.precision&&(p=r.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."));const w=v.morphAttributes.position||v.morphAttributes.normal||v.morphAttributes.color,E=void 0!==w?w.length:0;let T,A,C,R,P=0;if(void 0!==v.morphAttributes.position&&(P=1),void 0!==v.morphAttributes.normal&&(P=2),void 0!==v.morphAttributes.color&&(P=3),M){const t=vb[M];T=t.vertexShader,A=t.fragmentShader}else T=s.vertexShader,A=s.fragmentShader,l.update(s),C=l.getVertexShaderID(s),R=l.getFragmentShaderID(s);const L=t.getRenderTarget(),I=!0===_.isInstancedMesh,N=!!s.map,D=!!s.matcap,O=!!S,U=!!s.aoMap,F=!!s.lightMap,B=!!s.bumpMap,z=!!s.normalMap,V=!!s.displacementMap,k=!!s.emissiveMap,G=!!s.metalnessMap,H=!!s.roughnessMap,W=s.anisotropy>0,j=s.clearcoat>0,X=s.iridescence>0,Y=s.sheen>0,q=s.transmission>0,$=W&&!!s.anisotropyMap,Z=j&&!!s.clearcoatMap,J=j&&!!s.clearcoatNormalMap,K=j&&!!s.clearcoatRoughnessMap,Q=X&&!!s.iridescenceMap,tt=X&&!!s.iridescenceThicknessMap,et=Y&&!!s.sheenColorMap,nt=Y&&!!s.sheenRoughnessMap,it=!!s.specularMap,rt=!!s.specularColorMap,st=!!s.specularIntensityMap,ot=q&&!!s.transmissionMap,at=q&&!!s.thicknessMap,lt=!!s.gradientMap,ct=!!s.alphaMap,ht=s.alphaTest>0,ut=!!s.extensions,dt=!!v.attributes.uv1,pt=!!v.attributes.uv2,ft=!!v.attributes.uv3;return{isWebGL2:h,shaderID:M,shaderType:s.type,shaderName:s.name,vertexShader:T,fragmentShader:A,defines:s.defines,customVertexShaderID:C,customFragmentShaderID:R,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:I,instancingColor:I&&null!==_.instanceColor,supportsVertexTextures:d,outputColorSpace:null===L?t.outputColorSpace:!0===L.isXRRenderTarget?L.texture.colorSpace:iy,map:N,matcap:D,envMap:O,envMapMode:O&&S.mapping,envMapCubeUVHeight:b,aoMap:U,lightMap:F,bumpMap:B,normalMap:z,displacementMap:d&&V,emissiveMap:k,normalMapObjectSpace:z&&s.normalMapType===ty,normalMapTangentSpace:z&&s.normalMapType===Q_,metalnessMap:G,roughnessMap:H,anisotropy:W,anisotropyMap:$,clearcoat:j,clearcoatMap:Z,clearcoatNormalMap:J,clearcoatRoughnessMap:K,iridescence:X,iridescenceMap:Q,iridescenceThicknessMap:tt,sheen:Y,sheenColorMap:et,sheenRoughnessMap:nt,specularMap:it,specularColorMap:rt,specularIntensityMap:st,transmission:q,transmissionMap:ot,thicknessMap:at,gradientMap:lt,opaque:!1===s.transparent&&s.blending===Dm,alphaMap:ct,alphaTest:ht,combine:s.combine,mapUv:N&&m(s.map.channel),aoMapUv:U&&m(s.aoMap.channel),lightMapUv:F&&m(s.lightMap.channel),bumpMapUv:B&&m(s.bumpMap.channel),normalMapUv:z&&m(s.normalMap.channel),displacementMapUv:V&&m(s.displacementMap.channel),emissiveMapUv:k&&m(s.emissiveMap.channel),metalnessMapUv:G&&m(s.metalnessMap.channel),roughnessMapUv:H&&m(s.roughnessMap.channel),anisotropyMapUv:$&&m(s.anisotropyMap.channel),clearcoatMapUv:Z&&m(s.clearcoatMap.channel),clearcoatNormalMapUv:J&&m(s.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:K&&m(s.clearcoatRoughnessMap.channel),iridescenceMapUv:Q&&m(s.iridescenceMap.channel),iridescenceThicknessMapUv:tt&&m(s.iridescenceThicknessMap.channel),sheenColorMapUv:et&&m(s.sheenColorMap.channel),sheenRoughnessMapUv:nt&&m(s.sheenRoughnessMap.channel),specularMapUv:it&&m(s.specularMap.channel),specularColorMapUv:rt&&m(s.specularColorMap.channel),specularIntensityMapUv:st&&m(s.specularIntensityMap.channel),transmissionMapUv:ot&&m(s.transmissionMap.channel),thicknessMapUv:at&&m(s.thicknessMap.channel),alphaMapUv:ct&&m(s.alphaMap.channel),vertexTangents:!!v.attributes.tangent&&(z||W),vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!v.attributes.color&&4===v.attributes.color.itemSize,vertexUv1s:dt,vertexUv2s:pt,vertexUv3s:ft,pointsUvs:!0===_.isPoints&&!!v.attributes.uv&&(N||ct),fog:!!y,useFog:!0===s.fog,fogExp2:y&&y.isFogExp2,flatShading:!0===s.flatShading,sizeAttenuation:!0===s.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===_.isSkinnedMesh,morphTargets:void 0!==v.morphAttributes.position,morphNormals:void 0!==v.morphAttributes.normal,morphColors:void 0!==v.morphAttributes.color,morphTargetsCount:E,morphTextureStride:P,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numSpotLightMaps:a.spotLightMap.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numSpotLightShadowsWithMaps:a.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:dg,useLegacyLights:t.useLegacyLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===Lm,flipSided:s.side===Pm,useDepthPacking:s.depthPacking>=0,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:ut&&!0===s.extensions.derivatives,extensionFragDepth:ut&&!0===s.extensions.fragDepth,extensionDrawBuffers:ut&&!0===s.extensions.drawBuffers,extensionShaderTextureLOD:ut&&!0===s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||i.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){a.disableAll(),e.isWebGL2&&a.enable(0),e.supportsVertexTextures&&a.enable(1),e.instancing&&a.enable(2),e.instancingColor&&a.enable(3),e.matcap&&a.enable(4),e.envMap&&a.enable(5),e.normalMapObjectSpace&&a.enable(6),e.normalMapTangentSpace&&a.enable(7),e.clearcoat&&a.enable(8),e.iridescence&&a.enable(9),e.alphaTest&&a.enable(10),e.vertexColors&&a.enable(11),e.vertexAlphas&&a.enable(12),e.vertexUv1s&&a.enable(13),e.vertexUv2s&&a.enable(14),e.vertexUv3s&&a.enable(15),e.vertexTangents&&a.enable(16),e.anisotropy&&a.enable(17),t.push(a.mask),a.disableAll(),e.fog&&a.enable(0),e.useFog&&a.enable(1),e.flatShading&&a.enable(2),e.logarithmicDepthBuffer&&a.enable(3),e.skinning&&a.enable(4),e.morphTargets&&a.enable(5),e.morphNormals&&a.enable(6),e.morphColors&&a.enable(7),e.premultipliedAlpha&&a.enable(8),e.shadowMapEnabled&&a.enable(9),e.useLegacyLights&&a.enable(10),e.doubleSided&&a.enable(11),e.flipSided&&a.enable(12),e.useDepthPacking&&a.enable(13),e.dithering&&a.enable(14),e.transmission&&a.enable(15),e.sheen&&a.enable(16),e.opaque&&a.enable(17),e.pointsUvs&&a.enable(18),t.push(a.mask)}(n,e),n.push(t.outputColorSpace)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=vb[e];n=QS.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new fw(t,n,e,s),c.push(i)),i},releaseProgram:function(t){if(0===--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:c,dispose:function(){l.dispose()}}}function vw(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function xw(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Sw(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function bw(){const t=[];let e=0;const n=[],i=[],r=[];function s(n,i,r,s,o,a){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:i,material:r,groupOrder:s,renderOrder:n.renderOrder,z:o,group:a},t[e]=l):(l.id=n.id,l.object=n,l.geometry=i,l.material=r,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=o,l.group=a),e++,l}return{opaque:n,transmissive:i,transparent:r,init:function(){e=0,n.length=0,i.length=0,r.length=0},push:function(t,e,o,a,l,c){const h=s(t,e,o,a,l,c);o.transmission>0?i.push(h):!0===o.transparent?r.push(h):n.push(h)},unshift:function(t,e,o,a,l,c){const h=s(t,e,o,a,l,c);o.transmission>0?i.unshift(h):!0===o.transparent?r.unshift(h):n.unshift(h)},finish:function(){for(let n=e,i=t.length;n<i;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||xw),i.length>1&&i.sort(e||Sw),r.length>1&&r.sort(e||Sw)}}}function Mw(){let t=new WeakMap;return{get:function(e,n){const i=t.get(e);let r;return void 0===i?(r=new bw,t.set(e,[r])):n>=i.length?(r=new bw,i.push(r)):r=i[n],r},dispose:function(){t=new WeakMap}}}function ww(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new Ov,color:new eS};break;case"SpotLight":n={position:new Ov,direction:new Ov,color:new eS,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Ov,color:new eS,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Ov,skyColor:new eS,groundColor:new eS};break;case"RectAreaLight":n={color:new eS,position:new Ov,halfWidth:new Ov,halfHeight:new Ov}}return t[e.id]=n,n}}}let Ew=0;function Tw(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function Aw(t,e){const n=new ww,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rv};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rv,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let t=0;t<9;t++)r.probe.push(new Ov);const s=new Ov,o=new ux,a=new ux;return{setup:function(s,o){let a=0,l=0,c=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let h=0,u=0,d=0,p=0,f=0,m=0,g=0,_=0,y=0,v=0;s.sort(Tw);const x=!0===o?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],o=e.color,S=e.intensity,b=e.distance,M=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)a+=o.r*S*x,l+=o.g*S*x,c+=o.b*S*x;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],S);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[h]=n,r.directionalShadowMap[h]=M,r.directionalShadowMatrix[h]=e.shadow.matrix,m++}r.directional[h]=t,h++}else if(e.isSpotLight){const t=n.get(e);t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(o).multiplyScalar(S*x),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,r.spot[d]=t;const s=e.shadow;if(e.map&&(r.spotLightMap[y]=e.map,y++,s.updateMatrices(e),e.castShadow&&v++),r.spotLightMatrix[d]=s.matrix,e.castShadow){const t=i.get(e);t.shadowBias=s.bias,t.shadowNormalBias=s.normalBias,t.shadowRadius=s.radius,t.shadowMapSize=s.mapSize,r.spotShadow[d]=t,r.spotShadowMap[d]=M,_++}d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(o).multiplyScalar(S),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=M,r.pointShadowMatrix[u]=e.shadow.matrix,g++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(S*x),t.groundColor.copy(e.groundColor).multiplyScalar(S*x),r.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=yb.LTC_FLOAT_1,r.rectAreaLTC2=yb.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=yb.LTC_HALF_1,r.rectAreaLTC2=yb.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=a,r.ambient[1]=l,r.ambient[2]=c;const S=r.hash;S.directionalLength===h&&S.pointLength===u&&S.spotLength===d&&S.rectAreaLength===p&&S.hemiLength===f&&S.numDirectionalShadows===m&&S.numPointShadows===g&&S.numSpotShadows===_&&S.numSpotMaps===y||(r.directional.length=h,r.spot.length=d,r.rectArea.length=p,r.point.length=u,r.hemi.length=f,r.directionalShadow.length=m,r.directionalShadowMap.length=m,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=_,r.spotShadowMap.length=_,r.directionalShadowMatrix.length=m,r.pointShadowMatrix.length=g,r.spotLightMatrix.length=_+y-v,r.spotLightMap.length=y,r.numSpotLightShadowsWithMaps=v,S.directionalLength=h,S.pointLength=u,S.spotLength=d,S.rectAreaLength=p,S.hemiLength=f,S.numDirectionalShadows=m,S.numPointShadows=g,S.numSpotShadows=_,S.numSpotMaps=y,r.version=Ew++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,h=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),a.identity(),o.copy(d.matrixWorld),o.premultiply(u),a.extractRotation(o),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),c++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),i++}else if(d.isHemisphereLight){const t=r.hemi[h];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),h++}}},state:r}}function Cw(t,e){const n=new Aw(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(t){n.setup(i,t)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function Rw(t,e){let n=new WeakMap;return{get:function(i,r=0){const s=n.get(i);let o;return void 0===s?(o=new Cw(t,e),n.set(i,[o])):r>=s.length?(o=new Cw(t,e),s.push(o)):o=s[r],o},dispose:function(){n=new WeakMap}}}class Pw extends Zx{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=J_,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Lw extends Zx{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function Iw(t,e,n){let i=new pb;const r=new rv,s=new rv,o=new Av,a=new Pw({depthPacking:K_}),l=new Lw,c={},h=n.maxTextureSize,u={[Rm]:Pm,[Pm]:Rm,[Lm]:Lm},d=new tb({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new rv},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new RS;f.setAttribute("position",new uS(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new YS(f,d),g=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Tm;let _=this.type;function y(n,i){const s=e.update(m);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new Cv(r.x,r.y)),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,s,d,m,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,s,p,m,null)}function v(e,n,i,r){let s=null;const o=!0===i.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==o)s=o;else if(s=!0===i.isPointLight?l:a,t.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0){const t=s.uuid,e=n.uuid;let i=c[t];void 0===i&&(i={},c[t]=i);let r=i[e];void 0===r&&(r=s.clone(),i[e]=r),s=r}return s.visible=n.visible,s.wireframe=n.wireframe,s.side=r===Cm?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:u[n.side],s.alphaMap=n.alphaMap,s.alphaTest=n.alphaTest,s.map=n.map,s.clipShadows=n.clipShadows,s.clippingPlanes=n.clippingPlanes,s.clipIntersection=n.clipIntersection,s.displacementMap=n.displacementMap,s.displacementScale=n.displacementScale,s.displacementBias=n.displacementBias,s.wireframeLinewidth=n.wireframeLinewidth,s.linewidth=n.linewidth,!0===i.isPointLight&&!0===s.isMeshDistanceMaterial&&(t.properties.get(s).light=i),s}function x(n,r,s,o,a){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&a===Cm)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],h=r[c.materialIndex];if(h&&h.visible){const e=v(n,h,o,a);t.renderBufferDirect(s,null,i,e,n,c)}}}else if(r.visible){const e=v(n,r,o,a);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)x(l[t],r,s,o,a)}this.render=function(e,n,a){if(!1===g.enabled)return;if(!1===g.autoUpdate&&!1===g.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(Nm),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);const p=_!==Cm&&this.type===Cm,f=_===Cm&&this.type!==Cm;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const m=u.getFrameExtents();if(r.multiply(m),s.copy(u.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/m.x),r.x=s.x*m.x,u.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/m.y),r.y=s.y*m.y,u.mapSize.y=s.y)),null===u.map||!0===p||!0===f){const t=this.type!==Cm?{minFilter:Ag,magFilter:Ag}:{};null!==u.map&&u.map.dispose(),u.map=new Cv(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const g=u.getViewportCount();for(let t=0;t<g;t++){const e=u.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),u.updateMatrices(c,t),i=u.getFrustum(),x(n,a,u.camera,c,this.type)}!0!==u.isPointLightShadow&&this.type===Cm&&y(u,a),u.needsUpdate=!1}_=this.type,g.needsUpdate=!1,t.setRenderTarget(l,c,u)}}function Nw(t,e,n){const i=n.isWebGL2,r=new function(){let e=!1;const n=new Av;let i=null;const r=new Av(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,o,a){!0===a&&(e*=o,i*=o,s*=o),n.set(e,i,s,o),!1===r.equals(n)&&(t.clearColor(e,i,s,o),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(e){e?V(t.DEPTH_TEST):k(t.DEPTH_TEST)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){switch(e){case eg:t.depthFunc(t.NEVER);break;case ng:t.depthFunc(t.ALWAYS);break;case ig:t.depthFunc(t.LESS);break;case rg:t.depthFunc(t.LEQUAL);break;case sg:t.depthFunc(t.EQUAL);break;case og:t.depthFunc(t.GEQUAL);break;case ag:t.depthFunc(t.GREATER);break;case lg:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},o=new function(){let e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(n){e||(n?V(t.STENCIL_TEST):k(t.STENCIL_TEST))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,o){i===e&&r===n&&s===o||(t.stencilFunc(e,n,o),i=e,r=n,s=o)},setOp:function(e,n,i){o===e&&a===n&&l===i||(t.stencilOp(e,n,i),o=e,a=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null}}},a=new WeakMap,l=new WeakMap;let c={},h={},u=new WeakMap,d=[],p=null,f=!1,m=null,g=null,_=null,y=null,v=null,x=null,S=null,b=!1,M=null,w=null,E=null,T=null,A=null;const C=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let R=!1,P=0;const L=t.getParameter(t.VERSION);-1!==L.indexOf("WebGL")?(P=parseFloat(/^WebGL (\d)/.exec(L)[1]),R=P>=1):-1!==L.indexOf("OpenGL ES")&&(P=parseFloat(/^OpenGL ES (\d)/.exec(L)[1]),R=P>=2);let I=null,N={};const D=t.getParameter(t.SCISSOR_BOX),O=t.getParameter(t.VIEWPORT),U=(new Av).fromArray(D),F=(new Av).fromArray(O);function B(e,n,r,s){const o=new Uint8Array(4),a=t.createTexture();t.bindTexture(e,a),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let a=0;a<r;a++)!i||e!==t.TEXTURE_3D&&e!==t.TEXTURE_2D_ARRAY?t.texImage2D(n+a,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,o):t.texImage3D(n,0,t.RGBA,1,1,s,0,t.RGBA,t.UNSIGNED_BYTE,o);return a}const z={};function V(e){!0!==c[e]&&(t.enable(e),c[e]=!0)}function k(e){!1!==c[e]&&(t.disable(e),c[e]=!1)}z[t.TEXTURE_2D]=B(t.TEXTURE_2D,t.TEXTURE_2D,1),z[t.TEXTURE_CUBE_MAP]=B(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),i&&(z[t.TEXTURE_2D_ARRAY]=B(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),z[t.TEXTURE_3D]=B(t.TEXTURE_3D,t.TEXTURE_3D,1,1)),r.setClear(0,0,0,1),s.setClear(1),o.setClear(0),V(t.DEPTH_TEST),s.setFunc(rg),j(!1),X(bm),V(t.CULL_FACE),W(Nm);const G={[zm]:t.FUNC_ADD,[Vm]:t.FUNC_SUBTRACT,[km]:t.FUNC_REVERSE_SUBTRACT};if(i)G[Gm]=t.MIN,G[Hm]=t.MAX;else{const t=e.get("EXT_blend_minmax");null!==t&&(G[Gm]=t.MIN_EXT,G[Hm]=t.MAX_EXT)}const H={[Wm]:t.ZERO,[jm]:t.ONE,[Xm]:t.SRC_COLOR,[qm]:t.SRC_ALPHA,[tg]:t.SRC_ALPHA_SATURATE,[Km]:t.DST_COLOR,[Zm]:t.DST_ALPHA,[Ym]:t.ONE_MINUS_SRC_COLOR,[$m]:t.ONE_MINUS_SRC_ALPHA,[Qm]:t.ONE_MINUS_DST_COLOR,[Jm]:t.ONE_MINUS_DST_ALPHA};function W(e,n,i,r,s,o,a,l){if(e!==Nm){if(!1===f&&(V(t.BLEND),f=!0),e===Bm)s=s||n,o=o||i,a=a||r,n===g&&s===v||(t.blendEquationSeparate(G[n],G[s]),g=n,v=s),i===_&&r===y&&o===x&&a===S||(t.blendFuncSeparate(H[i],H[r],H[o],H[a]),_=i,y=r,x=o,S=a),m=e,b=!1;else if(e!==m||l!==b){if(g===zm&&v===zm||(t.blendEquation(t.FUNC_ADD),g=zm,v=zm),l)switch(e){case Dm:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case Om:t.blendFunc(t.ONE,t.ONE);break;case Um:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case Fm:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case Dm:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case Om:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case Um:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case Fm:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}_=null,y=null,x=null,S=null,m=e,b=l}}else!0===f&&(k(t.BLEND),f=!1)}function j(e){M!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),M=e)}function X(e){e!==Sm?(V(t.CULL_FACE),e!==w&&(e===bm?t.cullFace(t.BACK):e===Mm?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):k(t.CULL_FACE),w=e}function Y(e,n,i){e?(V(t.POLYGON_OFFSET_FILL),T===n&&A===i||(t.polygonOffset(n,i),T=n,A=i)):k(t.POLYGON_OFFSET_FILL)}return{buffers:{color:r,depth:s,stencil:o},enable:V,disable:k,bindFramebuffer:function(e,n){return h[e]!==n&&(t.bindFramebuffer(e,n),h[e]=n,i&&(e===t.DRAW_FRAMEBUFFER&&(h[t.FRAMEBUFFER]=n),e===t.FRAMEBUFFER&&(h[t.DRAW_FRAMEBUFFER]=n)),!0)},drawBuffers:function(i,r){let s=d,o=!1;if(i)if(s=u.get(r),void 0===s&&(s=[],u.set(r,s)),i.isWebGLMultipleRenderTargets){const e=i.texture;if(s.length!==e.length||s[0]!==t.COLOR_ATTACHMENT0){for(let n=0,i=e.length;n<i;n++)s[n]=t.COLOR_ATTACHMENT0+n;s.length=e.length,o=!0}}else s[0]!==t.COLOR_ATTACHMENT0&&(s[0]=t.COLOR_ATTACHMENT0,o=!0);else s[0]!==t.BACK&&(s[0]=t.BACK,o=!0);o&&(n.isWebGL2?t.drawBuffers(s):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function(e){return p!==e&&(t.useProgram(e),p=e,!0)},setBlending:W,setMaterial:function(e,n){e.side===Lm?k(t.CULL_FACE):V(t.CULL_FACE);let i=e.side===Pm;n&&(i=!i),j(i),e.blending===Dm&&!1===e.transparent?W(Nm):W(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),s.setFunc(e.depthFunc),s.setTest(e.depthTest),s.setMask(e.depthWrite),r.setMask(e.colorWrite);const a=e.stencilWrite;o.setTest(a),a&&(o.setMask(e.stencilWriteMask),o.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),o.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),Y(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?V(t.SAMPLE_ALPHA_TO_COVERAGE):k(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:j,setCullFace:X,setLineWidth:function(e){e!==E&&(R&&t.lineWidth(e),E=e)},setPolygonOffset:Y,setScissorTest:function(e){e?V(t.SCISSOR_TEST):k(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+C-1),I!==e&&(t.activeTexture(e),I=e)},bindTexture:function(e,n,i){void 0===i&&(i=null===I?t.TEXTURE0+C-1:I);let r=N[i];void 0===r&&(r={type:void 0,texture:void 0},N[i]=r),r.type===e&&r.texture===n||(I!==i&&(t.activeTexture(i),I=i),t.bindTexture(e,n||z[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=N[I];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(e,n){let i=l.get(n);void 0===i&&(i=new WeakMap,l.set(n,i));let r=i.get(e);void 0===r&&(r=t.getUniformBlockIndex(n,e.name),i.set(e,r))},uniformBlockBinding:function(e,n){const i=l.get(n).get(e);a.get(n)!==i&&(t.uniformBlockBinding(n,i,e.__bindingPointIndex),a.set(n,i))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===U.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),U.copy(e))},viewport:function(e){!1===F.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),F.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),!0===i&&(t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),c={},I=null,N={},h={},u=new WeakMap,d=[],p=null,f=!1,m=null,g=null,_=null,y=null,v=null,x=null,S=null,b=!1,M=null,w=null,E=null,T=null,A=null,U.set(0,0,t.canvas.width,t.canvas.height),F.set(0,0,t.canvas.width,t.canvas.height),r.reset(),s.reset(),o.reset()}}}function Dw(t,e,n,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,h=r.maxTextureSize,u=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let m;const g=new WeakMap;let _=!1;try{_="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function y(t,e){return _?new OffscreenCanvas(t,e):hv("canvas")}function v(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?tv:Math.floor,s=i(r*t.width),o=i(r*t.height);void 0===m&&(m=y(s,o));const a=n?y(s,o):m;return a.width=s,a.height=o,a.getContext("2d").drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function x(t){return Ky(t.width)&&Ky(t.height)}function S(t,e){return t.generateMipmaps&&e&&t.minFilter!==Ag&&t.minFilter!==Ig}function b(e){t.generateMipmap(e)}function M(n,i,r,s,o=!1){if(!1===a)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=i;return i===t.RED&&(r===t.FLOAT&&(l=t.R32F),r===t.HALF_FLOAT&&(l=t.R16F),r===t.UNSIGNED_BYTE&&(l=t.R8)),i===t.RG&&(r===t.FLOAT&&(l=t.RG32F),r===t.HALF_FLOAT&&(l=t.RG16F),r===t.UNSIGNED_BYTE&&(l=t.RG8)),i===t.RGBA&&(r===t.FLOAT&&(l=t.RGBA32F),r===t.HALF_FLOAT&&(l=t.RGBA16F),r===t.UNSIGNED_BYTE&&(l=s===ny&&!1===o?t.SRGB8_ALPHA8:t.RGBA8),r===t.UNSIGNED_SHORT_4_4_4_4&&(l=t.RGBA4),r===t.UNSIGNED_SHORT_5_5_5_1&&(l=t.RGB5_A1)),l!==t.R16F&&l!==t.R32F&&l!==t.RG16F&&l!==t.RG32F&&l!==t.RGBA16F&&l!==t.RGBA32F||e.get("EXT_color_buffer_float"),l}function w(t,e,n){return!0===S(t,n)||t.isFramebufferTexture&&t.minFilter!==Ag&&t.minFilter!==Ig?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function E(e){return e===Ag||e===Cg||e===Pg?t.NEAREST:t.LINEAR}function T(t){const e=t.target;e.removeEventListener("dispose",T),function(t){const e=i.get(t);if(void 0===e.__webglInit)return;const n=t.source,r=g.get(n);if(r){const i=r[e.__cacheKey];i.usedTimes--,0===i.usedTimes&&C(t),0===Object.keys(r).length&&g.delete(n)}i.remove(t)}(e),e.isVideoTexture&&f.delete(e)}function A(e){const n=e.target;n.removeEventListener("dispose",A),function(e){const n=e.texture,r=i.get(e),s=i.get(n);if(void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),o.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e]);else{if(t.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer)for(let e=0;e<r.__webglColorRenderbuffer.length;e++)r.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);r.__webglTexture&&(t.deleteTexture(r.__webglTexture),o.memory.textures--),i.remove(n[e])}i.remove(n),i.remove(e)}(n)}function C(e){const n=i.get(e);t.deleteTexture(n.__webglTexture);const r=e.source;delete g.get(r)[n.__cacheKey],o.memory.textures--}let R=0;function P(e,r){const s=i.get(e);if(e.isVideoTexture&&function(t){const e=o.render.frame;f.get(t)!==e&&(f.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&s.__version!==e.version){const t=e.image;if(null===t)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void U(s,e,r);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.bindTexture(t.TEXTURE_2D,s.__webglTexture,t.TEXTURE0+r)}const L={[wg]:t.REPEAT,[Eg]:t.CLAMP_TO_EDGE,[Tg]:t.MIRRORED_REPEAT},I={[Ag]:t.NEAREST,[Cg]:t.NEAREST_MIPMAP_NEAREST,[Pg]:t.NEAREST_MIPMAP_LINEAR,[Ig]:t.LINEAR,[Ng]:t.LINEAR_MIPMAP_NEAREST,[Og]:t.LINEAR_MIPMAP_LINEAR},N={[Sy]:t.NEVER,[Cy]:t.ALWAYS,[by]:t.LESS,[wy]:t.LEQUAL,[My]:t.EQUAL,[Ay]:t.GEQUAL,[Ey]:t.GREATER,[Ty]:t.NOTEQUAL};function D(n,s,o){if(o?(t.texParameteri(n,t.TEXTURE_WRAP_S,L[s.wrapS]),t.texParameteri(n,t.TEXTURE_WRAP_T,L[s.wrapT]),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,L[s.wrapR]),t.texParameteri(n,t.TEXTURE_MAG_FILTER,I[s.magFilter]),t.texParameteri(n,t.TEXTURE_MIN_FILTER,I[s.minFilter])):(t.texParameteri(n,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(n,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),s.wrapS===Eg&&s.wrapT===Eg||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,t.TEXTURE_MAG_FILTER,E(s.magFilter)),t.texParameteri(n,t.TEXTURE_MIN_FILTER,E(s.minFilter)),s.minFilter!==Ag&&s.minFilter!==Ig&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),s.compareFunction&&(t.texParameteri(n,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(n,t.TEXTURE_COMPARE_FUNC,N[s.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){const o=e.get("EXT_texture_filter_anisotropic");if(s.magFilter===Ag)return;if(s.minFilter!==Pg&&s.minFilter!==Og)return;if(s.type===Hg&&!1===e.has("OES_texture_float_linear"))return;if(!1===a&&s.type===Wg&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function O(e,n){let i=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",T));const r=n.source;let s=g.get(r);void 0===s&&(s={},g.set(r,s));const a=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(n);if(a!==e.__cacheKey){void 0===s[a]&&(s[a]={texture:t.createTexture(),usedTimes:0},o.memory.textures++,i=!0),s[a].usedTimes++;const r=s[e.__cacheKey];void 0!==r&&(s[e.__cacheKey].usedTimes--,0===r.usedTimes&&C(n)),e.__cacheKey=a,e.__webglTexture=s[a].texture}return i}function U(e,r,o){let l=t.TEXTURE_2D;(r.isDataArrayTexture||r.isCompressedArrayTexture)&&(l=t.TEXTURE_2D_ARRAY),r.isData3DTexture&&(l=t.TEXTURE_3D);const c=O(e,r),u=r.source;n.bindTexture(l,e.__webglTexture,t.TEXTURE0+o);const d=i.get(u);if(u.version!==d.__version||!0===c){n.activeTexture(t.TEXTURE0+o),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,t.NONE);const e=function(t){return!a&&(t.wrapS!==Eg||t.wrapT!==Eg||t.minFilter!==Ag&&t.minFilter!==Ig)}(r)&&!1===x(r.image);let i=v(r.image,e,!1,h);i=G(r,i);const p=x(i)||a,f=s.convert(r.format,r.colorSpace);let m,g=s.convert(r.type),_=M(r.internalFormat,f,g,r.colorSpace);D(l,r,p);const y=r.mipmaps,E=a&&!0!==r.isVideoTexture,T=void 0===d.__version||!0===c,A=w(r,i,p);if(r.isDepthTexture)_=t.DEPTH_COMPONENT,a?_=r.type===Hg?t.DEPTH_COMPONENT32F:r.type===Gg?t.DEPTH_COMPONENT24:r.type===Yg?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT16:r.type===Hg&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Kg&&_===t.DEPTH_COMPONENT&&r.type!==Vg&&r.type!==Gg&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Gg,g=s.convert(r.type)),r.format===Qg&&_===t.DEPTH_COMPONENT&&(_=t.DEPTH_STENCIL,r.type!==Yg&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=Yg,g=s.convert(r.type))),T&&(E?n.texStorage2D(t.TEXTURE_2D,1,_,i.width,i.height):n.texImage2D(t.TEXTURE_2D,0,_,i.width,i.height,0,f,g,null));else if(r.isDataTexture)if(y.length>0&&p){E&&T&&n.texStorage2D(t.TEXTURE_2D,A,_,y[0].width,y[0].height);for(let e=0,i=y.length;e<i;e++)m=y[e],E?n.texSubImage2D(t.TEXTURE_2D,e,0,0,m.width,m.height,f,g,m.data):n.texImage2D(t.TEXTURE_2D,e,_,m.width,m.height,0,f,g,m.data);r.generateMipmaps=!1}else E?(T&&n.texStorage2D(t.TEXTURE_2D,A,_,i.width,i.height),n.texSubImage2D(t.TEXTURE_2D,0,0,0,i.width,i.height,f,g,i.data)):n.texImage2D(t.TEXTURE_2D,0,_,i.width,i.height,0,f,g,i.data);else if(r.isCompressedTexture)if(r.isCompressedArrayTexture){E&&T&&n.texStorage3D(t.TEXTURE_2D_ARRAY,A,_,y[0].width,y[0].height,i.depth);for(let e=0,s=y.length;e<s;e++)m=y[e],r.format!==$g?null!==f?E?n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,m.width,m.height,i.depth,f,m.data,0,0):n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,_,m.width,m.height,i.depth,0,m.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):E?n.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,m.width,m.height,i.depth,f,g,m.data):n.texImage3D(t.TEXTURE_2D_ARRAY,e,_,m.width,m.height,i.depth,0,f,g,m.data)}else{E&&T&&n.texStorage2D(t.TEXTURE_2D,A,_,y[0].width,y[0].height);for(let e=0,i=y.length;e<i;e++)m=y[e],r.format!==$g?null!==f?E?n.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,m.width,m.height,f,m.data):n.compressedTexImage2D(t.TEXTURE_2D,e,_,m.width,m.height,0,m.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):E?n.texSubImage2D(t.TEXTURE_2D,e,0,0,m.width,m.height,f,g,m.data):n.texImage2D(t.TEXTURE_2D,e,_,m.width,m.height,0,f,g,m.data)}else if(r.isDataArrayTexture)E?(T&&n.texStorage3D(t.TEXTURE_2D_ARRAY,A,_,i.width,i.height,i.depth),n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,i.width,i.height,i.depth,f,g,i.data)):n.texImage3D(t.TEXTURE_2D_ARRAY,0,_,i.width,i.height,i.depth,0,f,g,i.data);else if(r.isData3DTexture)E?(T&&n.texStorage3D(t.TEXTURE_3D,A,_,i.width,i.height,i.depth),n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,i.width,i.height,i.depth,f,g,i.data)):n.texImage3D(t.TEXTURE_3D,0,_,i.width,i.height,i.depth,0,f,g,i.data);else if(r.isFramebufferTexture){if(T)if(E)n.texStorage2D(t.TEXTURE_2D,A,_,i.width,i.height);else{let e=i.width,r=i.height;for(let i=0;i<A;i++)n.texImage2D(t.TEXTURE_2D,i,_,e,r,0,f,g,null),e>>=1,r>>=1}}else if(y.length>0&&p){E&&T&&n.texStorage2D(t.TEXTURE_2D,A,_,y[0].width,y[0].height);for(let e=0,i=y.length;e<i;e++)m=y[e],E?n.texSubImage2D(t.TEXTURE_2D,e,0,0,f,g,m):n.texImage2D(t.TEXTURE_2D,e,_,f,g,m);r.generateMipmaps=!1}else E?(T&&n.texStorage2D(t.TEXTURE_2D,A,_,i.width,i.height),n.texSubImage2D(t.TEXTURE_2D,0,0,0,f,g,i)):n.texImage2D(t.TEXTURE_2D,0,_,f,g,i);S(r,p)&&b(l),d.__version=u.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function F(e,r,o,a,l){const c=s.convert(o.format,o.colorSpace),h=s.convert(o.type),u=M(o.internalFormat,c,h,o.colorSpace);i.get(r).__hasExternalTextures||(l===t.TEXTURE_3D||l===t.TEXTURE_2D_ARRAY?n.texImage3D(l,0,u,r.width,r.height,r.depth,0,c,h,null):n.texImage2D(l,0,u,r.width,r.height,0,c,h,null)),n.bindFramebuffer(t.FRAMEBUFFER,e),k(r)?d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,a,l,i.get(o).__webglTexture,0,V(r)):(l===t.TEXTURE_2D||l>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&l<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,a,l,i.get(o).__webglTexture,0),n.bindFramebuffer(t.FRAMEBUFFER,null)}function B(e,n,i){if(t.bindRenderbuffer(t.RENDERBUFFER,e),n.depthBuffer&&!n.stencilBuffer){let r=t.DEPTH_COMPONENT16;if(i||k(n)){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===Hg?r=t.DEPTH_COMPONENT32F:e.type===Gg&&(r=t.DEPTH_COMPONENT24));const i=V(n);k(n)?d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,i,r,n.width,n.height):t.renderbufferStorageMultisample(t.RENDERBUFFER,i,r,n.width,n.height)}else t.renderbufferStorage(t.RENDERBUFFER,r,n.width,n.height);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,e)}else if(n.depthBuffer&&n.stencilBuffer){const r=V(n);i&&!1===k(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,r,t.DEPTH24_STENCIL8,n.width,n.height):k(n)?d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,r,t.DEPTH24_STENCIL8,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,n.width,n.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let r=0;r<e.length;r++){const o=e[r],a=s.convert(o.format,o.colorSpace),l=s.convert(o.type),c=M(o.internalFormat,a,l,o.colorSpace),h=V(n);i&&!1===k(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,h,c,n.width,n.height):k(n)?d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,h,c,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,c,n.width,n.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function z(e){const r=i.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!r.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),P(r.depthTexture,0);const s=i.get(r.depthTexture).__webglTexture,o=V(r);if(r.depthTexture.format===Kg)k(r)?d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,s,0,o):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,s,0);else{if(r.depthTexture.format!==Qg)throw new Error("Unknown depthTexture format");k(r)?d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,s,0,o):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,s,0)}}(r.__webglFramebuffer,e)}else if(s){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),B(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),B(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(t.FRAMEBUFFER,null)}function V(t){return Math.min(u,t.samples)}function k(t){const n=i.get(t);return a&&t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function G(t,n){const i=t.colorSpace,r=t.format,s=t.type;return!0===t.isCompressedTexture||t.format===Vy||i!==iy&&i!==ey&&(i===ny?!1===a?!0===e.has("EXT_sRGB")&&r===$g?(t.format=Vy,t.minFilter=Ig,t.generateMipmaps=!1):n=Sv.sRGBToLinear(n):r===$g&&s===Fg||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",i)),n}this.allocateTextureUnit=function(){const t=R;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),R+=1,t},this.resetTextureUnits=function(){R=0},this.setTexture2D=P,this.setTexture2DArray=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?U(s,e,r):n.bindTexture(t.TEXTURE_2D_ARRAY,s.__webglTexture,t.TEXTURE0+r)},this.setTexture3D=function(e,r){const s=i.get(e);e.version>0&&s.__version!==e.version?U(s,e,r):n.bindTexture(t.TEXTURE_3D,s.__webglTexture,t.TEXTURE0+r)},this.setTextureCube=function(e,r){const o=i.get(e);e.version>0&&o.__version!==e.version?function(e,r,o){if(6!==r.image.length)return;const l=O(e,r),h=r.source;n.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+o);const u=i.get(h);if(h.version!==u.__version||!0===l){n.activeTexture(t.TEXTURE0+o),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,t.NONE);const e=r.isCompressedTexture||r.image[0].isCompressedTexture,i=r.image[0]&&r.image[0].isDataTexture,d=[];for(let t=0;t<6;t++)d[t]=e||i?i?r.image[t].image:r.image[t]:v(r.image[t],!1,!0,c),d[t]=G(r,d[t]);const p=d[0],f=x(p)||a,m=s.convert(r.format,r.colorSpace),g=s.convert(r.type),_=M(r.internalFormat,m,g,r.colorSpace),y=a&&!0!==r.isVideoTexture,E=void 0===u.__version||!0===l;let T,A=w(r,p,f);if(D(t.TEXTURE_CUBE_MAP,r,f),e){y&&E&&n.texStorage2D(t.TEXTURE_CUBE_MAP,A,_,p.width,p.height);for(let e=0;e<6;e++){T=d[e].mipmaps;for(let i=0;i<T.length;i++){const s=T[i];r.format!==$g?null!==m?y?n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,s.width,s.height,m,s.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,_,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):y?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,s.width,s.height,m,g,s.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,_,s.width,s.height,0,m,g,s.data)}}}else{T=r.mipmaps,y&&E&&(T.length>0&&A++,n.texStorage2D(t.TEXTURE_CUBE_MAP,A,_,d[0].width,d[0].height));for(let e=0;e<6;e++)if(i){y?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,d[e].width,d[e].height,m,g,d[e].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,_,d[e].width,d[e].height,0,m,g,d[e].data);for(let i=0;i<T.length;i++){const r=T[i].image[e].image;y?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,r.width,r.height,m,g,r.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,_,r.width,r.height,0,m,g,r.data)}}else{y?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,m,g,d[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,_,m,g,d[e]);for(let i=0;i<T.length;i++){const r=T[i];y?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,m,g,r.image[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,_,m,g,r.image[e])}}}S(r,f)&&b(t.TEXTURE_CUBE_MAP),u.__version=h.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(o,e,r):n.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture,t.TEXTURE0+r)},this.rebindTextures=function(e,n,r){const s=i.get(e);void 0!==n&&F(s.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D),void 0!==r&&z(e)},this.setupRenderTarget=function(e){const l=e.texture,c=i.get(e),h=i.get(l);e.addEventListener("dispose",A),!0!==e.isWebGLMultipleRenderTargets&&(void 0===h.__webglTexture&&(h.__webglTexture=t.createTexture()),h.__version=l.version,o.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=x(e)||a;if(u){c.__webglFramebuffer=[];for(let e=0;e<6;e++)c.__webglFramebuffer[e]=t.createFramebuffer()}else{if(c.__webglFramebuffer=t.createFramebuffer(),d)if(r.drawBuffers){const n=e.texture;for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);void 0===r.__webglTexture&&(r.__webglTexture=t.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&e.samples>0&&!1===k(e)){const i=d?l:[l];c.__webglMultisampledFramebuffer=t.createFramebuffer(),c.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer);for(let n=0;n<i.length;n++){const r=i[n];c.__webglColorRenderbuffer[n]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,c.__webglColorRenderbuffer[n]);const o=s.convert(r.format,r.colorSpace),a=s.convert(r.type),l=M(r.internalFormat,o,a,r.colorSpace,!0===e.isXRRenderTarget),h=V(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,h,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+n,t.RENDERBUFFER,c.__webglColorRenderbuffer[n])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=t.createRenderbuffer(),B(c.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if(u){n.bindTexture(t.TEXTURE_CUBE_MAP,h.__webglTexture),D(t.TEXTURE_CUBE_MAP,l,p);for(let n=0;n<6;n++)F(c.__webglFramebuffer[n],e,l,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n);S(l,p)&&b(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(d){const r=e.texture;for(let s=0,o=r.length;s<o;s++){const o=r[s],a=i.get(o);n.bindTexture(t.TEXTURE_2D,a.__webglTexture),D(t.TEXTURE_2D,o,p),F(c.__webglFramebuffer,e,o,t.COLOR_ATTACHMENT0+s,t.TEXTURE_2D),S(o,p)&&b(t.TEXTURE_2D)}n.unbindTexture()}else{let i=t.TEXTURE_2D;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(a?i=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(i,h.__webglTexture),D(i,l,p),F(c.__webglFramebuffer,e,l,t.COLOR_ATTACHMENT0,i),S(l,p)&&b(i),n.unbindTexture()}e.depthBuffer&&z(e)},this.updateRenderTargetMipmap=function(e){const r=x(e)||a,s=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let o=0,a=s.length;o<a;o++){const a=s[o];if(S(a,r)){const r=e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:t.TEXTURE_2D,s=i.get(a).__webglTexture;n.bindTexture(r,s),b(r),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(a&&e.samples>0&&!1===k(e)){const r=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],s=e.width,o=e.height;let a=t.COLOR_BUFFER_BIT;const l=[],c=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,h=i.get(e),u=!0===e.isWebGLMultipleRenderTargets;if(u)for(let e=0;e<r.length;e++)n.bindFramebuffer(t.FRAMEBUFFER,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,h.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,h.__webglMultisampledFramebuffer),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,h.__webglFramebuffer);for(let n=0;n<r.length;n++){l.push(t.COLOR_ATTACHMENT0+n),e.depthBuffer&&l.push(c);const d=void 0!==h.__ignoreDepthValues&&h.__ignoreDepthValues;if(!1===d&&(e.depthBuffer&&(a|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&(a|=t.STENCIL_BUFFER_BIT)),u&&t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,h.__webglColorRenderbuffer[n]),!0===d&&(t.invalidateFramebuffer(t.READ_FRAMEBUFFER,[c]),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[c])),u){const e=i.get(r[n]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,s,o,0,0,s,o,a,t.NEAREST),p&&t.invalidateFramebuffer(t.READ_FRAMEBUFFER,l)}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),u)for(let e=0;e<r.length;e++){n.bindFramebuffer(t.FRAMEBUFFER,h.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,h.__webglColorRenderbuffer[e]);const s=i.get(r[e]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,h.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,s,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,h.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=z,this.setupFrameBufferTexture=F,this.useMultisampledRTT=k}function Ow(t,e,n){const i=n.isWebGL2;return{convert:function(n,r=ey){let s;if(n===Fg)return t.UNSIGNED_BYTE;if(n===jg)return t.UNSIGNED_SHORT_4_4_4_4;if(n===Xg)return t.UNSIGNED_SHORT_5_5_5_1;if(n===Bg)return t.BYTE;if(n===zg)return t.SHORT;if(n===Vg)return t.UNSIGNED_SHORT;if(n===kg)return t.INT;if(n===Gg)return t.UNSIGNED_INT;if(n===Hg)return t.FLOAT;if(n===Wg)return i?t.HALF_FLOAT:(s=e.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(n===qg)return t.ALPHA;if(n===$g)return t.RGBA;if(n===Zg)return t.LUMINANCE;if(n===Jg)return t.LUMINANCE_ALPHA;if(n===Kg)return t.DEPTH_COMPONENT;if(n===Qg)return t.DEPTH_STENCIL;if(n===Vy)return s=e.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(n===t_)return t.RED;if(n===e_)return t.RED_INTEGER;if(n===n_)return t.RG;if(n===i_)return t.RG_INTEGER;if(n===r_)return t.RGBA_INTEGER;if(n===s_||n===o_||n===a_||n===l_)if(r===ny){if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(n===s_)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===o_)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===a_)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===l_)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=e.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(n===s_)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===o_)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===a_)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===l_)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===c_||n===h_||n===u_||n===d_){if(s=e.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(n===c_)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===h_)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===u_)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===d_)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===p_)return s=e.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===f_||n===m_){if(s=e.get("WEBGL_compressed_texture_etc"),null===s)return null;if(n===f_)return r===ny?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===m_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(n===g_||n===__||n===y_||n===v_||n===x_||n===S_||n===b_||n===M_||n===w_||n===E_||n===T_||n===A_||n===C_||n===R_){if(s=e.get("WEBGL_compressed_texture_astc"),null===s)return null;if(n===g_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===__)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===y_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===v_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===x_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===S_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===b_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===M_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===w_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===E_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===T_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===A_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===C_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===R_)return r===ny?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===P_){if(s=e.get("EXT_texture_compression_bptc"),null===s)return null;if(n===P_)return r===ny?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}if(n===L_||n===I_||n===N_||n===D_){if(s=e.get("EXT_texture_compression_rgtc"),null===s)return null;if(n===P_)return s.COMPRESSED_RED_RGTC1_EXT;if(n===I_)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===N_)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===D_)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===Yg?i?t.UNSIGNED_INT_24_8:(s=e.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==t[n]?t[n]:null}}}class Uw extends nb{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class Fw extends Ux{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Bw={type:"move"};class zw{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Fw,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Fw,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Ov,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Ov),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Fw,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Ov,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Ov),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n),r=this._getHandJoint(l,i);null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],o=i.position.distanceTo(r.position),a=.02,c=.005;l.inputState.pinching&&o>a+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&o<=a-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1));null!==o&&(i=e.getPose(t.targetRaySpace,n),null===i&&null!==r&&(i=r),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Bw)))}return null!==o&&(o.visible=null!==i),null!==a&&(a.visible=null!==r),null!==l&&(l.visible=null!==s),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const n=new Fw;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class Vw extends Tv{constructor(t,e,n,i,r,s,o,a,l,c){if((c=void 0!==c?c:Kg)!==Kg&&c!==Qg)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===Kg&&(n=Gg),void 0===n&&c===Qg&&(n=Yg),super(null,i,r,s,o,a,c,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==o?o:Ag,this.minFilter=void 0!==a?a:Ag,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}class kw extends Hy{constructor(t,e){super();const n=this;let i=null,r=1,s=null,o="local-floor",a=1,l=null,c=null,h=null,u=null,d=null,p=null;const f=e.getContextAttributes();let m=null,g=null;const _=[],y=[];let v=null;const x=new nb;x.layers.enable(1),x.viewport=new Av;const S=new nb;S.layers.enable(2),S.viewport=new Av;const b=[x,S],M=new Uw;M.layers.enable(1),M.layers.enable(2);let w=null,E=null;function T(t){const e=y.indexOf(t.inputSource);if(-1===e)return;const n=_[e];void 0!==n&&(n.update(t.inputSource,t.frame,l||s),n.dispatchEvent({type:t.type,data:t.inputSource}))}function A(){i.removeEventListener("select",T),i.removeEventListener("selectstart",T),i.removeEventListener("selectend",T),i.removeEventListener("squeeze",T),i.removeEventListener("squeezestart",T),i.removeEventListener("squeezeend",T),i.removeEventListener("end",A),i.removeEventListener("inputsourceschange",C);for(let t=0;t<_.length;t++){const e=y[t];null!==e&&(y[t]=null,_[t].disconnect(e))}w=null,E=null,t.setRenderTarget(m),d=null,u=null,h=null,i=null,g=null,N.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function C(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=y.indexOf(n);i>=0&&(y[i]=null,_[i].disconnect(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let i=y.indexOf(n);if(-1===i){for(let t=0;t<_.length;t++){if(t>=y.length){y.push(n),i=t;break}if(null===y[t]){y[t]=n,i=t;break}}if(-1===i)break}const r=_[i];r&&r.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getCamera=function(){},this.setUserCamera=function(t){v=t},this.getController=function(t){let e=_[t];return void 0===e&&(e=new zw,_[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=_[t];return void 0===e&&(e=new zw,_[t]=e),e.getGripSpace()},this.getHand=function(t){let e=_[t];return void 0===e&&(e=new zw,_[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||s},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(c){if(i=c,null!==i){if(m=t.getRenderTarget(),i.addEventListener("select",T),i.addEventListener("selectstart",T),i.addEventListener("selectend",T),i.addEventListener("squeeze",T),i.addEventListener("squeezestart",T),i.addEventListener("squeezeend",T),i.addEventListener("end",A),i.addEventListener("inputsourceschange",C),!0!==f.xrCompatible&&await e.makeXRCompatible(),void 0===i.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==i.renderState.layers||f.antialias,alpha:!0,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,e,n),i.updateRenderState({baseLayer:d}),g=new Cv(d.framebufferWidth,d.framebufferHeight,{format:$g,type:Fg,colorSpace:t.outputColorSpace,stencilBuffer:f.stencil})}else{let n=null,s=null,o=null;f.depth&&(o=f.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,n=f.stencil?Qg:Kg,s=f.stencil?Yg:Gg);const a={colorFormat:e.RGBA8,depthFormat:o,scaleFactor:r};h=new XRWebGLBinding(i,e),u=h.createProjectionLayer(a),i.updateRenderState({layers:[u]}),g=new Cv(u.textureWidth,u.textureHeight,{format:$g,type:Fg,depthTexture:new Vw(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:f.stencil,colorSpace:t.outputColorSpace,samples:f.antialias?4:0}),t.properties.get(g).__ignoreDepthValues=u.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(a),l=null,s=await i.requestReferenceSpace(o),N.setContext(i),N.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==i)return i.environmentBlendMode};const R=new Ov,P=new Ov;function L(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCameraXR=function(t){if(null===i)return t;v&&(t=v),M.near=S.near=x.near=t.near,M.far=S.far=x.far=t.far,w===M.near&&E===M.far||(i.updateRenderState({depthNear:M.near,depthFar:M.far}),w=M.near,E=M.far);const e=t.parent,n=M.cameras;L(M,e);for(let t=0;t<n.length;t++)L(n[t],e);return 2===n.length?function(t,e,n){R.setFromMatrixPosition(e.matrixWorld),P.setFromMatrixPosition(n.matrixWorld);const i=R.distanceTo(P),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],h=(r[8]-1)/r[0],u=(s[8]+1)/s[0],d=o*h,p=o*u,f=i/(-h+u),m=f*-h;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=o+f,_=a+f,y=d-m,v=p+(i-m),x=l*a/_*g,S=c*a/_*g;t.projectionMatrix.makePerspective(y,v,x,S,g,_),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}(M,x,S):M.projectionMatrix.copy(x.projectionMatrix),v&&function(t,e){const n=v;null===e?n.matrix.copy(t.matrixWorld):(n.matrix.copy(e.matrixWorld),n.matrix.invert(),n.matrix.multiply(t.matrixWorld)),n.matrix.decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0);const i=n.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);n.projectionMatrix.copy(t.projectionMatrix),n.projectionMatrixInverse.copy(t.projectionMatrixInverse),n.isPerspectiveCamera&&(n.fov=2*Yy*Math.atan(1/n.projectionMatrix.elements[5]),n.zoom=1)}(M,e),M},this.getFoveation=function(){if(null!==u||null!==d)return a},this.setFoveation=function(t){a=t,null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};let I=null;const N=new fb;N.setAnimationLoop(function(e,i){if(c=i.getViewerPose(l||s),p=i,null!==c){const e=c.views;null!==d&&(t.setRenderTargetFramebuffer(g,d.framebuffer),t.setRenderTarget(g));let n=!1;e.length!==M.cameras.length&&(M.cameras.length=0,n=!0);for(let i=0;i<e.length;i++){const r=e[i];let s=null;if(null!==d)s=d.getViewport(r);else{const e=h.getViewSubImage(u,r);s=e.viewport,0===i&&(t.setRenderTargetTextures(g,e.colorTexture,u.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(g))}let o=b[i];void 0===o&&(o=new nb,o.layers.enable(i),o.viewport=new Av,b[i]=o),o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.quaternion,o.scale),o.projectionMatrix.fromArray(r.projectionMatrix),o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),o.viewport.set(s.x,s.y,s.width,s.height),0===i&&(M.matrix.copy(o.matrix),M.matrix.decompose(M.position,M.quaternion,M.scale)),!0===n&&M.cameras.push(o)}}for(let t=0;t<_.length;t++){const e=y[t],n=_[t];null!==e&&void 0!==n&&n.update(e,i,l||s)}I&&I(e,i),i.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:i}),p=null}),this.setAnimationLoop=function(t){I=t},this.dispose=function(){}}}function Gw(t,e){function n(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function i(i,r){i.opacity.value=r.opacity,r.color&&i.diffuse.value.copy(r.color),r.emissive&&i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(i.map.value=r.map,n(r.map,i.mapTransform)),r.alphaMap&&(i.alphaMap.value=r.alphaMap,n(r.alphaMap,i.alphaMapTransform)),r.bumpMap&&(i.bumpMap.value=r.bumpMap,n(r.bumpMap,i.bumpMapTransform),i.bumpScale.value=r.bumpScale,r.side===Pm&&(i.bumpScale.value*=-1)),r.normalMap&&(i.normalMap.value=r.normalMap,n(r.normalMap,i.normalMapTransform),i.normalScale.value.copy(r.normalScale),r.side===Pm&&i.normalScale.value.negate()),r.displacementMap&&(i.displacementMap.value=r.displacementMap,n(r.displacementMap,i.displacementMapTransform),i.displacementScale.value=r.displacementScale,i.displacementBias.value=r.displacementBias),r.emissiveMap&&(i.emissiveMap.value=r.emissiveMap,n(r.emissiveMap,i.emissiveMapTransform)),r.specularMap&&(i.specularMap.value=r.specularMap,n(r.specularMap,i.specularMapTransform)),r.alphaTest>0&&(i.alphaTest.value=r.alphaTest);const s=e.get(r).envMap;if(s&&(i.envMap.value=s,i.flipEnvMap.value=s.isCubeTexture&&!1===s.isRenderTargetTexture?-1:1,i.reflectivity.value=r.reflectivity,i.ior.value=r.ior,i.refractionRatio.value=r.refractionRatio),r.lightMap){i.lightMap.value=r.lightMap;const e=!0===t.useLegacyLights?Math.PI:1;i.lightMapIntensity.value=r.lightMapIntensity*e,n(r.lightMap,i.lightMapTransform)}r.aoMap&&(i.aoMap.value=r.aoMap,i.aoMapIntensity.value=r.aoMapIntensity,n(r.aoMap,i.aoMapTransform))}return{refreshFogUniforms:function(e,n){n.color.getRGB(e.fogColor.value,KS(t)),n.isFog?(e.fogNear.value=n.near,e.fogFar.value=n.far):n.isFogExp2&&(e.fogDensity.value=n.density)},refreshMaterialUniforms:function(t,r,s,o,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?i(t,r):r.isMeshToonMaterial?(i(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,r)):r.isMeshPhongMaterial?(i(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,r)):r.isMeshStandardMaterial?(i(t,r),function(t,i){t.metalness.value=i.metalness,i.metalnessMap&&(t.metalnessMap.value=i.metalnessMap,n(i.metalnessMap,t.metalnessMapTransform)),t.roughness.value=i.roughness,i.roughnessMap&&(t.roughnessMap.value=i.roughnessMap,n(i.roughnessMap,t.roughnessMapTransform));e.get(i).envMap&&(t.envMapIntensity.value=i.envMapIntensity)}(t,r),r.isMeshPhysicalMaterial&&function(t,e,i){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,n(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,n(e.sheenRoughnessMap,t.sheenRoughnessMapTransform))),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,n(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,n(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,n(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),e.side===Pm&&t.clearcoatNormalScale.value.negate())),e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,n(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,n(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform))),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,n(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,n(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,n(e.anisotropyMap,t.anisotropyMapTransform))),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,n(e.specularColorMap,t.specularColorMapTransform)),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,n(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,r,a)):r.isMeshMatcapMaterial?(i(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,r)):r.isMeshDepthMaterial?i(t,r):r.isMeshDistanceMaterial?(i(t,r),function(t,n){const i=e.get(n).light;t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),t.nearDistance.value=i.shadow.camera.near,t.farDistance.value=i.shadow.camera.far}(t,r)):r.isMeshNormalMaterial?i(t,r):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform))}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,i,r){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*i,t.scale.value=.5*r,e.map&&(t.map.value=e.map,n(e.map,t.uvTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r,s,o):r.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function Hw(t,e,n,i){let r={},s={},o=[];const a=n.isWebGL2?t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(t,e,n){const i=t.value;if(void 0===n[e]){if("number"==typeof i)n[e]=i;else{const t=Array.isArray(i)?i:[i],r=[];for(let e=0;e<t.length;e++)r.push(t[e].clone());n[e]=r}return!0}if("number"==typeof i){if(n[e]!==i)return n[e]=i,!0}else{const t=Array.isArray(n[e])?n[e]:[n[e]],r=Array.isArray(i)?i:[i];for(let e=0;e<t.length;e++){const n=t[e];if(!1===n.equals(r[e]))return n.copy(r[e]),!0}}return!1}function c(t){const e={boundary:0,storage:0};return"number"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),e}function h(e){const n=e.target;n.removeEventListener("dispose",h);const i=o.indexOf(n.__bindingPointIndex);o.splice(i,1),t.deleteBuffer(r[n.id]),delete r[n.id],delete s[n.id]}return{bind:function(t,e){const n=e.program;i.uniformBlockBinding(t,n)},update:function(n,u){let d=r[n.id];void 0===d&&(function(t){const e=t.uniforms;let n=0;let i=0;for(let t=0,r=e.length;t<r;t++){const r=e[t],s={boundary:0,storage:0},o=Array.isArray(r.value)?r.value:[r.value];for(let t=0,e=o.length;t<e;t++){const e=c(o[t]);s.boundary+=e.boundary,s.storage+=e.storage}r.__data=new Float32Array(s.storage/Float32Array.BYTES_PER_ELEMENT),r.__offset=n,t>0&&(i=n%16,0!==i&&16-i-s.boundary<0&&(n+=16-i,r.__offset=n)),n+=s.storage}i=n%16,i>0&&(n+=16-i),t.__size=n,t.__cache={}}(n),d=function(e){const n=function(){for(let t=0;t<a;t++)if(-1===o.indexOf(t))return o.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=n;const i=t.createBuffer(),r=e.__size,s=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,i),t.bufferData(t.UNIFORM_BUFFER,r,s),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,n,i),i}(n),r[n.id]=d,n.addEventListener("dispose",h));const p=u.program;i.updateUBOMapping(n,p);const f=e.render.frame;s[n.id]!==f&&(function(e){const n=r[e.id],i=e.uniforms,s=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,n);for(let e=0,n=i.length;e<n;e++){const n=i[e];if(!0===l(n,e,s)){const e=n.__offset,i=Array.isArray(n.value)?n.value:[n.value];let r=0;for(let s=0;s<i.length;s++){const o=i[s],a=c(o);"number"==typeof o?(n.__data[0]=o,t.bufferSubData(t.UNIFORM_BUFFER,e+r,n.__data)):o.isMatrix3?(n.__data[0]=o.elements[0],n.__data[1]=o.elements[1],n.__data[2]=o.elements[2],n.__data[3]=o.elements[0],n.__data[4]=o.elements[3],n.__data[5]=o.elements[4],n.__data[6]=o.elements[5],n.__data[7]=o.elements[0],n.__data[8]=o.elements[6],n.__data[9]=o.elements[7],n.__data[10]=o.elements[8],n.__data[11]=o.elements[0]):(o.toArray(n.__data,r),r+=a.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,n.__data)}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(n),s[n.id]=f)},dispose:function(){for(const e in r)t.deleteBuffer(r[e]);o=[],r={},s={}}}}function Ww(){const t=hv("canvas");return t.style.display="block",t}class jw{constructor(t={}){const{canvas:e=Ww(),context:n=null,depth:i=!0,stencil:r=!0,alpha:s=!1,antialias:o=!1,premultipliedAlpha:a=!0,preserveDrawingBuffer:l=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:h=!1}=t;let u;this.isWebGLRenderer=!0,u=null!==n?n.getContextAttributes().alpha:s;const d=new Uint32Array(4),p=new Int32Array(4);let f=null,m=null;const g=[],_=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputColorSpace=ny,this.useLegacyLights=!0,this.toneMapping=dg,this.toneMappingExposure=1;const y=this;let v=!1,x=0,S=0,b=null,M=-1,w=null;const E=new Av,T=new Av;let A=null;const C=new eS(0);let R=0,P=e.width,L=e.height,I=1,N=null,D=null;const O=new Av(0,0,P,L),U=new Av(0,0,P,L);let F=!1;const B=new pb;let z=!1,V=!1,k=null;const G=new ux,H=new rv,W=new Ov,j={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function X(){return null===b?I:1}let Y,q,$,Z,J,K,Q,tt,et,nt,it,rt,st,ot,at,lt,ct,ht,ut,dt,pt,ft,mt,gt,_t=n;function yt(t,n){for(let i=0;i<t.length;i++){const r=t[i],s=e.getContext(r,n);if(null!==s)return s}return null}try{const t={alpha:!0,depth:i,stencil:r,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${ym}`),e.addEventListener("webglcontextlost",St,!1),e.addEventListener("webglcontextrestored",bt,!1),e.addEventListener("webglcontextcreationerror",Mt,!1),null===_t){const e=["webgl2","webgl","experimental-webgl"];if(!0===y.isWebGL1Renderer&&e.shift(),_t=yt(e,t),null===_t)throw yt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}_t instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),void 0===_t.getShaderPrecisionFormat&&(_t.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function vt(){Y=new kb(_t),q=new wb(_t,Y,t),Y.init(q),ft=new Ow(_t,Y,q),$=new Nw(_t,Y,q),Z=new Wb(_t),J=new vw,K=new Dw(_t,Y,$,J,q,ft,Z),Q=new Tb(y),tt=new Vb(y),et=new mb(_t,q),mt=new bb(_t,Y,et,q),nt=new Gb(_t,et,Z,mt),it=new qb(_t,nt,et,Z),ut=new Yb(_t,q,K),lt=new Eb(J),rt=new yw(y,Q,tt,Y,q,mt,lt),st=new Gw(y,J),ot=new Mw,at=new Rw(Y,q),ht=new Sb(y,Q,tt,$,it,u,a),ct=new Iw(y,it,q),gt=new Hw(_t,Z,q,$),dt=new Mb(_t,Y,Z,q),pt=new Hb(_t,Y,Z,q),Z.programs=rt.programs,y.capabilities=q,y.extensions=Y,y.properties=J,y.renderLists=ot,y.shadowMap=ct,y.state=$,y.info=Z}vt();const xt=new kw(y,_t);function St(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function bt(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const t=Z.autoReset,e=ct.enabled,n=ct.autoUpdate,i=ct.needsUpdate,r=ct.type;vt(),Z.autoReset=t,ct.enabled=e,ct.autoUpdate=n,ct.needsUpdate=i,ct.type=r}function Mt(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function wt(t){const e=t.target;e.removeEventListener("dispose",wt),function(t){(function(t){const e=J.get(t).programs;void 0!==e&&(e.forEach(function(t){rt.releaseProgram(t)}),t.isShaderMaterial&&rt.releaseShaderCache(t))})(t),J.remove(t)}(e)}this.xr=xt,this.getContext=function(){return _t},this.getContextAttributes=function(){return _t.getContextAttributes()},this.forceContextLoss=function(){const t=Y.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=Y.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return I},this.setPixelRatio=function(t){void 0!==t&&(I=t,this.setSize(P,L,!1))},this.getSize=function(t){return t.set(P,L)},this.setSize=function(t,n,i=!0){xt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(P=t,L=n,e.width=Math.floor(t*I),e.height=Math.floor(n*I),!0===i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(P*I,L*I).floor()},this.setDrawingBufferSize=function(t,n,i){P=t,L=n,I=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(E)},this.getViewport=function(t){return t.copy(O)},this.setViewport=function(t,e,n,i){t.isVector4?O.set(t.x,t.y,t.z,t.w):O.set(t,e,n,i),$.viewport(E.copy(O).multiplyScalar(I).floor())},this.getScissor=function(t){return t.copy(U)},this.setScissor=function(t,e,n,i){t.isVector4?U.set(t.x,t.y,t.z,t.w):U.set(t,e,n,i),$.scissor(T.copy(U).multiplyScalar(I).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(t){$.setScissorTest(F=t)},this.setOpaqueSort=function(t){N=t},this.setTransparentSort=function(t){D=t},this.getClearColor=function(t){return t.copy(ht.getClearColor())},this.setClearColor=function(){ht.setClearColor.apply(ht,arguments)},this.getClearAlpha=function(){return ht.getClearAlpha()},this.setClearAlpha=function(){ht.setClearAlpha.apply(ht,arguments)},this.clear=function(t=!0,e=!0,n=!0){let i=0;if(t){let t=!1;if(null!==b){const e=b.texture.format;t=e===r_||e===i_||e===e_}if(t){const t=b.texture.type,e=t===Fg||t===Gg||t===Vg||t===Yg||t===jg||t===Xg,n=ht.getClearColor(),i=ht.getClearAlpha(),r=n.r,s=n.g,o=n.b,a=J.get(b).__webglFramebuffer;e?(d[0]=r,d[1]=s,d[2]=o,d[3]=i,_t.clearBufferuiv(_t.COLOR,a,d)):(p[0]=r,p[1]=s,p[2]=o,p[3]=i,_t.clearBufferiv(_t.COLOR,a,p))}else i|=_t.COLOR_BUFFER_BIT}e&&(i|=_t.DEPTH_BUFFER_BIT),n&&(i|=_t.STENCIL_BUFFER_BIT),_t.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",St,!1),e.removeEventListener("webglcontextrestored",bt,!1),e.removeEventListener("webglcontextcreationerror",Mt,!1),ot.dispose(),at.dispose(),J.dispose(),Q.dispose(),tt.dispose(),it.dispose(),mt.dispose(),gt.dispose(),rt.dispose(),xt.dispose(),xt.removeEventListener("sessionstart",Tt),xt.removeEventListener("sessionend",At),k&&(k.dispose(),k=null),Ct.stop()},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=j);const o=r.isMesh&&r.matrixWorld.determinant()<0,a=function(t,e,n,i,r){!0!==e.isScene&&(e=j),K.resetTextureUnits();const s=e.fog,o=i.isMeshStandardMaterial?e.environment:null,a=null===b?y.outputColorSpace:!0===b.isXRRenderTarget?b.texture.colorSpace:iy,l=(i.isMeshStandardMaterial?tt:Q).get(i.envMap||o),c=!0===i.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!n.attributes.tangent&&(!!i.normalMap||i.anisotropy>0),u=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=!!n.morphAttributes.color,f=i.toneMapped?y.toneMapping:dg,g=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,_=void 0!==g?g.length:0,v=J.get(i),x=m.state.lights;if(!0===z&&(!0===V||t!==w)){const e=t===w&&i.id===M;lt.setState(i,t,e)}let S=!1;i.version===v.__version?v.needsLights&&v.lightsStateVersion!==x.state.version||v.outputColorSpace!==a||r.isInstancedMesh&&!1===v.instancing?S=!0:r.isInstancedMesh||!0!==v.instancing?r.isSkinnedMesh&&!1===v.skinning?S=!0:r.isSkinnedMesh||!0!==v.skinning?v.envMap!==l||!0===i.fog&&v.fog!==s?S=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===lt.numPlanes&&v.numIntersection===lt.numIntersection?(v.vertexAlphas!==c||v.vertexTangents!==h||v.morphTargets!==u||v.morphNormals!==d||v.morphColors!==p||v.toneMapping!==f||!0===q.isWebGL2&&v.morphTargetsCount!==_)&&(S=!0):S=!0:S=!0:S=!0:(S=!0,v.__version=i.version);let E=v.currentProgram;!0===S&&(E=Nt(i,e,r));let T=!1,A=!1,C=!1;const R=E.getUniforms(),P=v.uniforms;if($.useProgram(E.program)&&(T=!0,A=!0,C=!0),i.id!==M&&(M=i.id,A=!0),T||w!==t){if(R.setValue(_t,"projectionMatrix",t.projectionMatrix),q.logarithmicDepthBuffer&&R.setValue(_t,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),w!==t&&(w=t,A=!0,C=!0),i.isShaderMaterial||i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshStandardMaterial||i.envMap){const e=R.map.cameraPosition;void 0!==e&&e.setValue(_t,W.setFromMatrixPosition(t.matrixWorld))}(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial)&&R.setValue(_t,"isOrthographic",!0===t.isOrthographicCamera),(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial||i.isShadowMaterial||r.isSkinnedMesh)&&R.setValue(_t,"viewMatrix",t.matrixWorldInverse)}if(r.isSkinnedMesh){R.setOptional(_t,r,"bindMatrix"),R.setOptional(_t,r,"bindMatrixInverse");const t=r.skeleton;t&&(q.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),R.setValue(_t,"boneTexture",t.boneTexture,K),R.setValue(_t,"boneTextureSize",t.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const N=n.morphAttributes;var D,O;if((void 0!==N.position||void 0!==N.normal||void 0!==N.color&&!0===q.isWebGL2)&&ut.update(r,n,E),(A||v.receiveShadow!==r.receiveShadow)&&(v.receiveShadow=r.receiveShadow,R.setValue(_t,"receiveShadow",r.receiveShadow)),i.isMeshGouraudMaterial&&null!==i.envMap&&(P.envMap.value=l,P.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1),A&&(R.setValue(_t,"toneMappingExposure",y.toneMappingExposure),v.needsLights&&(O=C,(D=P).ambientLightColor.needsUpdate=O,D.lightProbe.needsUpdate=O,D.directionalLights.needsUpdate=O,D.directionalLightShadows.needsUpdate=O,D.pointLights.needsUpdate=O,D.pointLightShadows.needsUpdate=O,D.spotLights.needsUpdate=O,D.spotLightShadows.needsUpdate=O,D.rectAreaLights.needsUpdate=O,D.hemisphereLights.needsUpdate=O),s&&!0===i.fog&&st.refreshFogUniforms(P,s),st.refreshMaterialUniforms(P,i,I,L,k),KM.upload(_t,v.uniformsList,P,K)),i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(KM.upload(_t,v.uniformsList,P,K),i.uniformsNeedUpdate=!1),i.isSpriteMaterial&&R.setValue(_t,"center",r.center),R.setValue(_t,"modelViewMatrix",r.modelViewMatrix),R.setValue(_t,"normalMatrix",r.normalMatrix),R.setValue(_t,"modelMatrix",r.matrixWorld),i.isShaderMaterial||i.isRawShaderMaterial){const t=i.uniformsGroups;for(let e=0,n=t.length;e<n;e++)if(q.isWebGL2){const n=t[e];gt.update(n,E),gt.bind(n,E)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return E}(t,e,n,i,r);$.setMaterial(i,o);let l=n.index,c=1;!0===i.wireframe&&(l=nt.getWireframeAttribute(n),c=2);const h=n.drawRange,u=n.attributes.position;let d=h.start*c,p=(h.start+h.count)*c;null!==s&&(d=Math.max(d,s.start*c),p=Math.min(p,(s.start+s.count)*c)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=u&&(d=Math.max(d,0),p=Math.min(p,u.count));const f=p-d;if(f<0||f===1/0)return;let g;mt.setup(r,i,a,n,l);let _=dt;if(null!==l&&(g=et.get(l),_=pt,_.setIndex(g)),r.isMesh)!0===i.wireframe?($.setLineWidth(i.wireframeLinewidth*X()),_.setMode(_t.LINES)):_.setMode(_t.TRIANGLES);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),$.setLineWidth(t*X()),r.isLineSegments?_.setMode(_t.LINES):r.isLineLoop?_.setMode(_t.LINE_LOOP):_.setMode(_t.LINE_STRIP)}else r.isPoints?_.setMode(_t.POINTS):r.isSprite&&_.setMode(_t.TRIANGLES);if(r.isInstancedMesh)_.renderInstances(d,f,r.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,e=Math.min(n.instanceCount,t);_.renderInstances(d,f,e)}else _.render(d,f)},this.compile=function(t,e){function n(t,e,n){!0===t.transparent&&t.side===Lm&&!1===t.forceSinglePass?(t.side=Pm,t.needsUpdate=!0,Nt(t,e,n),t.side=Rm,t.needsUpdate=!0,Nt(t,e,n),t.side=Lm):Nt(t,e,n)}m=at.get(t),m.init(),_.push(m),t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(m.pushLight(t),t.castShadow&&m.pushShadow(t))}),m.setupLights(y.useLegacyLights),t.traverse(function(e){const i=e.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++)n(i[r],t,e);else n(i,t,e)}),_.pop(),m=null};let Et=null;function Tt(){Ct.stop()}function At(){Ct.start()}const Ct=new fb;function Rt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)m.pushLight(t),t.castShadow&&m.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||B.intersectsSprite(t)){i&&W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);const e=it.update(t),r=t.material;r.visible&&f.push(t,e,r,n,W.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||B.intersectsObject(t))){t.isSkinnedMesh&&t.skeleton.frame!==Z.render.frame&&(t.skeleton.update(),t.skeleton.frame=Z.render.frame);const e=it.update(t),r=t.material;if(i&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),W.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),W.copy(e.boundingSphere.center)),W.applyMatrix4(t.matrixWorld).applyMatrix4(G)),Array.isArray(r)){const i=e.groups;for(let s=0,o=i.length;s<o;s++){const o=i[s],a=r[o.materialIndex];a&&a.visible&&f.push(t,e,a,n,W.z,o)}}else r.visible&&f.push(t,e,r,n,W.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)Rt(r[t],e,n,i)}function Pt(t,e,n,i){const r=t.opaque,s=t.transmissive,a=t.transparent;m.setupLightsView(n),!0===z&&lt.setGlobalState(y.clippingPlanes,n),s.length>0&&function(t,e,n,i){const r=q.isWebGL2;null===k&&(k=new Cv(1,1,{generateMipmaps:!0,type:Y.has("EXT_color_buffer_half_float")?Wg:Fg,minFilter:Og,samples:r&&!0===o?4:0})),y.getDrawingBufferSize(H),r?k.setSize(H.x,H.y):k.setSize(tv(H.x),tv(H.y));const s=y.getRenderTarget();y.setRenderTarget(k),y.getClearColor(C),R=y.getClearAlpha(),R<1&&y.setClearColor(16777215,.5),y.clear();const a=y.toneMapping;y.toneMapping=dg,Lt(t,n,i),K.updateMultisampleRenderTarget(k),K.updateRenderTargetMipmap(k);let l=!1;for(let t=0,r=e.length;t<r;t++){const r=e[t],s=r.object,o=r.geometry,a=r.material,c=r.group;if(a.side===Lm&&s.layers.test(i.layers)){const t=a.side;a.side=Pm,a.needsUpdate=!0,It(s,n,i,o,a,c),a.side=t,a.needsUpdate=!0,l=!0}}!0===l&&(K.updateMultisampleRenderTarget(k),K.updateRenderTargetMipmap(k)),y.setRenderTarget(s),y.setClearColor(C,R),y.toneMapping=a}(r,s,e,n),i&&$.viewport(E.copy(i)),r.length>0&&Lt(r,e,n),s.length>0&&Lt(s,e,n),a.length>0&&Lt(a,e,n),$.buffers.depth.setTest(!0),$.buffers.depth.setMask(!0),$.buffers.color.setMask(!0),$.setPolygonOffset(!1)}function Lt(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],o=s.object,a=s.geometry,l=null===i?s.material:i,c=s.group;o.layers.test(n.layers)&&It(o,e,n,a,l,c)}}function It(t,e,n,i,r,s){t.onBeforeRender(y,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),r.onBeforeRender(y,e,n,i,t,s),!0===r.transparent&&r.side===Lm&&!1===r.forceSinglePass?(r.side=Pm,r.needsUpdate=!0,y.renderBufferDirect(n,e,i,r,t,s),r.side=Rm,r.needsUpdate=!0,y.renderBufferDirect(n,e,i,r,t,s),r.side=Lm):y.renderBufferDirect(n,e,i,r,t,s),t.onAfterRender(y,e,n,i,r,s)}function Nt(t,e,n){!0!==e.isScene&&(e=j);const i=J.get(t),r=m.state.lights,s=m.state.shadowsArray,o=r.state.version,a=rt.getParameters(t,r.state,s,e,n),l=rt.getProgramCacheKey(a);let c=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?tt:Q).get(t.envMap||i.environment),void 0===c&&(t.addEventListener("dispose",wt),c=new Map,i.programs=c);let h=c.get(l);if(void 0!==h){if(i.currentProgram===h&&i.lightsStateVersion===o)return Dt(t,a),h}else a.uniforms=rt.getUniforms(t),t.onBuild(n,a,y),t.onBeforeCompile(a,y),h=rt.acquireProgram(a,l),c.set(l,h),i.uniforms=a.uniforms;const u=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=lt.uniform),Dt(t,a),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=o,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotLightMatrix.value=r.state.spotLightMatrix,u.spotLightMap.value=r.state.spotLightMap,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);const d=h.getUniforms(),p=KM.seqWithValue(d.seq,u);return i.currentProgram=h,i.uniformsList=p,h}function Dt(t,e){const n=J.get(t);n.outputColorSpace=e.outputColorSpace,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}Ct.setAnimationLoop(function(t){Et&&Et(t)}),"undefined"!=typeof self&&Ct.setContext(self),this.setAnimationLoop=function(t){Et=t,xt.setAnimationLoop(t),null===t?Ct.stop():Ct.start()},xt.addEventListener("sessionstart",Tt),xt.addEventListener("sessionend",At),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===v)return;!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===xt.enabled&&!0===xt.isPresenting&&(e=xt.updateCameraXR(e)),!0===t.isScene&&t.onBeforeRender(y,t,e,b),m=at.get(t,_.length),m.init(),_.push(m),G.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),B.setFromProjectionMatrix(G),V=this.localClippingEnabled,z=lt.init(this.clippingPlanes,V),f=ot.get(t,g.length),f.init(),g.push(f),Rt(t,e,0,y.sortObjects),f.finish(),!0===y.sortObjects&&f.sort(N,D),!0===z&&lt.beginShadows();const n=m.state.shadowsArray;if(ct.render(n,t,e),!0===z&&lt.endShadows(),!0===this.info.autoReset&&this.info.reset(),this.info.render.frame++,ht.render(f,t),m.setupLights(y.useLegacyLights),e.isArrayCamera){const n=e.cameras;for(let e=0,i=n.length;e<i;e++){const i=n[e];Pt(f,t,i,i.viewport)}}else Pt(f,t,e);null!==b&&(K.updateMultisampleRenderTarget(b),K.updateRenderTargetMipmap(b)),!0===t.isScene&&t.onAfterRender(y,t,e),mt.resetDefaultState(),M=-1,w=null,_.pop(),m=_.length>0?_[_.length-1]:null,g.pop(),f=g.length>0?g[g.length-1]:null},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return b},this.setRenderTargetTextures=function(t,e,n){J.get(t.texture).__webglTexture=e,J.get(t.depthTexture).__webglTexture=n;const i=J.get(t);i.__hasExternalTextures=!0,i.__hasExternalTextures&&(i.__autoAllocateDepthBuffer=void 0===n,i.__autoAllocateDepthBuffer||!0===Y.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),i.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(t,e){const n=J.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){b=t,x=e,S=n;let i=!0,r=null,s=!1,o=!1;if(t){const n=J.get(t);void 0!==n.__useDefaultFramebuffer?($.bindFramebuffer(_t.FRAMEBUFFER,null),i=!1):void 0===n.__webglFramebuffer?K.setupRenderTarget(t):n.__hasExternalTextures&&K.rebindTextures(t,J.get(t.texture).__webglTexture,J.get(t.depthTexture).__webglTexture);const a=t.texture;(a.isData3DTexture||a.isDataArrayTexture||a.isCompressedArrayTexture)&&(o=!0);const l=J.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(r=l[e],s=!0):r=q.isWebGL2&&t.samples>0&&!1===K.useMultisampledRTT(t)?J.get(t).__webglMultisampledFramebuffer:l,E.copy(t.viewport),T.copy(t.scissor),A=t.scissorTest}else E.copy(O).multiplyScalar(I).floor(),T.copy(U).multiplyScalar(I).floor(),A=F;if($.bindFramebuffer(_t.FRAMEBUFFER,r)&&q.drawBuffers&&i&&$.drawBuffers(t,r),$.viewport(E),$.scissor(T),$.setScissorTest(A),s){const i=J.get(t.texture);_t.framebufferTexture2D(_t.FRAMEBUFFER,_t.COLOR_ATTACHMENT0,_t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i.__webglTexture,n)}else if(o){const i=J.get(t.texture),r=e||0;_t.framebufferTextureLayer(_t.FRAMEBUFFER,_t.COLOR_ATTACHMENT0,i.__webglTexture,n||0,r)}M=-1},this.readRenderTargetPixels=function(t,e,n,i,r,s,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=J.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){$.bindFramebuffer(_t.FRAMEBUFFER,a);try{const o=t.texture,a=o.format,l=o.type;if(a!==$g&&ft.convert(a)!==_t.getParameter(_t.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===Wg&&(Y.has("EXT_color_buffer_half_float")||q.isWebGL2&&Y.has("EXT_color_buffer_float"));if(!(l===Fg||ft.convert(l)===_t.getParameter(_t.IMPLEMENTATION_COLOR_READ_TYPE)||l===Hg&&(q.isWebGL2||Y.has("OES_texture_float")||Y.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&_t.readPixels(e,n,i,r,ft.convert(a),ft.convert(l),s)}finally{const t=null!==b?J.get(b).__webglFramebuffer:null;$.bindFramebuffer(_t.FRAMEBUFFER,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i);K.setTexture2D(e,0),_t.copyTexSubImage2D(_t.TEXTURE_2D,n,0,0,t.x,t.y,r,s),$.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,o=ft.convert(n.format),a=ft.convert(n.type);K.setTexture2D(n,0),_t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL,n.flipY),_t.pixelStorei(_t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),_t.pixelStorei(_t.UNPACK_ALIGNMENT,n.unpackAlignment),e.isDataTexture?_t.texSubImage2D(_t.TEXTURE_2D,i,t.x,t.y,r,s,o,a,e.image.data):e.isCompressedTexture?_t.compressedTexSubImage2D(_t.TEXTURE_2D,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):_t.texSubImage2D(_t.TEXTURE_2D,i,t.x,t.y,o,a,e.image),0===i&&n.generateMipmaps&&_t.generateMipmap(_t.TEXTURE_2D),$.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(y.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,o=t.max.y-t.min.y+1,a=t.max.z-t.min.z+1,l=ft.convert(i.format),c=ft.convert(i.type);let h;if(i.isData3DTexture)K.setTexture3D(i,0),h=_t.TEXTURE_3D;else{if(!i.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");K.setTexture2DArray(i,0),h=_t.TEXTURE_2D_ARRAY}_t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL,i.flipY),_t.pixelStorei(_t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),_t.pixelStorei(_t.UNPACK_ALIGNMENT,i.unpackAlignment);const u=_t.getParameter(_t.UNPACK_ROW_LENGTH),d=_t.getParameter(_t.UNPACK_IMAGE_HEIGHT),p=_t.getParameter(_t.UNPACK_SKIP_PIXELS),f=_t.getParameter(_t.UNPACK_SKIP_ROWS),m=_t.getParameter(_t.UNPACK_SKIP_IMAGES),g=n.isCompressedTexture?n.mipmaps[0]:n.image;_t.pixelStorei(_t.UNPACK_ROW_LENGTH,g.width),_t.pixelStorei(_t.UNPACK_IMAGE_HEIGHT,g.height),_t.pixelStorei(_t.UNPACK_SKIP_PIXELS,t.min.x),_t.pixelStorei(_t.UNPACK_SKIP_ROWS,t.min.y),_t.pixelStorei(_t.UNPACK_SKIP_IMAGES,t.min.z),n.isDataTexture||n.isData3DTexture?_t.texSubImage3D(h,r,e.x,e.y,e.z,s,o,a,l,c,g.data):n.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),_t.compressedTexSubImage3D(h,r,e.x,e.y,e.z,s,o,a,l,g.data)):_t.texSubImage3D(h,r,e.x,e.y,e.z,s,o,a,l,c,g),_t.pixelStorei(_t.UNPACK_ROW_LENGTH,u),_t.pixelStorei(_t.UNPACK_IMAGE_HEIGHT,d),_t.pixelStorei(_t.UNPACK_SKIP_PIXELS,p),_t.pixelStorei(_t.UNPACK_SKIP_ROWS,f),_t.pixelStorei(_t.UNPACK_SKIP_IMAGES,m),0===r&&i.generateMipmaps&&_t.generateMipmap(h),$.unbindTexture()},this.initTexture=function(t){t.isCubeTexture?K.setTextureCube(t,0):t.isData3DTexture?K.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?K.setTexture2DArray(t,0):K.setTexture2D(t,0),$.unbindTexture()},this.resetState=function(){x=0,S=0,b=null,$.reset(),mt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return ky}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(t){console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!t}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===ny?Z_:$_}set outputEncoding(t){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=t===Z_?ny:iy}}class Xw extends jw{}Xw.prototype.isWebGL1Renderer=!0;class Yw{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new eS(t),this.density=e}clone(){return new Yw(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class qw{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new eS(t),this.near=e,this.far=n}clone(){return new qw(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class $w extends Ux{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(t){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=t}}class Zw{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=Ry,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=qy()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=qy()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=qy()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Jw=new Ov;class Kw{constructor(t,e,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Jw.fromBufferAttribute(this,e),Jw.applyMatrix4(t),this.setXYZ(e,Jw.x,Jw.y,Jw.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Jw.fromBufferAttribute(this,e),Jw.applyNormalMatrix(t),this.setXYZ(e,Jw.x,Jw.y,Jw.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Jw.fromBufferAttribute(this,e),Jw.transformDirection(t),this.setXYZ(e,Jw.x,Jw.y,Jw.z);return this}setX(t,e){return this.normalized&&(e=nv(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=nv(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=nv(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=nv(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=ev(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=ev(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=ev(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=ev(e,this.array)),e}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=nv(e,this.array),n=nv(n,this.array),i=nv(i,this.array),r=nv(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new uS(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Kw(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Qw extends Zx{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new eS(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let tE;const eE=new Ov,nE=new Ov,iE=new Ov,rE=new rv,sE=new rv,oE=new ux,aE=new Ov,lE=new Ov,cE=new Ov,hE=new rv,uE=new rv,dE=new rv;class pE extends Ux{constructor(t){if(super(),this.isSprite=!0,this.type="Sprite",void 0===tE){tE=new RS;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new Zw(t,5);tE.setIndex([0,1,2,0,2,3]),tE.setAttribute("position",new Kw(e,3,0,!1)),tE.setAttribute("uv",new Kw(e,2,3,!1))}this.geometry=tE,this.material=void 0!==t?t:new Qw,this.center=new rv(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),nE.setFromMatrixScale(this.matrixWorld),oE.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),iE.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&nE.multiplyScalar(-iE.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;fE(aE.set(-.5,-.5,0),iE,s,nE,i,r),fE(lE.set(.5,-.5,0),iE,s,nE,i,r),fE(cE.set(.5,.5,0),iE,s,nE,i,r),hE.set(0,0),uE.set(1,0),dE.set(1,1);let o=t.ray.intersectTriangle(aE,lE,cE,!1,eE);if(null===o&&(fE(lE.set(-.5,.5,0),iE,s,nE,i,r),uE.set(0,1),o=t.ray.intersectTriangle(aE,cE,lE,!1,eE),null===o))return;const a=t.ray.origin.distanceTo(eE);a<t.near||a>t.far||e.push({distance:a,point:eE.clone(),uv:qx.getInterpolation(eE,aE,lE,cE,hE,uE,dE,new rv),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function fE(t,e,n,i,r,s){rE.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(sE.x=s*rE.x-r*rE.y,sE.y=r*rE.x+s*rE.y):sE.copy(rE),t.copy(e),t.x+=sE.x,t.y+=sE.y,t.applyMatrix4(oE)}const mE=new Ov,gE=new Ov;class _E extends Ux{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance,n.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,n=0){e=Math.abs(e);const i=this.levels;let r;for(r=0;r<i.length&&!(e<i[r].distance);r++);return i.splice(r,0,{distance:e,hysteresis:n,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i;n++){let i=e[n].distance;if(e[n].object.visible&&(i-=i*e[n].hysteresis),t<i)break}return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){mE.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(mE);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){mE.setFromMatrixPosition(t.matrixWorld),gE.setFromMatrixPosition(this.matrixWorld);const n=mE.distanceTo(gE)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r;i++){let t=e[i].distance;if(e[i].object.visible&&(t-=t*e[i].hysteresis),!(n>=t))break;e[i-1].object.visible=!1,e[i].object.visible=!0}for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,i=n.length;t<i;t++){const i=n[t];e.object.levels.push({object:i.object.uuid,distance:i.distance,hysteresis:i.hysteresis})}return e}}const yE=new Ov,vE=new Av,xE=new Av,SE=new Ov,bE=new ux,ME=new Ov,wE=new nx,EE=new ux,TE=new hx;class AE extends YS{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ux,this.bindMatrixInverse=new ux,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new Bv),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)ME.fromBufferAttribute(e,t),this.applyBoneTransform(t,ME),this.boundingBox.expandByPoint(ME)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new nx),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)ME.fromBufferAttribute(e,t),this.applyBoneTransform(t,ME),this.boundingSphere.expandByPoint(ME)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const n=this.material,i=this.matrixWorld;void 0!==n&&(null===this.boundingSphere&&this.computeBoundingSphere(),wE.copy(this.boundingSphere),wE.applyMatrix4(i),!1!==t.ray.intersectsSphere(wE)&&(EE.copy(i).invert(),TE.copy(t.ray).applyMatrix4(EE),null!==this.boundingBox&&!1===TE.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,TE)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Av,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.fromBufferAttribute(e,n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const n=this.skeleton,i=this.geometry;vE.fromBufferAttribute(i.attributes.skinIndex,t),xE.fromBufferAttribute(i.attributes.skinWeight,t),yE.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=xE.getComponent(t);if(0!==i){const r=vE.getComponent(t);bE.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(SE.copy(yE).applyMatrix4(bE),i)}}return e.applyMatrix4(this.bindMatrixInverse)}boneTransform(t,e){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(t,e)}}class CE extends Ux{constructor(){super(),this.isBone=!0,this.type="Bone"}}class RE extends Tv{constructor(t=null,e=1,n=1,i,r,s,o,a,l=Ag,c=Ag,h,u){super(null,s,o,a,l,c,i,r,h,u),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const PE=new ux,LE=new ux;class IE{constructor(t=[],e=[]){this.uuid=qy(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new ux)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new ux;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,r=t.length;i<r;i++){const r=t[i]?t[i].matrixWorld:LE;PE.multiplyMatrices(r,e[i]),PE.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)}clone(){return new IE(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=Qy(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new RE(e,t,t,$g,Hg);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new CE),this.bones.push(r),this.boneInverses.push((new ux).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const r=e[i];t.bones.push(r.uuid);const s=n[i];t.boneInverses.push(s.toArray())}return t}}class NE extends uS{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const DE=new ux,OE=new ux,UE=[],FE=new Bv,BE=new ux,zE=new YS,VE=new nx;class kE extends YS{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new NE(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<n;t++)this.setMatrixAt(t,BE)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new Bv),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,DE),FE.copy(t.boundingBox).applyMatrix4(DE),this.boundingBox.union(FE)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new nx),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,DE),VE.copy(t.boundingSphere).applyMatrix4(DE),this.boundingSphere.union(VE)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(zE.geometry=this.geometry,zE.material=this.material,void 0!==zE.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),VE.copy(this.boundingSphere),VE.applyMatrix4(n),!1!==t.ray.intersectsSphere(VE)))for(let r=0;r<i;r++){this.getMatrixAt(r,DE),OE.multiplyMatrices(n,DE),zE.matrixWorld=OE,zE.raycast(t,UE);for(let t=0,n=UE.length;t<n;t++){const n=UE[t];n.instanceId=r,n.object=this,e.push(n)}UE.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new NE(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class GE extends Zx{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new eS(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const HE=new Ov,WE=new Ov,jE=new ux,XE=new hx,YE=new nx;class qE extends Ux{constructor(t=new RS,e=new GE){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)HE.fromBufferAttribute(e,t-1),WE.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=HE.distanceTo(WE);t.setAttribute("lineDistance",new xS(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),YE.copy(n.boundingSphere),YE.applyMatrix4(i),YE.radius+=r,!1===t.ray.intersectsSphere(YE))return;jE.copy(i).invert(),XE.copy(t.ray).applyMatrix4(jE);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=new Ov,c=new Ov,h=new Ov,u=new Ov,d=this.isLineSegments?2:1,p=n.index,f=n.attributes.position;if(null!==p)for(let n=Math.max(0,s.start),i=Math.min(p.count,s.start+s.count)-1;n<i;n+=d){const i=p.getX(n),r=p.getX(n+1);if(l.fromBufferAttribute(f,i),c.fromBufferAttribute(f,r),XE.distanceSqToSegment(l,c,u,h)>a)continue;u.applyMatrix4(this.matrixWorld);const s=t.ray.origin.distanceTo(u);s<t.near||s>t.far||e.push({distance:s,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,s.start),i=Math.min(f.count,s.start+s.count)-1;n<i;n+=d){if(l.fromBufferAttribute(f,n),c.fromBufferAttribute(f,n+1),XE.distanceSqToSegment(l,c,u,h)>a)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}const $E=new Ov,ZE=new Ov;class JE extends qE{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)$E.fromBufferAttribute(e,t),ZE.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+$E.distanceTo(ZE);t.setAttribute("lineDistance",new xS(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class KE extends qE{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class QE extends Zx{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new eS(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const tT=new ux,eT=new hx,nT=new nx,iT=new Ov;class rT extends Ux{constructor(t=new RS,e=new QE){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),nT.copy(n.boundingSphere),nT.applyMatrix4(i),nT.radius+=r,!1===t.ray.intersectsSphere(nT))return;tT.copy(i).invert(),eT.copy(t.ray).applyMatrix4(tT);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=n.index,c=n.attributes.position;if(null!==l)for(let n=Math.max(0,s.start),r=Math.min(l.count,s.start+s.count);n<r;n++){const r=l.getX(n);iT.fromBufferAttribute(c,r),sT(iT,r,a,i,t,e,this)}else for(let n=Math.max(0,s.start),r=Math.min(c.count,s.start+s.count);n<r;n++)iT.fromBufferAttribute(c,n),sT(iT,n,a,i,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function sT(t,e,n,i,r,s,o){const a=eT.distanceSqToPoint(t);if(a<n){const n=new Ov;eT.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:o})}}class oT extends Tv{constructor(t,e,n,i,r,s,o,a,l){super(t,e,n,i,r,s,o,a,l),this.isVideoTexture=!0,this.minFilter=void 0!==s?s:Ig,this.magFilter=void 0!==r?r:Ig,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)})}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class aT extends Tv{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=Ag,this.minFilter=Ag,this.generateMipmaps=!1,this.needsUpdate=!0}}class lT extends Tv{constructor(t,e,n,i,r,s,o,a,l,c,h,u){super(null,s,o,a,l,c,i,r,h,u),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class cT extends lT{constructor(t,e,n,i,r,s){super(t,e,n,r,s),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Eg}}class hT extends Tv{constructor(t,e,n,i,r,s,o,a,l){super(t,e,n,i,r,s,o,a,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class uT{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let o,a=0,l=r-1;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),o=n[i]-s,o<0)a=i+1;else{if(!(o>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const c=n[i];return(i+(s-c)/(n[i+1]-c))/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=e||(s.isVector2?new rv:new Ov);return a.copy(o).sub(s).normalize(),a}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new Ov,i=[],r=[],s=[],o=new Ov,a=new ux;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new Ov)}r[0]=new Ov,s[0]=new Ov;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),h=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),s[e]=s[e-1].clone(),o.crossVectors(i[e-1],i[e]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos($y(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(a.makeRotationAxis(o,t))}s[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos($y(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(a.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class dT extends uT{constructor(t=0,e=0,n=1,i=1,r=0,s=2*Math.PI,o=!1,a=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=o,this.aRotation=a}getPoint(t,e){const n=e||new rv,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const o=this.aStartAngle+t*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,i=l-this.aY;a=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(a,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class pT extends dT{constructor(t,e,n,i,r,s){super(t,e,n,n,i,r,s),this.isArcCurve=!0,this.type="ArcCurve"}}function fT(){let t=0,e=0,n=0,i=0;function r(r,s,o,a){t=r,e=o,n=-3*r+3*s-2*o-a,i=2*r-2*s+o+a}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,o,a){let l=(e-t)/s-(n-t)/(s+o)+(n-e)/o,c=(n-e)/o-(i-e)/(o+a)+(i-n)/a;l*=o,c*=o,r(e,n,l,c)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}const mT=new Ov,gT=new fT,_T=new fT,yT=new fT;class vT extends uT{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new Ov){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let o,a,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?o=i[(l-1)%r]:(mT.subVectors(i[0],i[1]).add(i[0]),o=mT);const h=i[l%r],u=i[(l+1)%r];if(this.closed||l+2<r?a=i[(l+2)%r]:(mT.subVectors(i[r-1],i[r-2]).add(i[r-1]),a=mT),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(h),t),n=Math.pow(h.distanceToSquared(u),t),i=Math.pow(u.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),gT.initNonuniformCatmullRom(o.x,h.x,u.x,a.x,e,n,i),_T.initNonuniformCatmullRom(o.y,h.y,u.y,a.y,e,n,i),yT.initNonuniformCatmullRom(o.z,h.z,u.z,a.z,e,n,i)}else"catmullrom"===this.curveType&&(gT.initCatmullRom(o.x,h.x,u.x,a.x,this.tension),_T.initCatmullRom(o.y,h.y,u.y,a.y,this.tension),yT.initCatmullRom(o.z,h.z,u.z,a.z,this.tension));return n.set(gT.calc(c),_T.calc(c),yT.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new Ov).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function xT(t,e,n,i,r){const s=.5*(i-e),o=.5*(r-n),a=t*t;return(2*n-2*i+s+o)*(t*a)+(-3*n+3*i-2*s-o)*a+s*t+n}function ST(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function bT(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}class MT extends uT{constructor(t=new rv,e=new rv,n=new rv,i=new rv){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new rv){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(bT(t,i.x,r.x,s.x,o.x),bT(t,i.y,r.y,s.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class wT extends uT{constructor(t=new Ov,e=new Ov,n=new Ov,i=new Ov){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new Ov){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(bT(t,i.x,r.x,s.x,o.x),bT(t,i.y,r.y,s.y,o.y),bT(t,i.z,r.z,s.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class ET extends uT{constructor(t=new rv,e=new rv){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new rv){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new rv){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class TT extends uT{constructor(t=new Ov,e=new Ov){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new Ov){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new Ov){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class AT extends uT{constructor(t=new rv,e=new rv,n=new rv){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new rv){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(ST(t,i.x,r.x,s.x),ST(t,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class CT extends uT{constructor(t=new Ov,e=new Ov,n=new Ov){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Ov){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(ST(t,i.x,r.x,s.x),ST(t,i.y,r.y,s.y),ST(t,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class RT extends uT{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new rv){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),o=r-s,a=i[0===s?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],h=i[s>i.length-3?i.length-1:s+2];return n.set(xT(o,a.x,l.x,c.x,h.x),xT(o,a.y,l.y,c.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new rv).fromArray(n))}return this}}var PT=Object.freeze({__proto__:null,ArcCurve:pT,CatmullRomCurve3:vT,CubicBezierCurve:MT,CubicBezierCurve3:wT,EllipseCurve:dT,LineCurve:ET,LineCurve3:TT,QuadraticBezierCurve:AT,QuadraticBezierCurve3:CT,SplineCurve:RT});class LT extends uT{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new ET(e,t))}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const t=i[r]-n,s=this.curves[r],o=s.getLength(),a=0===o?0:1-t/o;return s.getPointAt(a,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s.isEllipseCurve?2*t:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?t*s.points.length:t,a=s.getPoints(o);for(let t=0;t<a.length;t++){const i=a[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new PT[n.type]).fromJSON(n))}return this}}class IT extends LT{constructor(t){super(),this.type="Path",this.currentPoint=new rv,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new ET(this.currentPoint.clone(),new rv(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new AT(this.currentPoint.clone(),new rv(t,e),new rv(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,s){const o=new MT(this.currentPoint.clone(),new rv(t,e),new rv(n,i),new rv(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new RT(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,n,i,r,s),this}absarc(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this}ellipse(t,e,n,i,r,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,i,r,s,o,a),this}absellipse(t,e,n,i,r,s,o,a){const l=new dT(t,e,n,i,r,s,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class NT extends RS{constructor(t=[new rv(0,-.5),new rv(.5,0),new rv(0,.5)],e=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=$y(i,0,2*Math.PI);const r=[],s=[],o=[],a=[],l=[],c=1/e,h=new Ov,u=new rv,d=new Ov,p=new Ov,f=new Ov;let m=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),a.push(d.x,d.y,d.z);break;case t.length-1:a.push(f.x,f.y,f.z);break;default:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),a.push(d.x,d.y,d.z),f.copy(p)}for(let r=0;r<=e;r++){const d=n+r*c*i,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=t.length-1;n++){h.x=t[n].x*p,h.y=t[n].y,h.z=t[n].x*f,s.push(h.x,h.y,h.z),u.x=r/e,u.y=n/(t.length-1),o.push(u.x,u.y);const i=a[3*n+0]*p,c=a[3*n+1],d=a[3*n+0]*f;l.push(i,c,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const i=e+n*t.length,s=i,o=i+t.length,a=i+t.length+1,l=i+1;r.push(s,o,l),r.push(a,l,o)}this.setIndex(r),this.setAttribute("position",new xS(s,3)),this.setAttribute("uv",new xS(o,2)),this.setAttribute("normal",new xS(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new NT(t.points,t.segments,t.phiStart,t.phiLength)}}class DT extends NT{constructor(t=1,e=1,n=4,i=8){const r=new IT;r.absarc(0,-e/2,t,1.5*Math.PI,0),r.absarc(0,e/2,t,0,.5*Math.PI),super(r.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:i}}static fromJSON(t){return new DT(t.radius,t.length,t.capSegments,t.radialSegments)}}class OT extends RS{constructor(t=1,e=32,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],s=[],o=[],a=[],l=new Ov,c=new rv;s.push(0,0,0),o.push(0,0,1),a.push(.5,.5);for(let r=0,h=3;r<=e;r++,h+=3){const u=n+r/e*i;l.x=t*Math.cos(u),l.y=t*Math.sin(u),s.push(l.x,l.y,l.z),o.push(0,0,1),c.x=(s[h]/t+1)/2,c.y=(s[h+1]/t+1)/2,a.push(c.x,c.y)}for(let t=1;t<=e;t++)r.push(t,t+1,0);this.setIndex(r),this.setAttribute("position",new xS(s,3)),this.setAttribute("normal",new xS(o,3)),this.setAttribute("uv",new xS(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new OT(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class UT extends RS{constructor(t=1,e=1,n=1,i=32,r=1,s=!1,o=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a};const l=this;i=Math.floor(i),r=Math.floor(r);const c=[],h=[],u=[],d=[];let p=0;const f=[],m=n/2;let g=0;function _(n){const r=p,s=new rv,f=new Ov;let _=0;const y=!0===n?t:e,v=!0===n?1:-1;for(let t=1;t<=i;t++)h.push(0,m*v,0),u.push(0,v,0),d.push(.5,.5),p++;const x=p;for(let t=0;t<=i;t++){const e=t/i*a+o,n=Math.cos(e),r=Math.sin(e);f.x=y*r,f.y=m*v,f.z=y*n,h.push(f.x,f.y,f.z),u.push(0,v,0),s.x=.5*n+.5,s.y=.5*r*v+.5,d.push(s.x,s.y),p++}for(let t=0;t<i;t++){const e=r+t,i=x+t;!0===n?c.push(i,i+1,e):c.push(i+1,i,e),_+=3}l.addGroup(g,_,!0===n?1:2),g+=_}!function(){const s=new Ov,_=new Ov;let y=0;const v=(e-t)/n;for(let l=0;l<=r;l++){const c=[],g=l/r,y=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*a+o,l=Math.sin(r),f=Math.cos(r);_.x=y*l,_.y=-g*n+m,_.z=y*f,h.push(_.x,_.y,_.z),s.set(l,v,f).normalize(),u.push(s.x,s.y,s.z),d.push(e,1-g),c.push(p++)}f.push(c)}for(let t=0;t<i;t++)for(let e=0;e<r;e++){const n=f[e][t],i=f[e+1][t],r=f[e+1][t+1],s=f[e][t+1];c.push(n,i,s),c.push(i,r,s),y+=6}l.addGroup(g,y,0),g+=y}(),!1===s&&(t>0&&_(!0),e>0&&_(!1)),this.setIndex(c),this.setAttribute("position",new xS(h,3)),this.setAttribute("normal",new xS(u,3)),this.setAttribute("uv",new xS(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new UT(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class FT extends UT{constructor(t=1,e=1,n=32,i=1,r=!1,s=0,o=2*Math.PI){super(0,t,e,n,i,r,s,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:o}}static fromJSON(t){return new FT(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class BT extends RS{constructor(t=[],e=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],s=[];function o(t,e,n,i){const r=i+1,s=[];for(let i=0;i<=r;i++){s[i]=[];const o=t.clone().lerp(n,i/r),a=e.clone().lerp(n,i/r),l=r-i;for(let t=0;t<=l;t++)s[i][t]=0===t&&i===r?o:o.clone().lerp(a,t/l)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const n=Math.floor(e/2);e%2==0?(a(s[t][n+1]),a(s[t+1][n]),a(s[t][n])):(a(s[t][n+1]),a(s[t+1][n+1]),a(s[t+1][n]))}}function a(t){r.push(t.x,t.y,t.z)}function l(e,n){const i=3*e;n.x=t[i+0],n.y=t[i+1],n.z=t[i+2]}function c(t,e,n,i){i<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=i/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}function u(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}!function(t){const n=new Ov,i=new Ov,r=new Ov;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],i),l(e[s+2],r),o(n,i,r,t)}(i),function(t){const e=new Ov;for(let n=0;n<r.length;n+=3)e.x=r[n+0],e.y=r[n+1],e.z=r[n+2],e.normalize().multiplyScalar(t),r[n+0]=e.x,r[n+1]=e.y,r[n+2]=e.z}(n),function(){const t=new Ov;for(let e=0;e<r.length;e+=3){t.x=r[e+0],t.y=r[e+1],t.z=r[e+2];const n=h(t)/2/Math.PI+.5,i=u(t)/Math.PI+.5;s.push(n,1-i)}(function(){const t=new Ov,e=new Ov,n=new Ov,i=new Ov,o=new rv,a=new rv,l=new rv;for(let u=0,d=0;u<r.length;u+=9,d+=6){t.set(r[u+0],r[u+1],r[u+2]),e.set(r[u+3],r[u+4],r[u+5]),n.set(r[u+6],r[u+7],r[u+8]),o.set(s[d+0],s[d+1]),a.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),i.copy(t).add(e).add(n).divideScalar(3);const p=h(i);c(o,d+0,t,p),c(a,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],i=s[t+4],r=Math.max(e,n,i),o=Math.min(e,n,i);r>.9&&o<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),i<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new xS(r,3)),this.setAttribute("normal",new xS(r.slice(),3)),this.setAttribute("uv",new xS(s,2)),0===i?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new BT(t.vertices,t.indices,t.radius,t.details)}}class zT extends BT{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new zT(t.radius,t.detail)}}const VT=new Ov,kT=new Ov,GT=new Ov,HT=new qx;class WT extends RS{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,i=Math.pow(10,n),r=Math.cos(Xy*e),s=t.getIndex(),o=t.getAttribute("position"),a=s?s.count:o.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let t=0;t<a;t+=3){s?(l[0]=s.getX(t),l[1]=s.getX(t+1),l[2]=s.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:a}=HT;if(e.fromBufferAttribute(o,l[0]),n.fromBufferAttribute(o,l[1]),a.fromBufferAttribute(o,l[2]),HT.getNormal(GT),h[0]=`${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`,h[1]=`${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`,h[2]=`${Math.round(a.x*i)},${Math.round(a.y*i)},${Math.round(a.z*i)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=h[t],i=h[e],s=HT[c[t]],o=HT[c[e]],a=`${n}_${i}`,p=`${i}_${n}`;p in u&&u[p]?(GT.dot(u[p].normal)<=r&&(d.push(s.x,s.y,s.z),d.push(o.x,o.y,o.z)),u[p]=null):a in u||(u[a]={index0:l[t],index1:l[e],normal:GT.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];VT.fromBufferAttribute(o,e),kT.fromBufferAttribute(o,n),d.push(VT.x,VT.y,VT.z),d.push(kT.x,kT.y,kT.z)}this.setAttribute("position",new xS(d,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class jT extends IT{constructor(t){super(t),this.uuid=qy(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new IT).fromJSON(n))}return this}}function XT(t,e,n,i,r){let s,o;if(r===function(t,e,n,i){let r=0;for(let s=e,o=n-i;s<n;s+=i)r+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return r}(t,e,n,i)>0)for(s=e;s<n;s+=i)o=pA(s,t[s],t[s+1],o);else for(s=n-i;s>=e;s-=i)o=pA(s,t[s],t[s+1],o);return o&&aA(o,o.next)&&(fA(o),o=o.next),o}function YT(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!aA(i,i.next)&&0!==oA(i.prev,i,i.next))i=i.next;else{if(fA(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function qT(t,e,n,i,r,s,o){if(!t)return;!o&&s&&function(t,e,n,i){let r=t;do{0===r.z&&(r.z=nA(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,s,o,a,l,c=1;do{for(n=t,t=null,s=null,o=0;n;){for(o++,i=n,a=0,e=0;e<c&&(a++,i=i.nextZ,i);e++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;n=i}s.nextZ=null,c*=2}while(o>1)}(r)}(t,i,r,s);let a,l,c=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,s?ZT(t,i,r,s):$T(t))e.push(a.i/n|0),e.push(t.i/n|0),e.push(l.i/n|0),fA(t),t=l.next,c=l.next;else if((t=l)===c){o?1===o?qT(t=JT(YT(t),e,n),e,n,i,r,s,2):2===o&&KT(t,e,n,i,r,s):qT(YT(t),e,n,i,r,s,1);break}}function $T(t){const e=t.prev,n=t,i=t.next;if(oA(e,n,i)>=0)return!1;const r=e.x,s=n.x,o=i.x,a=e.y,l=n.y,c=i.y,h=r<s?r<o?r:o:s<o?s:o,u=a<l?a<c?a:c:l<c?l:c,d=r>s?r>o?r:o:s>o?s:o,p=a>l?a>c?a:c:l>c?l:c;let f=i.next;for(;f!==e;){if(f.x>=h&&f.x<=d&&f.y>=u&&f.y<=p&&rA(r,a,s,l,o,c,f.x,f.y)&&oA(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function ZT(t,e,n,i){const r=t.prev,s=t,o=t.next;if(oA(r,s,o)>=0)return!1;const a=r.x,l=s.x,c=o.x,h=r.y,u=s.y,d=o.y,p=a<l?a<c?a:c:l<c?l:c,f=h<u?h<d?h:d:u<d?u:d,m=a>l?a>c?a:c:l>c?l:c,g=h>u?h>d?h:d:u>d?u:d,_=nA(p,f,e,n,i),y=nA(m,g,e,n,i);let v=t.prevZ,x=t.nextZ;for(;v&&v.z>=_&&x&&x.z<=y;){if(v.x>=p&&v.x<=m&&v.y>=f&&v.y<=g&&v!==r&&v!==o&&rA(a,h,l,u,c,d,v.x,v.y)&&oA(v.prev,v,v.next)>=0)return!1;if(v=v.prevZ,x.x>=p&&x.x<=m&&x.y>=f&&x.y<=g&&x!==r&&x!==o&&rA(a,h,l,u,c,d,x.x,x.y)&&oA(x.prev,x,x.next)>=0)return!1;x=x.nextZ}for(;v&&v.z>=_;){if(v.x>=p&&v.x<=m&&v.y>=f&&v.y<=g&&v!==r&&v!==o&&rA(a,h,l,u,c,d,v.x,v.y)&&oA(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;x&&x.z<=y;){if(x.x>=p&&x.x<=m&&x.y>=f&&x.y<=g&&x!==r&&x!==o&&rA(a,h,l,u,c,d,x.x,x.y)&&oA(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function JT(t,e,n){let i=t;do{const r=i.prev,s=i.next.next;!aA(r,s)&&lA(r,i,i.next,s)&&uA(r,s)&&uA(s,r)&&(e.push(r.i/n|0),e.push(i.i/n|0),e.push(s.i/n|0),fA(i),fA(i.next),i=t=s),i=i.next}while(i!==t);return YT(i)}function KT(t,e,n,i,r,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&sA(o,t)){let a=dA(o,t);return o=YT(o,o.next),a=YT(a,a.next),qT(o,e,n,i,r,s,0),void qT(a,e,n,i,r,s,0)}t=t.next}o=o.next}while(o!==t)}function QT(t,e){return t.x-e.x}function tA(t,e){const n=function(t,e){let n,i=e,r=-1/0;const s=t.x,o=t.y;do{if(o<=i.y&&o>=i.next.y&&i.next.y!==i.y){const t=i.x+(o-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(t<=s&&t>r&&(r=t,n=i.x<i.next.x?i:i.next,t===s))return n}i=i.next}while(i!==e);if(!n)return null;const a=n,l=n.x,c=n.y;let h,u=1/0;i=n;do{s>=i.x&&i.x>=l&&s!==i.x&&rA(o<c?s:r,o,l,c,o<c?r:s,o,i.x,i.y)&&(h=Math.abs(o-i.y)/(s-i.x),uA(i,t)&&(h<u||h===u&&(i.x>n.x||i.x===n.x&&eA(n,i)))&&(n=i,u=h)),i=i.next}while(i!==a);return n}(t,e);if(!n)return e;const i=dA(n,t);return YT(i,i.next),YT(n,n.next)}function eA(t,e){return oA(t.prev,t,e.prev)<0&&oA(e.next,t,t.next)<0}function nA(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function iA(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function rA(t,e,n,i,r,s,o,a){return(r-o)*(e-a)>=(t-o)*(s-a)&&(t-o)*(i-a)>=(n-o)*(e-a)&&(n-o)*(s-a)>=(r-o)*(i-a)}function sA(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&lA(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(uA(t,e)&&uA(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(oA(t.prev,t,e.prev)||oA(t,e.prev,e))||aA(t,e)&&oA(t.prev,t,t.next)>0&&oA(e.prev,e,e.next)>0)}function oA(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function aA(t,e){return t.x===e.x&&t.y===e.y}function lA(t,e,n,i){const r=hA(oA(t,e,n)),s=hA(oA(t,e,i)),o=hA(oA(n,i,t)),a=hA(oA(n,i,e));return r!==s&&o!==a||!(0!==r||!cA(t,n,e))||!(0!==s||!cA(t,i,e))||!(0!==o||!cA(n,t,i))||!(0!==a||!cA(n,e,i))}function cA(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function hA(t){return t>0?1:t<0?-1:0}function uA(t,e){return oA(t.prev,t,t.next)<0?oA(t,e,t.next)>=0&&oA(t,t.prev,e)>=0:oA(t,e,t.prev)<0||oA(t,t.next,e)<0}function dA(t,e){const n=new mA(t.i,t.x,t.y),i=new mA(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function pA(t,e,n,i){const r=new mA(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function fA(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function mA(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class gA{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n}static isClockWise(t){return gA.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];_A(t),yA(n,t);let s=t.length;e.forEach(_A);for(let t=0;t<e.length;t++)i.push(s),s+=e[t].length,yA(n,e[t]);const o=function(t,e,n=2){const i=e&&e.length,r=i?e[0]*n:t.length;let s=XT(t,0,r,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,h,u,d,p;if(i&&(s=function(t,e,n,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:t.length,c=XT(t,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(iA(c));for(r.sort(QT),s=0;s<r.length;s++)n=tA(r[s],n);return n}(t,e,s,n)),t.length>80*n){a=c=t[0],l=h=t[1];for(let e=n;e<r;e+=n)u=t[e],d=t[e+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-a,h-l),p=0!==p?32767/p:0}return qT(s,o,n,a,l,p,0),o}(n,i);for(let t=0;t<o.length;t+=3)r.push(o.slice(t,t+3));return r}}function _A(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function yA(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class vA extends RS{constructor(t=new jT([new rv(.5,.5),new rv(-.5,.5),new rv(-.5,-.5),new rv(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++)s(t[e]);function s(t){const s=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let c=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:xA;let g,_,y,v,x,S=!1;f&&(g=f.getSpacedPoints(a),S=!0,c=!1,_=f.computeFrenetFrames(a,!1),y=new Ov,v=new Ov,x=new Ov),c||(p=0,h=0,u=0,d=0);const b=t.extractPoints(o);let M=b.shape;const w=b.holes;if(!gA.isClockWise(M)){M=M.reverse();for(let t=0,e=w.length;t<e;t++){const e=w[t];gA.isClockWise(e)&&(w[t]=e.reverse())}}const E=gA.triangulateShape(M,w),T=M;for(let t=0,e=w.length;t<e;t++){const e=w[t];M=M.concat(e)}function A(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,n)}const C=M.length,R=E.length;function P(t,e,n){let i,r,s;const o=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,h=o*o+a*a,u=o*c-a*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=e.x-a/u,f=e.y+o/u,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(o*c-a*l);i=p+o*m-t.x,r=f+a*m-t.y;const g=i*i+r*r;if(g<=2)return new rv(i,r);s=Math.sqrt(g/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(i=-a,r=o,s=Math.sqrt(h)):(i=o,r=a,s=Math.sqrt(h/2))}return new rv(i/s,r/s)}const L=[];for(let t=0,e=T.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),L[t]=P(T[t],T[n],T[i]);const I=[];let N,D=L.concat();for(let t=0,e=w.length;t<e;t++){const e=w[t];N=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),N[t]=P(e[t],e[i],e[r]);I.push(N),D=D.concat(N)}for(let t=0;t<p;t++){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=T.length;t<e;t++){const e=A(T[t],L[t],i);F(e.x,e.y,-n)}for(let t=0,e=w.length;t<e;t++){const e=w[t];N=I[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],N[t],i);F(r.x,r.y,-n)}}}const O=u+d;for(let t=0;t<C;t++){const e=c?A(M[t],D[t],O):M[t];S?(v.copy(_.normals[0]).multiplyScalar(e.x),y.copy(_.binormals[0]).multiplyScalar(e.y),x.copy(g[0]).add(v).add(y),F(x.x,x.y,x.z)):F(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<C;e++){const n=c?A(M[e],D[e],O):M[e];S?(v.copy(_.normals[t]).multiplyScalar(n.x),y.copy(_.binormals[t]).multiplyScalar(n.y),x.copy(g[t]).add(v).add(y),F(x.x,x.y,x.z)):F(n.x,n.y,l/a*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=T.length;t<e;t++){const e=A(T[t],L[t],i);F(e.x,e.y,l+n)}for(let t=0,e=w.length;t<e;t++){const e=w[t];N=I[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],N[t],i);S?F(r.x,r.y+g[a-1].y,g[a-1].x+n):F(r.x,r.y,l+n)}}}function U(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=a+2*p;t<n;t++){const n=C*t,s=C*(t+1);z(e+i+n,e+r+n,e+r+s,e+i+s)}}}function F(t,e,n){s.push(t),s.push(e),s.push(n)}function B(t,e,r){V(t),V(e),V(r);const s=i.length/3,o=m.generateTopUV(n,i,s-3,s-2,s-1);k(o[0]),k(o[1]),k(o[2])}function z(t,e,r,s){V(t),V(e),V(s),V(e),V(r),V(s);const o=i.length/3,a=m.generateSideWallUV(n,i,o-6,o-3,o-2,o-1);k(a[0]),k(a[1]),k(a[3]),k(a[1]),k(a[2]),k(a[3])}function V(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function k(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=C*t;for(let t=0;t<R;t++){const n=E[t];B(n[2]+e,n[1]+e,n[0]+e)}t=a+2*p,e=C*t;for(let t=0;t<R;t++){const n=E[t];B(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<R;t++){const e=E[t];B(e[2],e[1],e[0])}for(let t=0;t<R;t++){const e=E[t];B(e[0]+C*a,e[1]+C*a,e[2]+C*a)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;U(T,e),e+=T.length;for(let t=0,n=w.length;t<n;t++){const n=w[t];U(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new xS(i,3)),this.setAttribute("uv",new xS(r,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);return n.options=Object.assign({},e),void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}const i=t.options.extrudePath;return void 0!==i&&(t.options.extrudePath=(new PT[i.type]).fromJSON(i)),new vA(n,t.options)}}const xA={generateTopUV:function(t,e,n,i,r){const s=e[3*n],o=e[3*n+1],a=e[3*i],l=e[3*i+1],c=e[3*r],h=e[3*r+1];return[new rv(s,o),new rv(a,l),new rv(c,h)]},generateSideWallUV:function(t,e,n,i,r,s){const o=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*i],h=e[3*i+1],u=e[3*i+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*s],g=e[3*s+1],_=e[3*s+2];return Math.abs(a-h)<Math.abs(o-c)?[new rv(o,1-l),new rv(c,1-u),new rv(d,1-f),new rv(m,1-_)]:[new rv(a,1-l),new rv(h,1-u),new rv(p,1-f),new rv(g,1-_)]}};class SA extends BT{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new SA(t.radius,t.detail)}}class bA extends BT{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new bA(t.radius,t.detail)}}class MA extends RS{constructor(t=.5,e=1,n=32,i=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n);const o=[],a=[],l=[],c=[];let h=t;const u=(e-t)/(i=Math.max(1,i)),d=new Ov,p=new rv;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*s;d.x=h*Math.cos(i),d.y=h*Math.sin(i),a.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}h+=u}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,s=i+n+1,a=i+n+2,l=i+1;o.push(r,s,l),o.push(s,a,l)}}this.setIndex(o),this.setAttribute("position",new xS(a,3)),this.setAttribute("normal",new xS(l,3)),this.setAttribute("uv",new xS(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new MA(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class wA extends RS{constructor(t=new jT([new rv(0,.5),new rv(-.5,-.5),new rv(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(o,a,e),o+=a,a=0;function l(t){const o=i.length/3,l=t.extractPoints(e);let c=l.shape;const h=l.holes;!1===gA.isClockWise(c)&&(c=c.reverse());for(let t=0,e=h.length;t<e;t++){const e=h[t];!0===gA.isClockWise(e)&&(h[t]=e.reverse())}const u=gA.triangulateShape(c,h);for(let t=0,e=h.length;t<e;t++){const e=h[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];i.push(e.x,e.y,0),r.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],i=e[0]+o,r=e[1]+o,s=e[2]+o;n.push(i,r,s),a+=3}}this.setIndex(n),this.setAttribute("position",new xS(i,3)),this.setAttribute("normal",new xS(r,3)),this.setAttribute("uv",new xS(s,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}return new wA(n,t.curveSegments)}}class EA extends RS{constructor(t=1,e=32,n=16,i=0,r=2*Math.PI,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:o},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const a=Math.min(s+o,Math.PI);let l=0;const c=[],h=new Ov,u=new Ov,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],_=d/n;let y=0;0===d&&0===s?y=.5/e:d===n&&a===Math.PI&&(y=-.5/e);for(let n=0;n<=e;n++){const a=n/e;h.x=-t*Math.cos(i+a*r)*Math.sin(s+_*o),h.y=t*Math.cos(s+_*o),h.z=t*Math.sin(i+a*r)*Math.sin(s+_*o),p.push(h.x,h.y,h.z),u.copy(h).normalize(),f.push(u.x,u.y,u.z),m.push(a+y,1-_),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=c[t][i+1],r=c[t][i],o=c[t+1][i],l=c[t+1][i+1];(0!==t||s>0)&&d.push(e,r,l),(t!==n-1||a<Math.PI)&&d.push(r,o,l)}this.setIndex(d),this.setAttribute("position",new xS(p,3)),this.setAttribute("normal",new xS(f,3)),this.setAttribute("uv",new xS(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new EA(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class TA extends BT{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new TA(t.radius,t.detail)}}class AA extends RS{constructor(t=1,e=.4,n=12,i=48,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const s=[],o=[],a=[],l=[],c=new Ov,h=new Ov,u=new Ov;for(let s=0;s<=n;s++)for(let d=0;d<=i;d++){const p=d/i*r,f=s/n*Math.PI*2;h.x=(t+e*Math.cos(f))*Math.cos(p),h.y=(t+e*Math.cos(f))*Math.sin(p),h.z=e*Math.sin(f),o.push(h.x,h.y,h.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),u.subVectors(h,c).normalize(),a.push(u.x,u.y,u.z),l.push(d/i),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*t+e-1,r=(i+1)*(t-1)+e-1,o=(i+1)*(t-1)+e,a=(i+1)*t+e;s.push(n,r,a),s.push(r,o,a)}this.setIndex(s),this.setAttribute("position",new xS(o,3)),this.setAttribute("normal",new xS(a,3)),this.setAttribute("uv",new xS(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new AA(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class CA extends RS{constructor(t=1,e=.4,n=64,i=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:s},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],l=[],c=[],h=new Ov,u=new Ov,d=new Ov,p=new Ov,f=new Ov,m=new Ov,g=new Ov;for(let o=0;o<=n;++o){const y=o/n*r*Math.PI*2;_(y,r,s,t,d),_(y+.01,r,s,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=i;++t){const r=t/i*Math.PI*2,s=-e*Math.cos(r),p=e*Math.sin(r);h.x=d.x+(s*g.x+p*f.x),h.y=d.y+(s*g.y+p*f.y),h.z=d.z+(s*g.z+p*f.z),a.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(o/n),c.push(t/i)}}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,a=(i+1)*(t-1)+e;o.push(n,r,a),o.push(r,s,a)}function _(t,e,n,i,r){const s=Math.cos(t),o=Math.sin(t),a=n/e*t,l=Math.cos(a);r.x=i*(2+l)*.5*s,r.y=i*(2+l)*o*.5,r.z=i*Math.sin(a)*.5}this.setIndex(o),this.setAttribute("position",new xS(a,3)),this.setAttribute("normal",new xS(l,3)),this.setAttribute("uv",new xS(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new CA(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class RA extends RS{constructor(t=new CT(new Ov(-1,-1,0),new Ov(-1,1,0),new Ov(1,1,0)),e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const s=t.computeFrenetFrames(e,r);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const o=new Ov,a=new Ov,l=new rv;let c=new Ov;const h=[],u=[],d=[],p=[];function f(r){c=t.getPointAt(r/e,c);const l=s.normals[r],d=s.binormals[r];for(let t=0;t<=i;t++){const e=t/i*Math.PI*2,r=Math.sin(e),s=-Math.cos(e);a.x=s*l.x+r*d.x,a.y=s*l.y+r*d.y,a.z=s*l.z+r*d.z,a.normalize(),u.push(a.x,a.y,a.z),o.x=c.x+n*a.x,o.y=c.y+n*a.y,o.z=c.z+n*a.z,h.push(o.x,o.y,o.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===r?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=i;n++)l.x=t/e,l.y=n/i,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,o=(i+1)*(t-1)+e;p.push(n,r,o),p.push(r,s,o)}}()}(),this.setIndex(p),this.setAttribute("position",new xS(h,3)),this.setAttribute("normal",new xS(u,3)),this.setAttribute("uv",new xS(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new RA((new PT[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class PA extends RS{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,i=new Ov,r=new Ov;if(null!==t.index){const s=t.attributes.position,o=t.index;let a=t.groups;0===a.length&&(a=[{start:0,count:o.count,materialIndex:0}]);for(let t=0,l=a.length;t<l;++t){const l=a[t],c=l.start;for(let t=c,a=c+l.count;t<a;t+=3)for(let a=0;a<3;a++){const l=o.getX(t+a),c=o.getX(t+(a+1)%3);i.fromBufferAttribute(s,l),r.fromBufferAttribute(s,c),!0===LA(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const s=t.attributes.position;for(let t=0,o=s.count/3;t<o;t++)for(let o=0;o<3;o++){const a=3*t+o,l=3*t+(o+1)%3;i.fromBufferAttribute(s,a),r.fromBufferAttribute(s,l),!0===LA(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new xS(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function LA(t,e,n){const i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(i)&&!0!==n.has(r)&&(n.add(i),n.add(r),!0)}var IA=Object.freeze({__proto__:null,BoxGeometry:$S,CapsuleGeometry:DT,CircleGeometry:OT,ConeGeometry:FT,CylinderGeometry:UT,DodecahedronGeometry:zT,EdgesGeometry:WT,ExtrudeGeometry:vA,IcosahedronGeometry:SA,LatheGeometry:NT,OctahedronGeometry:bA,PlaneGeometry:gb,PolyhedronGeometry:BT,RingGeometry:MA,ShapeGeometry:wA,SphereGeometry:EA,TetrahedronGeometry:TA,TorusGeometry:AA,TorusKnotGeometry:CA,TubeGeometry:RA,WireframeGeometry:PA});class NA extends Zx{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new eS(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class DA extends tb{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class OA extends Zx{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new eS(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new eS(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class UA extends OA{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new rv(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return $y(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new eS(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new eS(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new eS(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class FA extends Zx{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new eS(16777215),this.specular=new eS(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new eS(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class BA extends Zx{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new eS(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new eS(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class zA extends Zx{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class VA extends Zx{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new eS(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new eS(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cg,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class kA extends Zx{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new eS(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Q_,this.normalScale=new rv(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class GA extends GE{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function HA(t,e,n){return jA(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)}function WA(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function jA(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function XA(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort(function(e,n){return t[e]-t[n]}),n}function YA(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,o=0;o!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[o++]=t[i+n]}return r}function qA(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let o=s[i];if(void 0!==o)if(Array.isArray(o))do{o=s[i],void 0!==o&&(e.push(s.time),n.push.apply(n,o)),s=t[r++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[i],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{o=s[i],void 0!==o&&(e.push(s.time),n.push(o)),s=t[r++]}while(void 0!==s)}const $A={arraySlice:HA,convertArray:WA,isTypedArray:jA,getKeyframeOrder:XA,sortedArray:YA,flattenJSON:qA,subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const o=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],a=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*r;if(!(s<n||s>=i)){l.push(e.times[t]);for(let n=0;n<a;++n)c.push(e.values[t*a+n])}}0!==l.length&&(e.times=WA(l,e.times.constructor),e.values=WA(c,e.values.constructor),o.push(e))}s.tracks=o;let a=1/0;for(let t=0;t<s.tracks.length;++t)a>s.tracks[t].times[0]&&(a=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const o=t.tracks.find(function(t){return t.name===i.name&&t.ValueTypeName===r});if(void 0===o)continue;let a=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=i.times.length-1;let d;if(s<=i.times[0]){const t=a,e=l-a;d=HA(i.values,t,e)}else if(s>=i.times[u]){const t=u*l+a,e=t+l-a;d=HA(i.values,t,e)}else{const t=i.createInterpolant(),e=a,n=l-a;t.evaluate(s),d=HA(t.resultBuffer,e,n)}"quaternion"===r&&(new Dv).fromArray(d).normalize().conjugate().toArray(d);const p=o.times.length;for(let t=0;t<p;++t){const e=t*h+c;if("quaternion"===r)Dv.multiplyQuaternionsFlat(o.values,e,d,0,o.values,e);else{const t=h-2*c;for(let n=0;n<t;++n)o.values[e+n]-=d[n]}}}return t.blendMode=j_,t}};class ZA{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(!(t>=r)){const o=e[1];t<o&&(n=2,r=o);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0;break n}break t}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===i)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class JA extends ZA{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:k_,endingEnd:k_}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],a=i[s];if(void 0===o)switch(this.getSettings_().endingStart){case G_:r=t,o=2*e-n;break;case H_:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case G_:s=t,a=2*n-e;break;case H_:s=1,a=n+i[1]-i[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-u*m+2*u*f-u*p,_=(1+u)*m+(-1.5-2*u)*f+(-.5+u)*p+1,y=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;for(let t=0;t!==o;++t)r[t]=g*s[c+t]+_*s[l+t]+y*s[a+t]+v*s[h+t];return r}}class KA extends ZA{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(i-e),h=1-c;for(let t=0;t!==o;++t)r[t]=s[l+t]*h+s[a+t]*c;return r}}class QA extends ZA{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class tC{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=WA(e,this.TimeBufferType),this.values=WA(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:WA(t.times,Array),values:WA(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new QA(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new KA(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new JA(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case B_:e=this.InterpolantFactoryMethodDiscrete;break;case z_:e=this.InterpolantFactoryMethodLinear;break;case V_:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return B_;case this.InterpolantFactoryMethodLinear:return z_;case this.InterpolantFactoryMethodSmooth:return V_}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=HA(n,r,s),this.values=HA(this.values,r*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==s&&s>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,s),t=!1;break}s=i}if(void 0!==i&&jA(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=HA(this.times),e=HA(this.values),n=this.getValueSize(),i=this.getInterpolation()===V_,r=t.length-1;let s=1;for(let o=1;o<r;++o){let r=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(i)r=!0;else{const t=o*n,i=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[i+o]||n!==e[s+o]){r=!0;break}}}if(r){if(o!==s){t[s]=t[o];const i=o*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,o=0;o!==n;++o)e[i+o]=e[t+o];++s}return s!==t.length?(this.times=HA(t,0,s),this.values=HA(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=HA(this.times,0),e=HA(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}tC.prototype.TimeBufferType=Float32Array,tC.prototype.ValueBufferType=Float32Array,tC.prototype.DefaultInterpolation=z_;class eC extends tC{}eC.prototype.ValueTypeName="bool",eC.prototype.ValueBufferType=Array,eC.prototype.DefaultInterpolation=B_,eC.prototype.InterpolantFactoryMethodLinear=void 0,eC.prototype.InterpolantFactoryMethodSmooth=void 0;class nC extends tC{}nC.prototype.ValueTypeName="color";class iC extends tC{}iC.prototype.ValueTypeName="number";class rC extends ZA{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(i-e);let l=t*o;for(let t=l+o;l!==t;l+=4)Dv.slerpFlat(r,0,s,l-o,s,l,a);return r}}class sC extends tC{InterpolantFactoryMethodLinear(t){return new rC(this.times,this.values,this.getValueSize(),t)}}sC.prototype.ValueTypeName="quaternion",sC.prototype.DefaultInterpolation=z_,sC.prototype.InterpolantFactoryMethodSmooth=void 0;class oC extends tC{}oC.prototype.ValueTypeName="string",oC.prototype.ValueBufferType=Array,oC.prototype.DefaultInterpolation=B_,oC.prototype.InterpolantFactoryMethodLinear=void 0,oC.prototype.InterpolantFactoryMethodSmooth=void 0;class aC extends tC{}aC.prototype.ValueTypeName="vector";class lC{constructor(t,e=-1,n,i=W_){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=qy(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(cC(n[t]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(tC.toJSON(n[t]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let t=0;t<r;t++){let o=[],a=[];o.push((t+r-1)%r,t,(t+1)%r),a.push(0,1,0);const l=XA(o);o=YA(o,1,l),a=YA(a,1,l),i||0!==o[0]||(o.push(r),a.push(a[0])),s.push(new iC(".morphTargetInfluences["+e[t].name+"]",o,a).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(r);if(s&&s.length>1){const t=s[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const s=[];for(const t in i)s.push(this.CreateFromMorphTargetSequence(t,i[t],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],o=[];qA(n,s,o,i),0!==s.length&&r.push(new t(e,s,o))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new iC(".morphTargetInfluence["+n+"]",t,s))}a=t.length*s}else{const s=".bones["+e[t].name+"]";n(aC,s+".position",r,"pos",i),n(sC,s+".quaternion",r,"rot",i),n(aC,s+".scale",r,"scl",i)}}return 0===i.length?null:new this(r,a,i,o)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function cC(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return iC;case"vector":case"vector2":case"vector3":case"vector4":return aC;case"color":return nC;case"quaternion":return sC;case"bool":case"boolean":return eC;case"string":return oC}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];qA(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const hC={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class uC{constructor(t,e,n){const i=this;let r,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===s&&void 0!==i.onStart&&i.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==i.onProgress&&i.onProgress(t,o,a),o===a&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}}const dC=new uC;class pC{constructor(t){this.manager=void 0!==t?t:dC,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const fC={};class mC extends Error{constructor(t,e){super(t),this.response=e}}class gC extends pC{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=hC.get(t);if(void 0!==r)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(void 0!==fC[t])return void fC[t].push({onLoad:e,onProgress:n,onError:i});fC[t]=[],fC[t].push({onLoad:e,onProgress:n,onError:i});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(s).then(e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=fC[t],i=e.body.getReader(),r=e.headers.get("Content-Length")||e.headers.get("X-File-Size"),s=r?parseInt(r):0,o=0!==s;let a=0;const l=new ReadableStream({start(t){!function e(){i.read().then(({done:i,value:r})=>{if(i)t.close();else{a+=r.byteLength;const i=new ProgressEvent("progress",{lengthComputable:o,loaded:a,total:s});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(i)}t.enqueue(r),e()}})}()}});return new Response(l)}throw new mC(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)}).then(t=>{switch(a){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then(t=>(new DOMParser).parseFromString(t,o));case"json":return t.json();default:if(void 0===o)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(o),n=e&&e[1]?e[1].toLowerCase():void 0,i=new TextDecoder(n);return t.arrayBuffer().then(t=>i.decode(t))}}}).then(e=>{hC.add(t,e);const n=fC[t];delete fC[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onLoad&&i.onLoad(e)}}).catch(e=>{const n=fC[t];if(void 0===n)throw this.manager.itemError(t),e;delete fC[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class _C extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new gC(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=lC.parse(t[n]);e.push(i)}return e}}class yC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=[],o=new lT,a=new gC(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(c){a.load(t[c],function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=Ig),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))},n,i)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else a.load(t,function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=Ig),o.format=n.format,o.needsUpdate=!0,e&&e(o)},n,i);return o}}class vC extends pC{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=hC.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o=hv("img");function a(){c(),hC.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){c(),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}class xC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=new sb;r.colorSpace=ny;const s=new vC(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],function(t){r.images[n]=t,o++,6===o&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let e=0;e<t.length;++e)a(e);return r}}class SC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new RE,o=new gC(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(t){const n=r.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:Eg,s.wrapT=void 0!==n.wrapT?n.wrapT:Eg,s.magFilter=void 0!==n.magFilter?n.magFilter:Ig,s.minFilter=void 0!==n.minFilter?n.minFilter:Ig,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.colorSpace?s.colorSpace=n.colorSpace:void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=Og),1===n.mipmapCount&&(s.minFilter=Ig),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n))},n,i),s}}class bC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=new Tv,s=new vC(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(t){r.image=t,r.needsUpdate=!0,void 0!==e&&e(r)},n,i),r}}class MC extends Ux{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new eS(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}class wC extends MC{constructor(t,e,n){super(t,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Ux.DEFAULT_UP),this.updateMatrix(),this.groundColor=new eS(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const EC=new ux,TC=new Ov,AC=new Ov;class CC{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new rv(512,512),this.map=null,this.mapPass=null,this.matrix=new ux,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new pb,this._frameExtents=new rv(1,1),this._viewportCount=1,this._viewports=[new Av(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;TC.setFromMatrixPosition(t.matrixWorld),e.position.copy(TC),AC.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(AC),e.updateMatrixWorld(),EC.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(EC),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(EC)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class RC extends CC{constructor(){super(new nb(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,n=2*Yy*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class PC extends MC{constructor(t,e,n=0,i=Math.PI/3,r=0,s=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Ux.DEFAULT_UP),this.updateMatrix(),this.target=new Ux,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.map=null,this.shadow=new RC}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const LC=new ux,IC=new Ov,NC=new Ov;class DC extends CC{constructor(){super(new nb(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new rv(4,2),this._viewportCount=6,this._viewports=[new Av(2,1,1,1),new Av(0,1,1,1),new Av(3,1,1,1),new Av(1,1,1,1),new Av(3,0,1,1),new Av(1,0,1,1)],this._cubeDirections=[new Ov(1,0,0),new Ov(-1,0,0),new Ov(0,0,1),new Ov(0,0,-1),new Ov(0,1,0),new Ov(0,-1,0)],this._cubeUps=[new Ov(0,1,0),new Ov(0,1,0),new Ov(0,1,0),new Ov(0,1,0),new Ov(0,0,1),new Ov(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),IC.setFromMatrixPosition(t.matrixWorld),n.position.copy(IC),NC.copy(n.position),NC.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(NC),n.updateMatrixWorld(),i.makeTranslation(-IC.x,-IC.y,-IC.z),LC.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(LC)}}class OC extends MC{constructor(t,e,n=0,i=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new DC}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class UC extends CC{constructor(){super(new Ab(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class FC extends MC{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ux.DEFAULT_UP),this.updateMatrix(),this.target=new Ux,this.shadow=new UC}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class BC extends MC{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class zC extends MC{constructor(t,e,n=10,i=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class VC{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new Ov)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}class kC extends MC{constructor(t=new VC,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class GC extends pC{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,s=new gC(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=GC.createMaterialFromType(t.type);if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=t.sheen),void 0!==t.sheenColor&&(i.sheenColor=(new eS).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(i.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.specularIntensity&&(i.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==i.specularColor&&i.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.iridescence&&(i.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(i.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(i.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.thickness&&(i.thickness=t.thickness),void 0!==t.attenuationDistance&&(i.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==i.attenuationColor&&i.attenuationColor.setHex(t.attenuationColor),void 0!==t.anisotropy&&(i.anisotropy=t.anisotropy),void 0!==t.anisotropyRotation&&(i.anisotropyRotation=t.anisotropyRotation),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.shadowSide&&(i.shadowSide=t.shadowSide),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),1!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.alphaToCoverage&&(i.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(i.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.forceSinglePass&&(i.forceSinglePass=t.forceSinglePass),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const r=t.uniforms[e];switch(i.uniforms[e]={},r.type){case"t":i.uniforms[e].value=n(r.value);break;case"c":i.uniforms[e].value=(new eS).setHex(r.value);break;case"v2":i.uniforms[e].value=(new rv).fromArray(r.value);break;case"v3":i.uniforms[e].value=(new Ov).fromArray(r.value);break;case"v4":i.uniforms[e].value=(new Av).fromArray(r.value);break;case"m3":i.uniforms[e].value=(new sv).fromArray(r.value);break;case"m4":i.uniforms[e].value=(new ux).fromArray(r.value);break;default:i.uniforms[e].value=r.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.glslVersion&&(i.glslVersion=t.glslVersion),void 0!==t.extensions)for(const e in t.extensions)i.extensions[e]=t.extensions[e];if(void 0!==t.lights&&(i.lights=t.lights),void 0!==t.clipping&&(i.clipping=t.clipping),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new rv).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(i.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(i.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new rv).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(i.iridescenceMap=n(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(i.iridescenceThicknessMap=n(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(i.thicknessMap=n(t.thicknessMap)),void 0!==t.anisotropyMap&&(i.anisotropyMap=n(t.anisotropyMap)),void 0!==t.sheenColorMap&&(i.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(i.sheenRoughnessMap=n(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}static createMaterialFromType(t){return new{ShadowMaterial:NA,SpriteMaterial:Qw,RawShaderMaterial:DA,ShaderMaterial:tb,PointsMaterial:QE,MeshPhysicalMaterial:UA,MeshStandardMaterial:OA,MeshPhongMaterial:FA,MeshToonMaterial:BA,MeshNormalMaterial:zA,MeshLambertMaterial:VA,MeshDepthMaterial:Pw,MeshDistanceMaterial:Lw,MeshBasicMaterial:iS,MeshMatcapMaterial:kA,LineDashedMaterial:GA,LineBasicMaterial:GE,Material:Zx}[t]}}class HC{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class WC extends RS{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class jC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new gC(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}},n,i)}parse(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],s=function(t,e){if(void 0!==n[e])return n[e];const i=t.arrayBuffers[e],r=new Uint32Array(i).buffer;return n[e]=r,r}(t,r.buffer),o=cv(r.type,s),a=new Zw(o,r.stride);return a.uuid=r.uuid,e[i]=a,a}const r=t.isInstancedBufferGeometry?new WC:new RS,s=t.data.index;if(void 0!==s){const t=cv(s.type,s.array);r.setIndex(new uS(t,1))}const o=t.data.attributes;for(const e in o){const n=o[e];let s;if(n.isInterleavedBufferAttribute){const e=i(t.data,n.data);s=new Kw(e,n.itemSize,n.offset,n.normalized)}else{const t=cv(n.type,n.array);s=new(n.isInstancedBufferAttribute?NE:uS)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),void 0!==n.updateRange&&(s.updateRange.offset=n.updateRange.offset,s.updateRange.count=n.updateRange.count),r.setAttribute(e,s)}const a=t.data.morphAttributes;if(a)for(const e in a){const n=a[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];let o;if(r.isInterleavedBufferAttribute){const e=i(t.data,r.data);o=new Kw(e,r.itemSize,r.offset,r.normalized)}else{const t=cv(r.type,r.array);o=new uS(t,r.itemSize,r.normalized)}void 0!==r.name&&(o.name=r.name),s.push(o)}r.morphAttributes[e]=s}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];r.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new Ov;void 0!==c.center&&t.fromArray(c.center),r.boundingSphere=new nx(t,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}class XC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=""===this.path?HC.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const o=new gC(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==i&&i(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const o=s.metadata;if(void 0===o||void 0===o.type||"geometry"===o.type.toLowerCase())return void 0!==i&&i(new Error("THREE.ObjectLoader: Can't load "+t)),void console.error("THREE.ObjectLoader: Can't load "+t);r.parse(s,e)},n,i)}async loadAsync(t,e){const n=""===this.path?HC.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const i=new gC(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const r=await i.loadAsync(t,e),s=JSON.parse(r),o=s.metadata;if(void 0===o||void 0===o.type||"geometry"===o.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),s=this.parseImages(t.images,function(){void 0!==e&&e(l)}),o=this.parseTextures(t.textures,s),a=this.parseMaterials(t.materials,o),l=this.parseObject(t.object,r,a,o,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),void 0!==e){let t=!1;for(const e in s)if(s[e].data instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,r),o=this.parseMaterials(t.materials,s),a=this.parseObject(t.object,i,o,s,e),l=this.parseSkeletons(t.skeletons,a);return this.bindSkeletons(a,l),a}parseShapes(t){const e={};if(void 0!==t)for(let n=0,i=t.length;n<i;n++){const i=(new jT).fromJSON(t[n]);e[i.uuid]=i}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse(function(t){t.isBone&&(i[t.uuid]=t)}),void 0!==t)for(let e=0,r=t.length;e<r;e++){const r=(new IE).fromJSON(t[e],i);n[r.uuid]=r}return n}parseGeometries(t,e){const n={};if(void 0!==t){const i=new jC;for(let r=0,s=t.length;r<s;r++){let s;const o=t[r];switch(o.type){case"BufferGeometry":case"InstancedBufferGeometry":s=i.parse(o);break;default:o.type in IA?s=IA[o.type].fromJSON(o,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)}s.uuid=o.uuid,void 0!==o.name&&(s.name=o.name),void 0!==o.userData&&(s.userData=o.userData),n[o.uuid]=s}}return n}parseMaterials(t,e){const n={},i={};if(void 0!==t){const r=new GC;r.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];void 0===n[s.uuid]&&(n[s.uuid]=r.parse(s)),i[s.uuid]=n[s.uuid]}}return i}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const i=t[n],r=lC.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),r.load(t,function(){n.manager.itemEnd(t)},void 0,function(){n.manager.itemError(t),n.manager.itemEnd(t)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:cv(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new uC(e);r=new vC(n),r.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.url;if(Array.isArray(r)){const t=[];for(let e=0,n=r.length;e<n;e++){const n=s(r[e]);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new RE(n.data,n.width,n.height)))}i[n.uuid]=new Mv(t)}else{const t=s(n.url);i[n.uuid]=new Mv(t)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(t){if("string"==typeof t){const n=t,r=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await i.loadAsync(r)}return t.data?{data:cv(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){i=new vC(this.manager),i.setCrossOrigin(this.crossOrigin);for(let e=0,i=t.length;e<i;e++){const i=t[e],s=i.url;if(Array.isArray(s)){const t=[];for(let e=0,n=s.length;e<n;e++){const n=s[e],i=await r(n);null!==i&&(i instanceof HTMLImageElement?t.push(i):t.push(new RE(i.data,i.width,i.height)))}n[i.uuid]=new Mv(t)}else{const t=await r(i.url);n[i.uuid]=new Mv(t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const i={};if(void 0!==t)for(let r=0,s=t.length;r<s;r++){const s=t[r];void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const o=e[s.image],a=o.data;let l;Array.isArray(a)?(l=new sb,6===a.length&&(l.needsUpdate=!0)):(l=a&&a.data?new RE:new Tv,a&&(l.needsUpdate=!0)),l.source=o,l.uuid=s.uuid,void 0!==s.name&&(l.name=s.name),void 0!==s.mapping&&(l.mapping=n(s.mapping,YC)),void 0!==s.channel&&(l.channel=s.channel),void 0!==s.offset&&l.offset.fromArray(s.offset),void 0!==s.repeat&&l.repeat.fromArray(s.repeat),void 0!==s.center&&l.center.fromArray(s.center),void 0!==s.rotation&&(l.rotation=s.rotation),void 0!==s.wrap&&(l.wrapS=n(s.wrap[0],qC),l.wrapT=n(s.wrap[1],qC)),void 0!==s.format&&(l.format=s.format),void 0!==s.internalFormat&&(l.internalFormat=s.internalFormat),void 0!==s.type&&(l.type=s.type),void 0!==s.colorSpace&&(l.colorSpace=s.colorSpace),void 0!==s.encoding&&(l.encoding=s.encoding),void 0!==s.minFilter&&(l.minFilter=n(s.minFilter,$C)),void 0!==s.magFilter&&(l.magFilter=n(s.magFilter,$C)),void 0!==s.anisotropy&&(l.anisotropy=s.anisotropy),void 0!==s.flipY&&(l.flipY=s.flipY),void 0!==s.generateMipmaps&&(l.generateMipmaps=s.generateMipmaps),void 0!==s.premultiplyAlpha&&(l.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(l.unpackAlignment=s.unpackAlignment),void 0!==s.compareFunction&&(l.compareFunction=s.compareFunction),void 0!==s.userData&&(l.userData=s.userData),i[s.uuid]=l}return i}parseObject(t,e,n,i,r){let s,o,a;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function c(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];void 0===n[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(n[r])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function h(t){return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),i[t]}switch(t.type){case"Scene":s=new $w,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new eS(t.background):s.background=h(t.background)),void 0!==t.environment&&(s.environment=h(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new qw(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new Yw(t.fog.color,t.fog.density))),void 0!==t.backgroundBlurriness&&(s.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(s.backgroundIntensity=t.backgroundIntensity);break;case"PerspectiveCamera":s=new nb(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new Ab(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new BC(t.color,t.intensity);break;case"DirectionalLight":s=new FC(t.color,t.intensity);break;case"PointLight":s=new OC(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new zC(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new PC(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":s=new wC(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new kC).fromJSON(t);break;case"SkinnedMesh":o=l(t.geometry),a=c(t.material),s=new AE(o,a),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":o=l(t.geometry),a=c(t.material),s=new YS(o,a);break;case"InstancedMesh":o=l(t.geometry),a=c(t.material);const e=t.count,n=t.instanceMatrix,i=t.instanceColor;s=new kE(o,a,e),s.instanceMatrix=new NE(new Float32Array(n.array),16),void 0!==i&&(s.instanceColor=new NE(new Float32Array(i.array),i.itemSize));break;case"LOD":s=new _E;break;case"Line":s=new qE(l(t.geometry),c(t.material));break;case"LineLoop":s=new KE(l(t.geometry),c(t.material));break;case"LineSegments":s=new JE(l(t.geometry),c(t.material));break;case"PointCloud":case"Points":s=new rT(l(t.geometry),c(t.material));break;case"Sprite":s=new pE(c(t.material));break;case"Group":s=new Fw;break;case"Bone":s=new CE;break;default:s=new Ux}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.up&&s.up.fromArray(t.up),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const o=t.children;for(let t=0;t<o.length;t++)s.add(this.parseObject(o[t],e,n,i,r))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];s.animations.push(r[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],i=s.getObjectByProperty("uuid",n.object);void 0!==i&&s.addLevel(i,n.distance,n.hysteresis)}}return s}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse(function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}})}}const YC={UVMapping:yg,CubeReflectionMapping:vg,CubeRefractionMapping:xg,EquirectangularReflectionMapping:Sg,EquirectangularRefractionMapping:bg,CubeUVReflectionMapping:Mg},qC={RepeatWrapping:wg,ClampToEdgeWrapping:Eg,MirroredRepeatWrapping:Tg},$C={NearestFilter:Ag,NearestMipmapNearestFilter:Cg,NearestMipmapLinearFilter:Pg,LinearFilter:Ig,LinearMipmapNearestFilter:Ng,LinearMipmapLinearFilter:Og};class ZC extends pC{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=hC.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(n){hC.add(t,n),e&&e(n),r.manager.itemEnd(t)}).catch(function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}let JC;class KC{static getContext(){return void 0===JC&&(JC=new(window.AudioContext||window.webkitAudioContext)),JC}static setContext(t){JC=t}}class QC extends pC{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new gC(this.manager);function o(e){i?i(e):console.error(e),r.manager.itemError(t)}s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(t){try{const n=t.slice(0);KC.getContext().decodeAudioData(n,function(t){e(t)},o)}catch(t){o(t)}},n,i)}}class tR extends kC{constructor(t,e,n=1){super(void 0,n),this.isHemisphereLightProbe=!0;const i=(new eS).set(t),r=(new eS).set(e),s=new Ov(i.r,i.g,i.b),o=new Ov(r.r,r.g,r.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}}class eR extends kC{constructor(t,e=1){super(void 0,e),this.isAmbientLightProbe=!0;const n=(new eS).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const nR=new ux,iR=new ux,rR=new ux;class sR{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new nb,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new nb,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,rR.copy(t.projectionMatrix);const n=e.eyeSep/2,i=n*e.near/e.focus,r=e.near*Math.tan(Xy*e.fov*.5)/e.zoom;let s,o;iR.elements[12]=-n,nR.elements[12]=n,s=-r*e.aspect+i,o=r*e.aspect+i,rR.elements[0]=2*e.near/(o-s),rR.elements[8]=(o+s)/(o-s),this.cameraL.projectionMatrix.copy(rR),s=-r*e.aspect-i,o=r*e.aspect-i,rR.elements[0]=2*e.near/(o-s),rR.elements[8]=(o+s)/(o-s),this.cameraR.projectionMatrix.copy(rR)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(iR),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(nR)}}class oR{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=aR(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=aR();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function aR(){return("undefined"==typeof performance?Date:performance).now()}const lR=new Ov,cR=new Dv,hR=new Ov,uR=new Ov;class dR extends Ux{constructor(){super(),this.type="AudioListener",this.context=KC.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new oR}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(lR,cR,hR),uR.set(0,0,-1).applyQuaternion(cR),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(lR.x,t),e.positionY.linearRampToValueAtTime(lR.y,t),e.positionZ.linearRampToValueAtTime(lR.z,t),e.forwardX.linearRampToValueAtTime(uR.x,t),e.forwardY.linearRampToValueAtTime(uR.y,t),e.forwardZ.linearRampToValueAtTime(uR.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(lR.x,lR.y,lR.z),e.setOrientation(uR.x,uR.y,uR.z,n.x,n.y,n.z)}}class pR extends Ux{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const fR=new Ov,mR=new Dv,gR=new Ov,_R=new Ov;class yR extends pR{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(fR,mR,gR),_R.set(0,0,1).applyQuaternion(mR);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(fR.x,t),e.positionY.linearRampToValueAtTime(fR.y,t),e.positionZ.linearRampToValueAtTime(fR.z,t),e.orientationX.linearRampToValueAtTime(_R.x,t),e.orientationY.linearRampToValueAtTime(_R.y,t),e.orientationZ.linearRampToValueAtTime(_R.z,t)}else e.setPosition(fR.x,fR.y,fR.z),e.setOrientation(_R.x,_R.y,_R.z)}}class vR{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class xR{constructor(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){o.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}_slerp(t,e,n,i){Dv.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;Dv.multiplyQuaternionsFlat(t,s,t,e,t,n),Dv.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const r=e+o;t[r]=t[r]*s+t[n+o]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}}const SR="\\[\\]\\.:\\/",bR=new RegExp("["+SR+"]","g"),MR="[^"+SR+"]",wR="[^"+SR.replace("\\.","")+"]",ER=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",MR)+/(WCOD+)?/.source.replace("WCOD",wR)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",MR)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",MR)+"$"),TR=["material","materials","bones","map"];class AR{constructor(t,e,n){this.path=e,this.parsedPath=n||AR.parseTrackName(e),this.node=AR.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new AR.Composite(t,e,n):new AR(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(bR,"")}static parseTrackName(t){const e=ER.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==TR.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=AR.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}AR.Composite=class{constructor(t,e,n){const i=n||AR.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},AR.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},AR.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},AR.prototype.GetterByBindingType=[AR.prototype._getValue_direct,AR.prototype._getValue_array,AR.prototype._getValue_arrayElement,AR.prototype._getValue_toArray],AR.prototype.SetterByBindingTypeAndVersioning=[[AR.prototype._setValue_direct,AR.prototype._setValue_direct_setNeedsUpdate,AR.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[AR.prototype._setValue_array,AR.prototype._setValue_array_setNeedsUpdate,AR.prototype._setValue_array_setMatrixWorldNeedsUpdate],[AR.prototype._setValue_arrayElement,AR.prototype._setValue_arrayElement_setNeedsUpdate,AR.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[AR.prototype._setValue_fromArray,AR.prototype._setValue_fromArray_setNeedsUpdate,AR.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class CR{constructor(){this.isAnimationObjectGroup=!0,this.uuid=qy(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=t.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=e[u];if(void 0===d){d=a++,e[u]=d,t.push(h);for(let t=0,e=s;t!==e;++t)r[t].push(new AR(h,n[t],i[t]))}else if(d<l){o=t[d];const a=--l,c=t[a];e[c.uuid]=d,t[d]=c,e[u]=a,t[a]=h;for(let t=0,e=s;t!==e;++t){const e=r[t],s=e[a];let o=e[d];e[d]=s,void 0===o&&(o=new AR(h,n[t],i[t])),e[a]=o}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s],a=o.uuid,l=e[a];if(void 0!==l&&l>=r){const s=r++,c=t[s];e[c.uuid]=l,t[l]=c,e[a]=s,t[s]=o;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[s],r=e[l];e[l]=i,e[s]=r}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){const a=arguments[o].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<r){const o=--r,a=t[o],c=--s,h=t[c];e[a.uuid]=l,t[l]=a,e[h.uuid]=o,t[o]=h,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[o],r=e[c];e[l]=i,e[o]=r,e.pop()}}else{const r=--s,o=t[r];r>0&&(e[o.uuid]=l),t[l]=o,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,h=new Array(l);i=r.length,n[t]=i,s.push(t),o.push(e),r.push(h);for(let n=c,i=a.length;n!==i;++n){const i=a[n];h[n]=new AR(i,t,e)}return h}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o];e[t[o]]=n,s[n]=a,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}}class RR{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),a={endingStart:k_,endingEnd:k_};for(let t=0;t!==s;++t){const e=r[t].createInterpolant(null);o[t]=e,e.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=U_,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=i/n,s=n/i;t.warp(1,r,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,a[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;i<0||0===n?e=0:(this._startTime=null,e=n*i)}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===j_)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=n===F_;if(0===t)return-1===r||!s||1&~r?i:e-i;if(n===O_){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const o=this.repetitions-r;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&!(1&~r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=G_,i.endingEnd=G_):(i.endingStart=t?this.zeroSlopeAtStart?G_:k_:H_,i.endingEnd=e?this.zeroSlopeAtEnd?G_:k_:H_)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=r,a[0]=e,o[1]=r+t,a[1]=n,this}}const PR=new Float32Array(1);class LR extends Hy{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let h=c[l];if(void 0!==h)++h.referenceCount,s[t]=h;else{if(h=s[t],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,a,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;h=new xR(AR.create(n,l,i),r.ValueTypeName,r.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,a,l),s[t]=h}o[t].resultBuffer=h.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0===--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],0===Object.keys(o).length&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new KA(new Float32Array(2),new Float32Array(2),1,PR),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?lC.findByName(i,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:W_),void 0!==a){const t=a.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new RR(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?lC.findByName(n,t):t,s=r?r.uuid:t,o=this._actionsByClip[s];return void 0!==o&&o.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let o=0;o!==n;++o)e[o]._update(i,t,r,s);const o=this._bindings,a=this._nActiveBindings;for(let t=0;t!==a;++t)o[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class IR{constructor(t){this.value=t}clone(){return new IR(void 0===this.value.clone?this.value:this.value.clone())}}let NR=0;class DR extends Hy{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:NR++}),this.name="",this.usage=Ry,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,n=e.length;t<n;t++)this.uniforms.push(e[t].clone());return this}clone(){return(new this.constructor).copy(this)}}class OR extends Zw{constructor(t,e,n=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class UR{constructor(t,e,n,i,r){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}class FR{constructor(t,e,n=0,i=1/0){this.ray=new hx(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new bx,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return zR(t,this,n,e),n.sort(BR),n}intersectObjects(t,e=!0,n=[]){for(let i=0,r=t.length;i<r;i++)zR(t[i],this,n,e);return n.sort(BR),n}}function BR(t,e){return t.distance-e.distance}function zR(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)zR(i[t],e,n,!0)}}class VR{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos($y(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class kR{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}}const GR=new rv;class HR{constructor(t=new rv(1/0,1/0),e=new rv(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=GR.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,GR).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const WR=new Ov,jR=new Ov;class XR{constructor(t=new Ov,e=new Ov){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){WR.subVectors(t,this.start),jR.subVectors(this.end,this.start);const n=jR.dot(jR);let i=jR.dot(WR)/n;return e&&(i=$y(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const YR=new Ov;class qR extends Ux{constructor(t,e){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const n=new RS,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const r=t/n*Math.PI*2,s=e/n*Math.PI*2;i.push(Math.cos(r),Math.sin(r),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new xS(i,3));const r=new GE({fog:!1,toneMapped:!1});this.cone=new JE(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),YR.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(YR),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const $R=new Ov,ZR=new ux,JR=new ux;class KR extends JE{constructor(t){const e=QR(t),n=new RS,i=[],r=[],s=new eS(0,0,1),o=new eS(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new xS(i,3)),n.setAttribute("color",new xS(r,3)),super(n,new GE({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");JR.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(ZR.multiplyMatrices(JR,r.matrixWorld),$R.setFromMatrixPosition(ZR),i.setXYZ(n,$R.x,$R.y,$R.z),ZR.multiplyMatrices(JR,r.parent.matrixWorld),$R.setFromMatrixPosition(ZR),i.setXYZ(n+1,$R.x,$R.y,$R.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose()}}function QR(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,QR(t.children[n]));return e}class tP extends YS{constructor(t,e,n){super(new EA(e,4,2),new iS({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const eP=new Ov,nP=new eS,iP=new eS;class rP extends Ux{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new bA(e);i.rotateY(.5*Math.PI),this.material=new iS({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),s=new Float32Array(3*r.count);i.setAttribute("color",new uS(s,3)),this.add(new YS(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");nP.copy(this.light.color),iP.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?nP:iP;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(eP.setFromMatrixPosition(this.light.matrixWorld).negate())}}class sP extends JE{constructor(t=10,e=10,n=4473924,i=8947848){n=new eS(n),i=new eS(i);const r=e/2,s=t/e,o=t/2,a=[],l=[];for(let t=0,c=0,h=-o;t<=e;t++,h+=s){a.push(-o,0,h,o,0,h),a.push(h,0,-o,h,0,o);const e=t===r?n:i;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new RS;c.setAttribute("position",new xS(a,3)),c.setAttribute("color",new xS(l,3)),super(c,new GE({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class oP extends JE{constructor(t=10,e=16,n=8,i=64,r=4473924,s=8947848){r=new eS(r),s=new eS(s);const o=[],a=[];if(e>1)for(let n=0;n<e;n++){const i=n/e*(2*Math.PI),l=Math.sin(i)*t,c=Math.cos(i)*t;o.push(0,0,0),o.push(l,0,c);const h=1&n?r:s;a.push(h.r,h.g,h.b),a.push(h.r,h.g,h.b)}for(let e=0;e<n;e++){const l=1&e?r:s,c=t-t/n*e;for(let t=0;t<i;t++){let e=t/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c;o.push(n,0,r),a.push(l.r,l.g,l.b),e=(t+1)/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c,o.push(n,0,r),a.push(l.r,l.g,l.b)}}const l=new RS;l.setAttribute("position",new xS(o,3)),l.setAttribute("color",new xS(a,3)),super(l,new GE({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const aP=new Ov,lP=new Ov,cP=new Ov;class hP extends Ux{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",void 0===e&&(e=1);let i=new RS;i.setAttribute("position",new xS([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new GE({fog:!1,toneMapped:!1});this.lightPlane=new qE(i,r),this.add(this.lightPlane),i=new RS,i.setAttribute("position",new xS([0,0,0,0,0,1],3)),this.targetLine=new qE(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),aP.setFromMatrixPosition(this.light.matrixWorld),lP.setFromMatrixPosition(this.light.target.matrixWorld),cP.subVectors(lP,aP),this.lightPlane.lookAt(lP),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(lP),this.targetLine.scale.z=cP.length()}}const uP=new Ov,dP=new eb;class pP extends JE{constructor(t){const e=new RS,n=new GE({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],s={};function o(t,e){a(t),a(e)}function a(t){i.push(0,0,0),r.push(0,0,0),void 0===s[t]&&(s[t]=[]),s[t].push(i.length/3-1)}o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4"),e.setAttribute("position",new xS(i,3)),e.setAttribute("color",new xS(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update();const l=new eS(16755200),c=new eS(16711680),h=new eS(43775),u=new eS(16777215),d=new eS(3355443);this.setColors(l,c,h,u,d)}setColors(t,e,n,i,r){const s=this.geometry.getAttribute("color");s.setXYZ(0,t.r,t.g,t.b),s.setXYZ(1,t.r,t.g,t.b),s.setXYZ(2,t.r,t.g,t.b),s.setXYZ(3,t.r,t.g,t.b),s.setXYZ(4,t.r,t.g,t.b),s.setXYZ(5,t.r,t.g,t.b),s.setXYZ(6,t.r,t.g,t.b),s.setXYZ(7,t.r,t.g,t.b),s.setXYZ(8,t.r,t.g,t.b),s.setXYZ(9,t.r,t.g,t.b),s.setXYZ(10,t.r,t.g,t.b),s.setXYZ(11,t.r,t.g,t.b),s.setXYZ(12,t.r,t.g,t.b),s.setXYZ(13,t.r,t.g,t.b),s.setXYZ(14,t.r,t.g,t.b),s.setXYZ(15,t.r,t.g,t.b),s.setXYZ(16,t.r,t.g,t.b),s.setXYZ(17,t.r,t.g,t.b),s.setXYZ(18,t.r,t.g,t.b),s.setXYZ(19,t.r,t.g,t.b),s.setXYZ(20,t.r,t.g,t.b),s.setXYZ(21,t.r,t.g,t.b),s.setXYZ(22,t.r,t.g,t.b),s.setXYZ(23,t.r,t.g,t.b),s.setXYZ(24,e.r,e.g,e.b),s.setXYZ(25,e.r,e.g,e.b),s.setXYZ(26,e.r,e.g,e.b),s.setXYZ(27,e.r,e.g,e.b),s.setXYZ(28,e.r,e.g,e.b),s.setXYZ(29,e.r,e.g,e.b),s.setXYZ(30,e.r,e.g,e.b),s.setXYZ(31,e.r,e.g,e.b),s.setXYZ(32,n.r,n.g,n.b),s.setXYZ(33,n.r,n.g,n.b),s.setXYZ(34,n.r,n.g,n.b),s.setXYZ(35,n.r,n.g,n.b),s.setXYZ(36,n.r,n.g,n.b),s.setXYZ(37,n.r,n.g,n.b),s.setXYZ(38,i.r,i.g,i.b),s.setXYZ(39,i.r,i.g,i.b),s.setXYZ(40,r.r,r.g,r.b),s.setXYZ(41,r.r,r.g,r.b),s.setXYZ(42,r.r,r.g,r.b),s.setXYZ(43,r.r,r.g,r.b),s.setXYZ(44,r.r,r.g,r.b),s.setXYZ(45,r.r,r.g,r.b),s.setXYZ(46,r.r,r.g,r.b),s.setXYZ(47,r.r,r.g,r.b),s.setXYZ(48,r.r,r.g,r.b),s.setXYZ(49,r.r,r.g,r.b),s.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;dP.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),fP("c",e,t,dP,0,0,-1),fP("t",e,t,dP,0,0,1),fP("n1",e,t,dP,-1,-1,-1),fP("n2",e,t,dP,1,-1,-1),fP("n3",e,t,dP,-1,1,-1),fP("n4",e,t,dP,1,1,-1),fP("f1",e,t,dP,-1,-1,1),fP("f2",e,t,dP,1,-1,1),fP("f3",e,t,dP,-1,1,1),fP("f4",e,t,dP,1,1,1),fP("u1",e,t,dP,.7,1.1,-1),fP("u2",e,t,dP,-.7,1.1,-1),fP("u3",e,t,dP,0,2,-1),fP("cf1",e,t,dP,-1,0,1),fP("cf2",e,t,dP,1,0,1),fP("cf3",e,t,dP,0,-1,1),fP("cf4",e,t,dP,0,1,1),fP("cn1",e,t,dP,-1,0,-1),fP("cn2",e,t,dP,1,0,-1),fP("cn3",e,t,dP,0,-1,-1),fP("cn4",e,t,dP,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function fP(t,e,n,i,r,s,o){uP.set(r,s,o).unproject(i);const a=e[t];if(void 0!==a){const t=n.getAttribute("position");for(let e=0,n=a.length;e<n;e++)t.setXYZ(a[e],uP.x,uP.y,uP.z)}}const mP=new Bv;class gP extends JE{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new RS;r.setIndex(new uS(n,1)),r.setAttribute("position",new uS(i,3)),super(r,new GE({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&mP.setFromObject(this.object),mP.isEmpty())return;const e=mP.min,n=mP.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=e.x,r[4]=n.y,r[5]=n.z,r[6]=e.x,r[7]=e.y,r[8]=n.z,r[9]=n.x,r[10]=e.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=e.z,r[15]=e.x,r[16]=n.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=n.x,r[22]=e.y,r[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class _P extends JE{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new RS;i.setIndex(new uS(n,1)),i.setAttribute("position",new xS([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new GE({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}class yP extends qE{constructor(t,e=1,n=16776960){const i=n,r=new RS;r.setAttribute("position",new xS([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),r.computeBoundingSphere(),super(r,new GE({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new RS;s.setAttribute("position",new xS([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),s.computeBoundingSphere(),this.add(new YS(s,new iS({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const vP=new Ov;let xP,SP;class bP extends Ux{constructor(t=new Ov(0,0,1),e=new Ov(0,0,0),n=1,i=16776960,r=.2*n,s=.2*r){super(),this.type="ArrowHelper",void 0===xP&&(xP=new RS,xP.setAttribute("position",new xS([0,0,0,0,1,0],3)),SP=new UT(0,.5,1,5,1),SP.translate(0,-.5,0)),this.position.copy(e),this.line=new qE(xP,new GE({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new YS(SP,new iS({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{vP.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(vP,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class MP extends JE{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new RS;n.setAttribute("position",new xS(e,3)),n.setAttribute("color",new xS([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new GE({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const i=new eS,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class wP{constructor(){this.type="ShapePath",this.color=new eS,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new IT,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,s){return this.currentPath.bezierCurveTo(t,e,n,i,r,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const n=e.length;let i=!1;for(let r=n-1,s=0;s<n;r=s++){let n=e[r],o=e[s],a=o.x-n.x,l=o.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],a=-a,o=e[r],l=-l),t.y<n.y||t.y>o.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(o.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=o.x)return!0}}return i}const n=gA.isClockWise,i=this.subPaths;if(0===i.length)return[];let r,s,o;const a=[];if(1===i.length)return s=i[0],o=new jT,o.curves=s.curves,a.push(o),a;let l=!n(i[0].getPoints());l=t?!l:l;const c=[],h=[];let u,d,p=[],f=0;h[f]=void 0,p[f]=[];for(let e=0,o=i.length;e<o;e++)s=i[e],u=s.getPoints(),r=n(u),r=t?!r:r,r?(!l&&h[f]&&f++,h[f]={s:new jT,p:u},h[f].s.curves=s.curves,l&&f++,p[f]=[]):p[f].push({h:s,p:u[0]});if(!h[0])return function(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new jT;r.curves=i.curves,e.push(r)}return e}(i);if(h.length>1){let t=!1,n=0;for(let t=0,e=h.length;t<e;t++)c[t]=[];for(let i=0,r=h.length;i<r;i++){const r=p[i];for(let s=0;s<r.length;s++){const o=r[s];let a=!0;for(let r=0;r<h.length;r++)e(o.p,h[r].p)&&(i!==r&&n++,a?(a=!1,c[r].push(o)):t=!0);a&&c[i].push(o)}}n>0&&!1===t&&(p=c)}for(let t=0,e=h.length;t<e;t++){o=h[t].s,a.push(o),d=p[t];for(let t=0,e=d.length;t<e;t++)o.holes.push(d[t].h)}return a}}class EP extends $S{constructor(t,e,n,i,r,s){console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),super(t,e,n,i,r,s)}}class TP extends DT{constructor(t,e,n,i){console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),super(t,e,n,i)}}class AP extends OT{constructor(t,e,n,i){console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),super(t,e,n,i)}}class CP extends FT{constructor(t,e,n,i,r,s,o){console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),super(t,e,n,i,r,s,o)}}class RP extends UT{constructor(t,e,n,i,r,s,o,a){console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),super(t,e,n,i,r,s,o,a)}}class PP extends zT{constructor(t,e){console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),super(t,e)}}class LP extends vA{constructor(t,e){console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),super(t,e)}}class IP extends SA{constructor(t,e){console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),super(t,e)}}class NP extends NT{constructor(t,e,n,i){console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),super(t,e,n,i)}}class DP extends bA{constructor(t,e){console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),super(t,e)}}class OP extends gb{constructor(t,e,n,i){console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),super(t,e,n,i)}}class UP extends BT{constructor(t,e,n,i){console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),super(t,e,n,i)}}class FP extends MA{constructor(t,e,n,i,r,s){console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),super(t,e,n,i,r,s)}}class BP extends wA{constructor(t,e){console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),super(t,e)}}class zP extends EA{constructor(t,e,n,i,r,s,o){console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),super(t,e,n,i,r,s,o)}}class VP extends TA{constructor(t,e){console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),super(t,e)}}class kP extends AA{constructor(t,e,n,i,r){console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),super(t,e,n,i,r)}}class GP extends CA{constructor(t,e,n,i,r,s){console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),super(t,e,n,i,r,s)}}class HP extends RA{constructor(t,e,n,i,r){console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),super(t,e,n,i,r)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:ym}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=ym);var WP={89:t=>{var e=function(){var t=function(t,e,n,i){for(n=n||{},i=t.length;i--;n[t[i]]=e);return n},e=[1,60],n=[1,62],i=[1,63],r=[1,65],s=[1,66],o=[1,67],a=[1,68],l=[1,69],c=[1,80],h=[1,72],u=[1,73],d=[1,74],p=[1,75],f=[1,99],m=[1,76],g=[1,100],_=[1,79],y=[1,51],v=[1,81],x=[1,82],S=[1,84],b=[1,83],M=[1,85],w=[1,96],E=[1,97],T=[1,98],A=[1,86],C=[1,87],R=[1,64],P=[1,70],L=[1,71],I=[1,77],N=[1,78],D=[1,53],O=[1,54],U=[1,55],F=[1,61],B=[1,88],z=[1,89],V=[1,90],k=[1,91],G=[1,92],H=[1,93],W=[1,94],j=[1,95],X=[1,101],Y=[1,102],q=[1,103],$=[1,104],Z=[1,105],J=[1,56],K=[1,57],Q=[1,58],tt=[1,59],et=[1,115],nt=[1,111],it=[1,114],rt=[1,112],st=[1,113],ot=[1,118],at=[1,117],lt=[1,134],ct=[1,149],ht=[1,150],ut=[1,157],dt=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],pt=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,71,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],ft=[5,6,7,9,13,15,17,18,19,20,23,25,26,27,30,33,34,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,82,83,84,85,86,87,88,89,90,91,92,93,94,95],mt=[5,70,72],gt=[5,74],_t=[71,101],yt={trace:function(){},yy:{},symbols_:{error:2,Program:3,Command:4,EOF:5,RESET:6,BUILD:7,ALL:8,HELP:9,Path:10,MOTM:11,OneArgCommand:12,GET:13,STRING:14,SET:15,Value:16,SET_SAVE:17,SET_RESTORE:18,SET_RESET:19,PRESET:20,AddRepresentation:21,EditRepresentation:22,REMOVE:23,RepresentationReference:24,HIDE:25,SHOW:26,LIST:27,EXPAND_KEY:28,SELECTOR_KEY:29,SELECT:30,AS:31,WordAll:32,SELECTOR:33,WITHIN:34,NUMBER:35,OF:36,MATERIAL:37,IDENTIFIER:38,ModeCMD:39,ColorCMD:40,VIEW:41,BASE_64:42,UNIT:43,DSSP:44,SCALE:45,ROTATE:46,AxesList:47,TRANSLATE:48,CENTER:49,GetURLBranch:50,Screenshot:51,LINE:52,ArgList:53,LISTOBJ:54,REMOVEOBJ:55,URL:56,VIEW_KEY:57,SCREENSHOT:58,LOAD:59,Url:60,FILE_KEY:61,ADD:62,Description:63,REP:64,MODE:65,COLOR:66,Descriptor:67,RepresentationOwnProperty:68,RepresentationOwnPropertyOpts:69,DESC_KEY:70,"=":71,DESC_KEY_OPTS:72,AxesArg:73,DESC_KEY_AXES:74,Arg:75,PathWoDescKey:76,HEX:77,BOOL:78,Word:79,CommandSetWoDESC_KEY:80,DescKeys:81,CLEAR:82,FILE_LIST:83,FILE_REGISTER:84,FILE_DELETE:85,PRESET_ADD:86,PRESET_DELETE:87,PRESET_UPDATE:88,PRESET_RENAME:89,PRESET_OPEN:90,CREATE_SCENARIO:91,RESET_SCENARIO:92,DELETE_SCENARIO:93,ADD_SCENARIO_ITEM:94,LIST_SCENARIO:95,PDB_KEY:96,DELAY_KEY:97,PRST_KEY:98,DESCRIPTION_KEY:99,CommandSet:100,".":101,PresetPath:102,"/":103,HexOrNumber:104,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",6:"RESET",7:"BUILD",8:"ALL",9:"HELP",11:"MOTM",13:"GET",14:"STRING",15:"SET",17:"SET_SAVE",18:"SET_RESTORE",19:"SET_RESET",20:"PRESET",23:"REMOVE",25:"HIDE",26:"SHOW",27:"LIST",28:"EXPAND_KEY",29:"SELECTOR_KEY",30:"SELECT",31:"AS",33:"SELECTOR",34:"WITHIN",35:"NUMBER",36:"OF",37:"MATERIAL",38:"IDENTIFIER",41:"VIEW",42:"BASE_64",43:"UNIT",44:"DSSP",45:"SCALE",46:"ROTATE",48:"TRANSLATE",49:"CENTER",52:"LINE",54:"LISTOBJ",55:"REMOVEOBJ",56:"URL",57:"VIEW_KEY",58:"SCREENSHOT",59:"LOAD",61:"FILE_KEY",62:"ADD",64:"REP",65:"MODE",66:"COLOR",70:"DESC_KEY",71:"=",72:"DESC_KEY_OPTS",74:"DESC_KEY_AXES",77:"HEX",78:"BOOL",82:"CLEAR",83:"FILE_LIST",84:"FILE_REGISTER",85:"FILE_DELETE",86:"PRESET_ADD",87:"PRESET_DELETE",88:"PRESET_UPDATE",89:"PRESET_RENAME",90:"PRESET_OPEN",91:"CREATE_SCENARIO",92:"RESET_SCENARIO",93:"DELETE_SCENARIO",94:"ADD_SCENARIO_ITEM",95:"LIST_SCENARIO",96:"PDB_KEY",97:"DELAY_KEY",98:"PRST_KEY",99:"DESCRIPTION_KEY",101:".",103:"/"},productions_:[0,[3,2],[3,1],[4,1],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,3],[4,3],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,2],[4,4],[4,2],[4,6],[4,2],[4,1],[4,1],[4,1],[4,2],[4,2],[4,1],[4,2],[4,1],[4,2],[4,2],[4,2],[4,1],[4,2],[4,1],[4,1],[4,3],[4,3],[4,4],[4,4],[4,1],[4,2],[50,1],[50,2],[50,2],[50,3],[50,3],[51,1],[51,2],[51,3],[12,2],[12,2],[12,2],[21,1],[21,2],[21,2],[21,3],[22,2],[22,3],[39,2],[39,3],[40,2],[40,3],[24,1],[24,1],[63,1],[63,2],[63,3],[63,4],[67,1],[67,1],[67,2],[68,3],[69,3],[47,1],[47,2],[73,2],[53,1],[53,2],[75,3],[16,1],[16,1],[16,1],[16,1],[16,1],[79,1],[79,1],[32,1],[32,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[100,1],[100,1],[76,1],[76,3],[76,3],[10,1],[10,1],[10,3],[10,3],[10,3],[60,1],[102,1],[102,3],[104,1],[104,1]],performAction:function(t,e,n,i,r,s,o){var a=s.length-1;switch(r){case 1:return s[a-1];case 3:this.$=i.miew.reset(!1),i.ClearContext(),i.miew.resetReps("empty");break;case 4:this.$=i.miew.rebuild();break;case 5:this.$=i.miew.rebuildAll(),i.miew.rebuild();break;case 6:this.$=i.echo(i.utils.help().toString());break;case 7:this.$=i.echo(i.utils.help(s[a]).toString());break;case 8:this.$=i.miew.motm();break;case 10:case 11:this.$=i.utils.propagateProp(s[a]),i.echo(i.miew.get(s[a]).toString());break;case 12:case 13:this.$=i.miew.set(s[a-1],i.utils.propagateProp(s[a-1],s[a]));break;case 14:this.$=i.miew.saveSettings();break;case 15:this.$=i.miew.restoreSettings();break;case 16:this.$=i.miew.resetSettings();break;case 17:this.$=i.miew.resetReps();break;case 18:this.$=i.miew.applyPreset(s[a]);break;case 21:this.$=i.miew.repRemove(s[a]),i.representations.remove(s[a]);break;case 22:this.$=i.miew.repHide(s[a]);break;case 23:this.$=i.miew.repHide(s[a],!1);break;case 24:this.$=i.echo(i.utils.listRep(i.miew,i.representations,s[a],"-e"));break;case 25:this.$=i.echo(i.utils.list(i.miew,i.representations));break;case 26:this.$=i.echo(i.utils.list(i.miew,i.representations,s[a]));break;case 27:this.$=i.echo(i.utils.listSelector(i.miew,i.Context));break;case 28:this.$=i.miew.select(i.utils.checkArg(s[a-1].toLowerCase(),s[a],!0));break;case 29:this.$=i.Context[s[a].toLowerCase()]=i.utils.checkArg(s[a-3].toLowerCase(),s[a-2],!0),i.miew.select(i.Context[s[a].toLowerCase()]);break;case 30:this.$=i.miew.rep(i.miew.repCurrent(),{selector:i.utils.checkArg(s[a-1].toLowerCase(),s[a])});break;case 31:this.$=i.Context[s[a].toLowerCase()]=i.miew.within(i.utils.checkArg("select",s[a-2],!0),Number(s[a-4]));break;case 32:this.$=i.miew.rep(i.miew.repCurrent(),{material:i.utils.checkArg(s[a-1].toLowerCase(),s[a].toUpperCase())});break;case 35:this.$=i.echo(i.miew.view());break;case 36:case 37:this.$=i.miew.view(s[a]);break;case 38:this.$=i.echo(i.miew.changeUnit());break;case 39:this.$=i.echo(i.miew.changeUnit(s[a]));break;case 40:this.$=i.miew.dssp();break;case 41:this.$=i.miew.scale(s[a]);break;case 42:for(var l=0,c=s[a].length;l<c;l++)i.miew.rotate(s[a][l].x*Math.PI/180,s[a][l].y*Math.PI/180,s[a][l].z*Math.PI/180);break;case 43:for(l=0,c=s[a].length;l<c;l++)i.miew.translate(s[a][l].x||0,s[a][l].y||0,s[a][l].z||0);break;case 44:this.$=i.miew.center();break;case 45:this.$=i.miew.center(s[a]);break;case 48:case 49:this.$=i.miew.addObject({type:"line",params:[s[a-1],s[a]]},!0);break;case 50:case 51:this.$=i.miew.addObject({type:"line",params:[s[a-2],s[a-1]],opts:s[a].toJSO(i.utils,"objects","line")},!0);break;case 52:this.$=i.echo(i.utils.listObjs(i.miew));break;case 53:this.$=i.miew.removeObject(s[a]);break;case 54:this.$=i.echo(i.miew.getURL({view:!1,settings:!1}));break;case 55:this.$=i.echo(i.miew.getURL({view:!1,settings:!0}));break;case 56:this.$=i.echo(i.miew.getURL({view:!0,settings:!1}));break;case 57:case 58:this.$=i.echo(i.miew.getURL({view:!0,settings:!0}));break;case 59:this.$=i.miew.screenshotSave();break;case 60:this.$=i.miew.screenshotSave("",Number(s[a]));break;case 61:this.$=i.miew.screenshotSave("",Number(s[a-1]),Number(s[a]));break;case 62:case 63:case 64:this.$=i.utils.load(i.miew,s[a]),i.representations.clear();break;case 65:this.$=i.echo(i.representations.add(i.miew.repAdd()));break;case 66:this.$=i.echo(i.representations.add(s[a],i.miew.repAdd()));break;case 67:this.$=i.echo(i.representations.add(i.miew.repAdd(s[a])));break;case 68:this.$=i.echo(i.representations.add(s[a-1],i.miew.repAdd(s[a])));break;case 69:this.$=i.miew.rep(s[a]),i.miew.repCurrent(s[a]);break;case 70:this.$=i.miew.rep(s[a-1],s[a]),i.miew.repCurrent(s[a-1]);break;case 71:this.$=i.miew.rep(i.miew.repCurrent(),{mode:i.utils.checkArg(s[a-1].toLowerCase(),s[a].toUpperCase())});break;case 72:this.$=i.miew.rep(i.miew.repCurrent(),{mode:new Array(i.utils.checkArg(s[a-2].toLowerCase(),s[a-1].toUpperCase()),s[a].toJSO(i.utils,s[a-2],s[a-1].toUpperCase()))});break;case 73:this.$=i.miew.rep(i.miew.repCurrent(),{colorer:i.utils.checkArg(s[a-1].toLowerCase(),s[a].toUpperCase())});break;case 74:this.$=i.miew.rep(i.miew.repCurrent(),{colorer:new Array(i.utils.checkArg(s[a-2].toLowerCase(),s[a-1].toUpperCase()),s[a].toJSO(i.utils,s[a-2],s[a-1].toUpperCase()))});break;case 75:this.$=Number(i.representations.get(s[a]));break;case 76:case 92:this.$=Number(s[a]);break;case 77:this.$=s[a];break;case 78:this.$=i._.assign(s[a-1],s[a]);break;case 79:this.$=i._.assign(s[a-2],s[a-1],s[a]);break;case 80:this.$=i._.assign(s[a-3],s[a-2],s[a-1],s[a]);break;case 81:case 82:this.$=i.CreateObjectPair(s[a].key,s[a].val);break;case 83:this.$=i.CreateObjectPair(s[a-1].key,new Array(s[a-1].val,s[a].toJSO(i.utils,s[a-1].key,s[a-1].val)));break;case 84:case 85:this.$=Object.create({key:i.keyRemap(s[a-2]),val:i.utils.checkArg(s[a-2],s[a])});break;case 86:this.$=[s[a]];break;case 87:this.$=s[a-1].concat(s[a]);break;case 88:this.$=i.CreateObjectPair(s[a-1].toLowerCase(),Number(s[a]));break;case 89:this.$=new i.ArgList(s[a]);break;case 90:this.$=s[a-1].append(s[a]);break;case 91:this.$=new i.Arg(s[a-2],s[a]);break;case 93:this.$=parseInt(s[a]);break;case 94:this.$=JSON.parse(s[a]);break;case 95:case 96:this.$=String(s[a]);break;case 157:case 158:case 161:case 162:case 163:this.$=s[a-2]+s[a-1]+s[a];break;case 166:this.$=s[a-2]=s[a-2]+s[a-1]+s[a]}},table:[{3:1,4:2,5:[1,3],6:[1,4],7:[1,5],9:[1,6],11:[1,7],12:8,13:[1,9],15:[1,10],17:[1,11],18:[1,12],19:[1,13],20:[1,14],21:15,22:16,23:[1,17],25:[1,18],26:[1,19],27:[1,20],30:[1,21],33:[1,22],34:[1,23],37:[1,24],39:25,40:26,41:[1,27],43:[1,28],44:[1,29],45:[1,30],46:[1,31],48:[1,32],49:[1,33],50:34,51:35,52:[1,36],54:[1,37],55:[1,38],56:[1,44],58:[1,45],59:[1,39],62:[1,40],64:[1,41],65:[1,42],66:[1,43]},{1:[3]},{5:[1,46]},{1:[2,2]},{5:[2,3]},{5:[2,4],8:[1,47]},{5:[2,6],6:e,7:n,9:i,10:48,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:49,80:52,81:50,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{5:[2,8]},{5:[2,9]},{6:e,7:n,9:i,10:106,13:r,14:[1,107],15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:49,80:52,81:50,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{6:e,7:n,9:i,10:108,13:r,14:[1,109],15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:49,80:52,81:50,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{5:[2,14]},{5:[2,15]},{5:[2,16]},{5:[2,17],14:et,16:110,35:nt,38:it,77:rt,78:st},{5:[2,19]},{5:[2,20]},{24:116,35:ot,38:at},{24:119,35:ot,38:at},{24:120,35:ot,38:at},{5:[2,25],24:121,28:[1,122],29:[1,123],35:ot,38:at},{14:[1,124]},{14:[1,125]},{35:[1,126]},{38:[1,127]},{5:[2,33]},{5:[2,34]},{5:[2,35],14:[1,128],42:[1,129]},{5:[2,38],35:[1,130]},{5:[2,40]},{35:[1,131]},{47:132,73:133,74:lt},{47:135,73:133,74:lt},{5:[2,44],14:[1,136]},{5:[2,46]},{5:[2,47]},{6:e,7:n,9:i,10:138,13:r,14:[1,137],15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:49,80:52,81:50,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{5:[2,52]},{35:[1,139]},{14:[1,143],38:[1,141],60:140,61:[1,142]},{5:[2,65],38:[1,144],63:145,67:146,68:147,69:148,70:ct,72:ht},{24:151,35:ot,38:at},{38:[1,152]},{38:[1,153]},{5:[2,54],29:[1,154],57:[1,155]},{5:[2,59],35:[1,156]},{1:[2,1]},{5:[2,5]},{5:[2,7],101:ut},t(dt,[2,159]),t(dt,[2,160]),t(pt,[2,97]),t(pt,[2,98]),t(dt,[2,147]),t(dt,[2,148]),t(dt,[2,149]),t(dt,[2,150]),t(dt,[2,151]),t(dt,[2,152]),t(dt,[2,153]),t(pt,[2,101]),t(pt,[2,102]),t(pt,[2,103]),t(pt,[2,104]),t(pt,[2,105]),t(pt,[2,106]),t(pt,[2,107]),t(pt,[2,108]),t(pt,[2,109]),t(pt,[2,110]),t(pt,[2,111]),t(pt,[2,112]),t(pt,[2,113]),t(pt,[2,114]),t(pt,[2,115]),t(pt,[2,116]),t(pt,[2,117]),t(pt,[2,118]),t(pt,[2,119]),t(pt,[2,120]),t(pt,[2,121]),t(pt,[2,122]),t(pt,[2,123]),t(pt,[2,124]),t(pt,[2,125]),t(pt,[2,126]),t(pt,[2,127]),t(pt,[2,128]),t(pt,[2,129]),t(pt,[2,130]),t(pt,[2,131]),t(pt,[2,132]),t(pt,[2,133]),t(pt,[2,134]),t(pt,[2,135]),t(pt,[2,136]),t(pt,[2,137]),t(pt,[2,138]),t(pt,[2,139]),t(pt,[2,140]),t(pt,[2,141]),t(pt,[2,142]),t(pt,[2,143]),t(pt,[2,144]),t(pt,[2,145]),t(pt,[2,146]),{5:[2,10],101:ut},{5:[2,11]},{14:et,16:158,35:nt,38:it,77:rt,78:st,101:ut},{14:et,16:159,35:nt,38:it,77:rt,78:st},{5:[2,18]},t(ft,[2,92]),t(ft,[2,93]),t(ft,[2,94]),t(ft,[2,95]),t(ft,[2,96]),{5:[2,21]},t(mt,[2,75]),t(mt,[2,76]),{5:[2,22]},{5:[2,23]},{5:[2,24]},{5:[2,26]},{5:[2,27]},{5:[2,28],31:[1,160]},{5:[2,30]},{36:[1,161]},{5:[2,32]},{5:[2,36]},{5:[2,37]},{5:[2,39]},{5:[2,41]},{5:[2,42],73:162,74:lt},t(gt,[2,86]),{35:[1,163]},{5:[2,43],73:162,74:lt},{5:[2,45]},{14:[1,164]},{6:e,7:n,9:i,10:165,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:49,80:52,81:50,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt,101:ut},{5:[2,53]},{5:[2,62]},{5:[2,63]},{5:[2,64]},{5:[2,164]},{5:[2,66],63:166,67:146,68:147,69:148,70:ct,72:ht},{5:[2,67]},{5:[2,77],67:167,68:147,69:148,70:ct,72:ht},t(mt,[2,81]),t(mt,[2,82],{80:52,53:168,75:169,76:170,79:171,6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z}),{71:[1,172]},{71:[1,173]},{5:[2,69],63:174,67:146,68:147,69:148,70:ct,72:ht},{5:[2,71],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,53:175,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:169,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,73],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,53:176,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:169,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,55],57:[1,177]},{5:[2,56],29:[1,178]},{5:[2,60],35:[1,179]},{6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,35:[1,181],37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:180,80:52,81:182,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{5:[2,12]},{5:[2,13]},{6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,32:183,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:184,80:52,81:185,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{14:[1,186]},t(gt,[2,87]),t(gt,[2,88]),{5:[2,48],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,53:187,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:169,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,49],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,53:188,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:169,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,101:ut},{5:[2,68]},{5:[2,78],67:189,68:147,69:148,70:ct,72:ht},t(mt,[2,83],{80:52,76:170,79:171,75:190,6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z}),t(ft,[2,89]),{71:[1,191],101:[1,192]},t(_t,[2,156]),{14:et,16:193,35:nt,38:it,77:rt,78:st},{14:et,16:194,35:nt,38:it,77:rt,78:st},{5:[2,70]},{5:[2,72],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:190,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,74],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:190,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,57]},{5:[2,58]},{5:[2,61]},t(dt,[2,161]),t(dt,[2,162]),t(dt,[2,163]),{5:[2,29]},{5:[2,99]},{5:[2,100]},{31:[1,195]},{5:[2,50],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:190,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,51],6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,75:190,76:170,79:171,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},{5:[2,79],67:196,68:147,69:148,70:ct,72:ht},t(ft,[2,90]),{14:et,16:197,35:nt,38:it,77:rt,78:st},{6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,33:m,34:g,35:[1,199],37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,79:198,80:52,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z},t(mt,[2,84]),t(ft,[2,85]),{6:e,7:n,9:i,13:r,15:s,17:o,18:a,19:l,20:c,23:h,25:u,26:d,27:p,30:f,32:200,33:m,34:g,37:_,38:y,41:v,43:x,45:S,46:b,49:M,52:w,54:E,55:T,56:A,58:C,59:R,62:P,64:L,65:I,66:N,70:D,72:O,74:U,79:184,80:52,81:185,82:F,83:B,84:z,85:V,86:k,87:G,88:H,89:W,90:j,91:X,92:Y,93:q,94:$,95:Z,96:J,97:K,98:Q,99:tt},{5:[2,80]},t(ft,[2,91]),t(_t,[2,157]),t(_t,[2,158]),{5:[2,31]}],defaultActions:{3:[2,2],4:[2,3],7:[2,8],8:[2,9],11:[2,14],12:[2,15],13:[2,16],15:[2,19],16:[2,20],25:[2,33],26:[2,34],29:[2,40],34:[2,46],35:[2,47],37:[2,52],46:[2,1],47:[2,5],107:[2,11],110:[2,18],116:[2,21],119:[2,22],120:[2,23],121:[2,24],122:[2,26],123:[2,27],125:[2,30],127:[2,32],128:[2,36],129:[2,37],130:[2,39],131:[2,41],136:[2,45],139:[2,53],140:[2,62],141:[2,63],142:[2,64],143:[2,164],145:[2,67],158:[2,12],159:[2,13],166:[2,68],174:[2,70],177:[2,57],178:[2,58],179:[2,61],183:[2,29],184:[2,99],185:[2,100],196:[2,80],200:[2,31]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],i=[],r=[null],s=[],o=this.table,a="",l=0,c=0,h=0,u=s.slice.call(arguments,1),d=Object.create(this.lexer),p={yy:{}};for(var f in this.yy)Object.prototype.hasOwnProperty.call(this.yy,f)&&(p.yy[f]=this.yy[f]);d.setInput(t,p.yy),p.yy.lexer=d,p.yy.parser=this,void 0===d.yylloc&&(d.yylloc={});var m=d.yylloc;s.push(m);var g=d.options&&d.options.ranges;function _(){var t;return"number"!=typeof(t=i.pop()||d.lex()||1)&&(t instanceof Array&&(t=(i=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof p.yy.parseError?this.parseError=p.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var y,v,x,S,b,M,w,E,T,A={};;){if(x=n[n.length-1],this.defaultActions[x]?S=this.defaultActions[x]:(null==y&&(y=_()),S=o[x]&&o[x][y]),void 0===S||!S.length||!S[0]){var C;for(M in T=[],o[x])this.terminals_[M]&&M>2&&T.push("'"+this.terminals_[M]+"'");C=d.showPosition?"Parse error on line "+(l+1)+":\n"+d.showPosition()+"\nExpecting "+T.join(", ")+", got '"+(this.terminals_[y]||y)+"'":"Parse error on line "+(l+1)+": Unexpected "+(1==y?"end of input":"'"+(this.terminals_[y]||y)+"'"),this.parseError(C,{text:d.match,token:this.terminals_[y]||y,line:d.yylineno,loc:m,expected:T})}if(S[0]instanceof Array&&S.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+y);switch(S[0]){case 1:n.push(y),r.push(d.yytext),s.push(d.yylloc),n.push(S[1]),y=null,v?(y=v,v=null):(c=d.yyleng,a=d.yytext,l=d.yylineno,m=d.yylloc,h>0&&h--);break;case 2:if(w=this.productions_[S[1]][1],A.$=r[r.length-w],A._$={first_line:s[s.length-(w||1)].first_line,last_line:s[s.length-1].last_line,first_column:s[s.length-(w||1)].first_column,last_column:s[s.length-1].last_column},g&&(A._$.range=[s[s.length-(w||1)].range[0],s[s.length-1].range[1]]),void 0!==(b=this.performAction.apply(A,[a,c,l,p.yy,S[1],r,s].concat(u))))return b;w&&(n=n.slice(0,-1*w*2),r=r.slice(0,-1*w),s=s.slice(0,-1*w)),n.push(this.productions_[S[1]][0]),r.push(A.$),s.push(A._$),E=o[n[n.length-2]][n[n.length-1]],n.push(E);break;case 3:return!0}}return!0}},vt={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var i=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var r=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===i.length?this.yylloc.first_column:0)+i[i.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[r[0],r[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,i,r;if(this.options.backtrack_lexer&&(r={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(r.yylloc.range=this.yylloc.range.slice(0))),(i=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=i.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:i?i[i.length-1].length-i[i.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var s in r)this[s]=r[s];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,i;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var r=this._currentRules(),s=0;s<r.length;s++)if((n=this._input.match(this.rules[r[s]]))&&(!e||n[0].length>e[0].length)){if(e=n,i=s,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,r[s])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,r[i]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){return this.next()||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,i){switch(n){case 0:break;case 1:case 2:return"";case 3:return 42;case 4:return 35;case 5:return 77;case 6:case 7:return 78;case 8:return 8;case 9:return 6;case 10:return 82;case 11:return 7;case 12:return 9;case 13:return 59;case 14:return 13;case 15:return 15;case 16:return 17;case 17:return 18;case 18:return 19;case 19:return 20;case 20:return 11;case 21:return 62;case 22:return 64;case 23:return 23;case 24:return 25;case 25:return 26;case 26:return 27;case 27:return 30;case 28:return 34;case 29:return 33;case 30:return 65;case 31:return 66;case 32:return 37;case 33:return 41;case 34:return 43;case 35:return 52;case 36:return 54;case 37:return 55;case 38:return 46;case 39:return 48;case 40:return 45;case 41:return 49;case 42:return 56;case 43:return 58;case 44:return 44;case 45:return 83;case 46:return 84;case 47:return 85;case 48:return 86;case 49:return 87;case 50:return 88;case 51:return 89;case 52:return 90;case 53:return 91;case 54:return 92;case 55:return 93;case 56:return 94;case 57:return 95;case 58:case 59:return 70;case 60:case 61:return 72;case 62:case 63:case 64:return 74;case 65:return 31;case 66:return 36;case 67:return 96;case 68:return 97;case 69:return 98;case 70:return 99;case 71:return e.yytext=t.utils.unquoteString(e.yytext),14;case 72:return 38;case 73:return 5;case 74:return 101;case 75:return 103;case 76:return"\\";case 77:return 28;case 78:return 61;case 79:return 29;case 80:return 57;case 81:return 71}},rules:[/^(?:\s+)/i,/^(?:[#].*)/i,/^(?:\/\/.*)/i,/^(?:([_A-Z0-9\/\+]+==))/i,/^(?:-?[0-9]+(\.[0-9]+)?\b)/i,/^(?:0[xX][0-9A-F]+\b)/i,/^(?:false\b)/i,/^(?:true\b)/i,/^(?:all\b)/i,/^(?:reset\b)/i,/^(?:clear\b)/i,/^(?:build\b)/i,/^(?:help\b)/i,/^(?:load\b)/i,/^(?:get\b)/i,/^(?:set\b)/i,/^(?:set_save\b)/i,/^(?:set_restore\b)/i,/^(?:set_reset\b)/i,/^(?:preset\b)/i,/^(?:motm\b)/i,/^(?:add\b)/i,/^(?:rep\b)/i,/^(?:remove\b)/i,/^(?:hide\b)/i,/^(?:show\b)/i,/^(?:list\b)/i,/^(?:select\b)/i,/^(?:within\b)/i,/^(?:selector\b)/i,/^(?:mode\b)/i,/^(?:color\b)/i,/^(?:material\b)/i,/^(?:view\b)/i,/^(?:unit\b)/i,/^(?:line\b)/i,/^(?:listobj\b)/i,/^(?:removeobj\b)/i,/^(?:rotate\b)/i,/^(?:translate\b)/i,/^(?:scale\b)/i,/^(?:center\b)/i,/^(?:url\b)/i,/^(?:screenshot\b)/i,/^(?:dssp\b)/i,/^(?:file_list\b)/i,/^(?:file_register\b)/i,/^(?:file_delete\b)/i,/^(?:preset_add\b)/i,/^(?:preset_delete\b)/i,/^(?:preset_update\b)/i,/^(?:preset_rename\b)/i,/^(?:preset_open\b)/i,/^(?:create_scenario\b)/i,/^(?:reset_scenario\b)/i,/^(?:delete_scenario\b)/i,/^(?:add_scenario_item\b)/i,/^(?:list_scenario\b)/i,/^(?:s\b)/i,/^(?:mt\b)/i,/^(?:m\b)/i,/^(?:c\b)/i,/^(?:x\b)/i,/^(?:y\b)/i,/^(?:z\b)/i,/^(?:as\b)/i,/^(?:of\b)/i,/^(?:pdb\b)/i,/^(?:delay\b)/i,/^(?:prst\b)/i,/^(?:desc\b)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:\.)/i,/^(?:\/)/i,/^(?:\\)/i,/^(?:-e\b)/i,/^(?:-f\b)/i,/^(?:-s\b)/i,/^(?:-v\b)/i,/^(?:=)/i],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],inclusive:!0}}};function xt(){this.yy={}}return yt.lexer=vt,xt.prototype=yt,yt.Parser=xt,new xt}();t.exports={parser:e}},99:t=>{var e=function(){var t=function(t,e,n,i){for(n=n||{},i=t.length;i--;n[t[i]]=e);return n},e=[1,4],n=[1,5],i=[1,6],r=[1,7],s=[1,8],o=[1,9],a=[1,11],l=[1,12],c=[5,7,8,11],h=[1,17],u=[1,22],d=[1,20],p=[1,21],f=[5,7,8,11,19],m={trace:function(){},yy:{},symbols_:{error:2,Program:3,Expression:4,EOF:5,Selector:6,OR:7,AND:8,NOT:9,"(":10,")":11,SELECTOR:12,NAMED_SELECTOR:13,SELECTOR_RANGED:14,RangeList:15,SELECTOR_NAMED:16,NameList:17,Range:18,",":19,NUMBER:20,":":21,Name:22,IDENTIFIER:23,STRING:24,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",7:"OR",8:"AND",9:"NOT",10:"(",11:")",12:"SELECTOR",13:"NAMED_SELECTOR",14:"SELECTOR_RANGED",16:"SELECTOR_NAMED",19:",",20:"NUMBER",21:":",23:"IDENTIFIER",24:"STRING"},productions_:[0,[3,2],[4,1],[4,3],[4,3],[4,2],[4,3],[6,1],[6,1],[6,2],[6,2],[15,1],[15,3],[18,1],[18,3],[17,1],[17,3],[22,1],[22,1],[22,1]],performAction:function(t,e,n,i,r,s,o){var a=s.length-1;switch(r){case 1:return s[a-1];case 3:this.$=i.keyword("or")(s[a-2],s[a]);break;case 4:this.$=i.keyword("and")(s[a-2],s[a]);break;case 5:this.$=i.keyword("not")(s[a]);break;case 6:this.$=s[a-1];break;case 7:this.$=i.keyword(s[a])();break;case 8:this.$=i.GetSelector(s[a].toLowerCase().slice(1,s[a].length));break;case 9:case 10:this.$=i.keyword(s[a-1])(s[a]);break;case 11:this.$=new i.RangeList(s[a]);break;case 12:case 16:this.$=s[a-2].append(s[a]);break;case 13:this.$=new i.Range(Number(s[a]));break;case 14:this.$=new i.Range(Number(s[a-2]),Number(s[a]));break;case 15:this.$=new i.ValueList(s[a])}},table:[{3:1,4:2,6:3,9:e,10:n,12:i,13:r,14:s,16:o},{1:[3]},{5:[1,10],7:a,8:l},t(c,[2,2]),{4:13,6:3,9:e,10:n,12:i,13:r,14:s,16:o},{4:14,6:3,9:e,10:n,12:i,13:r,14:s,16:o},t(c,[2,7]),t(c,[2,8]),{15:15,18:16,20:h},{17:18,20:u,22:19,23:d,24:p},{1:[2,1]},{4:23,6:3,9:e,10:n,12:i,13:r,14:s,16:o},{4:24,6:3,9:e,10:n,12:i,13:r,14:s,16:o},t(c,[2,5]),{7:a,8:l,11:[1,25]},t(c,[2,9],{19:[1,26]}),t(f,[2,11]),t(f,[2,13],{21:[1,27]}),t(c,[2,10],{19:[1,28]}),t(f,[2,15]),t(f,[2,17]),t(f,[2,18]),t(f,[2,19]),t([5,7,11],[2,3],{8:l}),t(c,[2,4]),t(c,[2,6]),{18:29,20:h},{20:[1,30]},{20:u,22:31,23:d,24:p},t(f,[2,12]),t(f,[2,14]),t(f,[2,16])],defaultActions:{10:[2,1]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],i=[],r=[null],s=[],o=this.table,a="",l=0,c=0,h=0,u=s.slice.call(arguments,1),d=Object.create(this.lexer),p={yy:{}};for(var f in this.yy)Object.prototype.hasOwnProperty.call(this.yy,f)&&(p.yy[f]=this.yy[f]);d.setInput(t,p.yy),p.yy.lexer=d,p.yy.parser=this,void 0===d.yylloc&&(d.yylloc={});var m=d.yylloc;s.push(m);var g=d.options&&d.options.ranges;function _(){var t;return"number"!=typeof(t=i.pop()||d.lex()||1)&&(t instanceof Array&&(t=(i=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof p.yy.parseError?this.parseError=p.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var y,v,x,S,b,M,w,E,T,A={};;){if(x=n[n.length-1],this.defaultActions[x]?S=this.defaultActions[x]:(null==y&&(y=_()),S=o[x]&&o[x][y]),void 0===S||!S.length||!S[0]){var C;for(M in T=[],o[x])this.terminals_[M]&&M>2&&T.push("'"+this.terminals_[M]+"'");C=d.showPosition?"Parse error on line "+(l+1)+":\n"+d.showPosition()+"\nExpecting "+T.join(", ")+", got '"+(this.terminals_[y]||y)+"'":"Parse error on line "+(l+1)+": Unexpected "+(1==y?"end of input":"'"+(this.terminals_[y]||y)+"'"),this.parseError(C,{text:d.match,token:this.terminals_[y]||y,line:d.yylineno,loc:m,expected:T})}if(S[0]instanceof Array&&S.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+y);switch(S[0]){case 1:n.push(y),r.push(d.yytext),s.push(d.yylloc),n.push(S[1]),y=null,v?(y=v,v=null):(c=d.yyleng,a=d.yytext,l=d.yylineno,m=d.yylloc,h>0&&h--);break;case 2:if(w=this.productions_[S[1]][1],A.$=r[r.length-w],A._$={first_line:s[s.length-(w||1)].first_line,last_line:s[s.length-1].last_line,first_column:s[s.length-(w||1)].first_column,last_column:s[s.length-1].last_column},g&&(A._$.range=[s[s.length-(w||1)].range[0],s[s.length-1].range[1]]),void 0!==(b=this.performAction.apply(A,[a,c,l,p.yy,S[1],r,s].concat(u))))return b;w&&(n=n.slice(0,-1*w*2),r=r.slice(0,-1*w),s=s.slice(0,-1*w)),n.push(this.productions_[S[1]][0]),r.push(A.$),s.push(A._$),E=o[n[n.length-2]][n[n.length-1]],n.push(E);break;case 3:return!0}}return!0}},g={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var i=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var r=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===i.length?this.yylloc.first_column:0)+i[i.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[r[0],r[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,i,r;if(this.options.backtrack_lexer&&(r={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(r.yylloc.range=this.yylloc.range.slice(0))),(i=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=i.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:i?i[i.length-1].length-i[i.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var s in r)this[s]=r[s];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,i;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var r=this._currentRules(),s=0;s<r.length;s++)if((n=this._input.match(this.rules[r[s]]))&&(!e||n[0].length>e[0].length)){if(e=n,i=s,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,r[s])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,r[i]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){return this.next()||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,i){switch(n){case 0:break;case 1:return 20;case 2:return 7;case 3:return 8;case 4:return 9;case 5:return 12;case 6:return 16;case 7:return 14;case 8:return 10;case 9:return 11;case 10:return 19;case 11:return 21;case 12:return"<=";case 13:return">=";case 14:return"<";case 15:return">";case 16:return e.yytext=e.yytext.substr(1,e.yyleng-2),24;case 17:return 13;case 18:return 23;case 19:return 5;case 20:return"INVALID"}},rules:[/^(?:\s+)/i,/^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i,/^(?:OR\b)/i,/^(?:AND\b)/i,/^(?:NOT\b)/i,/^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i,/^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i,/^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i,/^(?:\()/i,/^(?:\))/i,/^(?:,)/i,/^(?::)/i,/^(?:<=)/i,/^(?:>=)/i,/^(?:<)/i,/^(?:>)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:(@[_A-Z0-9]+))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:.)/i],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],inclusive:!0}}};function _(){this.yy={}}return m.lexer=g,_.prototype=m,m.Parser=_,new _}();t.exports={parser:e}},690:function(t,e){(function(){var t,n,i,r,s,o,a,l,c,h,u,d,p,f,m,g,_,y,v,x,S,b,M,w,E,T,A=Object.prototype.hasOwnProperty,C=function(t,e){for(var n in e)A.call(e,n)&&(t[n]=e[n]);function i(){this.constructor=t}return i.prototype=e.prototype,t.prototype=new i,t.__super__=e.prototype,t};for(g in d={method:(i={METHOD_NEAREST:"nearest",METHOD_LINEAR:"linear",METHOD_CUBIC:"cubic",METHOD_LANCZOS:"lanczos",METHOD_SINC:"sinc",CLIP_CLAMP:"clamp",CLIP_ZERO:"zero",CLIP_PERIODIC:"periodic",CLIP_MIRROR:"mirror",CUBIC_TENSION_DEFAULT:0,CUBIC_TENSION_CATMULL_ROM:0}).METHOD_CUBIC,cubicTension:i.CUBIC_TENSION_DEFAULT,clip:i.CLIP_CLAMP,scaleTo:0,sincFilterSize:2,sincWindow:void 0},c=function(t,e){return Math.max(0,Math.min(t,e-1))},u=function(t,e){return(t%=e)<0&&(t+=e),t},h=function(t,e){var n;return(t=u(t,n=2*(e-1)))>e-1&&(t=n-t),t},t=function(){function t(t,e){if(this.array=t.slice(0),this.length=this.array.length,!(this.clipHelper={clamp:this.clipHelperClamp,zero:this.clipHelperZero,periodic:this.clipHelperPeriodic,mirror:this.clipHelperMirror}[e.clip]))throw"Invalid clip: "+e.clip}return t.prototype.getClippedInput=function(t){return 0<=t&&t<this.length?this.array[t]:this.clipHelper(t)},t.prototype.clipHelperClamp=function(t){return this.array[c(t,this.length)]},t.prototype.clipHelperZero=function(t){return 0},t.prototype.clipHelperPeriodic=function(t){return this.array[u(t,this.length)]},t.prototype.clipHelperMirror=function(t){return this.array[h(t,this.length)]},t.prototype.interpolate=function(t){throw"Subclasses of AbstractInterpolator must override the interpolate() method."},t}(),s=function(t){function e(){e.__super__.constructor.apply(this,arguments)}return C(e,t),e.prototype.interpolate=function(t){return this.getClippedInput(Math.round(t))},e}(t),r=function(t){function e(){e.__super__.constructor.apply(this,arguments)}return C(e,t),e.prototype.interpolate=function(t){var e;return(1-(t-=e=Math.floor(t)))*this.getClippedInput(e)+t*this.getClippedInput(e+1)},e}(t),n=function(t){function e(t,n){this.tangentFactor=1-Math.max(-1,Math.min(1,n.cubicTension)),e.__super__.constructor.apply(this,arguments)}return C(e,t),e.prototype.getTangent=function(t){return this.tangentFactor*(this.getClippedInput(t+1)-this.getClippedInput(t-1))/2},e.prototype.interpolate=function(t){var e,n,i,r,s;return e=Math.floor(t),n=[this.getTangent(e),this.getTangent(e+1)],(2*(s=(t-=e)*(r=t*t))-3*r+1)*(i=[this.getClippedInput(e),this.getClippedInput(e+1)])[0]+(s-2*r+t)*n[0]+(-2*s+3*r)*i[1]+(s-r)*n[1]},e}(t),b=Math.sin,o=Math.PI,M=function(t){return 0===t?1:b(o*t)/(o*t)},_=function(t){return function(e){return M(e/t)}},v=function(t){return function(e){return M(e)*t(e)}},a=function(t){function e(t,n){if(e.__super__.constructor.apply(this,arguments),this.a=n.sincFilterSize,!n.sincWindow)throw"No sincWindow provided";this.kernel=v(n.sincWindow)}return C(e,t),e.prototype.interpolate=function(t){var e,n,i,r,s;for(i=0,n=r=(e=Math.floor(t))-this.a+1,s=e+this.a;r<=s?n<=s:n>=s;r<=s?n++:n--)i+=this.kernel(t-n)*this.getClippedInput(n);return i},e}(t),p=function(t,e){var n,i,r,s;for(s=[],i=0,r=t.length;i<r;i++)n=t[i],s.push(n[e]);return s},y=function(t,e,n){var i,r;return"0,1"===n.join?t:(i=e/(n[1]-n[0]),r=n[0],function(e){return t(i*(e-r))})},f=function(t){return Object.prototype.toString.call(t).slice(8,-1)},E=function(t){if(isNaN(t))throw"NaN in Smooth() input";if("Number"!==f(t))throw"Non-number in Smooth() input";if(!isFinite(t))throw"Infinity in Smooth() input"},T=function(t,e){var n,i,r;if("Array"!==f(t))throw"Non-vector in Smooth() input";if(t.length!==e)throw"Inconsistent dimension in Smooth() input";for(i=0,r=t.length;i<r;i++)n=t[i],E(n)},m=function(t){return"Number"===f(t)&&isFinite(t)&&!isNaN(t)},x=function(t){var e;switch(e="scaleTo param must be number or array of two numbers",f(t)){case"Number":if(!m(t))throw e;t=[0,t];break;case"Array":if(2!==t.length)throw e;if(!m(t[0])||!m(t[1]))throw e;break;default:throw e}return t},S=function(t){var e,n,i;for(n in e={},t)A.call(t,n)&&(i=t[n],e[n]=i);return e},l=function(t,e){var i,o,c,h,u,m,g,v,b,M,w;for(g in null==e&&(e={}),b={},e=S(e),b.config=S(e),null==e.scaleTo&&(e.scaleTo=e.period),null==e.sincFilterSize&&(e.sincFilterSize=e.lanczosFilterSize),d)A.call(d,g)&&(w=d[g],null==e[g]&&(e[g]=w));if(!(u={nearest:s,linear:r,cubic:n,lanczos:a,sinc:a}[e.method]))throw"Invalid method: "+e.method;if("lanczos"===e.method&&(e.sincWindow=_(e.sincFilterSize)),t.length<2)throw"Array must have at least two elements";for(g in b.count=t.length,M=function(){var n,i,r,s;switch(f(t[0])){case"Number":if(b.dimension="scalar",l.deepValidation)for(n=0,r=t.length;n<r;n++)v=t[n],E(v);return h=new u(t,e),function(t){return h.interpolate(t)};case"Array":if(b.dimension=o=t[0].length,!o)throw"Vectors must be non-empty";if(l.deepValidation)for(i=0,s=t.length;i<s;i++)w=t[i],T(w,o);return m=function(){var n;for(n=[],c=0;0<=o?c<o:c>o;0<=o?c++:c--)n.push(new u(p(t,c),e));return n}(),function(t){var e,n,i,r;for(r=[],n=0,i=m.length;n<i;n++)e=m[n],r.push(e.interpolate(t));return r};default:throw"Invalid element type: "+f(t[0])}}(),i="periodic"===e.clip?t.length:t.length-1,e.scaleTo||(e.scaleTo=i),b.domain=x(e.scaleTo),M=y(M,i,b.domain),b.domain.sort(),b)A.call(b,g)&&(w=b[g],M[g]=w);return M},i)A.call(i,g)&&(w=i[g],l[g]=w);l.deepValidation=!0,(null!==e?e:window).Smooth=l}).call(this)},660:function(t,e){var n;void 0===(n=function(t){function e(t,e,n){for(var i=(t.byteLength,0),r=n.length;r>i;i++){var s=n.charCodeAt(i);if(128>s)t.setUint8(e++,s>>>0&127);else if(2048>s)t.setUint8(e++,s>>>6&31|192),t.setUint8(e++,s>>>0&63|128);else if(65536>s)t.setUint8(e++,s>>>12&15|224),t.setUint8(e++,s>>>6&63|128),t.setUint8(e++,s>>>0&63|128);else{if(!(1114112>s))throw new Error("bad codepoint "+s);t.setUint8(e++,s>>>18&7|240),t.setUint8(e++,s>>>12&63|128),t.setUint8(e++,s>>>6&63|128),t.setUint8(e++,s>>>0&63|128)}}}function n(t){for(var e=0,n=0,i=t.length;i>n;n++){var r=t.charCodeAt(n);if(128>r)e+=1;else if(2048>r)e+=2;else if(65536>r)e+=3;else{if(!(1114112>r))throw new Error("bad codepoint "+r);e+=4}}return e}function i(t,r,s){var o=typeof t;if("string"===o){if(32>(a=n(t)))return r.setUint8(s,160|a),e(r,s+1,t),1+a;if(256>a)return r.setUint8(s,217),r.setUint8(s+1,a),e(r,s+2,t),2+a;if(65536>a)return r.setUint8(s,218),r.setUint16(s+1,a),e(r,s+3,t),3+a;if(4294967296>a)return r.setUint8(s,219),r.setUint32(s+1,a),e(r,s+5,t),5+a}if(t instanceof Uint8Array){var a=t.byteLength,l=new Uint8Array(r.buffer);if(256>a)return r.setUint8(s,196),r.setUint8(s+1,a),l.set(t,s+2),2+a;if(65536>a)return r.setUint8(s,197),r.setUint16(s+1,a),l.set(t,s+3),3+a;if(4294967296>a)return r.setUint8(s,198),r.setUint32(s+1,a),l.set(t,s+5),5+a}if("number"===o){if(!isFinite(t))throw new Error("Number not finite: "+t);if(Math.floor(t)!==t)return r.setUint8(s,203),r.setFloat64(s+1,t),9;if(t>=0){if(128>t)return r.setUint8(s,t),1;if(256>t)return r.setUint8(s,204),r.setUint8(s+1,t),2;if(65536>t)return r.setUint8(s,205),r.setUint16(s+1,t),3;if(4294967296>t)return r.setUint8(s,206),r.setUint32(s+1,t),5;throw new Error("Number too big 0x"+t.toString(16))}if(t>=-32)return r.setInt8(s,t),1;if(t>=-128)return r.setUint8(s,208),r.setInt8(s+1,t),2;if(t>=-32768)return r.setUint8(s,209),r.setInt16(s+1,t),3;if(t>=-2147483648)return r.setUint8(s,210),r.setInt32(s+1,t),5;throw new Error("Number too small -0x"+(-t).toString(16).substr(1))}if(null===t)return r.setUint8(s,192),1;if("boolean"===o)return r.setUint8(s,t?195:194),1;if("object"===o){var c=0,h=Array.isArray(t);if(h)a=t.length;else{var u=Object.keys(t);a=u.length}if(16>a?(r.setUint8(s,a|(h?144:128)),c=1):65536>a?(r.setUint8(s,h?220:222),r.setUint16(s+1,a),c=3):4294967296>a&&(r.setUint8(s,h?221:223),r.setUint32(s+1,a),c=5),h)for(var d=0;a>d;d++)c+=i(t[d],r,s+c);else for(d=0;a>d;d++){var p=u[d];c+=i(p,r,s+c),c+=i(t[p],r,s+c)}return c}throw new Error("Unknown type "+o)}function r(t){var e=typeof t;if("string"===e){if(32>(i=n(t)))return 1+i;if(256>i)return 2+i;if(65536>i)return 3+i;if(4294967296>i)return 5+i}if(t instanceof Uint8Array){if(256>(i=t.byteLength))return 2+i;if(65536>i)return 3+i;if(4294967296>i)return 5+i}if("number"===e){if(Math.floor(t)!==t)return 9;if(t>=0){if(128>t)return 1;if(256>t)return 2;if(65536>t)return 3;if(4294967296>t)return 5;throw new Error("Number too big 0x"+t.toString(16))}if(t>=-32)return 1;if(t>=-128)return 2;if(t>=-32768)return 3;if(t>=-2147483648)return 5;throw new Error("Number too small -0x"+t.toString(16).substr(1))}if("boolean"===e||null===t)return 1;if("object"===e){var i,s=0;if(Array.isArray(t)){i=t.length;for(var o=0;i>o;o++)s+=r(t[o])}else{var a=Object.keys(t);for(i=a.length,o=0;i>o;o++){var l=a[o];s+=r(l)+r(t[l])}}if(16>i)return 1+s;if(65536>i)return 3+s;if(4294967296>i)return 5+s;throw new Error("Array or object too long 0x"+i.toString(16))}throw new Error("Unknown type "+e)}function s(t){var e=new ArrayBuffer(r(t));return i(t,new DataView(e),0),new Uint8Array(e)}function o(t,e,n){return e?new t(e.buffer,e.byteOffset,e.byteLength/(n||1)):void 0}function a(t){return o(DataView,t)}function l(t){return o(Uint8Array,t)}function c(t){return o(Int8Array,t)}function h(t){return o(Int32Array,t,4)}function u(t,e){var n=t.length/2;e||(e=new Int16Array(n));for(var i=0,r=0;n>i;++i,r+=2)e[i]=t[r]<<8^t[r+1];return e}function d(t,e){var n=t.length/4;e||(e=new Int32Array(n));for(var i=0,r=0;n>i;++i,r+=4)e[i]=t[r]<<24^t[r+1]<<16^t[r+2]<<8^t[r+3];return e}function p(t,e){var n=t.length;e||(e=new Uint8Array(4*n));for(var i=a(e),r=0;n>r;++r)i.setInt32(4*r,t[r]);return l(e)}function f(t,e,n){var i=t.length,r=1/e;n||(n=new Float32Array(i));for(var s=0;i>s;++s)n[s]=t[s]*r;return n}function m(t,e,n){var i=t.length;n||(n=new Int32Array(i));for(var r=0;i>r;++r)n[r]=Math.round(t[r]*e);return n}function g(t,e){var n,i;if(!e){var r=0;for(n=0,i=t.length;i>n;n+=2)r+=t[n+1];e=new t.constructor(r)}var s=0;for(n=0,i=t.length;i>n;n+=2)for(var o=t[n],a=t[n+1],l=0;a>l;++l)e[s]=o,++s;return e}function _(t){if(0===t.length)return new Int32Array;var e,n,i=2;for(e=1,n=t.length;n>e;++e)t[e-1]!==t[e]&&(i+=2);var r=new Int32Array(i),s=0,o=1;for(e=1,n=t.length;n>e;++e)t[e-1]!==t[e]?(r[s]=t[e-1],r[s+1]=o,o=1,s+=2):++o;return r[s]=t[t.length-1],r[s+1]=o,r}function y(t,e){var n=t.length;e||(e=new t.constructor(n)),n&&(e[0]=t[0]);for(var i=1;n>i;++i)e[i]=t[i]+e[i-1];return e}function v(t,e){var n=t.length;e||(e=new t.constructor(n)),e[0]=t[0];for(var i=1;n>i;++i)e[i]=t[i]-t[i-1];return e}function x(t,e){var n,i,r=t instanceof Int8Array?127:32767,s=-r-1,o=t.length;if(!e){var a=0;for(n=0;o>n;++n)t[n]<r&&t[n]>s&&++a;e=new Int32Array(a)}for(n=0,i=0;o>n;){for(var l=0;t[n]===r||t[n]===s;)l+=t[n],++n;l+=t[n],++n,e[i]=l,++i}return e}function S(t,e,n){return f(x(t,h(n)),e,n)}function b(t,e,n){var i=x(t,h(n));return function(t,e,n){return f(y(t,h(n)),e,n)}(i,e,function(t){return o(Float32Array,t,4)}(i))}function M(t,e,n){return function(t,e){var n,i=e?127:32767,r=-i-1,s=t.length,o=0;for(n=0;s>n;++n)0===(c=t[n])?++o:o+=c===i||c===r?2:c>0?Math.ceil(c/i):Math.ceil(c/r);var a=e?new Int8Array(o):new Int16Array(o),l=0;for(n=0;s>n;++n){var c;if((c=t[n])>=0)for(;c>=i;)a[l]=i,++l,c-=i;else for(;r>=c;)a[l]=r,++l,c-=r;a[l]=c,++l}return a}(function(t,e,n){return v(m(t,e),n)}(t,e),n)}function w(t,e,n,i){var r=new ArrayBuffer(12+i.byteLength),s=new Uint8Array(r),o=new DataView(r);return o.setInt32(0,t),o.setInt32(4,e),n&&s.set(n,8),s.set(i,12),s}function E(t){return w(2,t.length,void 0,l(t))}function T(t){return w(4,t.length,void 0,p(t))}function A(t,e){return w(5,t.length/e,p([e]),l(t))}function C(t){return w(6,t.length,void 0,p(_(t)))}function R(t){return w(8,t.length,void 0,p(function(t){return _(v(t))}(t)))}function P(t,e){return w(9,t.length,p([e]),p(function(t,e){return _(m(t,e))}(t,e)))}function L(t,e){return w(10,t.length,p([e]),function(t,e){var n=t.length;e||(e=new Uint8Array(2*n));for(var i=a(e),r=0;n>r;++r)i.setInt16(2*r,t[r]);return l(e)}(M(t,e)))}function I(t){var e={};return z.forEach(function(n){void 0!==t[n]&&(e[n]=t[n])}),t.bondAtomList&&(e.bondAtomList=T(t.bondAtomList)),t.bondOrderList&&(e.bondOrderList=E(t.bondOrderList)),e.xCoordList=L(t.xCoordList,1e3),e.yCoordList=L(t.yCoordList,1e3),e.zCoordList=L(t.zCoordList,1e3),t.bFactorList&&(e.bFactorList=L(t.bFactorList,100)),t.atomIdList&&(e.atomIdList=R(t.atomIdList)),t.altLocList&&(e.altLocList=C(t.altLocList)),t.occupancyList&&(e.occupancyList=P(t.occupancyList,100)),e.groupIdList=R(t.groupIdList),e.groupTypeList=T(t.groupTypeList),t.secStructList&&(e.secStructList=E(t.secStructList)),t.insCodeList&&(e.insCodeList=C(t.insCodeList)),t.sequenceIndexList&&(e.sequenceIndexList=R(t.sequenceIndexList)),e.chainIdList=A(t.chainIdList,4),t.chainNameList&&(e.chainNameList=A(t.chainNameList,4)),e}function N(t){function e(t){for(var e={},n=0;t>n;n++)e[s()]=s();return e}function n(e){var n=t.subarray(o,o+e);return o+=e,n}function i(e){var n=t.subarray(o,o+e);o+=e;var i=65535;if(e>i){for(var r=[],s=0;s<n.length;s+=i)r.push(String.fromCharCode.apply(null,n.subarray(s,s+i)));return r.join("")}return String.fromCharCode.apply(null,n)}function r(t){for(var e=new Array(t),n=0;t>n;n++)e[n]=s();return e}function s(){var s,l,c=t[o];if(!(128&c))return o++,c;if(128==(240&c))return o++,e(l=15&c);if(144==(240&c))return o++,r(l=15&c);if(160==(224&c))return o++,i(l=31&c);if(!(224&~c))return s=a.getInt8(o),o++,s;switch(c){case 192:return o++,null;case 194:return o++,!1;case 195:return o++,!0;case 196:return l=a.getUint8(o+1),o+=2,n(l);case 197:return l=a.getUint16(o+1),o+=3,n(l);case 198:return l=a.getUint32(o+1),o+=5,n(l);case 202:return s=a.getFloat32(o+1),o+=5,s;case 203:return s=a.getFloat64(o+1),o+=9,s;case 204:return s=t[o+1],o+=2,s;case 205:return s=a.getUint16(o+1),o+=3,s;case 206:return s=a.getUint32(o+1),o+=5,s;case 208:return s=a.getInt8(o+1),o+=2,s;case 209:return s=a.getInt16(o+1),o+=3,s;case 210:return s=a.getInt32(o+1),o+=5,s;case 217:return l=a.getUint8(o+1),o+=2,i(l);case 218:return l=a.getUint16(o+1),o+=3,i(l);case 219:return l=a.getUint32(o+1),o+=5,i(l);case 220:return l=a.getUint16(o+1),o+=3,r(l);case 221:return l=a.getUint32(o+1),o+=5,r(l);case 222:return l=a.getUint16(o+1),o+=3,e(l);case 223:return l=a.getUint32(o+1),o+=5,e(l)}throw new Error("Unknown type 0x"+c.toString(16))}var o=0,a=new DataView(t.buffer);return s()}function D(t,e,n,i){switch(t){case 1:return function(t,e){var n=t.length;e||(e=new Float32Array(n/4));for(var i=a(e),r=a(t),s=0,o=0,l=n/4;l>s;++s,o+=4)i.setFloat32(o,r.getFloat32(o),!0);return e}(e);case 2:return c(e);case 3:return u(e);case 4:return d(e);case 5:return l(e);case 6:return g(d(e),new Uint8Array(n));case 7:return g(d(e));case 8:return function(t,e){return y(g(t),e)}(d(e));case 9:return function(t,e,n){return f(g(t,h(n)),e,n)}(d(e),d(i)[0]);case 10:return b(u(e),d(i)[0]);case 11:return f(u(e),d(i)[0]);case 12:return S(u(e),d(i)[0]);case 13:return S(c(e),d(i)[0]);case 14:return x(u(e));case 15:return x(c(e))}}function O(t,e){var n=(e=e||{}).ignoreFields,i={};return V.forEach(function(e){var r=!!n&&-1!==n.indexOf(e),s=t[e];r||void 0===s||(s instanceof Uint8Array?i[e]=D.apply(null,function(t){var e=a(t),n=e.getInt32(0),i=e.getInt32(4),r=t.subarray(8,12);return[n,t=t.subarray(12),i,r]}(s)):i[e]=s)}),i}function U(t){return String.fromCharCode.apply(null,t).replace(/\0/g,"")}function F(t,e){return t instanceof ArrayBuffer&&(t=new Uint8Array(t)),O(t instanceof Uint8Array?N(t):t,e)}function B(t,e,n,i){var r=new XMLHttpRequest;r.addEventListener("load",function(){try{var t=F(r.response);n(t)}catch(t){i(t)}},!0),r.addEventListener("error",i,!0),r.responseType="arraybuffer",r.open("GET",e+t.toUpperCase()),r.send()}var z=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],V=z.concat(["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"]),k="//mmtf.rcsb.org/v1.0/",G=k+"full/",H=k+"reduced/";t.encode=function(t){return s(I(t))},t.decode=F,t.traverse=function(t,e,n){var i,r,s,o,a,l,c=(n=n||{}).firstModelOnly,h=e.onModel,u=e.onChain,d=e.onGroup,p=e.onAtom,f=e.onBond,m=0,g=0,_=0,y=0,v=0,x=-1,S=t.chainNameList,b=t.secStructList,M=t.insCodeList,w=t.sequenceIndexList,E=t.atomIdList,T=t.bFactorList,A=t.altLocList,C=t.occupancyList,R=t.bondAtomList,P=t.bondOrderList;for(i=0,r=t.chainsPerModel.length;r>i&&!(c&&m>0);++i){var L=t.chainsPerModel[m];for(h&&h({chainCount:L,modelIndex:m}),s=0;L>s;++s){var I=t.groupsPerChain[g];if(u){var N=U(t.chainIdList.subarray(4*g,4*g+4)),D=null;S&&(D=U(S.subarray(4*g,4*g+4))),u({groupCount:I,chainIndex:g,modelIndex:m,chainId:N,chainName:D})}for(o=0;I>o;++o){var O=t.groupList[t.groupTypeList[_]],F=O.atomNameList.length;if(d){var B=null;b&&(B=b[_]);var z=null;t.insCodeList&&(z=String.fromCharCode(M[_]));var V=null;w&&(V=w[_]),d({atomCount:F,groupIndex:_,chainIndex:g,modelIndex:m,groupId:t.groupIdList[_],groupType:t.groupTypeList[_],groupName:O.groupName,singleLetterCode:O.singleLetterCode,chemCompType:O.chemCompType,secStruct:B,insCode:z,sequenceIndex:V})}for(a=0;F>a;++a){if(p){var k=null;E&&(k=E[y]);var G=null;T&&(G=T[y]);var H=null;A&&(H=String.fromCharCode(A[y]));var W=null;C&&(W=C[y]),p({atomIndex:y,groupIndex:_,chainIndex:g,modelIndex:m,atomId:k,element:O.elementList[a],atomName:O.atomNameList[a],formalCharge:O.formalChargeList[a],xCoord:t.xCoordList[y],yCoord:t.yCoordList[y],zCoord:t.zCoordList[y],bFactor:G,altLoc:H,occupancy:W})}y+=1}if(f){var j=O.bondAtomList;for(a=0,l=O.bondOrderList.length;l>a;++a)f({atomIndex1:y-F+j[2*a],atomIndex2:y-F+j[2*a+1],bondOrder:O.bondOrderList[a]})}_+=1}g+=1}if(v=x+1,x=y-1,f&&R)for(a=0,l=R.length;l>a;a+=2){var X=R[a],Y=R[a+1];(X>=v&&x>=X||Y>=v&&x>=Y)&&f({atomIndex1:X,atomIndex2:Y,bondOrder:P?P[a/2]:null})}m+=1}},t.fetch=function(t,e,n){B(t,G,e,n)},t.fetchReduced=function(t,e,n){B(t,H,e,n)},t.version="v1.1.0dev",t.fetchUrl=G,t.fetchReducedUrl=H,t.encodeMsgpack=s,t.encodeMmtf=I,t.decodeMsgpack=N,t.decodeMmtf=O}.apply(e,[e]))||(t.exports=n)}},jP={};function XP(t){var e=jP[t];if(void 0!==e)return e.exports;var n=jP[t]={exports:{}};return WP[t].call(n.exports,n,n.exports,XP),n.exports}XP.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return XP.d(e,{a:e}),e},XP.d=(t,e)=>{for(var n in e)XP.o(e,n)&&!XP.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},XP.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var YP={};XP.d(YP,{A:()=>HG});const qP=(ZP={default:()=>_m()},JP={},XP.d(JP,ZP),JP),$P=e;var ZP,JP,KP=function(){return KP=Object.assign||function(t){for(var e,n=1,i=arguments.length;n<i;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t},KP.apply(this,arguments)},QP={lines:12,length:7,width:5,radius:10,scale:1,corners:1,color:"#000",fadeColor:"transparent",animation:"spinner-line-fade-default",rotate:0,direction:1,speed:1,zIndex:2e9,className:"spinner",top:"50%",left:"50%",shadow:"0 0 1px transparent",position:"absolute"},tL=function(){function t(t){void 0===t&&(t={}),this.opts=KP(KP({},QP),t)}return t.prototype.spin=function(t){return this.stop(),this.el=document.createElement("div"),this.el.className=this.opts.className,this.el.setAttribute("role","progressbar"),this.el.style.position=this.opts.position,this.el.style.width="0",this.el.style.zIndex=this.opts.zIndex.toString(),this.el.style.left=this.opts.left,this.el.style.top=this.opts.top,this.el.style.transform="scale(".concat(this.opts.scale,")"),t&&t.insertBefore(this.el,t.firstChild||null),function(t,e){var n=Math.round(e.corners*e.width*500)/1e3+"px",i="none";!0===e.shadow?i="0 2px 4px #000":"string"==typeof e.shadow&&(i=e.shadow);for(var r=function(t){for(var e=/^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/,n=[],i=0,r=t.split(",");i<r.length;i++){var s=r[i].match(e);if(null!==s){var o=+s[2],a=+s[5],l=s[4],c=s[7];0!==o||l||(l=c),0!==a||c||(c=l),l===c&&n.push({prefix:s[1]||"",x:o,y:a,xUnits:l,yUnits:c,end:s[8]})}}return n}(i),s=0;s<e.lines;s++){var o=~~(360/e.lines*s+e.rotate),a=document.createElement("div");a.style.position="absolute",a.style.top="".concat(-e.width/2,"px"),a.style.width=e.length+e.width+"px",a.style.height=e.width+"px",a.style.background=eL(e.fadeColor,s),a.style.borderRadius=n,a.style.transformOrigin="left",a.style.transform="rotate(".concat(o,"deg) translateX(").concat(e.radius,"px)");var l=s*e.direction/e.lines/e.speed;l-=1/e.speed;var c=document.createElement("div");c.style.width="100%",c.style.height="100%",c.style.background=eL(e.color,s),c.style.borderRadius=n,c.style.boxShadow=nL(r,o),c.style.animation="".concat(1/e.speed,"s linear ").concat(l,"s infinite ").concat(e.animation),a.appendChild(c),t.appendChild(a)}}(this.el,this.opts),this},t.prototype.stop=function(){return this.el&&(this.el.parentNode&&this.el.parentNode.removeChild(this.el),this.el=void 0),this},t}();function eL(t,e){return"string"==typeof t?t:t[e%t.length]}function nL(t,e){for(var n=[],i=0,r=t;i<r.length;i++){var s=r[i],o=iL(s.x,s.y,e);n.push(s.prefix+o[0]+s.xUnits+" "+o[1]+s.yUnits+s.end)}return n.join(", ")}function iL(t,e,n){var i=n*Math.PI/180,r=Math.sin(i),s=Math.cos(i);return[Math.round(1e3*(t*s+e*r))/1e3,Math.round(1e3*(-t*r+e*s))/1e3]}class rL{constructor(){this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=rL.now(),this.oldTime=this.startTime,this.running=!0}stop(){this.getElapsedTime(),this.running=!1}getElapsedTime(){return this.update(),this.elapsedTime}update(){let t=0;if(this.running){const e=rL.now();t=.001*(e-this.oldTime),this.oldTime=e,this.elapsedTime+=t}return t}}rL.now=function(){const t="undefined"!=typeof window&&window.performance;return t&&t.now?t.now.bind(t):Date.now}();const{now:sL}=rL;function oL(t,e,n){const i=document.createElement(t);return i.id=e,i.style.cssText=n,i}const aL=class{constructor(){this.domElement=oL("div","stats","padding:8px"),this._text=oL("p","fps","margin:0;color:silver;font-size:large"),this.domElement.appendChild(this._text),this._startTime=sL(),this._prevTime=this._startTime,this._deltas=new Array(20),this._index=0,this._total=0,this._count=0}end(){const t=sL(),e=t-this._startTime;return this._count<this._deltas.length?this._count++:this._total-=this._deltas[this._index],this._total+=e,this._deltas[this._index]=e,this._index=(this._index+1)%this._deltas.length,this.ms=this._total/this._count,this.fps=1e3/this.ms,t>this._prevTime+1e3&&(this._text.textContent=this.fps.toPrecision(2),this._prevTime=t),t}update(){this._startTime=this.end()}show(t){void 0===t&&(t=!0),this.domElement.style.display=t?"block":"none"}};function lL(t,e){return!t||t===e}function cL(){this._handlers={}}cL.prototype.addEventListener=function(t,e,n){let i=this._handlers[t];i||(this._handlers[t]=[],i=this._handlers[t]);const r=[e,n];void 0===qP.default.find(i,function(t){return t[0]===r[0]&&t[1]===r[1]})&&i.push(r)},cL.prototype.removeEventListener=function(t,e,n){const i=this;qP.default.forEach(i._handlers,(r,s)=>{qP.default.remove(r,r=>lL(t,s)&&lL(e,r[0])&&lL(n,r[1]||i))}),this._handlers=qP.default.omitBy(i._handlers,t=>0===t.length)},cL.prototype.dispatchEvent=function(t){const e=this;qP.default.forEach(this._handlers[t.type],n=>{const i=n[1]||e;n[0].apply(i,[t])})};const hL=cL,uL={debug:0,info:1,report:2,warn:3,error:4};function dL(){hL.call(this),this.console=!1,this._priority=uL.warn}function pL(t){if(!qP.default.isNumber(t))throw new Error("Wrong log level specified!");return t}dL.prototype=Object.create(hL.prototype),dL.prototype.constructor=dL,dL.prototype.instantiate=function(){return new dL},Object.defineProperty(dL.prototype,"level",{get(){return qP.default.findKey(uL,t=>t===this._priority)},set(t){this._priority=pL(uL[t])}}),dL.prototype.levels=function(){return Object.keys(uL)},dL.prototype.message=function(t,e){const n=pL(uL[t]);this._message(n,e)},dL.prototype.debug=function(t){this._message(uL.debug,t)},dL.prototype.info=function(t){this._message(uL.info,t)},dL.prototype.report=function(t){this._message(uL.report,t)},dL.prototype.warn=function(t){this._message(uL.warn,t)},dL.prototype.error=function(t){this._message(uL.error,t)},dL.prototype._message=function(t,e){if(t<this._priority)return;const n=qP.default.findKey(uL,e=>e===t);if(e=String(e),this.console){const t=`miew:${n}: ${e}`;"error"===n?console.error(t):"warn"===n?console.warn(t):console.log(t)}this.dispatchEvent({type:"message",level:n,message:e})};const fL=new dL,mL={DEFAULT:0,SAFARI:1};function gL(t){return decodeURIComponent(t.replace(/\+/g," "))}function _L(t){const e=(t=t||window.location.search).substring(t.indexOf("?")+1),n=/([^&=]+)=?([^&]*)/g,i=[];let r;for(;null!==(r=n.exec(e));)i.push([gL(r[1]),gL(r[2])]);return i}function yL(t){let e=!1;this.enable=function(t){e=t};let n=0;const i=Object.keys(t);function r(t,i){return function(){const r=yL.spaces.substr(0,2*n);e&&fL.debug(`${r+i} {`),n++;for(var s=arguments.length,o=new Array(s),a=0;a<s;a++)o[a]=arguments[a];const l=t.apply(this,o);return n--,e&&fL.debug(`${r}} // ${i}`),l}}for(let e=0,n=i.length;e<n;++e){const n=i[e],s=t[n];s instanceof Function&&"constructor"!==n&&(t[n]=r(s,n))}}yL.spaces="                                                                                          ";class vL extends Error{constructor(t){super(),this.name="OutOfMemoryError",this.message=t}}function xL(t){const e=new Uint8Array(t);let n="";for(let t=0;t<e.byteLength;t++)n+=String.fromCharCode(e[t]);return window.btoa(n)}function SL(t){const e=window.atob(t),n=new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=e[t].charCodeAt(0);return n.buffer}function bL(t){if(qP.default.isPlainObject(t))return!0;const e=t&&Object.getPrototypeOf(t);return!!e&&!e.hasOwnProperty("constructor")&&bL(e)}function ML(t){return t.slice(Math.max(0,t.lastIndexOf("."))||1/0)}function wL(t){const e=t.split(/[:;,]/),n=e.length;return n>=3&&"base64"===e[n-2]?new Blob([SL(e[n-1])]):null}const EL=/^[a-zA-Z0-9_]*$/,TL=['"',"",'"'],AL={browserType:mL,encodeQueryComponent:function(t,e){return encodeURIComponent(t).replace(e,t=>String.fromCharCode(parseInt(t.substr(1),16))).replace(/%20/g,"+")},decodeQueryComponent:gL,getUrlParameters:_L,getUrlParametersAsDict:function(t){const e={},n=_L(t);for(let t=0;t<n.length;++t){const[i,r]=n[t];e[i]=r}return e},resolveURL:function(t){if("undefined"!=typeof URL)try{return"undefined"!=typeof window?new URL(t,window.location).href:new URL(t).href}catch(t){}if("undefined"!=typeof document){const e=document.createElement("a");return e.href=t,e.href}return t},generateRegExp:function(t){const e=[];for(let n=0,i=t.length;n<i;++n)e[e.length]=t[n].charCodeAt(0).toString(16);const n=e.join("|");return new RegExp(`%(?:${n})`,"gi")},createElement:function(t,e,n){const i=document.createElement(t);let r,s;if(e){const t=Object.keys(e);for(r=0,s=t.length;r<s;++r){const n=t[r];i.setAttribute(n,e[n])}}if(n)for(n instanceof Array||(n=[n]),r=0,s=n.length;r<s;++r){const t=n[r];"string"==typeof t?i.appendChild(document.createTextNode(t)):t instanceof HTMLElement&&i.appendChild(t)}return i},deriveClass:function(t,e,n,i){return t.prototype=qP.default.assign(Object.create(e.prototype),{constructor:t},n),i&&qP.default.assign(t,i),t},deriveDeep:function t(e,n){let i,r,s=e;if(e instanceof Array)for(s=new Array(e.length),i=0,r=e.length;i<r;++i)s[i]=t(e[i]);else if(e instanceof Object){s=Object.create(e);const o=Object.keys(e);for(i=0,r=o.length;i<r;++i){const n=o[i],r=e[n],a=t(r);a!==r&&(s[n]=a)}n&&Object.keys(s).length>0&&(s=Object.create(s))}return s},hexColor:function(t){return`#${`0000000${t.toString(16)}`.substr(-6)}`},DebugTracer:yL,OutOfMemoryError:vL,allocateTyped:function(t,e){let n=null;try{n=new t(e)}catch(t){throw t instanceof RangeError?new vL(t.message):t}return n},bytesFromBase64:SL,bytesToBase64:xL,arrayFromBase64:function(t,e){return Array.prototype.slice.call(new e(SL(t)))},arrayToBase64:function(t,e){return xL(new e(t).buffer)},compareOptionsWithDefaults:function(t,e){const n=[];if(e&&t){const i=Object.keys(t);for(let r=0;r<i.length;++r){const s=i[r],o=t[s];o instanceof Object||void 0===e[s]||e[s]===o||n.push(`${s}:${o}`)}if(n.length>0)return`!${n.join()}`}return""},objectsDiff:function t(e,n){const i={};return qP.default.forIn(e,(e,r)=>{const s=n[r];if(bL(e)&&bL(s)){const n=t(e,s);qP.default.isEmpty(n)||(i[r]=n)}else qP.default.isEqual(e,s)||(i[r]=e)}),i},forInRecursive:function(t,e){!function t(n,i){qP.default.forIn(n,(n,r)=>{const s=i+(i.length>0?".":"");n instanceof Object?t(n,s+r):void 0!==n&&e(n,s+r)})}(t,"")},enquoteString:function(t){return qP.default.isString(t)?`"${t.replace(/"/g,'\\"')}"`:t},unquoteString:function(t){if(!qP.default.isString(t))return t;if('"'===t[0]&&'"'===t[t.length-1])return(t=t.slice(1,t.length-1)).replace(/\\"/g,'"');if("'"===t[0]&&"'"===t[t.length-1])return(t=t.slice(1,t.length-1)).replace(/\\'/g,"'");throw new SyntaxError("Incorrect string format, can't unqute it")},getBrowser:function(){return navigator.vendor&&navigator.vendor.indexOf("Apple")>-1&&navigator.userAgent&&-1===navigator.userAgent.indexOf("CriOS")&&-1===navigator.userAgent.indexOf("FxiOS")?mL.SAFARI:mL.DEFAULT},shotOpen:function(t){"undefined"!=typeof window&&window.open().document.write(`<body style="margin:0"><img src="${t}" /></body>`)},shotDownload:function(t,e){if(t&&"data:"===t.substr(0,5))if(e||(e=["screenshot-",+new Date,".png"].join("")),"undefined"!=typeof window&&window.navigator&&window.navigator.msSaveBlob)window.navigator.msSaveBlob(wL(t),e);else if("undefined"!=typeof document){const n=document.createElement("a");n.download=e,n.innerHTML="download",n.href=window.URL.createObjectURL(wL(t)),document.body.appendChild(n),n.click(),document.body.removeChild(n)}},copySubArrays:function(t,e,n,i){for(let r=0,s=n.length;r<s;++r)for(let s=0;s<i;++s)e[r*i+s]=t[n[r]*i+s]},shallowCloneNode:function(t){const e=t.cloneNode(!0);return e.worldPos=t.worldPos,e},correctSelectorIdentifier:function(t){return EL.test(t)?t:(TL[1]=t,TL.join(""))},getFileExtension:ML,splitFileName:function(t){const e=ML(t);return[t.slice(0,t.length-e.length),e]},download:function(t,e,n){const i=new Blob([t]);if(e||(e=["data",+new Date].join("")),e+=n?`.${n}`:i.type||".bin","undefined"!=typeof window&&window.navigator&&window.navigator.msSaveBlob)window.navigator.msSaveBlob(i,e);else if("undefined"!=typeof document){const t=document.createElement("a");t.download=e,t.innerHTML="download",t.href=window.URL.createObjectURL(i),document.body.appendChild(t),t.click(),document.body.removeChild(t)}},concatTypedArraysUnsafe:function(t,e){const n=new t.constructor(t.length+e.length);return n.set(t),n.set(e,t.length),n},mergeTypedArraysUnsafe:function(t){if(t.length<=0)return null;const e=t.reduce((t,e)=>t+e.length,0),n=new t[0].constructor(e);for(let e=0,i=0;e<t.length;e++){const r=t[e].length;n.set(t[e],i),i+=r}return n}};class CL extends hL{constructor(){super(),this._shouldCancel=!1}cancel(){this._shouldCancel=!0,this.dispatchEvent({type:"cancel"})}shouldCancel(){return this._shouldCancel}notify(t){this.dispatchEvent({type:"notification",slaveEvent:t})}}const RL={modes:{BS:{atom:.23,bond:.15,space:.5,multibond:!0,aromrad:.1,showarom:!0,polyComplexity:{poor:3,low:4,medium:6,high:12,ultra:32}},VW:{polyComplexity:{poor:4,low:6,medium:8,high:16,ultra:32}},LN:{multibond:!0,showarom:!0,offsarom:.2,chunkarom:10,atom:.23,lineWidth:2},LC:{bond:.2,space:0,multibond:!0,aromrad:.1,showarom:!0,polyComplexity:{poor:3,low:4,medium:6,high:12,ultra:32}},SA:{zClip:!1,probeRadius:1.5,subset:"",wireframe:!1,polyComplexity:{poor:6,low:8,medium:16,high:30,ultra:60}},SE:{zClip:!1,probeRadius:1.5,subset:"",wireframe:!1,polyComplexity:{poor:6,low:8,medium:16,high:30,ultra:60}},QS:{isoValue:.5,gaussLim:{poor:1.5,low:2,medium:2.5,high:3,ultra:4},scale:1,wireframe:!1,gridSpacing:{poor:2,low:1.5,medium:1,high:.5,ultra:.25},subset:"",zClip:!1},CS:{probeRadius:1.4,isoValue:1.5,wireframe:!1,probePositions:30,polyComplexity:{poor:.5,low:1,medium:1.5,high:1.75,ultra:2},subset:"",zClip:!1},TR:{radius:.3,polyComplexity:{poor:12,low:16,medium:32,high:64,ultra:64}},TU:{radius:.3,heightSegmentsRatio:1.5,tension:-.7,polyComplexity:{poor:4,low:6,medium:10,high:18,ultra:34}},CA:{radius:.3,depth:.25,ss:{helix:{width:1,arrow:2},strand:{width:1,arrow:2}},heightSegmentsRatio:1.5,tension:-.7,polyComplexity:{poor:4,low:6,medium:10,high:18,ultra:34}},TX:{template:"{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}",horizontalAlign:"center",verticalAlign:"middle",dx:0,dy:0,dz:1,fg:"none",bg:"0x202020",showBg:!0},VD:{kSigma:1,kSigmaMed:2,kSigmaMax:4,frame:!0,isoMode:!1,polyComplexity:{poor:2,low:3,medium:4,high:8,ultra:10}}},colorers:{EL:{carbon:-1},UN:{color:16777215},CO:{subset:"charged",color:16711680,baseColor:16777215},CB:{color:9474192,factor:.6},SQ:{gradient:"rainbow"},TM:{gradient:"temp",min:5,max:40},OC:{gradient:"reds"},HY:{gradient:"blue-red"},MO:{gradient:"rainbow"}},antialias:!0,camFov:45,camNear:.5,camFar:100,camDistance:2.5,radiusToFit:1,fogNearFactor:.5,fogFarFactor:1,fogAlpha:1,fogColor:0,fogColorEnable:!1,palette:"JM",resolution:"medium",autoResolution:!1,autoPreset:!0,preset:"default",presets:{default:[{mode:"BS",colorer:"EL",selector:"all",material:"SF"}],empty:[],wire:[{mode:"LN",colorer:"EL",selector:"all",material:"SF"}],small:[{mode:"BS",colorer:"EL",selector:"all",material:"SF"}],macro:[{mode:"CA",colorer:"SS",selector:"not hetatm",material:"SF"},{mode:"BS",colorer:"EL",selector:"hetatm and not water",material:"SF"}]},objects:{line:{color:4294967295,dashSize:.3,gapSize:.05}},bg:{color:2105376,transparent:!1},draft:{clipPlane:!1,clipPlaneFactor:.5,clipPlaneSpeed:3e-5},plugins:{},axes:!0,fog:!0,fps:!0,zSprites:!0,isoSurfaceFakeOpacity:!0,suspendRender:!0,nowater:!1,autobuild:!0,fxaa:!0,outline:{on:!1,color:0,threshold:.1,thickness:1},ao:!1,shadow:{on:!1,type:"random",radius:1},autoRotation:0,maxfps:30,fbxprec:4,autoRotationAxisFixed:!0,zooming:!0,picking:!0,pick:"atom",editing:!1,aromatic:!1,singleUnit:!0,stereo:"NONE",interpolateViews:!0,transparency:"prepass",translationSpeed:2,debug:{example:3.5,text:"hello!",good:!0,ssaoKernelRadius:.7,ssaoFactor:.7,stereoBarrel:.25},use:{multiFile:!1}};function PL(){hL.call(this),this.old=null,this.now={},this._changed={},this.reset()}AL.deriveClass(PL,hL,{defaults:RL,set(t,e){if(qP.default.isString(t))qP.default.get(this.now,t)!==e&&(qP.default.set(this.now,t,e),this._notifyChange(t,e));else{const e=AL.objectsDiff(t,this.now);qP.default.isEmpty(e)||(qP.default.merge(this.now,e),this._notifyChanges(e))}},get(t,e){return qP.default.get(this.now,t,e)},reset(){const t=AL.objectsDiff(RL,this.now);this.now=qP.default.cloneDeep(RL),this.old=null,this._notifyChanges(t),this._changed={}},checkpoint(){this.old=qP.default.cloneDeep(this.now),this._changed={}},_notifyChange(t,e){this._changed[t]=!0,this.dispatchEvent({type:`change:${t}`,value:e})},_notifyChanges(t){AL.forInRecursive(t,(t,e)=>{this._notifyChange(e,t)})},changed(){if(!this.old)return[];const{old:t,now:e}=this;return qP.default.filter(Object.keys(this._changed),n=>qP.default.get(t,n)!==qP.default.get(e,n))},applyDiffs(t){if(t.hasOwnProperty("VERSION")&&0!==t.VERSION)throw new Error("Settings version does not match!");delete t.VERSION,this.reset(),this.set(t)},getDiffs(t){const e=AL.objectsDiff(this.now,RL);return t&&(e.VERSION=0),e},setPluginOpts(t,e){RL.plugins[t]=qP.default.cloneDeep(e),this.now.plugins[t]=qP.default.cloneDeep(e)}});const LL=new PL;let IL=0;function NL(t){return!(!t||"0"===t||qP.default.isString(t)&&"false"===t.toLowerCase())}const DL={string:String,number:Number,boolean:NL},OL="$;@/?",UL=AL.generateRegExp(OL+":,");function FL(t){return AL.encodeQueryComponent(t,UL)}const BL=AL.generateRegExp(OL+" ");function zL(t){return AL.encodeQueryComponent(t,BL)}function VL(t){let{reps:e}=t;if(!e){const{presets:n}=LL.now;let i=t.preset||LL.now.preset;e=n[i],e||(fL.warn(`Unknown preset "${i}"`),[i]=Object.keys(n),e=n[i]),t.preset=i,t.reps=AL.deriveDeep(e,!0)}}function kL(t,e,n){VL(t);const i=t.reps[IL];i.hasOwnProperty(e)&&(IL=t.reps.length,t.reps[IL]=AL.deriveDeep(i,!0)),void 0!==n&&(t.reps[IL][e]=n)}function GL(t,e,n){if(t){const i=t.indexOf("!"),r=function(t,e){const n=t.indexOf(",");return n>=0?(e.push(t.substr(n+1).split(",")),t.substr(0,n)):t}(t.substr(0,i>=0?i:void 0),n);if(i>=0){const n=t.substr(i+1).split(",");if(t=r,e){const i=e[t],r=AL.deriveDeep(i,!0);n.forEach(e=>{const n=e.split(":",2),s=decodeURIComponent(n[0]),o=decodeURIComponent(n[1]),a=DL[typeof qP.default.get(i,s)];a?qP.default.set(r,s,a(o)):fL.warn(`Unknown argument "${s}" for option "${t}"`)}),Object.keys(r).length>0&&(t=[t,r])}}else t=r}return t}const HL={l:"load",load:String,t:"type",type:String,v:"view",view:String,u:"unit",unit:Number,menu:NL,o:"object",object(t,e){const n=[];let i=GL(t,LL.defaults.objects,n);Array.isArray(i)||(i=[i]),function(t,e,n){void 0===t._objects&&(t._objects=[]);const[i,r]=n,s={type:i,params:e};void 0!==r&&(s.opts=r),t._objects[t._objects.length]=s}(e,n[0],i)},p:"preset",preset(t,e){e.preset=t,e.reps=null,VL(e)},r:"rep",rep(t,e){VL(e),IL=Number(t),IL=IL<=e.reps.length?IL<0?0:IL:e.reps.length,IL===e.reps.length&&(e.reps[IL]=IL>0?AL.deriveDeep(e.reps[IL-1],!0):AL.deriveDeep(LL.defaults.presets.default[0],!0))},s:"select",select(t,e){kL(e,"selector",t)},m:"mode",mode(t,e){kL(e,"mode",GL(t,LL.defaults.modes))},c:"color",color(t,e){kL(e,"colorer",GL(t,LL.defaults.colorers))},mt:"material",material(t,e){kL(e,"material",GL(t,LL.defaults.materials))},dup(t,e){VL(e);const{reps:n}=e,i=n[IL];IL=n.length,n[IL]=AL.deriveDeep(i,!0)},ar:"autoResolution"};function WL(t){IL=0;const e={};for(let n=0,i=t.length;n<i;++n){const i=t[n];let r=i[0];const s=i[1];let o=HL[r];for(;qP.default.isString(o);)r=o,o=HL[r];if(o){if(qP.default.isFunction(o)){const t=o(s,e);void 0!==t&&(e[r]=t)}}else{const t=DL[typeof qP.default.get(LL.defaults,r)];t?qP.default.set(e,`settings.${r}`,t(s)):fL.warn(`Unknown option "${r}"`)}}return e}function jL(t){const e=[];let n=0;return AL.forInRecursive(t,(t,i)=>{e[n++]=zL(i)+":"+zL(t)}),e.join(",")}function XL(t){return qP.default.isArray(t)?t.length<2?t[0]:`${t[0]}!${jL(t[1])}`:t}function YL(t){if(!t||!t.type)return;let e=t.type;return qP.default.isArray(t.params)&&t.params.length>0&&(e+=`,${t.params.join(",")}`),t.opts&&(e+="!"+jL(t.opts)),e}function qL(t){const e=[];let n=0;return AL.forInRecursive(t,(t,i)=>{e[n++]=`${i}=${AL.enquoteString(t)}`}),e.join(" ")}function $L(t){return qP.default.isArray(t)?t.length<2?t[0]:`${t[0]} ${qL(t[1])}`:t}function ZL(t){if(!t||!t.type)return;let e=t.type;return qP.default.isArray(t.params)&&t.params.length>0&&(e+=` ${t.params.map(AL.enquoteString).join(" ")}`),t.opts&&(e+=` ${qL(t.opts)}`),e}function JL(t,e){const n=[];let i=0;function r(t,e){null!=e&&(n[i++]=t+e)}return qP.default.isEmpty(t)?null:(r("",e),r("s=",AL.enquoteString(t.selector)),r("m=",$L(t.mode)),r("c=",$L(t.colorer)),r("mt=",$L(t.material)),n.join(" "))}const KL={fromURL:function(t){return WL(AL.getUrlParameters(t))},fromAttr:function(t){return WL(AL.getUrlParameters(`?${t||""}`))},adapters:DL,toURL:function(t){const e=[];let n=0;function i(t,i){null!=i&&(e[n++]=FL(t)+"="+FL(i))}i("l",t.load),i("u",t.unit),i("p",t.preset),function(t){if(t)for(let e=0,n=t.length;e<n;++e)qP.default.isEmpty(t[e])||(i("r",e),i("s",t[e].selector),i("m",XL(t[e].mode)),i("c",XL(t[e].colorer)),i("mt",XL(t[e].material)))}(t.reps),function(t){if(t)for(let e=0,n=t.length;e<n;++e)i("o",YL(t[e]))}(t._objects),i("v",t.view),AL.forInRecursive(t.settings,(t,e)=>{"preset"!==e&&i(e,t)});let r="";if("undefined"!=typeof window){const{location:t}=window;r=`${t.protocol}//${t.host}${t.pathname}`}return e.length>0&&(r+=`?${e.join("&")}`),r},toScript:function(t){const e=[];let n=0;function i(t,i,r){if(null!=i){const s="string"==typeof i&&r?'"':"";e[n++]=`${t} ${s}${i}${s}`.trim()}}return i("set","autobuild false"),i("load",t.load,!0),i("unit",t.unit),i("preset",t.preset),function(t){if(t)for(let e=0,n=t.length;e<n;++e)i("rep",JL(t[e],e))}(t.reps),function(t){if(t)for(let e=0,n=t.length;e<n;++e)i("",ZL(t[e]))}(t._objects),AL.forInRecursive(t.settings,(t,e)=>{"preset"!==e&&i(`set ${e}`,t,!0)}),i("view",t.view),i("set","autobuild true"),e.join("\n")}};class QL{constructor(t,e,n,i,r,s,o,a,l,c,h){this.index=-1,this.residue=t,this.name=e,this.element=n,this.position=i,this.role=r,this.mask=1,this.het=s,this.serial=o,this.location=(a||" ").charCodeAt(0),this.occupancy=l||1,this.temperature=c,this.charge=h,this.hydrogenCount=-1,this.radicalCount=0,this.valence=-1,this.bonds=[],this.flags=0,"H"===n.name?this.flags|=QL.Flags.HYDROGEN:"C"===n.name&&(this.flags|=QL.Flags.CARBON)}isHet(){return this.het}isHydrogen(){return 1===this.element.number}getVisualName(){const{name:t}=this;return t.length>0?t:this.element.name.trim()}forEachBond(t){const{bonds:e}=this;for(let n=0,i=e.length;n<i;++n)t(e[n])}getFullName(){let t="";return null!==this.residue&&(null!==this.residue._chain&&(t+=`${this.residue._chain.getName()}.`),t+=`${this.residue._sequence}.`),t+=this.name,t}static Flags={CARBON:1,HYDROGEN:8,NONPOLARH:4104}}const tI=QL;class eI{constructor(t,e,n,i,r,s,o){this.number=t,this.name=e,this.fullName=n,this.weight=i,this.radius=r,this.radiusBonding=s,this.hydrogenValency=o}static Constants={U1:1,Lead:2,U2:3,Wing:4,U18:18};static Role=(()=>({N:eI.Constants.U1,CA:eI.Constants.Lead,C:eI.Constants.U2,O:eI.Constants.Wing,SG:eI.Constants.U18}))();static ByAtomicNumber=(()=>[null,new eI(1,"H","Hydrogen",1.008,1.2,.23,[1]),new eI(2,"HE","Helium",4.003,1.4,.93,[0]),new eI(3,"LI","Lithium",6.941,1.82,.68,[1]),new eI(4,"BE","Beryllium",9.012,1.7,.35,[2]),new eI(5,"B","Boron",10.81,2.08,.83,[3]),new eI(6,"C","Carbon",12.011,1.95,.68,[4]),new eI(7,"N","Nitrogen",14.007,1.85,.68,[3,5]),new eI(8,"O","Oxygen",15.999,1.7,.68,[2,4]),new eI(9,"F","Fluorine",18.998,1.73,.64,[1]),new eI(10,"NE","Neon",20.18,1.54,1.12,[0]),new eI(11,"NA","Sodium",22.99,2.27,.97,[1]),new eI(12,"MG","Magnesium",24.305,1.73,1.1,[2]),new eI(13,"AL","Aluminum",26.981,2.05,1.35,[3]),new eI(14,"SI","Silicon",28.086,2.1,1.2,[4]),new eI(15,"P","Phosphorus",30.974,2.08,.75,[3,5]),new eI(16,"S","Sulfur",32.07,2,1.02,[2,4,6]),new eI(17,"CL","Chlorine",35.453,1.97,.99,[1,3,5,7]),new eI(18,"AR","Argon",39.948,1.88,1.57,[0]),new eI(19,"K","Potassium",39.1,2.75,1.33,[1]),new eI(20,"CA","Calcium",40.08,1.973,.99,[2]),new eI(21,"SC","Scandium",44.956,1.7,1.44,[0]),new eI(22,"TI","Titanium",47.88,1.7,1.47,[0]),new eI(23,"V","Vanadium",50.941,1.7,1.33,[0]),new eI(24,"CR","Chromium",52,1.7,1.35,[0]),new eI(25,"MN","Manganese",54.938,1.7,1.35,[0]),new eI(26,"FE","Iron",55.847,1.7,1.34,[0]),new eI(27,"CO","Cobalt",58.93,1.7,1.33,[0]),new eI(28,"NI","Nickel",58.69,1.63,1.5,[0]),new eI(29,"CU","Copper",63.55,1.4,1.52,[0]),new eI(30,"ZN","Zinc",65.39,1.39,1.45,[0]),new eI(31,"GA","Gallium",69.72,1.87,1.22,[3]),new eI(32,"GE","Germanium",72.61,1.7,1.17,[4]),new eI(33,"AS","Arsenic",74.92,1.85,1.21,[3,5]),new eI(34,"SE","Selenium",78.96,1.9,1.22,[2,4,6]),new eI(35,"BR","Bromine",79.9,2.1,1.21,[1,3,5,7]),new eI(36,"KR","Krypton",83.8,2.02,1.91,[0]),new eI(37,"RB","Rubidium",85.47,1.7,1.47,[1]),new eI(38,"SR","Strontium",87.62,1.7,1.12,[2]),new eI(39,"Y","Yttrium",88.91,1.7,1.78,[0]),new eI(40,"ZR","Zirconium",91.22,1.7,1.56,[0]),new eI(41,"NB","Niobium",92.91,1.7,1.48,[0]),new eI(42,"MO","Molybdenum",95.94,1.7,1.47,[0]),new eI(43,"TC","Technetium",98.91,1.7,1.35,[0]),new eI(44,"RU","Ruthenium",101.07,1.7,1.4,[0]),new eI(45,"RH","Rhodium",102.91,1.7,1.45,[0]),new eI(46,"PD","Palladium",106.42,1.63,1.5,[0]),new eI(47,"AG","Silver",107.87,1.72,1.59,[0]),new eI(48,"CD","Cadmium",112.41,1.58,1.69,[0]),new eI(49,"IN","Indium",114.82,1.93,1.63,[3]),new eI(50,"SN","Tin",118.71,2.17,1.46,[2,4]),new eI(51,"SB","Antimony",121.75,2.2,1.46,[3,5]),new eI(52,"TE","Tellurium",127.6,2.06,1.47,[2,4,6]),new eI(53,"I","Iodine",126.91,2.15,1.4,[1,3,5,7]),new eI(54,"XE","Xenon",131.29,2.16,1.98,[0]),new eI(55,"CS","Cesium",132.91,1.7,1.67,[1]),new eI(56,"BA","Barium",137.33,1.7,1.34,[2]),new eI(57,"LA","Lanthanum",138.91,1.7,1.87,[0]),new eI(58,"CE","Cerium",140.12,1.7,1.83,[0]),new eI(59,"PR","Praseodymium",140.91,1.7,1.82,[0]),new eI(60,"ND","Neodymium",144.24,1.7,1.81,[0]),new eI(61,"PM","Promethium",144.9,1.7,1.8,[0]),new eI(62,"SM","Samarium",150.36,1.7,1.8,[0]),new eI(63,"EU","Europium",151.96,1.7,1.99,[0]),new eI(64,"GD","Gadolinium",157.25,1.7,1.79,[0]),new eI(65,"TB","Terbium",158.93,1.7,1.76,[0]),new eI(66,"DY","Dysprosium",162.5,1.7,1.75,[0]),new eI(67,"HO","Holmium",164.93,1.7,1.74,[0]),new eI(68,"ER","Erbium",167.26,1.7,1.73,[0]),new eI(69,"TM","Thulium",168.93,1.7,1.72,[0]),new eI(70,"YB","Ytterbium",173.04,1.7,1.94,[0]),new eI(71,"LU","Lutetium",174.97,1.7,1.72,[0]),new eI(72,"HF","Hafnium",178.49,1.7,1.57,[0]),new eI(73,"TA","Tantalum",180.95,1.7,1.43,[0]),new eI(74,"W","Tungsten",183.85,1.7,1.37,[0]),new eI(75,"RE","Rhenium",186.21,1.7,1.35,[0]),new eI(76,"OS","Osmium",190.2,1.7,1.37,[0]),new eI(77,"IR","Iridium",192.22,1.7,1.32,[0]),new eI(78,"PT","Platinum",195.08,1.72,1.5,[0]),new eI(79,"AU","Gold",196.97,1.66,1.5,[0]),new eI(80,"HG","Mercury",200.59,1.55,1.7,[0]),new eI(81,"TL","Thallium",204.38,1.96,1.55,[1,3]),new eI(82,"PB","Lead",207.2,2.02,1.54,[2,4]),new eI(83,"BI","Bismuth",208.98,1.7,1.54,[3,5]),new eI(84,"PO","Polonium",210,1.7,1.68,[2,4,6]),new eI(85,"AT","Astatine",210,1.7,1.7,[1,3,5,7]),new eI(86,"RN","Radon",222,1.7,2.4,[0]),new eI(87,"FR","Francium",223,1.7,2,[1]),new eI(88,"RA","Radium",226.03,1.7,1.9,[2]),new eI(89,"AC","Actinium",227.03,1.7,1.88,[0]),new eI(90,"TH","Thorium",232.04,1.7,1.79,[0]),new eI(91,"PA","Protactinium",231.04,1.7,1.61,[0]),new eI(92,"U","Uranium",238.03,1.86,1.58,[0]),new eI(93,"NP","Neptunium",237.05,1.7,1.55,[0]),new eI(94,"PU","Plutonium",239.1,1.7,1.53,[0]),new eI(95,"AM","Americium",243.1,1.7,1.51,[0]),new eI(96,"CM","Curium",247.1,1.7,1.5,[0]),new eI(97,"BK","Berkelium",247.1,1.7,1.5,[0]),new eI(98,"CF","Californium",252.1,1.7,1.5,[0]),new eI(99,"ES","Einsteinium",252.1,1.7,1.5,[0]),new eI(100,"FM","Fermium",257.1,1.7,1.5,[0]),new eI(101,"MD","Mendelevium",256.1,1.7,1.5,[0]),new eI(102,"NO","Nobelium",259.1,1.7,1.5,[0]),new eI(103,"LR","Lawrencium",260.1,1.7,1.5,[0]),new eI(104,"RF","Rutherfordium",261,1.7,1.6,[0]),new eI(105,"DB","Dubnium",262,1.7,1.6,[0]),new eI(106,"SG","Seaborgium",263,1.7,1.6,[0]),new eI(107,"BH","Bohrium",262,1.7,1.6,[0]),new eI(108,"HS","Hassium",265,1.7,1.6,[0]),new eI(109,"MT","Meitnerium",268,1.7,1.6,[0])])();static ByName=(()=>({D:new eI(1,"D","Deuterium",2.014,1.2,.23,[1]),T:new eI(1,"T","Tritium",3.016,1.2,.23,[1])}))()}!function(){const t=eI.ByAtomicNumber,e=eI.ByName;for(let n=0,i=t.length;n<i;++n){const i=t[n];i&&(e[i.name]=i)}}(),eI.getByName=function(t){let e=eI.ByName[t];return e||(e=eI.ByName[t]=new eI(0,t,"Unknown",0,1,.01,[0])),e};const nI=eI,iI={UNKNOWN:0,COVALENT:1,AROMATIC:2};function rI(t){return t.position}class sI{constructor(t,e,n,i,r){if(this._left=t,this._right=e,this._fixed=r,this._index=-1,t>e)throw new Error("In a bond atom indices must be in increasing order");this._order=n,this._type=i}getLeft(){return this._left}getRight(){return this._right}getOrder(){return this._order}calcLength(){return this._left.position.distanceTo(this._right.position)}_forEachNeighbour(t,e){const{bonds:n}=t;for(let i=0,r=n.length;i<r;++i)e(n[i]._left!==t?n[i]._left:n[i]._right)}forEachLevelOne(t){const e=this._left,n=this._right;this._forEachNeighbour(e,e=>{e!==n&&t(e)}),this._forEachNeighbour(n,n=>{n!==e&&t(n)})}forEachLevelTwo(t){const e=this._left,n=this._right,i=this;i._forEachNeighbour(e,r=>{r!==n&&i._forEachNeighbour(r,n=>{n!==e&&t(n)})}),i._forEachNeighbour(n,r=>{r!==e&&i._forEachNeighbour(r,e=>{e!==n&&t(e)})})}_fixDir(t,e,n){let i=0,r=0;const s=t.clone();function o(o){s.copy(n(o)),s.sub(t),e.dot(s)>0?++i:++r}function a(t){"C"===t.element.name&&o(t)}const l=[[this.forEachLevelOne,a],[this.forEachLevelOne,o],[this.forEachLevelTwo,a],[this.forEachLevelTwo,o]];for(let t=0;t<l.length;++t){if(l[t][0].call(this,l[t][1]),r>i)return e.multiplyScalar(-1);if(r<i)return e}return e}calcNormalDir(t){const e=this._left,n=this._right;let i=e,r=n;t=void 0===t?rI:t,e.bonds.length>n.bonds.length&&(i=n,r=e);let s=i,o=0;const{bonds:a}=r;for(let t=0,e=a.length;t<e;++t){let e=a[t]._left;a[t]._left===r&&(e=a[t]._right),e.bonds.length>o&&e!==i&&(s=e,o=e.bonds.length)}const l=t(r),c=t(i).clone().sub(l),h=t(s).clone().sub(l);return h.crossVectors(c,h),h.lengthSq()<1e-4&&h.set(0,1,0),c.normalize(),h.normalize(),c.crossVectors(h,c),c.lengthSq()<1e-4&&c.set(0,1,0),c.normalize(),this._fixDir(l,c,t)}static BondType=(()=>iI)()}sI.prototype.BondType=iI;const oI=sI,aI=["C3'","C3*","P","H5T","H3T"],lI=["OP1","O1P"],cI=["OP2","O2P"],hI=["C3'","C3*","C1","C1'","C1*","P"],uI=[{types:["A","DA","G","DG"],atoms:["N1"]},{types:["C","DC"],atoms:["N3"]},{types:["T","DT","U","DU"],atoms:["O4"]}],dI=class{constructor(t,e,n,i){this._chain=t,this._component=null,this._type=e,this._sequence=n,this._icode=i,this._mask=1,this._index=-1,this._atoms=[],this._secondary=null,this._firstAtom=null,this._leadAtom=null,this._wingAtom=null,this._lastAtom=null,this._controlPoint=null,this._midPoint=null,this._wingVector=null,this._cylinders=null,this._isValid=!0,this._het=!1,this._molecule=null,this.temperature=null,this.occupancy=null}getChain(){return this._chain}getMolecule(){return this._molecule}getType(){return this._type}getSequence(){return this._sequence}getSecondary(){return this._secondary}getICode(){return this._icode}addAtom(t,e,n,i,r,s,o,a,l,c){const h=new tI(this,t,e,n,i,r,s,o,a,l,c);return this._chain.getComplex().addAtom(h),this._atoms.push(h),this._het=this._het||r,h}getAtomCount(){return this._atoms.length}forEachAtom(t){const e=this._atoms;for(let n=0,i=e.length;n<i&&!t(e[n]);++n);}_findAtomByName(t){let e=null;return this.forEachAtom(n=>n.name===t&&(e=n,!0)),e}_findFirstAtomInList(t){let e=null;for(let n=0;n<t.length;++n)if(e=this._findAtomByName(t[n]),null!==e)return e;return e}collectMask(){let t=4294967295;const e=this._atoms;for(let n=0,i=e.length;n<i;++n)t&=e[n].mask;this._mask=t}getCylinderTargetList(){const t=this._type._name;for(let e=0,n=uI.length;e<n;++e)for(let n=0,i=uI[e].types.length;n<i;++n)if(t===uI[e].types[n])return uI[e].atoms;return null}_detectLeadWing(t,e,n){const i=this._findFirstAtomInList(aI);let r=this._findFirstAtomInList(lI),s=this._findFirstAtomInList(cI);if(null===r&&null!==e&&(r=e._findFirstAtomInList(lI)),null===s&&null!==e&&(s=e._findFirstAtomInList(cI)),null===i||null===r||null===s)return;t._leadAtom=i,t._controlPoint=n(i),t._wingVector=n(s).clone().sub(n(r)),t._isValid=!0;const o=this._findFirstAtomInList(hI),a=this.getCylinderTargetList(),l=null!==a?this._findFirstAtomInList(a):null;null!==o&&null!==l&&(t._cylinders=[n(o),n(l)])}calcWing(t,e,n,i){const r=e.clone().sub(t),s=t.clone().sub(n);return s.crossVectors(r,s),s.crossVectors(r,s).normalize(),null!==i&&i.length()>1e-4&&s.length()>1e-4&&Math.abs(i.angleTo(s))>Math.PI/2&&s.negate(),s}_innerFinalize(t,e,n,i,r,s){const o=null===e,a=s(this._leadAtom),l=new $P.Vector3(a.x,a.y,a.z);if(r)this._detectLeadWing(i,n,s);else{if(o)i._midPoint=s(this._firstAtom).clone();else{const n=e._controlPoint;i._midPoint=n.clone().lerp(l,.5),i._wingVector=this.calcWing(n,l,s(t._wingAtom),e._wingVector)}i._controlPoint=l}}_finalize2(t,e,n){this._innerFinalize(t,t,e,this,n,t=>t.position)}isConnected(t){if(this._chain!==t._chain)return!1;if(this===t)return!0;let e=!1;return this.forEachAtom(n=>{const{bonds:i}=n;for(let n=0,r=i.length;n<r;++n){const r=i[n];if(r._left.residue===t||r._right.residue===t)return e=!0,!0}return!1}),e}_finalize(){const t=this;[this._firstAtom]=this._atoms,this._lastAtom=this._atoms[this._atoms.length-1],this._leadAtom=null,this._wingAtom=null;let e=0,n=0,i=0,r=0;this.forEachAtom(s=>(null===t._leadAtom&&s.role===nI.Constants.Lead&&(t._leadAtom=s),null===t._wingAtom&&s.role===nI.Constants.Wing&&(t._wingAtom=s),s.temperature&&(n+=s.temperature,e++),s.occupancy&&(r+=s.occupancy,i++),null!==t._leadAtom&&null!==t._wingAtom)),e>0&&(this.temperature=n/e),i>0&&(this.occupancy=r/i),null!==this._leadAtom&&null!==this._wingAtom||(this._isValid=!1),null===this._leadAtom&&(this._leadAtom=this._firstAtom),null===this._wingAtom&&(this._wingAtom=this._lastAtom)}};class pI{constructor(t,e,n){this._name=t,this._fullName=e,this.letterCode=n,this.flags=0}getName(){return this._name}static StandardTypes=(()=>({ALA:new pI("ALA","Alanine","A"),ARG:new pI("ARG","Arginine","R"),ASN:new pI("ASN","Asparagine","N"),ASP:new pI("ASP","Aspartic Acid","D"),CYS:new pI("CYS","Cysteine","C"),GLN:new pI("GLN","Glutamine","Q"),GLU:new pI("GLU","Glutamic Acid","E"),GLY:new pI("GLY","Glycine","G"),HIS:new pI("HIS","Histidine","H"),ILE:new pI("ILE","Isoleucine","I"),LEU:new pI("LEU","Leucine","L"),LYS:new pI("LYS","Lysine","K"),MET:new pI("MET","Methionine","M"),PHE:new pI("PHE","Phenylalanine","F"),PRO:new pI("PRO","Proline","P"),PYL:new pI("PYL","Pyrrolysine","O"),SEC:new pI("SEC","Selenocysteine","U"),SER:new pI("SER","Serine","S"),THR:new pI("THR","Threonine","T"),TRP:new pI("TRP","Tryptophan","W"),TYR:new pI("TYR","Tyrosine","Y"),VAL:new pI("VAL","Valine","V"),A:new pI("A","Adenine","A"),C:new pI("C","Cytosine","C"),G:new pI("G","Guanine","G"),I:new pI("I","Inosine","I"),T:new pI("T","Thymine","T"),U:new pI("U","Uracil","U"),DA:new pI("DA","Adenine","A"),DC:new pI("DC","Cytosine","C"),DG:new pI("DG","Guanine","G"),DI:new pI("DI","Inosine","I"),DT:new pI("DT","Thymine","T"),DU:new pI("DU","Uracil","U"),"+A":new pI("+A","Adenine","A"),"+C":new pI("+C","Cytosine","C"),"+G":new pI("+G","Guanine","G"),"+I":new pI("+I","Inosine","I"),"+T":new pI("+T","Thymine","T"),"+U":new pI("+U","Uracil","U"),WAT:new pI("WAT","Water",""),H2O:new pI("H2O","Water",""),HOH:new pI("HOH","Water",""),DOD:new pI("DOD","Water",""),UNK:new pI("UNK","Unknown",""),UNL:new pI("UNL","Unknown Ligand","")}))();static Flags={PROTEIN:1,BASIC:2,ACIDIC:4,POLAR:8,NONPOLAR:16,AROMATIC:32,NUCLEIC:256,PURINE:512,PYRIMIDINE:1024,DNA:2048,RNA:4096,WATER:65536}}function fI(t,e){for(let n=0,i=e.length;n<i;++n){const i=pI.StandardTypes[e[n]];i&&(i.flags|=t)}}const{Flags:mI}=pI;fI(mI.WATER,["WAT","H2O","HOH","DOD"]),fI(mI.PROTEIN,["ALA","ARG","ASN","ASP","CYS","GLY","GLU","GLN","HIS","ILE","LEU","LYS","MET","PHE","PRO","PYL","SEC","SER","THR","TRP","TYR","VAL"]),fI(mI.BASIC,["ARG","HIS","LYS"]),fI(mI.ACIDIC,["ASP","GLU"]),fI(mI.POLAR,["ASN","CYS","GLN","SER","THR","TYR"]),fI(mI.NONPOLAR,["ALA","ILE","LEU","MET","PHE","PRO","TRP","VAL","GLY"]),fI(mI.AROMATIC,["PHE","TRP","TYR"]),fI(mI.NUCLEIC,["A","G","I","DA","DG","DI","+A","+G","+I","C","T","U","DC","DT","DU","+C","+T","+U"]),fI(mI.PURINE,["A","G","I","DA","DG","DI","+A","+G","+I"]),fI(mI.PYRIMIDINE,["C","T","U","DC","DT","DU","+C","+T","+U"]),fI(mI.DNA,["DA","DG","DI","DC","DT","DU"]),fI(mI.RNA,["A","G","I","C","T","U"]),function(t,e){const n=Object.keys(e);for(let t=0,i=n.length;t<i;++t){const i=n[t],r=e[i];pI.StandardTypes[i].hydrophobicity=r}}(0,{ILE:4.5,VAL:4.2,LEU:3.8,PHE:2.8,CYS:2.5,MET:1.9,ALA:1.8,GLY:-.4,THR:-.7,SER:-.8,TRP:-.9,TYR:-1.3,PRO:-1.6,HIS:-3.2,GLU:-3.5,GLN:-3.5,ASP:-3.5,ASN:-3.5,LYS:-3.9,ARG:-4.5});const gI=pI,_I=class{constructor(t,e){this._complex=t,this._name=e,this._mask=1,this._index=-1,this._residues=[],this.minSequence=Number.POSITIVE_INFINITY,this.maxSequence=Number.NEGATIVE_INFINITY}getComplex(){return this._complex}getName(){return this._name}getResidues(){return this._residues}_determineType(){const t=this._residues,{PROTEIN:e,NUCLEIC:n}=gI.Flags;this.type=0;for(let i=0,r=t.length;i<r;++i){const{flags:r}=t[i]._type;if(0!==(r&n)){this.type=2;break}if(0!==(r&e)){this.type=1;break}}}findResidue(t,e){const n=this._residues;for(let i=0,r=n.length;i<r;++i){const r=n[i];if(r._sequence===t&&r._icode===e)return[r,i]}return null}_finalize(){this._determineType();const t=this._residues;let e=null;for(let n=0,i=t.length;n<i;++n){const r=n+1<i?t[n+1]:null,s=t[n];s._finalize2(e,r,2===this.type),e=s}if(t.length>1&&t[1]._wingVector){const e=t[1]._wingVector;t[0]._wingVector=new $P.Vector3(e.x,e.y,e.z)}else t.length>0&&(t[0]._wingVector=new $P.Vector3(1,0,0))}updateToFrame(t){const e=this._residues;let n=null,i=null;const r=t._residues,s=e.length;function o(e){return t.getAtomPos(e.index)}for(let t=0;t<s;++t){const a=e[t],l=r[a._index],c=t+1<s?e[t+1]:null;a._innerFinalize(n,i,c,l,2===this.type,o),n=a,i=l}r[e[0]._index]._wingVector=s>1?r[e[1]._index]._wingVector:new $P.Vector3(1,0,0)}addResidue(t,e,n){let i=this._complex.getResidueType(t);null===i&&(i=this._complex.addResidueType(t));const r=new dI(this,i,e,n);return this._complex.addResidue(r),this._residues.push(r),i.flags&(gI.Flags.NUCLEIC|gI.Flags.PROTEIN)&&(this.maxSequence<e&&(this.maxSequence=e),this.minSequence>e&&(this.minSequence=e)),r}getResidueCount(){return this._residues.length}forEachResidue(t){const e=this._residues;for(let n=0,i=e.length;n<i;++n)t(e[n])}collectMask(){let t=4294967295;const e=this._residues;for(let n=0,i=e.length;n<i;++n)t&=e[n]._mask;this._mask=t}};class yI{constructor(t,e,n){this.type=t,this.generic=yI.genericByType[this.type]||"loop",this.init=e,this.term=n}_finalize(t,e,n){if(this.init instanceof dI&&this.term instanceof dI)return;const i=n.splitUnifiedSerial(this.init),r=n.splitUnifiedSerial(this.term);for(let t=i.chain;t<=r.chain;t++)for(let s=i.serial;s<=r.serial;s++)for(let{iCode:o}=i;o<=r.iCode;o++){const i=n.getUnifiedSerial(t,s,o);e[i]&&(e[i]._secondary=this)}this.init=e[this.init],this.term=e[this.term]}}yI.Type={STRAND:"E",BRIDGE:"B",HELIX_310:"G",HELIX_ALPHA:"H",HELIX_PI:"I",HELIX:"X",TURN_310:"3",TURN_ALPHA:"4",TURN_PI:"5",TURN:"T",BEND:"S",COIL:"C"},yI.Generic={STRAND:"strand",HELIX:"helix",LOOP:"loop"};const vI=yI.Type,xI=yI.Generic;yI.genericByType={[vI.STRAND]:xI.STRAND,[vI.HELIX_310]:xI.HELIX,[vI.HELIX_ALPHA]:xI.HELIX,[vI.HELIX_PI]:xI.HELIX,[vI.HELIX]:xI.HELIX};const SI=yI,bI=SI.Type,MI={1:bI.HELIX_ALPHA,3:bI.HELIX_PI,5:bI.HELIX_310},wI=class extends SI{constructor(t,e,n,i,r,s,o){super(MI[t]||SI.Type.HELIX,e,n),this.serial=i,this.name=r,this.comment=s,this.length=o}},EI=class extends SI{constructor(t,e,n,i,r,s){super(SI.Type.STRAND,e,n),this.sheet=t,this.sense=i,this.atomCur=r,this.atomPrev=s}_finalize(t,e,n){super._finalize(t,e,n);let i=this.atomCur;null===i||Number.isNaN(i)||(this.atomCur=t[i]),i=this.atomPrev,null===i||Number.isNaN(i)||(this.atomPrev=t[i])}},TI=class{constructor(t,e){this._name=t,this._width=e,this._strands=[]}getName(){return this._name}getWidth(){return this._width}addStrand(t){this._strands.push(t),this._width=this._strands.length}addEmptyStrand(){this._strands.push(new EI(null,null,null,null,null,null))}_finalize(t,e,n){const i=this._strands;for(let r=0,s=i.length;r<s;++r)i[r]._finalize(t,e,n);if(this._width||(this._width=i.length),i.length!==this._width)throw new Error(`Sheet ${this._name} is inconsistent.`)}};var AI=XP(99);class CI{constructor(t){if(t instanceof this.constructor)return t;this._values=t instanceof Array?t.slice(0):t?[t]:[]}append(t){const e=this._values;return e[e.length]=t,this}remove(t){const e=this._values,n=e.indexOf(t);return n>=0&&e.splice(n,1),this}toString(){return this._values.join(",")}toJSON(){const t=this._values,e=[];for(let n=0,i=t.length;n<i;++n){const i=t[n];e[n]=i.toJSON?i.toJSON():i}return e}}class RI extends CI{includes(t){const e=this._values;for(let n=0,i=e.length;n<i;++n)if(e[n].includes(t))return!0;return!1}}const PI=[];class LI extends CI{constructor(t,e){const n=super(t);if(e){this.upperOnly=!0;const t=n._values;for(let e=0,n=t.length;e<n;++e){const n=t[e];"string"==typeof n&&(t[e]=n.toUpperCase())}}else this.upperOnly=!1;return n}includes(t){return-1!==this._values.indexOf(t)}toString(){const t=this._values;PI.length=0;for(let e=0,n=t.length;e<n;++e)PI[e]=AL.correctSelectorIdentifier(String(t[e]));return PI.join(",")}_validate(t){return this.upperOnly&&"string"==typeof t?t.toUpperCase():t}append(t){return super.append(this._validate(t)),this}remove(t){return super.remove(this._validate(t)),this}}class II{toString(){return this.keyword}toJSON(){return[this.name]}}II.prototype.name="Error",II.prototype.keyword="error";class NI extends II{constructor(t){super(),this.list=t}toString(){return`${this.keyword} ${this.list}`}toJSON(){return[this.name,this.list.toJSON()]}}class DI extends NI{constructor(t){super(new RI(t))}}class OI extends NI{constructor(t,e){super(new LI(t,!e))}}class UI extends II{includesAtom(t){return!1}}UI.prototype.name="None",UI.prototype.keyword="none";class FI extends II{includesAtom(t){return!0}}FI.prototype.name="All",FI.prototype.keyword="all";const BI=new UI;class zI extends II{constructor(t){super(),this.rhs=t||BI}toString(){const t=this.rhs.priority&&this.rhs.priority>this.priority?`(${this.rhs})`:this.rhs;return`${this.keyword} ${t}`}toJSON(){return[this.name,this.rhs.toJSON()]}}zI.prototype.priority=1;class VI extends II{constructor(t,e){super(),this.lhs=t||BI,this.rhs=e||BI}toString(){const t=this.lhs.priority&&this.lhs.priority>this.priority?`(${this.lhs})`:this.lhs,e=this.rhs.priority&&this.rhs.priority>this.priority?`(${this.rhs})`:this.rhs;return`${t} ${this.keyword} ${e}`}toJSON(){return[this.name,this.lhs.toJSON(),this.rhs.toJSON()]}}VI.prototype.priority=1e3;const kI={};function GI(t,e){const n=t.toLowerCase();e.prototype.keyword=n,e.prototype.name=t;const i=function(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return new e(...n)};return i.SelectorClass=e,kI[n]=i,e}GI("Serial",class extends DI{includesAtom(t){return this.list.includes(t.serial)}}),GI("Name",class extends OI{includesAtom(t){return this.list.includes(t.name)}}),GI("AltLoc",class extends OI{includesAtom(t){return this.list.includes(String.fromCharCode(t.location))}}),GI("Elem",class extends OI{includesAtom(t){return this.list.includes(t.element.name)}}),GI("Residue",class extends OI{includesAtom(t){return this.list.includes(t.residue._type._name)}}),GI("Sequence",class extends DI{includesAtom(t){return this.list.includes(t.residue._sequence)}}),GI("ICode",class extends OI{constructor(t){super(t,!0)}includesAtom(t){return this.list.includes(t.residue._icode)}}),GI("ResIdx",class extends DI{includesAtom(t){return this.list.includes(t.residue._index)}}),GI("Chain",class extends OI{constructor(t){super(t,!0)}includesAtom(t){return this.list.includes(t.residue._chain._name)}}),GI("Hetatm",class extends II{includesAtom(t){return t.het}}),GI("PolarH",class extends II{includesAtom(t){return(t.flags&tI.Flags.NONPOLARH)===tI.Flags.HYDROGEN}}),GI("NonPolarH",class extends II{includesAtom(t){return(t.flags&tI.Flags.NONPOLARH)===tI.Flags.NONPOLARH}}),GI("All",FI),GI("None",UI);const HI=kI.none();function WI(t,e,n){return n.prototype.priority=e,GI(t,n)}function jI(t,e){return GI(e,class extends II{includesAtom(e){return 0!==(e.residue._type.flags&t)}})}WI("Not",1,class extends zI{includesAtom(t){return!this.rhs.includesAtom(t)}}),WI("And",2,class extends VI{includesAtom(t){return this.lhs.includesAtom(t)&&this.rhs.includesAtom(t)}}),WI("Or",3,class extends VI{includesAtom(t){return this.lhs.includesAtom(t)||this.rhs.includesAtom(t)}}),jI(gI.Flags.PROTEIN,"Protein"),jI(gI.Flags.BASIC,"Basic"),jI(gI.Flags.ACIDIC,"Acidic"),jI(gI.Flags.BASIC|gI.Flags.ACIDIC,"Charged"),jI(gI.Flags.POLAR,"Polar"),jI(gI.Flags.NONPOLAR,"NonPolar"),jI(gI.Flags.AROMATIC,"Aromatic"),jI(gI.Flags.NUCLEIC,"Nucleic"),jI(gI.Flags.PURINE,"Purine"),jI(gI.Flags.PYRIMIDINE,"Pyrimidine"),jI(gI.Flags.WATER,"Water");const XI=Object.create(kI);XI.Selector=II,XI.RangeListSelector=DI,XI.ValueListSelector=OI,XI.Range=class{constructor(t,e){this.min=t,this.max=void 0===e?t:e}includes(t){return this.min<=t&&t<=this.max}toString(){const{min:t,max:e}=this;return t===e?String(t):[t,e].join(":")}toJSON(){return[this.min,this.max]}},XI.RangeList=RI,XI.ValueList=LI,XI.PrefixOperator=zI,XI.InfixOperator=VI,XI.Context=Object.create({}),XI.GetSelector=function(t){if(!XI.Context.hasOwnProperty(t))throw{message:`selector ${t} is not registered`};return XI.Context[t]||HI},XI.ClearContext=function(){Object.keys(XI.Context).forEach(t=>{delete XI.Context[t]})},XI.keyword=function(t){return kI[t.toLowerCase()]||kI.none},XI.parse=function(t){const e={};try{e.selector=AI.parser.parse(t)}catch(t){e.selector=HI,e.error=t.message}return e},AI.parser.yy=XI,AI.parser.yy.parseError=AI.parser.parseError;const YI=XI,qI=class{constructor(t){this._complex=t,this._selector=YI.keyword("All")(),this._boundaries={boundingBox:new $P.Box3,boundingSphere:new $P.Sphere}}computeBoundaries(){const t=this._complex._atoms,e=t.length,n=this._selector,{boundingBox:i}=this._boundaries;if(i.makeEmpty(),1===e){i.expandByPoint(t[0].position);const e=new $P.Vector3;i.getCenter(e);const n=2*t[0].element.radius;i.setFromCenterAndSize(e,new $P.Vector3(n,n,n))}else for(let r=0;r<e;++r)n.includesAtom(t[r])&&i.expandByPoint(t[r].position);let r=0;const s=new $P.Vector3;if(i.getCenter(s),1===e)this._boundaries.boundingSphere.set(s,t[0].element.radius);else{for(let i=0;i<e;++i){if(!n.includesAtom(t[i]))continue;const e=t[i].position,o=s.distanceToSquared(e);r<o&&(r=o)}this._boundaries.boundingSphere.set(s,Math.sqrt(r))}}getTransforms(){return[]}getSelector(){return this._selector}getBoundaries(){return this._boundaries}finalize(){}},$I=class extends qI{constructor(t){super(t),this.chains=[],this.matrices=[]}computeBoundaries(){super.computeBoundaries();const{matrices:t}=this,e=this._boundaries.boundingSphere.center,n=this._boundaries.boundingSphere.radius,i=this._boundaries.boundingBox=new $P.Box3;i.makeEmpty();for(let n=0,r=t.length;n<r;++n)i.expandByPoint(e.clone().applyMatrix4(t[n]));const r=i.max.distanceTo(i.min)/2+n,s=new $P.Vector3;i.getCenter(s),this._boundaries.boundingSphere=(new $P.Sphere).set(s,r),i.max.addScalar(n),i.min.subScalar(n)}addChain(t){this.chains[this.chains.length]=t}addMatrix(t){this.matrices[this.matrices.length]=t}getTransforms(){return this.matrices}finalize(){this.chains.length>0?this._selector=YI.keyword("Chain")(this.chains):this._selector=YI.keyword("None")()}},ZI=class{constructor(t){this._complex=t,this._index=-1,this._residueIndices=[],this._cycles=[],this._subDivs=[],this._residueCount=0}getResidues(){return this._complex._residues}getResidueCount(){return this._residueCount}forEachResidue(t){const e=this._complex._residues,n=this._residueIndices;for(let i=0,r=n.length;i<r;++i)for(let r=n[i].start,s=n[i].end;r<=s;++r)t(e[r])}setSubDivs(t){this._subDivs=t;let e=0;const n=[];let i=0;for(let r=0,s=t.length;r<s;++r)if(r===s-1||t[r].end+1!==t[r+1].start){const{start:s}=t[e],{end:o}=t[r];n[n.length]={start:s,end:o},i+=o-s+1,e=r+1}this._residueIndices=n,this._residueCount=i}getComplex(){return this._complex}forEachBond(t){const e=this._complex._bonds;for(let n=0,i=e.length;n<i;++n){const i=e[n];i._left.residue._component===this&&t(i)}}update(){this.forEachCycle(t=>{t.update()})}forEachAtom(t){this.forEachResidue(e=>{e.forEachAtom(t)})}addCycle(t){this._cycles.push(t)}forEachCycle(t){const e=this._cycles;for(let n=0,i=e.length;n<i;++n)t(e[n])}markResidues(){const t=this;t.forEachResidue(e=>{e._component=t})}_forEachSubChain(t,e){const n=this._complex._residues,i=this._subDivs;for(let r=0,s=i.length;r<s;++r)for(let s=i[r].start,o=i[r].end;s<=o;++s){const i=n[s];if(t&i._mask&&i._isValid){let i=s+1;for(;i<=o;++i){const e=n[i];if(!(t&e._mask&&e._isValid))break}e(r,s,i-1),s=i}}}getMaskedSequences(t){const e=[];let n=0;return this._forEachSubChain(t,(t,i,r)=>{e[n++]={start:i,end:r}}),e}getMaskedSubdivSequences(t){const e=[];let n=-1,i=-1;const r=this._subDivs;return this._forEachSubChain(t,(t,s,o)=>{i!==t&&(++n,e[n]={arr:[],boundaries:r[t]},i=t),e[n].arr[e[n].arr.length]={start:s,end:o}}),e}},JI=class{constructor(t){this.numPairs=0,this.numMaxPairs=t,this.intBuffer=AL.allocateTyped(Int32Array,4*t);for(let e=0;e<4*t;e++)this.intBuffer[e]=-1;this.hashBuffer=AL.allocateTyped(Int32Array,33554432);for(let t=0;t<33554432;t++)this.hashBuffer[t]=-1}destroy(){this.intBuffer=null,this.hashBuffer=null}addPair(t,e){const n=t<e?t:e,i=t>e?t:e,r=n+(i<<14);let s=32*(n+89237*i&1048575),o=0;for(;o<32;o++){const t=this.hashBuffer[s+o];if(-1===t)break;if(t===r)return!1}if(o>=32)throw new Error("addPair: increase cMaxPairsForHashCode");if(this.hashBuffer[s+o]=r,this.numPairs>=this.numMaxPairs)throw new Error("addPair: increase num pairs");return s=4*this.numPairs,this.intBuffer[s]=n,this.intBuffer[s+1]=i,this.intBuffer[s+2]=r,this.numPairs++,!0}};function KI(t){const{element:e}=t;if(e)return e.radiusBonding;throw new Error("_getBondingRadius: Logic error.")}function QI(t){return!t.isHet()||t.bonds&&0===t.bonds.length}const tN=class{constructor(t){this._complex=t,this._maxRad=1.8;const e=this._complex.getDefaultBoundaries().boundingBox;this._vBoxMin=e.min.clone(),this._vBoxMax=e.max.clone(),this._pairCollection=null}_addExistingPairs(){const t=this._complex.getAtoms(),e=t.length;let n=0;const i=this._pairCollection;for(;n<e;n++){const{bonds:e}=t[n],r=e.length;for(let t=0;t<r;t++){const r=e[t];r._left.index===n&&i.addPair(n,r._right.index)}}return 0}_findPairs(){const t=this._complex.getVoxelWorld();if(null===t)return;const e=this._complex._atoms,n=e.length,i=this;let r,s,o,a,l;const c=function(t){if(s&&t.isHydrogen())return;const e=t.location;if(32!==a&&32!==e&&a!==e)return;const n=o.distanceToSquared(t.position),c=t.element.radiusBonding,h=r+c+.45;n>h*h||n<.001||i._pairCollection.addPair(l.index,t.index)};for(let i=0;i<n;++i)l=e[i],QI(l)&&(r=l.element.radiusBonding,s=l.isHydrogen(),o=l.position,a=l.location,t.forEachAtomWithinRadius(o,2*this._maxRad+.45,c))}_addPairs(){const t=this._complex._atoms;for(let e=0,n=0;e<this._pairCollection.numPairs;e++,n+=4){const e=this._pairCollection.intBuffer[n],i=this._pairCollection.intBuffer[n+1];this._addPair(t[e],t[i])}}_addPair(t,e){const n=t.bonds,i=t.index,r=e.index;for(let t=0,e=n.length;t<e;++t){const e=n[t];if(e._left.index===r||e._right.index===r)return}const s=i<r?t:e,o=i<r?e:t,a=this._complex.addBond(s,o,0,oI.BondType.UNKNOWN,!1);n.push(a),e.bonds.push(a)}build(){this._buildInner()}_buildInner(){const t=this._complex._atoms;if(!(t.length<2)){if(t[0].index<0)throw new Error("AutoBond: Atoms in complex were not indexed.");this._calcBoundingBox(),this._pairCollection=new JI(4*t.length),this._addExistingPairs(),this._findPairs(),this._addPairs()}}_calcBoundingBox(){const t=this._complex._atoms,e=t.length;let n=KI(t[0]);for(let i=1;i<e;++i)n=Math.max(n,KI(t[i]));this._vBoxMax.addScalar(n),this._vBoxMin.addScalar(-n),this._maxRad=1.2*n}destroy(){this._pairCollection&&this._pairCollection.destroy()}},eN=oI.BondType.AROMATIC,nN=[nI.ByName.C.number,nI.ByName.N.number],iN=function(){const t=new $P.Vector3,e=new $P.Vector3,n=new $P.Vector3;return function(i,r){return t.copy(i).normalize(),e.copy(r).normalize(),n.crossVectors(t,e),!(n.length()>.1)&&t.dot(e)>=0}}();function rN(t,e){let n=0;for(;n<t.length&&t[n]<e;)++n;t.splice(n,0,e)}function sN(t,e){return t._left===e?t._right:t._left}function oN(t){t._type=eN}class aN{constructor(t){this.atoms=t,this.update()}update(){const{atoms:t}=this,e=new $P.Vector3,n=t.length;for(let i=0;i<n;++i)e.add(t[i].position);e.multiplyScalar(1/n),this.center=e,this.radius=e.distanceTo(t[0].position.clone().lerp(t[1].position,.5))}forEachBond(t){const{atoms:e}=this,n=e.length;let i,r=e[0];function s(e){e._left!==i&&e._right!==i||t(e)}for(let t=0;t<n;++t)i=e[(t+1)%n],r.forEachBond(s),r=i}}function lN(t){return t._type===eN}function cN(t){if(t.type===eN)return!0;const e=nN.indexOf(t._right.element.number),n=nN.indexOf(t._left.element.number);return-1!==e&&-1!==n}function hN(t){return t.length>3}function uN(t){return console.assert(t.length>2),!0}const dN=class{constructor(t){this._complex=t;const e=new Array(t._bonds.length),n=new Array(t._bonds.length);for(let t=0,i=e.length;t<i;++t)e[t]=[],n[t]=!1;this._bondsData=e,this._bondMarks=n,this._resetCycles()}_resetCycles(){this._cycles=[],this._currIdx=-1}_haveSameCycle(t,e,n){const i=t[e._index],r=t[n._index],s=i.length,o=r.length;let a=0,l=0;for(;a<s&&l<o;){if(i[a]===r[l])return!0;i[a]>r[l]?++l:++a}return!1}_tryBond(t,e,n){const i=[],r=this._bondsData,s=sN(t,e),o=e.position.clone().sub(s.position),a=this._currStart,l=this,c=this._bondMarks;let h=this._checkBond;c[t._index]=!0,h=void 0===h?lN:h,e.forEachBond(s=>{if(!h(s)||s===t||c[s._index]||l._haveSameCycle(r,t,s))return;const u=sN(s,e),d=u.position.clone().sub(e.position),p=u===a?-2:1-function(t,e){const n=t.dot(e)/Math.sqrt(t.lengthSq()*e.lengthSq());return $P.MathUtils.clamp(n,-1,1)}(o,d),f=d.cross(o);if(!iN(f,n))return;let m=0;for(;m<i.length&&i[m].val<p;)++m;i.splice(m,0,{bond:s,val:p,dir:f})});for(let n=0,s=i.length;n<s;++n){const{bond:s}=i[n],o=s._left===e?s._right:s._left;if(o===a)return++this._currIdx,this._cycles.push([e]),c[t._index]=!1,!0;if(this._tryBond(s,o,i[n].dir))return rN(r[s._index],this._currIdx),this._cycles[this._currIdx].push(e),c[t._index]=!1,!0}return c[t._index]=!1,!1}_startCycle(t){this._currStart=t._left,this._tryBond(t,t._right,new $P.Vector3)&&(rN(this._bondsData[t._index],this._currIdx),this._cycles[this._currIdx].push(t._left))}_findLoops(t,e){this._checkBond=t;const n=this._complex,i=this;n.forEachComponent(n=>{i._resetCycles(),n.forEachBond(e=>{t(e)&&i._startCycle(e)});const r=i._cycles;for(let t=0,i=r.length;t<i;++t){const i=r[t];if(!e(i))continue;const s=new aN(i);s.forEachBond(oN),n.addCycle(s)}})}markCycles(){this._findLoops(lN,hN)}detectCycles(){this._findLoops(cN,uN)}};function pN(t,e,n,i){const r=n-t.z,s=i-t.z,o=Math.sqrt(Math.max(e*e-r*r,0)),a=Math.sqrt(Math.max(e*e-s*s,0)),l=Math.min(o,a);let c;return c=n<=t.z&&i>=t.z?e:Math.max(o,a),[l,c]}function fN(t,e,n,i){const r=n-t.y,s=i-t.y,o=Math.sqrt(Math.max(e*e-r*r,0)),a=Math.sqrt(Math.max(e*e-s*s,0)),l=Math.min(o,a);let c;return c=n<=t.y&&i>=t.y?e:Math.max(o,a),[l,c]}class mN{constructor(t,e){this._box=t.clone();const n=new $P.Vector3;t.getSize(n),this._count=n.clone().divide(e).floor().max(new $P.Vector3(1,1,1)),this._last=this._count.clone().subScalar(1),this._cellSize=n.clone().divide(this._count),this._cellInnerR=.5*Math.min(Math.min(this._cellSize.x,this._cellSize.y),this._cellSize.z),this._cellOuterR=.5*Math.sqrt(this._cellSize.dot(this._cellSize));const i=this._count.x*this._count.y*this._count.z;this._voxels=AL.allocateTyped(Int32Array,i);for(let t=0;t<i;++t)this._voxels[t]=-1;this._atoms=[]}addAtoms(t){const e=this;let n=this._atoms.length;this._atoms.length+=2*t.getAtomCount(),t.forEachAtom(t=>{const i=e._findVoxel(t.position);e._atoms[n]=t,e._atoms[n+1]=e._voxels[i],e._voxels[i]=n,n+=2})}static _zero=(()=>new $P.Vector3(0,0,0))();static _voxel=(()=>new $P.Vector3)();_findVoxel(t){const e=mN._zero,n=mN._voxel;return n.copy(t).sub(this._box.min).divide(this._cellSize).floor().clamp(e,this._last),n.x+this._count.x*(n.y+this._count.y*n.z)}_forEachAtomInVoxel(t,e){for(let n=this._voxels[t];n>=0;n=this._atoms[n+1])e(this._atoms[n])}static _xRange=(()=>new $P.Vector2)();static _yRange=(()=>new $P.Vector2)();static _zRange=(()=>new $P.Vector2)();_forEachVoxelWithinRadius(t,e,n){const i=mN._xRange,r=mN._yRange,s=mN._zRange;if(e/this._cellInnerR<10)return void this._forEachVoxelWithinRadiusSimple(t,e,n);let o,a,l,c,h,u,d,p;s.set(t.z-e,t.z+e),s.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0,this._count.z-1);for(let f=s.x;f<=s.y;++f){h=[this._box.min.z+f*this._cellSize.z,this._box.min.z+(f+1)*this._cellSize.z],p=t.z-e<=h[0]&&h[1]<=t.z+e,o=pN(t,e,h[0],h[1]),r.set(t.y-o[1],t.y+o[1]),r.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0,this._count.y-1);for(let e=r.x;e<=r.y;++e){c=[this._box.min.y+e*this._cellSize.y,this._box.min.y+(e+1)*this._cellSize.y],d=t.y-o[0]<=c[0]&&c[1]<=t.y+o[0],a=fN(t,o[1],c[0],c[1]),i.set(t.x-a[1],t.x+a[1]),i.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0,this._count.x-1);for(let{x:r}=i;r<=i.y;++r)l=[this._box.min.x+r*this._cellSize.x,this._box.min.x+(r+1)*this._cellSize.x],u=t.x-a[0]<=l[0]&&l[1]<=t.x+a[0],n(r+this._count.x*(e+this._count.y*f),u&&d&&p)}}}static _vCenter=(()=>new $P.Vector3)();_forEachVoxelWithinRadiusSimple(t,e,n){const i=mN._xRange,r=mN._yRange,s=mN._zRange,o=mN._vCenter,a=(e+this._cellOuterR)*(e+this._cellOuterR);let l=-1;e>this._cellOuterR&&(l=(e-this._cellOuterR)*(e-this._cellOuterR)),i.set(t.x-e,t.x+e),i.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor(),i.x=Math.min(Math.max(i.x,0),this._count.x-1),i.y=Math.min(Math.max(i.y,0),this._count.x-1),r.set(t.y-e,t.y+e),r.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor(),r.x=Math.min(Math.max(r.x,0),this._count.y-1),r.y=Math.min(Math.max(r.y,0),this._count.y-1),s.set(t.z-e,t.z+e),s.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor(),s.x=Math.min(Math.max(s.x,0),this._count.z-1),s.y=Math.min(Math.max(s.y,0),this._count.z-1);for(let e=s.x;e<=s.y;++e){const s=[this._box.min.z+e*this._cellSize.z,this._box.min.z+(e+1)*this._cellSize.z];o.z=.5*(s[0]+s[1]);for(let s=r.x;s<=r.y;++s){const r=[this._box.min.y+s*this._cellSize.y,this._box.min.y+(s+1)*this._cellSize.y];o.y=.5*(r[0]+r[1]);for(let{x:r}=i;r<=i.y;++r){const i=[this._box.min.x+r*this._cellSize.x,this._box.min.x+(r+1)*this._cellSize.x];o.x=.5*(i[0]+i[1]);const c=t.distanceToSquared(o);c<=a&&n(r+this._count.x*(s+this._count.y*e),c<=l)}}}}forEachAtomWithinRadius(t,e,n){const i=this,r=e*e;i._forEachVoxelWithinRadius(t,e,(e,s)=>{s?i._forEachAtomInVoxel(e,n):i._forEachAtomInVoxel(e,e=>{t.distanceToSquared(e.position)<=r&&n(e)})})}forEachAtomWithinDistFromMasked(t,e,n,i){this._forEachAtomWithinDistFromGroup(n=>{t.forEachAtom(t=>{0!==(t.mask&e)&&n(t)})},n,i)}forEachAtomWithinDistFromSelected(t,e,n,i){this._forEachAtomWithinDistFromGroup(n=>{t.forEachAtom(t=>{e.includesAtom(t)&&n(t)})},n,i)}_forEachAtomWithinDistFromGroup(t,e,n){const i=this,r=e*e,s=[],o=[];let a,l=0;t(t=>{i._forEachVoxelWithinRadius(t.position,e,(e,n)=>{n?s[e]=-1:void 0===s[e]?(o.push(t),o.push(-1),s[e]=l,l+=2):-1!==s[e]&&(o.push(t),o.push(s[e]),s[e]=l,l+=2)})});const c=function(t){if(void 0!==s[a])if(l=s[a],-1!==l){for(;l>=0;l=o[l+1])if(t.position.distanceToSquared(o[l].position)<r){n(t);break}}else n(t)};for(a in s)s.hasOwnProperty(a)&&i._forEachAtomInVoxel(a,c)}}const gN=mN,_N=.5,yN=-9.9,vN=-27.888;class xN{constructor(t){this._complex=t,this._hbonds=[],this._complex._residues.length>1e3?this._buildVW():this._build()}isBond(t,e){if(this._hbonds[t]){const[n,i]=this._hbonds[t].acceptor;if(n&&n.residue===e&&n.energy<-.5)return!0;if(i&&i.residue===e&&i.energy<-.5)return!0}return!1}_build(){const t=this;for(let e=0;e<this._complex._residues.length-1;++e){const n=this._complex._residues[e];if(0===(n.getType().flags&gI.Flags.PROTEIN))continue;let i=null;e>0&&this._complex._residues[e-1].getType().flags&gI.Flags.PROTEIN&&n._sequence===this._complex._residues[e-1]._sequence+1&&(i=this._complex._residues[e-1]);for(let r=e+1;r<this._complex._residues.length;++r){const s=this._complex._residues[r];if(0===(s.getType().flags&gI.Flags.PROTEIN))continue;let o=null;this._complex._residues[r-1].getType().flags&gI.Flags.PROTEIN&&s._sequence===this._complex._residues[r-1]._sequence+1&&(o=this._complex._residues[r-1]),t._calcHBondEnergy(i,n,s),r!==e+1&&t._calcHBondEnergy(o,s,n)}}}_buildVW(){const t=this,e=this._complex._residues;let n,i;const r=this._complex.getVoxelWorld();if(null===r)return;const s=new JI(this._complex._residues.length*this._complex._residues.length/2);function o(r){const o=r.residue;if(o._index===n._index)return;if(0===(o.getType().flags&gI.Flags.PROTEIN))return;if(!s.addPair(n._index,o._index))return;let a=o._index>0?e[o._index-1]:null;!a||0!==(a.getType().flags&gI.Flags.PROTEIN)&&o._sequence===a._sequence+1||(a=null),t._calcHBondEnergy(i,n,o),o._index!==n._index+1&&t._calcHBondEnergy(a,o,n)}for(let t=0;t<e.length-1;++t)n=e[t],0!==(n.getType().flags&gI.Flags.PROTEIN)&&(i=t>0?e[t-1]:null,!i||0!==(i.getType().flags&gI.Flags.PROTEIN)&&n._sequence===i._sequence+1||(i=null),r.forEachAtomWithinRadius(this._residueGetCAlpha(n),5,o))}_residueGetCAlpha(t){for(let e=0;e<t._atoms.length;++e){const{name:n}=t._atoms[e];if("CA"===n||"C1"===n)return t._atoms[e].position}return null}_residueGetCO(t){let e=null,n=null;return t.forEachAtom(t=>{"C"===t.name?e=t.position:"O"===t.name&&(n=t.position)}),[e,n]}_residueGetNH(t,e){const[n,i]=this._residueGetCO(t);let r;if(e.forEachAtom(t=>{"N"===t.name&&(r=t.position)}),n&&i&&r){const t=n.clone();return t.sub(i),t.multiplyScalar(1/t.length()),t.add(r),[r,t]}return[null,null]}_calcHBondEnergy(t,e,n){let i=0;if(null===t)return i;if("PRO"!==e.getType().getName()){const[r,s]=this._residueGetNH(t,e),[o,a]=this._residueGetCO(n);if(null===r||null===s||null===o||null===a)return i;const l=s.distanceTo(a),c=s.distanceTo(o),h=r.distanceTo(o),u=r.distanceTo(a);i=l<_N||c<_N||h<_N||u<_N?yN:vN/l-vN/c+vN/h-vN/u,i=Math.round(1e3*i)/1e3,i<yN&&(i=yN)}void 0===this._hbonds[e._index]&&(this._hbonds[e._index]={donor:[],acceptor:[]});const r=this._hbonds[e._index];r.acceptor.length<2&&r.acceptor.push({residue:n._index,energy:i}),r.acceptor.length>1&&(i<r.acceptor[0].energy?(r.acceptor[1].residue=r.acceptor[0].residue,r.acceptor[1].energy=r.acceptor[0].energy,r.acceptor[0].residue=n._index,r.acceptor[0].energy=i):i<r.acceptor[1].energy&&(r.acceptor[1].residue=n._index,r.acceptor[1].energy=i)),void 0===this._hbonds[n._index]&&(this._hbonds[n._index]={donor:[],acceptor:[]});const s=this._hbonds[n._index];return s.donor.length<2&&s.donor.push({residue:e._index,energy:i}),s.donor.length>1&&(i<s.donor[0].energy?(s.donor[1].residue=s.donor[0].residue,s.donor[1].energy=s.donor[0].energy,s.donor[0].residue=e._index,s.donor[0].energy=i):i<s.donor[1].energy&&(s.donor[1].residue=e._index,s.donor[1].energy=i)),i}}const SN=Object.freeze({NO_BRIDGE:0,PARALLEL:1,ANTI_PARALLEL:2}),bN=Object.freeze({START:1,MIDDLE:2,END:3,START_AND_END:4}),MN=Object.freeze({STRAND:"E",BRIDGE:"B",HELIX_310:"G",HELIX_ALPHA:"H",HELIX_PI:"I",TURN:"T",BEND:"S",LOOP:" "});class wN{constructor(t){this._complex=t,this._build()}_build(){const t=this;this._hbonds=new xN(this._complex),this._ss=[],this._sheet=[],this._betaPartners=[],this._bend=[];for(let t=0;t<this._complex.getResidues().length;++t)this._betaPartners[t]=[];this._helixFlags=[],this._helixFlags[3]=[],this._helixFlags[4]=[],this._helixFlags[5]=[],this._chainLengths=[];for(let t=0;t<this._complex._chains.length;++t){const e=this._complex._chains[t].getResidues();let n=0;for(;n<e.length&&0!==(e[n].getType().flags&gI.Flags.PROTEIN);++n);this._chainLengths[t]=n}this._buildBetaSheets();for(let e=0;e<this._complex._chains.length;++e)t._buildAlphaHelices(this._complex._chains[e].getResidues(),this._chainLengths[e],!1)}_buildAlphaHelices(t,e,n){for(let n=3;n<=5&&!(t.length<n);++n)for(let i=0;i+n<e;++i)if(this._hbonds.isBond(t[i+n]._index,t[i]._index)){this._helixFlags[n][t[i+n]._index]=bN.END;for(let e=i+1;e<i+n;++e)void 0===this._helixFlags[n][t[e]._index]&&(this._helixFlags[n][t[e]._index]=bN.MIDDLE);this._helixFlags[n][t[i]._index]===bN.END?this._helixFlags[n][t[i]._index]=bN.START_AND_END:this._helixFlags[n][t[i]._index]=bN.START}for(let n=2;n<e-2;++n){const e=this._kappa(t[n-2],t[n],t[n+2]);this._bend[t[n]._index]=360!==e&&e>70}for(let n=1;n+4<e;++n)if(this._isHelixStart(t[n]._index,4)&&this._isHelixStart(t[n-1]._index,4))for(let e=n;e<=n+3;++e)this._ss[t[e]._index]=MN.HELIX_ALPHA;for(let n=1;n+3<e;++n)if(this._isHelixStart(t[n]._index,3)&&this._isHelixStart(t[n-1]._index,3)){let e=!0;for(let i=n;e&&i<=n+2;++i)e=void 0===this._ss[t[i]._index]||this._ss[t[i]._index]===MN.HELIX_310;if(e)for(let e=n;e<=n+2;++e)this._ss[t[e]._index]=MN.HELIX_310}for(let i=1;i+5<e;++i)if(this._isHelixStart(t[i]._index,5)&&this._isHelixStart(t[i-1]._index,5)){let e=!0;for(let r=i;e&&r<=i+4;++r)e=void 0===this._ss[t[r]._index]||this._ss[t[r]._index]===MN.HELIX_PI||n&&this._ss[t[r]._index]===MN.HELIX_ALPHA;if(e)for(let e=i;e<=i+4;++e)this._ss[t[e]._index]=MN.HELIX_PI}for(let n=1;n+1<e;++n)if(void 0===this._ss[t[n]._index]){let e=!1;for(let i=3;i<=5&&!e;++i)for(let r=1;r<i&&!e;++r)e=n>=r&&this._isHelixStart(t[n-r]._index,i);e?this._ss[t[n]._index]=MN.TURN:this._bend[t[n]._index]&&(this._ss[t[n]._index]=MN.BEND)}}_residueGetCAlpha(t){for(let e=0;e<t._atoms.length;++e){const{name:n}=t._atoms[e];if("CA"===n||"C1"===n)return t._atoms[e].position}return null}_cosinusAngle(t,e,n,i){const r=t.clone().sub(e),s=n.clone().sub(i);let o=0;const a=r.dot(r)*s.dot(s);return a>0&&(o=r.dot(s)/Math.sqrt(a)),o}_kappa(t,e,n){const i=this._residueGetCAlpha(e),r=this._residueGetCAlpha(t),s=this._residueGetCAlpha(n);if(null===i||null===r||null===s)return 180;const o=this._cosinusAngle(i,r,s,i),a=Math.sqrt(1-o*o);return 180*Math.atan2(a,o)/Math.PI}_isHelixStart(t,e){return this._helixFlags[e][t]===bN.START||this._helixFlags[e][t]===bN.START_AND_END}_buildBetaSheets(){const t=[];for(let e=0;e<this._complex._chains.length;++e){const n=this._chainLengths[e];if(n<=4)continue;const i=this._complex._chains[e].getResidues();for(let r=e;r<this._complex._chains.length;++r){const s=this._chainLengths[r];if(s<=4)continue;const o=this._complex._chains[r].getResidues();for(let a=1;a+1<n;++a){const n=i[a];let l=1;for(r===e&&(l=a+3);l+1<s;++l){const e=o[l],r=this._testBridge(i,a,o,l);if(r===SN.NO_BRIDGE)continue;let s=!1;for(const i of t)if(r===i.type&&n._index===i.i[i.i.length-1]+1){if(r===SN.PARALLEL&&i.j[i.j.length-1]+1===e._index){i.i.push(n._index),i.j.push(e._index),s=!0;break}if(r===SN.ANTI_PARALLEL&&i.j[0]-1===e._index){i.i.push(n._index),i.j.unshift(e._index),s=!0;break}}s||t.push({type:r,i:[n._index],chainI:n.getChain()._index,j:[e._index],chainJ:e.getChain()._index})}}}}t.sort((t,e)=>t.chainI<e.chainI||t.chainI===e.chainI&&t.i[0]<e.i[0]?-1:1);for(let e=0;e<t.length;++e)for(let n=e+1;n<t.length;++n){const i=t[e].i[0],r=t[e].i[t[e].i.length-1],s=t[e].j[0],o=t[e].j[t[e].j.length-1],a=t[n].i[0],l=t[n].i[t[n].i.length-1],c=t[n].j[0],h=t[n].j[t[n].j.length-1];if(t[e].type!==t[n].type||this._hasChainBreak(Math.min(i,a),Math.max(r,l))||this._hasChainBreak(Math.min(s,c),Math.max(o,h))||a-r>=6||r>=a&&i<=l)continue;let u=!1;u=t[e].type===SN.PARALLEL?c-o<6&&a-r<3||c-o<3:s-h<6&&a-r<3||s-h<3,u&&(t[e].i=t[e].i.concat(t[n].i),t[e].type===SN.PARALLEL?t[e].j=t[e].j.concat(t[n].j):t[e].j=t[n].j.concat(t[e].j),t.splice(n--,1))}const e=new Set;for(let n=0;n<t.length;++n)e.add(t[n]);let n=1,i=0;for(;e.size>0;){let t=e.values().next().value;e.delete(t);const r=new Set;let s;r.add(t);do{s=new Set;for(const t of r.values())for(const n of e.values())this._areBridgesLinked(t,n)&&s.add(n);for(t of s.values())r.add(t),e.delete(t)}while(s.size>0);for(t of r.values())t.ladder=i,t.sheet=n,t.link=r,++i;++n}for(let e=0;e<t.length;++e){const n=t[e];let i=0,r=0;for(let t=0;t<n.i.length;++t)if(this._betaPartners[n.i[t]][0]){i=1;break}for(let t=0;t<n.j.length;++t)if(this._betaPartners[n.j[t]][0]){r=1;break}let s=MN.BRIDGE;if(n.i.length>1&&(s=MN.STRAND),n.type===SN.PARALLEL){let t=0;for(let e=0;e<n.i.length;++e)this._betaPartners[n.i[e]][i]={residue:n.j[t++],ladder:n.ladder,parallel:!0};t=0;for(let e=0;e<n.j.length;++e)this._betaPartners[n.j[e]][r]={residue:n.i[t++],ladder:n.ladder,parallel:!0}}else{let t=n.j.length-1;for(let e=0;e<n.i.length;++e)this._betaPartners[n.i[e]][i]={residue:n.j[t--],ladder:n.ladder,parallel:!1};t=n.i.length-1;for(let e=0;e<n.j.length;++e)this._betaPartners[n.j[e]][r]={residue:n.i[t--],ladder:n.ladder,parallel:!1}}for(let t=n.i[0];t<=n.i[n.i.length-1];++t)this._ss[t]!==MN.STRAND&&(this._ss[t]=s,this._sheet[t]=n.sheet);for(let t=n.j[0];t<=n.j[n.j.length-1];++t)this._ss[t]!==MN.STRAND&&(this._ss[t]=s,this._sheet[t]=n.sheet)}}_testBridge(t,e,n,i){let r=SN.NO_BRIDGE;const s=t[e-1]._index,o=t[e]._index,a=t[e+1]._index,l=n[i-1]._index,c=n[i]._index,h=n[i+1]._index,u=this._hbonds.isBond.bind(this._hbonds);return u(a,c)&&u(c,s)||u(h,o)&&u(o,l)?r=SN.PARALLEL:(u(a,l)&&u(h,s)||u(c,o)&&u(o,c))&&(r=SN.ANTI_PARALLEL),r}_areBridgesLinked(t,e){const n=new Set(t.i),i=new Set(t.j);for(const t of e.i)if(n.has(t)||i.has(t))return!0;for(const t of e.j)if(n.has(t)||i.has(t))return!0;return!1}_hasChainBreak(t,e){for(let n=t+1;n<=e;++n)if(this._complex._residues[n]._sequence!==this._complex._residues[n-1]._sequence+1)return!0;return!1}}wN.StructureType=MN;const{StructureType:EN}=wN,TN=SI.Type,AN={[EN.HELIX_ALPHA]:1,[EN.HELIX_PI]:3,[EN.HELIX_310]:5},CN={[EN.BRIDGE]:TN.BRIDGE,[EN.TURN]:TN.TURN,[EN.BEND]:TN.BEND,[EN.LOOP]:TN.COIL};class RN{constructor(){this._chains=[],this._components=[],this._helices=[],this._sheets=[],this.structures=[],this._residueTypes=Object.create(gI.StandardTypes),this._atoms=[],this._residues=[],this._bonds=[],this._sgroups=[],this._molecules=[],this._maskNeedsUpdate=!1,this.metadata={},this.symmetry=[],this.units=[new qI(this)],this._currentUnit=0}addAtom(t){const e=this._atoms.length;return this._atoms.push(t),e}addSheet(t){const e=this._sheets.length;return this._sheets.push(t),e}addHelix(t){const e=this._helices.length;return this._helices.push(t),e}getAtoms(){return this._atoms}getBonds(){return this._bonds}getAtomCount(){return this._atoms.length}addResidue(t){const e=this._residues.length;return this._residues.push(t),e}updateToFrame(t){this.forEachChain(e=>{e.updateToFrame(t)})}addResidueType(t){return this._residueTypes[t]=new gI(t,"Unknown","")}getResidueCount(){return this._residues.length}getResidues(){return this._residues}getSGroupCount(){return this._sgroups.length}getSGroups(){return this._sgroups}getAtomByFullname(t){const e=t.split(".");if(3!==e.length)return null;const n=e[0],i=parseInt(e[1],10);if(Number.isNaN(i))return null;const r=e[2].toUpperCase();let s=null;return this.forEachChain(t=>{s||0===t._name.localeCompare(n)&&t.forEachResidue(t=>{s||t._sequence===i&&t.forEachAtom(t=>{s||0===r.localeCompare(t.name)&&(s=t)})})}),s}addChain(t){const e=new _I(this,t);return this._chains.push(e),e}getChain(t){for(let e=0,n=this._chains.length;e<n;++e){const n=this._chains[e];if(n.getName()===t)return n}return null}getChainCount(){return this._chains.length}getMolecules(){return this._molecules}getMoleculeCount(){return this._molecules.length}forEachAtom(t){const e=this._atoms;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachBond(t){const e=this._bonds;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachResidue(t){const e=this._residues;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachChain(t){const e=this._chains;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachMolecule(t){const e=this._molecules,n=e.length;for(let i=0;i<n;++i)t(e[i])}forEachSGroup(t){const e=this._sgroups;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachComponent(t){const e=this._components;for(let n=0,i=e.length;n<i;++n)t(e[n])}forEachVisibleComponent(t){const e=this._components;for(let n=0,i=e.length;n<i;++n)t(e[n])}addBond(t,e,n,i,r){const s=new oI(t,e,n,i,r);return this._bonds.push(s),s}getBondCount(){return this._bonds.length}getResidueType(t){return this._residueTypes[t]||null}getUnifiedSerial(t,e,n){return e+65536*n+16777216*t}splitUnifiedSerial(t){const e=16777216,n=Math.floor(t/e),i=t-n*e,r=Math.floor(i/65536);return{chain:n,serial:i-65536*r,iCode:r}}_fillCmpEdit(){const t=this,e=this._components;function n(){const n=new ZI(t);return n._index=e.length,e[n._index]=n,n}this.forEachChain(t=>{const e=t._residues,i=e.length;if(i<1)return;let r=n(),s=e[0]._index;for(let t=0;t<i;++t){const o=e[t];o._component=r;const a=t===i-1?null:e[t+1];a&&o.isConnected(a)&&o._index===a._index-1||(r.setSubDivs([{start:s,end:o._index}]),a&&(s=a._index,r=n()))}})}_fillCmpNoedit(){const t=new ZI(this);t._index=0;const e=this._residues,n=e.length;if(0===n)return;const i=[];let r=0;for(let s=0;s<n;++s){const o=e[s];o._component=t;const a=s===n-1?null:e[s+1];a&&o.isConnected(a)||(i[i.length]={start:r,end:s},a&&(r=s+1))}t.setSubDivs(i),this._components[t._index]=t}_fillComponents(t){t?this._fillCmpEdit():this._fillCmpNoedit()}getCurrentUnit(){return this._currentUnit}getDefaultBoundaries(){return this.units[0].getBoundaries()}getBoundaries(){return this.units[this._currentUnit].getBoundaries()}getTransforms(){return this.units[this._currentUnit].getTransforms()}getSelector(){return this.units[this._currentUnit].getSelector()}resetCurrentUnit(){this._currentUnit=0,this.setCurrentUnit(1)}setCurrentUnit(t){return null!=t&&t!==this._currentUnit&&t>=0&&t<this.units.length&&(this._currentUnit=t,!0)}_computeBounds(){const{units:t}=this;for(let e=0,n=t.length;e<n;++e)t[e].computeBoundaries()}onAtomPositionChanged(){this.forEachChain(t=>{t._finalize()}),this.forEachComponent(t=>{t.update()}),this._computeBounds(),this._finalizeBonds(),this.forEachSGroup(t=>{t._rebuildSGroupOnAtomChange()})}update(){this._maskNeedsUpdate&&(this.updateStructuresMask(),this._maskNeedsUpdate=!1)}_finalizeBonds(){const t=this.getBonds(),e=t.length;for(let n=0;n<e;++n)t[n]._index=n}finalize(t){t=t||{};const e=this._bonds;let n,i;for(n=e.length-1;n>=0;n--){const t=e[n];null===t._left||null===t._right?e.splice(n,1):(t._left.bonds.push(t),t._right.bonds.push(t))}const r=this._residues;for(n=0,i=r.length;n<i;++n)r[n]._finalize();this.forEachChain(t=>{t._finalize()});const{units:s}=this;for(n=0,i=s.length;n<i;++n)s[n].finalize();this.setCurrentUnit(1);const o={};for(n=0,i=r.length;n<i;++n){const t=r[n];o[this.getUnifiedSerial(t.getChain().getName().charCodeAt(0),t.getSequence(),t.getICode().charCodeAt(0))]=t}const{structures:a}=this;for(n=0,i=a.length;n<i;++n)a[n]._finalize(t.serialAtomMap,o,this);const l=this._helices;for(n=0,i=l.length;n<i;++n)l[n]._finalize(t.serialAtomMap,o,this);const c=this._sheets;for(n=0,i=c.length;n<i;++n)c[n]._finalize(t.serialAtomMap,o,this);this._computeBounds();const h=this._atoms;for(n=0,i=h.length;n<i;++n)h[n].index=n;if(t.needAutoBonding){const t=new tN(this);t.build(),t.destroy()}const u=this._chains;for(n=0,i=u.length;n<i;++n)u[n]._index=n;for(n=0,i=r.length;n<i;++n)r[n]._index=n;for(n=0,i=h.length;n<i;++n){const t=h[n];if(t.flags&tI.Flags.HYDROGEN&&1===t.bonds.length){const e=t.bonds[0];(e._left!==t&&e._left||e._right).flags&tI.Flags.CARBON&&(t.flags|=tI.Flags.NONPOLARH)}}this._finalizeBonds(),this._fillComponents(t.enableEditing);const d=new dN(this);d.markCycles(),t.detectAromaticLoops&&d.detectCycles(),this._finalizeMolecules()}_finalizeMolecules(){for(let t=0;t<this._molecules.length;t++){const e=this._molecules[t],n=e.residues.length;for(let t=0;t<n;t++)e.residues[t]._molecule=e}}updateStructuresMask(){const t=t=>t.collectMask();this.forEachResidue(t),this.forEachChain(t),this.forEachMolecule(t)}countAtomsByMask(t){let e=0;return this.forEachAtom(n=>{0!==(n.mask&t)&&e++}),e}getNumAtomsBySelector(t){let e=0;return this.forEachAtom(n=>{t.includesAtom(n)&&e++}),e}resetAtomMask(t){this.forEachAtom(e=>{e.mask=t})}markAtoms(t,e){const n=e,i=~n;let r=0;const s=YI.keyword("And")(t,this.getSelector());return this.forEachAtom(t=>{s.includesAtom(t)?(t.mask|=n,r++):t.mask&=i}),this._maskNeedsUpdate=!0,r}markAtomsAdditionally(t,e){const n=e;let i=0;return this.forEachAtom(r=>{t.includesAtom(r)&&(r.mask&e)!==e&&(r.mask|=n,i++)}),i}clearAtomBits(t){const e=~t;this.forEachAtom(t=>{t.mask&=e});const n=t=>{t._mask&=e};this.forEachAtom(n),this.forEachResidue(n),this.forEachChain(n),this.forEachMolecule(n)}getAtomNames(){if(this.hasOwnProperty("_atomNames"))return this._atomNames;const t={};return this.forEachAtom(e=>{t[e.name]=1}),this._atomNames=Object.keys(t),this._atomNames}getElements(){if(this.hasOwnProperty("_elements"))return this._elements;const t={};return this.forEachAtom(e=>{t[e.element.name]=1}),this._elements=Object.keys(t),this._elements}getResidueNames(){if(this.hasOwnProperty("_residueNames"))return this._residueNames;const t={};return this.forEachResidue(e=>{t[e._type._name]=1}),this._residueNames=Object.keys(t),this._residueNames}getChainNames(){if(this.hasOwnProperty("_chainNames"))return this._chainNames;const t={};return this.forEachChain(e=>{t[e._name]=1}),this._chainNames=Object.keys(t),this._chainNames}getAltLocNames(){if(this.hasOwnProperty("_altlocNames"))return this._altlocNames;const t={};return this.forEachAtom(e=>{t[String.fromCharCode(e.location)]=1}),this._altlocNames=Object.keys(t),this._altlocNames}getVoxelWorld(){if(!this.hasOwnProperty("_voxelWorld"))try{this._voxelWorld=new gN(this.getDefaultBoundaries().boundingBox,new $P.Vector3(5,5,5)),this._voxelWorld.addAtoms(this)}catch(t){fL.warn("Unable to create voxel world"),this._voxelWorld=null}return this._voxelWorld}addElement(t,e,n,i){const{length:r}=t;for(let s=0;s<r;++s){const r=t[s];i(r,n),e.push(r)}}joinComplexes(t){this._chains=[],this._components=[],this._helices=[],this._sheets=[],this.structures=[],this._atoms=[],this._residues=[],this._bonds=[],this._sgroups=[];const e=this;let n=0,i=0,r=0,s=0,o=0;function a(t,e){t.serial+=e,t.index+=e}function l(t,e){t._index+=e}function c(t,e){t._index+=e}function h(t,n){t._complex=e,t._index+=n}function u(t,n){t._complex=e,t._index+=n}function d(){}for(let e=0;e<t.length;++e){const p=t[e];this.addElement(p._atoms,this._atoms,n,a),this.addElement(p._bonds,this._bonds,i,l),this.addElement(p._residues,this._residues,r,c),this.addElement(p._chains,this._chains,s,h),this.addElement(p._sheets,this._sheets,0,d),this.addElement(p._helices,this._helices,0,d),this.addElement(p._sgroups,this._sgroups,0,d),this.addElement(p._components,this._components,o,u),this.addElement(p.structures,this.structures,0,d);for(const t in p._residueTypes)p._residueTypes.hasOwnProperty(t)&&(this._residueTypes[t]=p._residueTypes[t]);n+=p._atoms.length,i+=p._bonds.length,r+=p._residues.length,s+=p._chains.length,o+=p._components.length}this._computeBounds()}dssp(){const t=new wN(this),e=this.structures=[],n=this._helices=[],i=this._sheets=[],r=t=>{let e=i[t];return e||(e=i[t]=new TI(String(t),0)),e};let s,o,a=0,l=null;for(let i=0,c=this._residues.length;i<c;++i){const c=t._ss[i],h=this._residues[i],u=t._sheet[i];if(c===s&&u===o){h._secondary=l,l&&(l.term=h),l instanceof wI&&l.length++;continue}const d=AN[c],p=CN[c];if(c===EN.STRAND){const t=r(u);l=new EI(t,h,h,0,null,null),t.addStrand(l)}else void 0!==d?(a++,l=new wI(d,h,h,a,String(a),"",1),n.push(l)):l=void 0!==p?new SI(p,h,h):null;l&&e.push(l),h._secondary=l,s=c,o=u}this._sheets=i.filter(t=>!0)}}RN.prototype.id="Complex",RN.prototype.name="";const PN=RN;function LN(t){let e=2;for(t=t-1>>1;t;)e<<=1,t>>=1;return e}class IN{constructor(t,e,n,i,r,s){switch(this._box=n.clone(),this._dimVec=Math.max(Math.floor(i||1),1),this._volumeInfo=s,e instanceof Array?[this._dimX,this._dimY,this._dimZ]=e:(this._dimX=e.x,this._dimY=e.y,this._dimZ=e.z),this._dimX=Math.max(Math.floor(this._dimX),1),this._dimY=Math.max(Math.floor(this._dimY),1),this._dimZ=Math.max(Math.floor(this._dimZ),1),this._rowElements=this._dimVec*this._dimX,this._planeElements=this._rowElements*this._dimY,this._totalElements=this._planeElements*this._dimZ,this._data=r||AL.allocateTyped(t,this._totalElements),this._dimVec){case 1:break;case 2:this.getValue=function(t,e,n){const i=t*this._dimVec+e*this._rowElements+n*this._planeElements;return[this._data[i],this._data[i+1]]},this.setValue=function(t,e,n,i,r){const s=t*this._dimVec+e*this._rowElements+n*this._planeElements;this._data[s]=i,this._data[s+1]=r},this.addValue=function(t,e,n,i,r){const s=t*this._dimVec+e*this._rowElements+n*this._planeElements;this._data[s]+=i,this._data[s+1]+=r};break;case 3:this.getValue=function(t,e,n){const i=t*this._dimVec+e*this._rowElements+n*this._planeElements;return[this._data[i],this._data[i+1],this._data[i+2]]},this.setValue=function(t,e,n,i,r,s){const o=t*this._dimVec+e*this._rowElements+n*this._planeElements;this._data[o]=i,this._data[o+1]=r,this._data[o+2]=s},this.addValue=function(t,e,n,i,r,s){const o=t*this._dimVec+e*this._rowElements+n*this._planeElements;this._data[o]+=i,this._data[o+1]+=r,this._data[o+2]+=s};break;default:throw new Error("Volume: invalid vector dimension")}}getValue(t,e,n){return this._data[t+e*this._rowElements+n*this._planeElements]}setValue(t,e,n,i){this._data[t+e*this._rowElements+n*this._planeElements]=i}addValue(t,e,n,i){this._data[t+e*this._rowElements+n*this._planeElements]+=i}getDimensions(){return[this._dimX,this._dimY,this._dimZ]}getBox(){return this._box}getVolumeInfo(){return this._volumeInfo}getCellSize(){const t=new $P.Vector3;this._box.getSize(t);const e=new $P.Vector3;return e.x=this._dimX>1?t.x/(this._dimX-1):0,e.y=this._dimY>1?t.y/(this._dimY-1):0,e.z=this._dimZ>1?t.z/(this._dimZ-1):0,e}computeGradient(){if(1!==this._dimVec)return null;const t=new IN(Float32Array,[this._dimX,this._dimY,this._dimZ],this._box,3),e=this.getCellSize(),n=new $P.Vector3(-.5/e.x,-.5/e.y,-.5/e.z);function i(t,e,n){return Math.min(n,Math.max(e,t))}const r=this._dimX,s=this._dimY,o=this._dimZ,a=this._data;function l(t,e,n){return a[n*r*s+e*r+t]}for(let e=0;e<o;++e){const a=i(e-1,0,o-1),c=i(e+1,0,o-1);for(let o=0;o<s;++o){const h=i(o-1,0,s-1),u=i(o+1,0,s-1);for(let s=0;s<r;++s){const d=i(s-1,0,r-1),p=i(s+1,0,r-1);t.setValue(s,o,e,(l(p,o,e)-l(d,o,e))*n.x,(l(s,u,e)-l(s,h,e))*n.y,(l(s,o,c)-l(s,o,a))*n.z)}}}return t}normalize(){const t=this._data;let e=t[0],n=t[0];for(let i=1;i<t.length;++i)e=Math.min(e,t[i]),n=Math.max(n,t[i]);const i=1/(n-e);if(0!==i)for(let n=0;n<t.length;++n)t[n]=i*(t[n]-e)}getTiledTextureStride(){return[this._dimX+2,this._dimY+2]}buildTiledTexture(){let t=Math.ceil(Math.sqrt(this._dimZ*this._dimY/this._dimX)),e=t*(this._dimX+2)-1;e=LN(e),t=Math.floor(e/(this._dimX+2));const n=Math.ceil(this._dimZ/t);let i=n*(this._dimY+2)-1;i=LN(i);const r=new Uint8Array(e*i);let s,o;for(let i=0;i<n;++i)for(let n=0;n<this._dimY;++n){s=i*t*this._planeElements+n*this._rowElements,o=e*(i*(this._dimY+2)+n);for(let e=0;e<t;++e){for(let t=0;t<this._dimX;++t)r[o++]=255*this._data[s++];r[o++]=255*this._data[s-1],e<t-1&&(s+=this._planeElements-this._rowElements,r[o++]=255*this._data[s])}}for(let t=0;t<n;++t){s=e*(t*(this._dimY+2)+this._dimY-1),o=s+e;for(let t=0;t<e;++t)r[o++]=r[s++];if(t<n-1){s=e*(t+1)*(this._dimY+2),o=s-e;for(let t=0;t<e;++t)r[o++]=r[s++]}}const a=new $P.DataTexture(r,e,i,$P.LuminanceFormat,$P.UnsignedByteType,$P.UVMapping,$P.ClampToEdgeWrapping,$P.ClampToEdgeWrapping,$P.LinearFilter,$P.LinearFilter);return a.needsUpdate=!0,a}getData(){return this._data}getDirectIdx(t,e,n){return t*this._dimVec+e*this._rowElements+n*this._planeElements}getStrideX(){return this._dimVec}getStrideY(){return this._rowElements}getStrideZ(){return this._planeElements}}IN.prototype.id="Volume";const NN=IN,DN={Atom:tI,Element:nI,Bond:oI,Residue:dI,ResidueType:gI,Chain:_I,Helix:wI,Strand:EI,Sheet:TI,SGroup:class{constructor(t,e,n,i,r){this._id=t,this._name=e,this._position=n||new $P.Vector3,this._atoms=i||[],this._charge=0,this._repeat=1,this._center=null,this.xmlNodeRef=r||null}getName(){return this._name}getPosition(){return this._position}getCentralPoint(){return this._center}_rebuildSGroupOnAtomChange(){const t=1e8;if(null===this._center)return;const e=new $P.Vector3(t,t,t),n=new $P.Vector3(-t,-t,-t);for(let t=0,i=this._atoms.length;t<i;t++){const i=this._atoms[t].position;e.set(Math.min(e.x,i.x),Math.min(e.y,i.y),Math.min(e.z,i.z)),n.set(Math.max(n.x,i.x),Math.max(n.y,i.y),Math.max(n.z,i.z))}this._center.addVectors(e,n),this._center.multiplyScalar(.5)}},Assembly:$I,Complex:PN,Volume:NN,VoxelWorld:gN,selectors:YI,Molecule:class{constructor(t,e,n){this.complex=t,this.name=e||"",this.residues=[],this.mask=1,this.index=n||-1}forEachResidue(t){const{residues:e}=this;for(let n=0,i=e.length;n<i;++n)t(e[n])}collectMask(){let t=4294967295;const{residues:e}=this;for(let n=0,i=e.length;n<i;++n)t&=e[n]._mask;this.mask=t}}};class ON extends $P.Object3D{constructor(t){super();const e=this;this._element=t,this._element.style.position="absolute",this.addEventListener("removed",()=>{null!==e._element.parentNode&&e._element.parentNode.removeChild(e._element)})}getElement(){return this._element}setTransparency(t){const e=this.getElement();if(null===e)return;if(1===t)return void(e.style.display="none");e.style.display="inline";const n=1-t,i=n.toString(),r=100*n;e.style.opacity=i,e.style.filter=`alpha(opacity=${r})`}clone(){const t=new ON(this._element);return t.copy(this),t}}const UN=ON;class FN extends $P.Group{raycast(t,e){if(!this.visible)return;const{children:n}=this;for(let i=0,r=n.length;i<r;++i)n[i].raycast(t,e)}enableSubset(t,e){const{children:n}=this;for(let i=0,r=n.length;i<r;++i)n[i].enableSubset&&n[i].enableSubset(t,e)}disableSubset(t,e){const{children:n}=this;for(let i=0,r=n.length;i<r;++i)n[i].disableSubset&&n[i].disableSubset(t,e)}isEmpty(){return 0===this.children.length}updateToFrame(t){const{children:e}=this;for(let n=0,i=e.length;n<i;++n)e[n].updateToFrame&&e[n].updateToFrame(t)}getSubset(t,e){const n=[],{children:i}=this;for(let r=0,s=i.length;r<s;++r)i[r].getSubset&&Array.prototype.push.apply(n,i[r].getSubset(t,e));return n}}const BN=FN,zN="uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n",VN={DEFAULT:0,VOLUME:1,TRANSPARENT:2,PREPASS_TRANSPARENT:3,VOLUME_BFPLANE:4,COLOR_FROM_POSITION:5,SHADOWMAP:6},kN=[VN.DEFAULT,VN.TRANSPARENT];$P.Object3D.prototype.resetTransform=function(){this.position.set(0,0,0),this.quaternion.set(0,0,0,1),this.scale.set(1,1,1)},$P.Object3D.prototype.updateMatrixWorldRecursive=function(){null!=this.parent&&this.parent.updateMatrixWorldRecursive(),this.updateMatrixWorld()},$P.Object3D.prototype.addSavingWorldTransform=function(){const t=new $P.Matrix4;return function(e){e instanceof $P.Object3D&&(t.copy(this.matrixWorld).invert(),t.multiply(e.matrixWorld),e.matrix.copy(t),e.matrix.decompose(e.position,e.quaternion,e.scale),this.add(e))}}(),$P.WebGLRenderer.prototype.renderDummyQuad=function(){const t=new $P.MeshBasicMaterial({transparent:!0,opacity:0,depthWrite:!1}),e=new $P.Scene,n=new $P.Mesh(new $P.PlaneGeometry(.01,.01),t);e.add(n);const i=new $P.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4);return i.position.z=100,function(){this.render(e,i)}}(),$P.WebGLRenderer.prototype.renderScreenQuad=function(){const t=new $P.Scene,e=new $P.Mesh(new $P.PlaneGeometry(1,1));t.add(e);const n=new $P.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4);return n.position.z=100,function(i){e.material=i,this.render(t,n)}}(),$P.Matrix4.prototype.isIdentity=function(){const t=new $P.Matrix4;return function(){return t.equals(this)}}(),$P.Matrix4.prototype.applyToPointsArray=function(t,e,n){if(!t||!e||e<3)return t;n=n||0;const i=this.elements;for(let r=0;r<t.length;r+=e){const e=t[r],s=t[r+1],o=t[r+2],a=1/(i[3]*e+i[7]*s+i[11]*o+i[15]);t[r]=(i[0]*e+i[4]*s+i[8]*o+i[12]*n)*a,t[r+1]=(i[1]*e+i[5]*s+i[9]*o+i[13]*n)*a,t[r+2]=(i[2]*e+i[6]*s+i[10]*o+i[14]*n)*a}return t};class GN extends $P.RawShaderMaterial{constructor(t){void 0===t.uniforms&&(t.uniforms={}),t.uniforms.srcTex={type:"t",value:null},t.vertexShader=zN,t.transparent=!1,t.depthTest=!1,t.depthWrite=!1,super(t)}}function HN(t){t.traverse(t=>{(t instanceof $P.Mesh||t instanceof $P.LineSegments||t instanceof $P.Line)&&t.geometry.dispose()}),function(t){const{children:e}=t;for(let t=0,n=e.length;t<n;++t){const n=e[t];n.parent=null,n.dispatchEvent({type:"removed"})}t.children=[]}(t)}$P.WebGLRenderer.prototype.renderScreenQuadFromTex=function(){const t=new GN({uniforms:{opacity:{type:"f",value:1}},fragmentShader:"precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n",transparent:!0});return function(e,n){t.uniforms.srcTex.value=e,t.transparent=n<1,t.uniforms.opacity.value=n,this.renderScreenQuad(t)}}(),$P.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion=function(){const t=new GN({uniforms:{coef:{type:"f",value:1}},fragmentShader:"precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n"});return function(e,n){t.uniforms.srcTex.value=e,t.uniforms.coef.value=n,this.renderScreenQuad(t)}}(),$P.PerspectiveCamera.prototype.setMinimalFov=function(t){this.aspect>=1?this.fov=t:this.fov=$P.MathUtils.radToDeg(2*Math.atan(Math.tan(.5*$P.MathUtils.degToRad(t))/this.aspect))},$P.StereoCamera.prototype.updateHalfSized=function(t,e){const n=t.aspect,i=t.fov;t.aspect=n/2,t.setMinimalFov(e),t.updateProjectionMatrix(),this.update(t),t.aspect=n,t.fov=i,t.updateProjectionMatrix()},$P.PerspectiveCamera.prototype.setDistanceToFit=function(t,e){this.position.z=t/Math.sin(.5*$P.MathUtils.degToRad(e))},$P.Raycaster.prototype.intersectVisibleObject=function(t,e,n,i){const r=this.intersectObject(t,!1);if(0===r.length)return null;const s=Math.min(e.near,n);let o,a=r[0];const l=new $P.Vector3;for(o=0;o<r.length&&(a=r[o],l.copy(a.point),l.applyMatrix4(e.matrixWorldInverse),!(l.z<=-s));++o);if(o===r.length)return null;const c=Math.min(e.far,i);return l.copy(a.point),l.applyMatrix4(e.matrixWorldInverse),l.z<=-c?null:a},$P.Matrix4.prototype.extractScale=function(){const t=new $P.Vector3;return function(e){void 0===e&&(fL.debug("extractScale(): new is too expensive operation to do it on-the-fly"),e=t.clone());const n=this.elements;return e.x=t.set(n[0],n[1],n[2]).length(),e.y=t.set(n[4],n[5],n[6]).length(),e.z=t.set(n[8],n[9],n[10]).length(),this.determinant()<0&&(e.x=-e.x),e}}(),$P.BufferAttribute.prototype.copyAtList=function(t,e){console.assert(this.itemSize===t.itemSize,"DEBUG: BufferAttribute.copyAtList buffers have different item size.");const{itemSize:n}=this;for(let i=0,r=e.length;i<r;++i)for(let r=0;r<n;++r)this.array[i*n+r]=t.array[e[i]*n+r];return this};const WN=$P.InstancedBufferGeometry.prototype.copy;$P.InstancedBufferGeometry.prototype.copy=function(t){WN.call(this,t),void 0===this.instanceCount&&(this.instanceCount=1/0)};const jN={calcCylinderMatrix:function(t,e,n){const i=t.clone().lerp(e,.5),r=new $P.Matrix4;r.makeScale(n,t.distanceTo(e),n);const s=new $P.Matrix4;s.makeRotationX(Math.PI/2);const o=new $P.Matrix4,a=new $P.Vector3(0,1,0);return o.lookAt(i,e,a),o.multiply(s),o.multiply(r),o.setPosition(i),o},calcChunkMatrix:function(t,e,n,i){const r=new $P.Matrix4;r.makeScale(i.x,i.y,0);const s=new $P.Matrix4;return s.lookAt(t,e,n),s.multiply(r),s.setPosition(t),s},groupHasGeometryToRender:function(t){let e=!1;return t.traverse(t=>{(t.hasOwnProperty("geometry")||t instanceof UN)&&(e=!0)}),e},buildDistorionMesh:function(t,e,n){function i(t){let e=0,i=t,r=1;for(;Math.abs(i-e)>1e-5;)r=1+n*i,e=i,i=t/(r*r);return 1/r}const r=new $P.PlaneGeometry(2,2,t,e),s=r.getAttribute("position");for(let t=0;t<s.count;++t){const e=s.array[3*t],n=s.array[3*t+1],r=i(e*e+n*n);s.setXY(t,r*e,r*n)}return r},RCGroup:BN,fillArray:function(t,e,n,i){n=void 0!==n?n:0,i=void 0!==i?i:t.length;for(let r=n;r<i;++r)t[r]=e},clearTree:HN,destroyObject:function(t){HN(t),t.parent?t.parent.remove(t):t.dispatchEvent({type:"removed"})},belongToSelectLayers:function(t){for(let e=0;e<kN.length;e++)if(1==(t.layers.mask>>kN[e]&1))return!0;return!1},processObjRenderOrder:function(t,e){const n=+("BA"!==e);t.traverse(t=>{t.isGroup&&(t.renderOrder=n)})},applySelectionMaterial:function(t){t.traverse(t=>{"material"in t&&(t.material=t.material.clone(!0),t.material.setValues({depthFunc:$P.LessEqualDepth,overrideColor:!0,fog:!1,lights:!1,shadowmap:!1}),t.material.setUberOptions({fixedColor:new $P.Color(16776960),zOffset:-1e-6}))})},getMiddlePoint:function(t,e,n){const i=n||new $P.Vector3;return i.set(0,0,0),i.addScaledVector(t,.5),i.addScaledVector(e,.5),i},LAYERS:VN},XN={boundingBox:new $P.Box3(new $P.Vector3(-1,-1,-1),new $P.Vector3(1,1,1)),boundingSphere:new $P.Sphere(new $P.Vector3(0,0,0),1)};class YN extends jN.RCGroup{constructor(t,e){super(t,e),this.name=t,this._dataSource=e}release(){this.parent&&this.parent.remove(this)}getDataSource(){return this._dataSource}getBoundaries(){return XN}}const qN=YN;function $N(t){return null==t||Array.isArray(t)?t:[t]}class ZN{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:["id"];this._list=[],this._dict={},this._indices=[...e],this._indices.forEach(t=>{this._dict[t]={}}),t.forEach(t=>this.register(t))}static registerInList(t,e){t.includes(e)||t.push(e)}static unregisterFromList(t,e){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}static registerInDict(t,e,n){e.forEach(e=>{e=e.toLowerCase();const i=t[e]=t[e]||[];i.includes(n)||i.push(n)})}static unregisterFromDict(t,e,n){e.forEach(e=>{e=e.toLowerCase();const i=t[e];if(i){const r=i.indexOf(n);-1!==r&&i.splice(r,1),0===i.length&&delete t[e]}})}register(t){ZN.registerInList(this._list,t),this._indices.forEach(e=>{ZN.registerInDict(this._dict[e],$N(t[e]),t)})}unregister(t){ZN.unregisterFromList(this._list,t),this._indices.forEach(e=>{ZN.unregisterFromDict(this._dict[e],$N(t[e]),t)})}get all(){return[...this._list]}get first(){return this._list[0]}keys(t){return Object.keys(this._dict[t||this._indices[0]])}get(t,e){const n=this._dict[e||this._indices[0]];if(n){const e=n[t&&t.toLowerCase()];return e&&e.length>0?e[0]:void 0}}}const JN=ZN,KN=function(t){Object.defineProperties(t,{logger:{get(){return this.context&&this.context.logger?this.context.logger:fL}},settings:{get(){return this.context&&this.context.settings?this.context.settings:LL}}})};class QN{constructor(t,e){this._position=t,this._radius=e}static _sphere=(()=>new $P.Sphere)();raycast(t){const e=QN._sphere;e.set(this._position,this._radius);const n=new $P.Vector3;return t.ray.intersectSphere(e,n)?{distance:t.ray.origin.distanceTo(n),point:n}:null}}const tD=t=>class extends t{constructor(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];super(...n),this._objects=new Array(t),this.boundingSphere=null,this.boundingBox=null}setSphere(t,e,n){this._objects[t]=new QN(e,n)}raycast(t,e){for(let n=0,i=this._objects.length;n<i;++n){const i=this._objects[n].raycast(t);i&&(i.chunkIdx=n,e.push(i))}}computeBoundingBox(){const t=this._objects;let{boundingBox:e}=this;null===e&&(this.boundingBox=e=new $P.Box3),e.makeEmpty();for(let n=0,i=t.length;n<i;++n)e.expandByPoint(t[n]._position)}computeBoundingSphere(){this.computeBoundingBox();const t=this._objects,{boundingBox:e}=this;let n=0;const i=new $P.Vector3;e.getCenter(i);for(let e=0,r=t.length;e<r;++e){const r=t[e]._position,s=i.distanceToSquared(r);n<s&&(n=s)}null===this.boundingSphere&&(this.boundingSphere=new $P.Sphere),this.boundingSphere.set(i,Math.sqrt(n))}},eD=new $P.Color,{copySubArrays:nD}=AL;class iD extends(tD($P.InstancedBufferGeometry)){constructor(t,e,n){super(t),this._sphGeometry=n?new $P.PlaneGeometry(2,2,1,1):new $P.SphereBufferGeometry(1,2*e,e,0,2*Math.PI,0,Math.PI),this._init(t,this._sphGeometry)}setItem(t,e,n){!function(t,e,n,i,r,s){t[e]=n,t[e+1]=i,t[e+2]=r,t[e+3]=s}(this._offsets,4*t,e.x,e.y,e.z,n),this.setSphere(t,e,n)}setColor(t,e){eD.set(e),function(t,e,n,i,r){t[e]=n,t[e+1]=i,t[e+2]=r}(this._colors,3*t,eD.r,eD.g,eD.b)}startUpdate(){return!0}finishUpdate(){this.getAttribute("offset").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(t,e){const n=this._alpha;for(let i=0,r=t.length;i<r;++i)n[t[i]]=e;this.getAttribute("alphaColor").needsUpdate=!0}getSubset(t){const e=t.length,n=new $P.InstancedBufferGeometry;return this._init.call(n,e,this._sphGeometry),nD(this._offsets,n._offsets,t,4),nD(this._colors,n._colors,t,3),n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(t,e){this.copy(e),this._offsets=AL.allocateTyped(Float32Array,4*t),this._colors=AL.allocateTyped(Float32Array,3*t);const n=this._alpha=AL.allocateTyped(Float32Array,t);qP.default.fill(n,1),this.setAttribute("offset",new $P.InstancedBufferAttribute(this._offsets,4,!1,1)),this.setAttribute("color",new $P.InstancedBufferAttribute(this._colors,3,!1,1)),this.setAttribute("alphaColor",new $P.InstancedBufferAttribute(n,1,!1,1))}}const rD=iD,sD=new $P.Color;class oD extends $P.BufferGeometry{constructor(t,e){if(super(),this.constructor===oD)throw new Error("Can not instantiate abstract class!");this._chunkGeo=t,this._init(t,e)}startUpdate(){return!0}finishUpdate(){this.getAttribute("position").needsUpdate=!0,this.getAttribute("normal").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0}setColor(t,e){sD.set(e);const n=this._colors,i=this._chunkSize;for(let e=t*i,r=e+i;e<r;++e){const t=3*e;n[t]=sD.r,n[t+1]=sD.g,n[t+2]=sD.b}}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(t,e){const n=this._alpha,i=this._chunkSize;for(let r=0,s=t.length;r<s;++r){const s=t[r]*i;qP.default.fill(n,e,s,s+i)}this.getAttribute("alphaColor").needsUpdate=!0}raycast(t,e){const n=[],i=new $P.Mesh;i.geometry=this,i.raycast(t,n);const r=this._chunkGeo.index.count/3;for(let t=0,i=n.length;t<i;++t)n[t].hasOwnProperty("faceIndex")&&(n[t].chunkIdx=Math.floor(n[t].faceIndex/r),e.push(n[t]))}getSubset(t){const e=t.length,n=new $P.BufferGeometry;this._init.call(n,this._chunkGeo,e);const i=this._positions,r=this._normals,s=this._colors,o=n._positions,a=n._normals,l=n._colors,c=3*this._chunkSize;for(let e=0,n=t.length;e<n;++e){const n=e*c,h=t[e]*c,u=h+c;o.set(i.subarray(h,u),n),a.set(r.subarray(h,u),n),l.set(s.subarray(h,u),n)}return n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(t,e){const n=this._chunkSize=t.attributes.position.count,i=t.index.array,r=i.length,s=this._chunkSize*e,o=s>65535,a=r*e,l=this._index=AL.allocateTyped(o?Uint32Array:Uint16Array,a);this._positions=AL.allocateTyped(Float32Array,3*s),this._normals=AL.allocateTyped(Float32Array,3*s),this._colors=AL.allocateTyped(Float32Array,3*s);const c=this._alpha=AL.allocateTyped(Float32Array,s);qP.default.fill(c,1);for(let t=0;t<e;++t){const e=t*r,s=t*n;l.set(i,e);for(let t=0;t<r;++t)l[e+t]+=s}this.setIndex(new $P.BufferAttribute(this._index,1)),this.setAttribute("position",new $P.BufferAttribute(this._positions,3)),this.setAttribute("normal",new $P.BufferAttribute(this._normals,3)),this.setAttribute("color",new $P.BufferAttribute(this._colors,3)),this.setAttribute("alphaColor",new $P.BufferAttribute(c,1))}}const aD=oD;class lD extends(tD(aD)){constructor(t,e){const n=new $P.SphereBufferGeometry(1,2*e,e,0,2*Math.PI,0,Math.PI);super(t,n,t);const i=this._normals,r=n.attributes.normal.array,s=this._chunkSize;this._chunkPos=this._chunkGeo.attributes.position.array,this._tmpPositions=AL.allocateTyped(Float32Array,3*s);for(let e=0;e<t;++e)i.set(r,3*s*e)}setItem(t,e,n){const i=this._tmpPositions,r=this._chunkSize,s=this._chunkPos;for(let t=0;t<r;++t){const r=3*t;i[r]=e.x+s[r]*n,i[r+1]=e.y+s[r+1]*n,i[r+2]=e.z+s[r+2]*n}this._positions.set(i,r*t*3),this.setSphere(t,e,n)}}const cD=lD,hD=new $P.Vector3,uD=new $P.Vector3,dD=new $P.Matrix3,pD=class extends aD{constructor(t,e){super(new $P.CylinderGeometry(1,1,1,Math.max(3,e),2,!0),2*t);const n=this._chunkSize;this._chunkPos=this._chunkGeo.attributes.position.array,this._chunkNorms=this._chunkGeo.attributes.normal.array,this._tmpVector=AL.allocateTyped(Float32Array,3*n)}setItem(t,e,n,i){const r=this._chunkSize,s=2*r*t*3,o=s+3*r,a=this._tmpVector,l=this._chunkPos,c=this._chunkNorms;hD.lerpVectors(e,n,.5);const h=jN.calcCylinderMatrix(e,hD,i);let u;dD.getNormalMatrix(h);for(let t=0;t<r;++t)u=3*t,uD.fromArray(l,u),uD.applyMatrix4(h),uD.toArray(a,u);this._positions.set(a,s),hD.sub(e);for(let t=0;t<r;++t)u=3*t,a[u]+=hD.x,a[u+1]+=hD.y,a[u+2]+=hD.z;this._positions.set(a,o);for(let t=0;t<r;++t)u=3*t,uD.fromArray(c,u),uD.applyMatrix3(dD),uD.toArray(a,u);this._normals.set(a,s),this._normals.set(a,o)}setColor(t,e,n){const i=2*t;super.setColor(i,e);const r=i+1;super.setColor(r,n)}};class fD extends $P.BufferGeometry{constructor(t,e,n,i,r,s){super();const o=2*Math.PI;this.type="CylinderBufferGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s};const a=!1===s&&t>0,l=!1===s&&e>0,c=(r+1)*i+a*(i+1)+l*(i+1),h=(2*r+a+l)*i,u=n/2,d=new $P.BufferAttribute(AL.allocateTyped(Float32Array,3*c),3),p=new $P.BufferAttribute(AL.allocateTyped(Float32Array,3*c),3),f=new $P.Uint16BufferAttribute(AL.allocateTyped(Uint16Array,3*h),1),m=new $P.BufferAttribute(AL.allocateTyped(Float32Array,2*c),2);console.assert(c<65536,"DEBUG: Cylinder Geometry has too many vertices (65536 max).");let g=0,_=0;const y=-(e-t)/n;for(let s=0;s<=r;s++){if(s!==r)for(let t=0;t<i;t++){const e=g+t,n=g+i+t,r=g+i+(t+1)%i,s=g+(t+1)%i;f.setXYZ(3*_,e,s,n),_++,f.setXYZ(3*_,n,s,r),_++}const a=s/r,l=a*(e-t)+t;for(let t=0;t<i;t++){const e=t/i,r=l*Math.sin(e*o+0),s=a*n-u,c=l*Math.cos(e*o+0),h=new $P.Vector3(r,Math.sqrt(r*r+c*c)*y,c).normalize();d.setXYZ(g,r,s,c),p.setXYZ(g,h.x,h.y,h.z),m.setXY(g,e,a),++g}}if(a){const t=g,e=g+i;for(let n=0;n<i;++n){const r=g-i;d.setXYZ(g,d.getX(r),d.getY(r),d.getZ(r)),p.setXYZ(g,0,1,0),m.setXY(g,1,1);const s=t+(n+1)%i;f.setXYZ(3*_,g,s,e),_++,g++}d.setXYZ(g,0,u,0),p.setXYZ(g,0,1,0),m.setXY(g,1,1),++g}if(l){const t=g,e=g+i;for(let n=0;n<i;++n){const r=n;d.setXYZ(g,d.getX(r),d.getY(r),d.getZ(r)),p.setXYZ(g,0,-1,0),m.setXY(g,0,0);const s=t+(n+1)%i;f.setXYZ(3*_,s,g,e),_++,g++}d.setXYZ(g,0,-u,0),p.setXYZ(g,0,-1,0),m.setXY(g,0,0)}this.setIndex(f),this.setAttribute("position",d),this.setAttribute("normal",p),this.setAttribute("uv",m)}clone(){const{parameters:t}=this;return new fD(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded)}}const mD=fD,gD=new $P.Color,_D=new $P.Matrix4,{copySubArrays:yD}=AL;function vD(t,e,n,i,r){t[e]=n,t[e+1]=i,t[e+2]=r}function xD(t,e,n,i,r,s){t[e]=n,t[e+1]=i,t[e+2]=r,t[e+3]=s}function SD(t,e){return t-e}class bD extends $P.InstancedBufferGeometry{constructor(t,e,n,i){super(),this._useZSprites=n,this._cylGeometry=n?new $P.PlaneGeometry(2,2,1,1):new mD(1,1,1,Math.max(3,e),2,i),this._init(t,this._cylGeometry,this._useZSprites),this._collisionGeo=new pD(t,3)}setItem(t,e,n,i){const r=jN.calcCylinderMatrix(e,n,i);let s=r.elements;const o=4*t;this._collisionGeo.setItem(t,e,n,i),xD(this._matVector1,o,s[0],s[4],s[8],s[12]),xD(this._matVector2,o,s[1],s[5],s[9],s[13]),xD(this._matVector3,o,s[2],s[6],s[10],s[14]),this._useZSprites&&(_D.copy(r).invert(),s=_D.elements,xD(this._invmatVector1,o,s[0],s[4],s[8],s[12]),xD(this._invmatVector2,o,s[1],s[5],s[9],s[13]),xD(this._invmatVector3,o,s[2],s[6],s[10],s[14]))}setColor(t,e,n){const i=3*t;gD.set(e),vD(this._color1,i,gD.r,gD.g,gD.b),gD.set(n),vD(this._color2,i,gD.r,gD.g,gD.b)}computeBoundingSphere(){this._collisionGeo.computeBoundingSphere(),this.boundingSphere=this._collisionGeo.boundingSphere}computeBoundingBox(){this._collisionGeo.computeBoundingBox(),this.boundingBox=this._collisionGeo.boundingBox}raycast(t,e){this._collisionGeo.raycast(t,e)}startUpdate(){return!0}finishUpdate(){this.getAttribute("matVector1").needsUpdate=!0,this.getAttribute("matVector2").needsUpdate=!0,this.getAttribute("matVector3").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0,this.getAttribute("color2").needsUpdate=!0,this.getAttribute("alphaColor").needsUpdate=!0,this._useZSprites&&(this.getAttribute("invmatVector1").needsUpdate=!0,this.getAttribute("invmatVector2").needsUpdate=!0,this.getAttribute("invmatVector3").needsUpdate=!0),this._collisionGeo.finishUpdate()}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(t,e){const n=this._alpha;for(let i=0,r=t.length;i<r;++i)n[Math.floor(t[i]/2)]=e;this.getAttribute("alphaColor").needsUpdate=!0}getSubset(t){const e=function(t){t.sort(SD);const e=[],n=[];for(let i=0,r=t.length;i<r;++i){const s=t[i],o={first:!1,second:!1};(0|s)%2==0?(o.first=!0,o.second=i+1<r&&t[i+1]===t[i]+1,o.second&&++i):o.second=!0,e.push(Math.floor(s/2)),n.push(o)}return{indices:e,cylinderInfo:n}}(t),n=e.indices,i=n.length,r=new $P.InstancedBufferGeometry;return this._init.call(r,i,this._cylGeometry,this._useZSprites),yD(this._matVector1,r._matVector1,n,4),yD(this._matVector2,r._matVector2,n,4),yD(this._matVector3,r._matVector3,n,4),this._useZSprites&&(yD(this._invmatVector1,r._invmatVector1,n,4),yD(this._invmatVector2,r._invmatVector2,n,4),yD(this._invmatVector3,r._invmatVector3,n,4)),yD(this._color1,r._color1,n,3),yD(this._color2,r._color2,n,3),function(t,e,n){for(let i=0,r=t.length;i<r;++i){const r=t[i];r.first||(e[3*i]=-.5),r.second||(n[3*i]=-.5)}}(e.cylinderInfo,r._color1,r._color2),r.boundingSphere=this.boundingSphere,r.boundingBox=this.boundingBox,[r]}getGeoParams(){return this._cylGeometry.parameters}_init(t,e,n){this.copy(e),this._matVector1=AL.allocateTyped(Float32Array,4*t),this._matVector2=AL.allocateTyped(Float32Array,4*t),this._matVector3=AL.allocateTyped(Float32Array,4*t),this._color1=AL.allocateTyped(Float32Array,3*t),this._color2=AL.allocateTyped(Float32Array,3*t);const i=this._alpha=AL.allocateTyped(Float32Array,t);qP.default.fill(i,1),this.setAttribute("matVector1",new $P.InstancedBufferAttribute(this._matVector1,4,!1,1)),this.setAttribute("matVector2",new $P.InstancedBufferAttribute(this._matVector2,4,!1,1)),this.setAttribute("matVector3",new $P.InstancedBufferAttribute(this._matVector3,4,!1,1)),this.setAttribute("color",new $P.InstancedBufferAttribute(this._color1,3,!1,1)),this.setAttribute("color2",new $P.InstancedBufferAttribute(this._color2,3,!1,1)),this.setAttribute("alphaColor",new $P.InstancedBufferAttribute(this._alpha,1,!1,1)),n&&(this._invmatVector1=AL.allocateTyped(Float32Array,4*t),this._invmatVector2=AL.allocateTyped(Float32Array,4*t),this._invmatVector3=AL.allocateTyped(Float32Array,4*t),this.setAttribute("invmatVector1",new $P.InstancedBufferAttribute(this._invmatVector1,4,!1,1)),this.setAttribute("invmatVector2",new $P.InstancedBufferAttribute(this._invmatVector2,4,!1,1)),this.setAttribute("invmatVector3",new $P.InstancedBufferAttribute(this._invmatVector3,4,!1,1)))}}const MD=bD,wD=new $P.Vector3,ED=new $P.Vector3,TD=new $P.Vector3,AD=new $P.Vector3(1,0,0),CD=new $P.Vector3,RD=new $P.Vector3,PD=new $P.Color,LD=new $P.Vector3;function ID(t,e,n,i,r){t[e]=n,t[e+1]=i,t[e+2]=r}function ND(t,e,n,i,r,s){t[e]=n,t[e+1]=i,t[e+2]=r,t[e+3]=s}function DD(t,e,n,i){const r=4*e,s=r+4*n;return t.subarray(r*i,s*i)}class OD extends $P.BufferGeometry{constructor(t){super(),this._initVertices(t)}startUpdate(){return!0}finishUpdate(){this.getAttribute("position").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0,this.getAttribute("alphaColor").needsUpdate=!0,this.getAttribute("direction").needsUpdate=!0}setColor(t,e){PD.set(e);let n=4*t*3;ID(this._colors,n,PD.r,PD.g,PD.b),n+=3,ID(this._colors,n,PD.r,PD.g,PD.b),n+=3,ID(this._colors,n,PD.r,PD.g,PD.b),n+=3,ID(this._colors,n,PD.r,PD.g,PD.b)}setSegment(t,e,n){LD.subVectors(e,n),LD.normalize();const i=this._positions,r=this._directions;let s=4*t*4,o=4*t*3;ND(i,s,e.x,e.y,e.z,.5),ID(r,o,LD.x,LD.y,LD.z),s+=4,o+=3,ND(i,s,e.x,e.y,e.z,-.5),ID(r,o,LD.x,LD.y,LD.z),s+=4,o+=3,ND(i,s,n.x,n.y,n.z,.5),ID(r,o,LD.x,LD.y,LD.z),s+=4,o+=3,ND(i,s,n.x,n.y,n.z,-.5),ID(r,o,LD.x,LD.y,LD.z)}setOpacity(t,e,n){const i=4*t,r=4*e;qP.default.fill(this.alpha,n,r,i),this.getAttribute("alphaColor").needsUpdate=!0}getSubsetSegments(t,e){return[DD(this._positions,t,e,4),DD(this._directions,t,e,3)]}getSubsetColors(t,e){return DD(this._colors,t,e,3)}getSubsetOpacities(t,e){return DD(this._alpha,t,e,1)}getNumVertexPerSegment(){return 4}getPositionSize(){return 4}setSegments(t,e){const n=4*t*4;if(e instanceof Array&&2===e.length){this._positions.set(e[0],n);const i=4*t*3;this._directions.set(e[1],i)}else this._positions.set(e,n)}setColors(t,e){const n=4*t*3;this._colors.set(e,n)}_initVertices(t){this._buffersSize=4*t;const e=this._buffersSize,n=e>65535;this._index=AL.allocateTyped(n?Uint32Array:Uint16Array,6*t),this._positions=AL.allocateTyped(Float32Array,4*e),this._colors=AL.allocateTyped(Float32Array,3*e),this._directions=AL.allocateTyped(Float32Array,3*e);const i=this._alpha=AL.allocateTyped(Float32Array,e);qP.default.fill(i,1);const r=this._index;let s=0,o=0;for(let e=0;e<t;e++,s+=6,o+=4)r[s]=o,r[s+1]=o+1,r[s+2]=o+3,r[s+3]=o,r[s+4]=o+2,r[s+5]=o+3;this.setIndex(new $P.BufferAttribute(this._index,1)),this.setAttribute("position",new $P.BufferAttribute(this._positions,4)),this.setAttribute("color",new $P.BufferAttribute(this._colors,3)),this.setAttribute("alphaColor",new $P.BufferAttribute(i,1)),this.setAttribute("direction",new $P.BufferAttribute(this._directions,3))}}const UD=OD,FD=class extends UD{startUpdate(){return!0}computeBoundingSphere(){const{boundingBox:t}=this;let e=0;const n=new $P.Vector3;t&&t.getCenter(n);const i=this._positions,r=this.boundingSphere||new $P.Sphere,s=this._positions.length,o=new $P.Vector3,a=this.getPositionSize();for(let t=0;t<s;t+=a){o.set(i[t],i[t+1],i[t+2]);const r=n.distanceToSquared(o);e<r&&(e=r)}r.set(n,Math.sqrt(e)),this.boundingSphere=r}computeBoundingBox(){const t=this._positions,e=new $P.Box3,n=this._positions.length,i=new $P.Vector3,r=this.getPositionSize();for(let s=0;s<n;s+=r)i.set(t[s],t[s+1],t[s+2]),e.expandByPoint(i);this.boundingBox=e}finalize(){this.finishUpdate(),this.computeBoundingSphere()}},BD=new $P.Vector3,zD=new $P.Matrix3,VD=class extends aD{constructor(t,e){super(new $P.CylinderGeometry(1,1,1,Math.max(3,e),2,!0),t);const n=this._chunkSize;this._chunkPos=this._chunkGeo.attributes.position.array,this._chunkNorms=this._chunkGeo.attributes.normal.array,this._tmpVector=AL.allocateTyped(Float32Array,3*n)}setItem(t,e,n,i){const r=this._chunkSize,s=r*t*3,o=this._tmpVector,a=this._chunkPos,l=this._chunkNorms,c=jN.calcCylinderMatrix(e,n,i);let h;zD.getNormalMatrix(c);for(let t=0;t<r;++t)h=3*t,BD.fromArray(a,h),BD.applyMatrix4(c),BD.toArray(o,h);this._positions.set(o,s);for(let t=0;t<r;++t)h=3*t,BD.fromArray(l,h),BD.applyMatrix3(zD),BD.toArray(o,h);this._normals.set(o,s)}};class kD extends FD{constructor(t,e,n){super(t*e),this._init(e),this._collisionGeo=n?new VD(t*e,3):null}startUpdate(){return!0}computeBoundingSphere(){const t=this._collisionGeo;if(t)return t.computeBoundingSphere(),void(this.boundingSphere=t.boundingSphere);super.computeBoundingSphere()}computeBoundingBox(){const t=this._collisionGeo;if(t)return t.computeBoundingBox(),void(this.boundingBox=t.boundingBox);super.computeBoundingBox()}raycast(t,e){if(!this._collisionGeo)return;const n=this._chunkSize;this._collisionGeo.raycast(t,e);for(let t=0,i=e.length;t<i;++t){let{chunkIdx:i}=e[t];void 0!==i&&(i=i/n|0,e[t].chunkIdx=i)}}setColor(t,e){const n=this._chunkSize;for(let i=t*n,r=i+n;i<r;++i)super.setColor(i,e)}setSegment(t,e,n,i){const r=this._chunkSize,s=t*r+e;super.setSegment(s,n,i),this._collisionGeo&&this._collisionGeo.setItem(t*r+e,n,i,.1)}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(t,e){const n=this._chunkSize;for(let i=0,r=t.length;i<r;++i){const r=t[i]*n;super.setOpacity(r,r+n-1,e)}}getSubset(t){const e=t.length,n=this._chunkSize,i=new kD(e,n,!1);for(let e=0,r=t.length;e<r;++e){const r=e*n,s=t[e]*n;i.setSegments(r,this.getSubsetSegments(s,n)),i.setColors(r,this.getSubsetColors(s,n))}return i.boundingSphere=this.boundingSphere,i.boundingBox=this.boundingBox,[i]}_init(t){this._chunkSize=t}}const GD=kD,HD=new $P.Vector3;class WD extends FD{constructor(t){super(2*t),this._init(t),this._collisionGeo=new pD(t,3)}setItem(t,e,n){this._collisionGeo.setItem(t,e,n,.3);const i=2*t;HD.lerpVectors(e,n,.5),super.setSegment(i,e,HD),super.setSegment(i+1,HD,n)}setColor(t,e,n){const i=2*t;super.setColor(i,e),super.setColor(i+1,n)}raycast(t,e){this._collisionGeo&&this._collisionGeo.raycast(t,e)}getSubset(t){const e=t.length,n=new WD(e,!1);for(let i=0,r=e;i<r;++i){const e=t[i];n.setSegments(i,this.getSubsetSegments(e,1)),n.setColors(i,this.getSubsetColors(e,1))}return n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(t){this._segCounts=2*t}}const jD=WD,XD=[new $P.Vector3(1,0,0),new $P.Vector3(-1,0,0),new $P.Vector3(0,1,0),new $P.Vector3(0,-1,0),new $P.Vector3(0,0,1),new $P.Vector3(0,0,-1)],YD=XD.length,qD=new $P.Vector3,$D=new $P.Vector3;class ZD extends(tD(GD)){constructor(t){super(t,t,YD/2|0,!1)}setItem(t,e,n){this.setSphere(t,e,n);for(let i=0;i<YD/2;++i){const r=2*i;qD.x=e.x+XD[r].x*n,qD.y=e.y+XD[r].y*n,qD.z=e.z+XD[r].z*n;const s=r+1;$D.x=e.x+XD[s].x*n,$D.y=e.y+XD[s].y*n,$D.z=e.z+XD[s].z*n,this.setSegment(t,i,qD,$D)}}}const JD=ZD,KD=new $P.Color;class QD extends $P.BufferGeometry{constructor(t,e){super(),this._opts=e,this.zClip=this._opts.zClip,this._posRad=AL.allocateTyped(Float32Array,4*t),this._colors=AL.allocateTyped(Float32Array,3*t)}setItem(t,e,n){const i=this._posRad;let r=4*t;i[r++]=e.x,i[r++]=e.y,i[r++]=e.z,i[r]=n}setColor(t,e){KD.set(e);const n=this._colors;let i=3*t;n[i++]=KD.r,n[i++]=KD.g,n[i]=KD.b}finalize(){this.finishUpdate(),this.computeBoundingSphere()}finishUpdate(){this._build()}setOpacity(){}raycast(){}getSubset(){return[]}}const tO=QD;class eO{constructor(){this.pointsValuesLinear=null,this.hasIntersection=null,this.bitsInside=null}create(t){const e=t*t*t;if(e>117440512)throw new Error("Too large cube dimension: lead to memory huge uasge");return this.pointsValuesLinear=AL.allocateTyped(Float32Array,32*e),this.hasIntersection=AL.allocateTyped(Int32Array,e),this.bitsInside=AL.allocateTyped(Int32Array,e),0}destroy(){this.bitsInside=null,this.hasIntersection=null,this.pointsValuesLinear=null}}eO.prototype.striIndicesMarchCube=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,9,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,2,10,0,2,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,8,3,2,10,8,10,9,8,-1,-1,-1,-1,-1,-1,-1,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,8,11,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,11,2,1,9,11,9,8,11,-1,-1,-1,-1,-1,-1,-1,3,10,1,11,10,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,10,1,0,8,10,8,11,10,-1,-1,-1,-1,-1,-1,-1,3,9,0,3,11,9,11,10,9,-1,-1,-1,-1,-1,-1,-1,9,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,7,3,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,1,9,4,7,1,7,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,4,7,3,0,4,1,2,10,-1,-1,-1,-1,-1,-1,-1,9,2,10,9,0,2,8,4,7,-1,-1,-1,-1,-1,-1,-1,2,10,9,2,9,7,2,7,3,7,9,4,-1,-1,-1,-1,8,4,7,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,4,7,11,2,4,2,0,4,-1,-1,-1,-1,-1,-1,-1,9,0,1,8,4,7,2,3,11,-1,-1,-1,-1,-1,-1,-1,4,7,11,9,4,11,9,11,2,9,2,1,-1,-1,-1,-1,3,10,1,3,11,10,7,8,4,-1,-1,-1,-1,-1,-1,-1,1,11,10,1,4,11,1,0,4,7,11,4,-1,-1,-1,-1,4,7,8,9,0,11,9,11,10,11,0,3,-1,-1,-1,-1,4,7,11,4,11,9,9,11,10,-1,-1,-1,-1,-1,-1,-1,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,4,1,5,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,5,4,8,3,5,3,1,5,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,10,4,9,5,-1,-1,-1,-1,-1,-1,-1,5,2,10,5,4,2,4,0,2,-1,-1,-1,-1,-1,-1,-1,2,10,5,3,2,5,3,5,4,3,4,8,-1,-1,-1,-1,9,5,4,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,0,8,11,4,9,5,-1,-1,-1,-1,-1,-1,-1,0,5,4,0,1,5,2,3,11,-1,-1,-1,-1,-1,-1,-1,2,1,5,2,5,8,2,8,11,4,8,5,-1,-1,-1,-1,10,3,11,10,1,3,9,5,4,-1,-1,-1,-1,-1,-1,-1,4,9,5,0,8,1,8,10,1,8,11,10,-1,-1,-1,-1,5,4,0,5,0,11,5,11,10,11,0,3,-1,-1,-1,-1,5,4,8,5,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,9,7,8,5,7,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,3,0,9,5,3,5,7,3,-1,-1,-1,-1,-1,-1,-1,0,7,8,0,1,7,1,5,7,-1,-1,-1,-1,-1,-1,-1,1,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,7,8,9,5,7,10,1,2,-1,-1,-1,-1,-1,-1,-1,10,1,2,9,5,0,5,3,0,5,7,3,-1,-1,-1,-1,8,0,2,8,2,5,8,5,7,10,5,2,-1,-1,-1,-1,2,10,5,2,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,7,9,5,7,8,9,3,11,2,-1,-1,-1,-1,-1,-1,-1,9,5,7,9,7,2,9,2,0,2,7,11,-1,-1,-1,-1,2,3,11,0,1,8,1,7,8,1,5,7,-1,-1,-1,-1,11,2,1,11,1,7,7,1,5,-1,-1,-1,-1,-1,-1,-1,9,5,8,8,5,7,10,1,3,10,3,11,-1,-1,-1,-1,5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,-1,11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,-1,11,10,5,7,11,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,0,1,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,1,9,8,5,10,6,-1,-1,-1,-1,-1,-1,-1,1,6,5,2,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,6,5,1,2,6,3,0,8,-1,-1,-1,-1,-1,-1,-1,9,6,5,9,0,6,0,2,6,-1,-1,-1,-1,-1,-1,-1,5,9,8,5,8,2,5,2,6,3,2,8,-1,-1,-1,-1,2,3,11,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,0,8,11,2,0,10,6,5,-1,-1,-1,-1,-1,-1,-1,0,1,9,2,3,11,5,10,6,-1,-1,-1,-1,-1,-1,-1,5,10,6,1,9,2,9,11,2,9,8,11,-1,-1,-1,-1,6,3,11,6,5,3,5,1,3,-1,-1,-1,-1,-1,-1,-1,0,8,11,0,11,5,0,5,1,5,11,6,-1,-1,-1,-1,3,11,6,0,3,6,0,6,5,0,5,9,-1,-1,-1,-1,6,5,9,6,9,11,11,9,8,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,4,7,3,6,5,10,-1,-1,-1,-1,-1,-1,-1,1,9,0,5,10,6,8,4,7,-1,-1,-1,-1,-1,-1,-1,10,6,5,1,9,7,1,7,3,7,9,4,-1,-1,-1,-1,6,1,2,6,5,1,4,7,8,-1,-1,-1,-1,-1,-1,-1,1,2,5,5,2,6,3,0,4,3,4,7,-1,-1,-1,-1,8,4,7,9,0,5,0,6,5,0,2,6,-1,-1,-1,-1,7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,-1,3,11,2,7,8,4,10,6,5,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,2,4,2,0,2,7,11,-1,-1,-1,-1,0,1,9,4,7,8,2,3,11,5,10,6,-1,-1,-1,-1,9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,-1,8,4,7,3,11,5,3,5,1,5,11,6,-1,-1,-1,-1,5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,-1,0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,-1,6,5,9,6,9,11,4,7,9,7,11,9,-1,-1,-1,-1,10,4,9,6,4,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,10,6,4,9,10,0,8,3,-1,-1,-1,-1,-1,-1,-1,10,0,1,10,6,0,6,4,0,-1,-1,-1,-1,-1,-1,-1,8,3,1,8,1,6,8,6,4,6,1,10,-1,-1,-1,-1,1,4,9,1,2,4,2,6,4,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,9,2,4,9,2,6,4,-1,-1,-1,-1,0,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,3,2,8,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,10,4,9,10,6,4,11,2,3,-1,-1,-1,-1,-1,-1,-1,0,8,2,2,8,11,4,9,10,4,10,6,-1,-1,-1,-1,3,11,2,0,1,6,0,6,4,6,1,10,-1,-1,-1,-1,6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,-1,9,6,4,9,3,6,9,1,3,11,6,3,-1,-1,-1,-1,8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,-1,3,11,6,3,6,0,0,6,4,-1,-1,-1,-1,-1,-1,-1,6,4,8,11,6,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,10,6,7,8,10,8,9,10,-1,-1,-1,-1,-1,-1,-1,0,7,3,0,10,7,0,9,10,6,7,10,-1,-1,-1,-1,10,6,7,1,10,7,1,7,8,1,8,0,-1,-1,-1,-1,10,6,7,10,7,1,1,7,3,-1,-1,-1,-1,-1,-1,-1,1,2,6,1,6,8,1,8,9,8,6,7,-1,-1,-1,-1,2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,-1,7,8,0,7,0,6,6,0,2,-1,-1,-1,-1,-1,-1,-1,7,3,2,6,7,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,11,10,6,8,10,8,9,8,6,7,-1,-1,-1,-1,2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,-1,1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,-1,11,2,1,11,1,7,10,6,1,6,7,1,-1,-1,-1,-1,8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,-1,0,9,1,11,6,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,8,0,7,0,6,3,11,0,11,6,0,-1,-1,-1,-1,7,11,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,1,9,8,3,1,11,7,6,-1,-1,-1,-1,-1,-1,-1,10,1,2,6,11,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,8,6,11,7,-1,-1,-1,-1,-1,-1,-1,2,9,0,2,10,9,6,11,7,-1,-1,-1,-1,-1,-1,-1,6,11,7,2,10,3,10,8,3,10,9,8,-1,-1,-1,-1,7,2,3,6,2,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,0,8,7,6,0,6,2,0,-1,-1,-1,-1,-1,-1,-1,2,7,6,2,3,7,0,1,9,-1,-1,-1,-1,-1,-1,-1,1,6,2,1,8,6,1,9,8,8,7,6,-1,-1,-1,-1,10,7,6,10,1,7,1,3,7,-1,-1,-1,-1,-1,-1,-1,10,7,6,1,7,10,1,8,7,1,0,8,-1,-1,-1,-1,0,3,7,0,7,10,0,10,9,6,10,7,-1,-1,-1,-1,7,6,10,7,10,8,8,10,9,-1,-1,-1,-1,-1,-1,-1,6,8,4,11,8,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,6,11,3,0,6,0,4,6,-1,-1,-1,-1,-1,-1,-1,8,6,11,8,4,6,9,0,1,-1,-1,-1,-1,-1,-1,-1,9,4,6,9,6,3,9,3,1,11,3,6,-1,-1,-1,-1,6,8,4,6,11,8,2,10,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,11,0,6,11,0,4,6,-1,-1,-1,-1,4,11,8,4,6,11,0,2,9,2,10,9,-1,-1,-1,-1,10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,-1,8,2,3,8,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,0,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,4,2,4,6,4,3,8,-1,-1,-1,-1,1,9,4,1,4,2,2,4,6,-1,-1,-1,-1,-1,-1,-1,8,1,3,8,6,1,8,4,6,6,10,1,-1,-1,-1,-1,10,1,0,10,0,6,6,0,4,-1,-1,-1,-1,-1,-1,-1,4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,-1,10,9,4,6,10,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,5,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,5,11,7,6,-1,-1,-1,-1,-1,-1,-1,5,0,1,5,4,0,7,6,11,-1,-1,-1,-1,-1,-1,-1,11,7,6,8,3,4,3,5,4,3,1,5,-1,-1,-1,-1,9,5,4,10,1,2,7,6,11,-1,-1,-1,-1,-1,-1,-1,6,11,7,1,2,10,0,8,3,4,9,5,-1,-1,-1,-1,7,6,11,5,4,10,4,2,10,4,0,2,-1,-1,-1,-1,3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,-1,7,2,3,7,6,2,5,4,9,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,6,0,6,2,6,8,7,-1,-1,-1,-1,3,6,2,3,7,6,1,5,0,5,4,0,-1,-1,-1,-1,6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,-1,9,5,4,10,1,6,1,7,6,1,3,7,-1,-1,-1,-1,1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,-1,4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,-1,7,6,10,7,10,8,5,4,10,4,8,10,-1,-1,-1,-1,6,9,5,6,11,9,11,8,9,-1,-1,-1,-1,-1,-1,-1,3,6,11,0,6,3,0,5,6,0,9,5,-1,-1,-1,-1,0,11,8,0,5,11,0,1,5,5,6,11,-1,-1,-1,-1,6,11,3,6,3,5,5,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,11,9,11,8,11,5,6,-1,-1,-1,-1,0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,-1,11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,-1,6,11,3,6,3,5,2,10,3,10,5,3,-1,-1,-1,-1,5,8,9,5,2,8,5,6,2,3,8,2,-1,-1,-1,-1,9,5,6,9,6,0,0,6,2,-1,-1,-1,-1,-1,-1,-1,1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,-1,1,5,6,2,1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,-1,10,1,0,10,0,6,9,5,0,5,6,0,-1,-1,-1,-1,0,3,8,5,6,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,5,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,7,5,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,11,7,5,8,3,0,-1,-1,-1,-1,-1,-1,-1,5,11,7,5,10,11,1,9,0,-1,-1,-1,-1,-1,-1,-1,10,7,5,10,11,7,9,8,1,8,3,1,-1,-1,-1,-1,11,1,2,11,7,1,7,5,1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,7,1,7,5,7,2,11,-1,-1,-1,-1,9,7,5,9,2,7,9,0,2,2,11,7,-1,-1,-1,-1,7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,-1,2,5,10,2,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,8,2,0,8,5,2,8,7,5,10,2,5,-1,-1,-1,-1,9,0,1,5,10,3,5,3,7,3,10,2,-1,-1,-1,-1,9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,-1,1,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,7,0,7,1,1,7,5,-1,-1,-1,-1,-1,-1,-1,9,0,3,9,3,5,5,3,7,-1,-1,-1,-1,-1,-1,-1,9,8,7,5,9,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,8,4,5,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,5,0,4,5,11,0,5,10,11,11,3,0,-1,-1,-1,-1,0,1,9,8,4,10,8,10,11,10,4,5,-1,-1,-1,-1,10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,-1,2,5,1,2,8,5,2,11,8,4,5,8,-1,-1,-1,-1,0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,-1,0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,-1,9,4,5,2,11,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,5,10,3,5,2,3,4,5,3,8,4,-1,-1,-1,-1,5,10,2,5,2,4,4,2,0,-1,-1,-1,-1,-1,-1,-1,3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,-1,5,10,2,5,2,4,1,9,2,9,4,2,-1,-1,-1,-1,8,4,5,8,5,3,3,5,1,-1,-1,-1,-1,-1,-1,-1,0,4,5,1,0,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,4,5,8,5,3,9,0,5,0,3,5,-1,-1,-1,-1,9,4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,11,7,4,9,11,9,10,11,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,7,9,11,7,9,10,11,-1,-1,-1,-1,1,10,11,1,11,4,1,4,0,7,4,11,-1,-1,-1,-1,3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,-1,4,11,7,9,11,4,9,2,11,9,1,2,-1,-1,-1,-1,9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,-1,11,7,4,11,4,2,2,4,0,-1,-1,-1,-1,-1,-1,-1,11,7,4,11,4,2,8,3,4,3,2,4,-1,-1,-1,-1,2,9,10,2,7,9,2,3,7,7,4,9,-1,-1,-1,-1,9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,-1,3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,-1,1,10,2,8,7,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,7,1,3,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,0,8,1,8,7,1,-1,-1,-1,-1,4,0,3,7,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,11,9,10,-1,-1,-1,-1,-1,-1,-1,0,1,10,0,10,8,8,10,11,-1,-1,-1,-1,-1,-1,-1,3,1,10,11,3,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,11,1,11,9,9,11,8,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,1,2,9,2,11,9,-1,-1,-1,-1,0,2,11,8,0,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,10,8,9,-1,-1,-1,-1,-1,-1,-1,9,10,2,0,9,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,0,1,8,1,10,8,-1,-1,-1,-1,1,10,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,8,9,1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,3,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];const nO=eO,iO=[0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0];function rO(t,e,n){const i=t.getValue(e.x,e.y,e.z);n.set(i[0],i[1],i[2])}class sO{constructor(){this._arrSize=8,this.p=new Array(this._arrSize),this.g=new Array(this._arrSize),this.val=new Array(this._arrSize);for(let t=0;t<this._arrSize;++t)this.p[t]=new $P.Vector3,this.g[t]=new $P.Vector3;this.cubeIndex=0}}class oO{constructor(){this.a={p:new $P.Vector3,n:new $P.Vector3},this.b={p:new $P.Vector3,n:new $P.Vector3},this.c={p:new $P.Vector3,n:new $P.Vector3}}}function aO(t){const e=new Array(t);for(let n=0;n<t;++n)e[n]=new $P.Vector3;return e}class lO{constructor(){this._numTriangles=0,this._numVertices=0,this._position=[],this._normals=[],this._colors=null,this._indices=[],this._volumetricData=null,this._xAxis=new $P.Vector3,this._yAxis=new $P.Vector3,this._zAxis=new $P.Vector3,this._xDir=new $P.Vector3,this._yDir=new $P.Vector3,this._zDir=new $P.Vector3}_prepareAxesAndDirs(){const t=this._volumetricData.getCellSize(),e=this._xAxis,n=this._yAxis,i=this._zAxis,r=this._xDir,s=this._yDir,o=this._zDir;e.set(t.x,0,0),n.set(0,t.y,0),i.set(0,0,t.z),r.set(1,0,0),s.set(0,1,0),o.set(0,0,1);const a=new $P.Vector3;if(a.crossVectors(r,s),a.dot(o)<0&&(r.negate(),s.negate(),o.negate()),r.x<0||r.y<0||r.z<0||s.x<0||s.y<0||s.z<0||o.x<0||o.y<0||o.z<0)return!1;const l=t=>Math.abs(t)>Number.EPSILON;return!(l(e.y)||l(e.z)||l(n.x)||l(n.z)||l(i.x)||l(i.y))}_vertexInterp(t,e,n,i,r,s){const o=e.p[n],a=e.p[i],l=e.g[n],c=e.g[i],h=e.val[n],u=t-h,d=e.val[i]-h;let p=0;Math.abs(d)>0&&(p=u/d),p=p>1?1:p,r.lerpVectors(o,a,p),s.lerpVectors(l,c,p)}static _triTable=(()=>nO.prototype.striIndicesMarchCube)();static _arrSize=12;static _firstIndices=[0,1,2,3,4,5,6,7,0,1,2,3];static _secondIndices=[1,2,3,0,5,6,7,4,4,5,6,7];static _vertexList=(()=>aO(lO._arrSize))();static _normalList=(()=>aO(lO._arrSize))();_polygonize(t,e,n){const{cubeIndex:i}=t;let r=0;const s=lO._arrSize,o=lO._firstIndices,a=lO._secondIndices,l=lO._vertexList,c=lO._normalList;for(;r<s;++r)iO[i]&1<<r&&this._vertexInterp(e,t,o[r],a[r],l[r],c[r]);let h=0;const u=16*i,d=lO._triTable;for(r=0;-1!==d[u+r];r+=3)n[h].a.p.copy(l[d[u+r]]),n[h].a.n.copy(c[d[u+r]]),n[h].b.p.copy(l[d[u+r+1]]),n[h].b.n.copy(c[d[u+r+1]]),n[h].c.p.copy(l[d[u+r+2]]),n[h].c.n.copy(c[d[u+r+2]]),++h;return h}_doGridPosNorms(t,e,n){const i=this._volumetricData,r=this._volumetricData.getData(),s=i.getDimensions(),o=s[0],a=s[1],l=s[2],c=e*i.getStrideX(),h=e*i.getStrideY(),u=e*i.getStrideZ(),d=new sO,p=d.val,f=d.val.length,m=[new $P.Vector3(0,0,0),new $P.Vector3(e,0,0),new $P.Vector3(e,e,0),new $P.Vector3(0,e,0),new $P.Vector3(0,0,e),new $P.Vector3(e,0,e),new $P.Vector3(e,e,e),new $P.Vector3(0,e,e)],g=new Array(5);for(let t=0;t<5;++t)g[t]=new oO;let _;const y=this,v=this._position,x=this._normals;_=n?function(){const t=new $P.Vector3(y._xAxis.x,y._yAxis.y,y._zAxis.z);return function(e){const n=e.p.clone();n.multiply(t),v.push(n.add(y._origin)),x.push(e.n.clone())}}():function(){const t=new $P.Matrix3;t.set(y._xAxis.x,y._yAxis.x,y._zAxis.x,y._xAxis.y,y._yAxis.y,y._zAxis.y,y._xAxis.z,y._yAxis.z,y._zAxis.z);const e=new $P.Matrix3;return e.set(y._xDir.x,y._yDir.x,y._zDir.x,y._xDir.y,y._yDir.y,y._zDir.y,y._xDir.z,y._yDir.z,y._zDir.z),function(n){v.push(n.p.clone().applyMatrix3(t).add(y._origin)),x.push(n.n.clone().applyMatrix3(e))}}();const S=this._indices;let b=0;for(let n=0;n<l-e;n+=e)for(let s=0;s<a-e;s+=e){let a=i.getDirectIdx(0,s,n);for(let i=0;i<o-e;i+=e,a+=c){p[0]=r[a],p[1]=r[a+c],p[3]=r[a+h],p[2]=r[a+c+h],p[4]=r[a+u],p[5]=r[a+c+u],p[7]=r[a+h+u],p[6]=r[a+c+h+u];let e=0,o=0;for(;o<f;++o)p[o]<t&&(e|=1<<o);if(0===iO[e])continue;for(d.cubeIndex=e,o=0;o<f;++o)d.p[o].set(i+m[o].x,s+m[o].y,n+m[o].z),rO(this._gradient,d.p[o],d.g[o]);const l=this._polygonize(d,t,g);for(b+=l,o=0;o<l;++o)S.push(3*this._numTriangles),S.push(3*this._numTriangles+1),S.push(3*this._numTriangles+2),++this._numTriangles,_(g[o].a),_(g[o].b),_(g[o].c)}}return b}compute(t,e,n,i){this._volumetricData=t,this._origin=e,this._gradient=t.computeGradient(),this._doGridPosNorms(n,i,this._prepareAxesAndDirs())}_remapIndices(t,e){const n=this._indices,i=AL.allocateTyped(Uint32Array,e);for(let r=0;r<e;++r)n[r]=t[n[r]],i[r]=n[r];this._indices=i}_remapVertices(t,e,n){const i=AL.allocateTyped(Float32Array,3*n),r=AL.allocateTyped(Float32Array,3*n);for(let s=0;s<n;++s){const n=t[s];i[3*s]=n.x,i[3*s+1]=n.y,i[3*s+2]=n.z;const o=e[s].normalize();r[3*s]=o.x,r[3*s+1]=o.y,r[3*s+2]=o.z}this._position=i,this._normals=r}vertexFusion(t,e){const n=this._indices.length,i=this._position,r=this._normals,s=0|i.length;if(0===n||0===s)return;const o=AL.allocateTyped(Uint32Array,s);o[0]=0;let a=1,l=1;for(;l<s;++l){const n=a-t<0?0:a-t,s=n+e>a?a:n+e;let c=-1;for(let t=n;t<s;++t)if(Math.abs(i[l]-i[t])<Number.EPSILON){c=t;break}-1!==c?o[l]=c:(i[a].copy(i[l]),r[a].copy(r[l]),o[l]=a,++a)}this._remapIndices(o,n),this._remapVertices(i,r,a)}setColorVolTex(t,e,n,i){let r,s;const o=this._position.length/3,a=this._position,l=this._origin,c=this._volumetricData.getDimensions(),h=c[0]-1,u=c[1]-1,d=c[2]-1,p=t.getData(),f=t.getStrideX(),m=t.getStrideY(),g=t.getStrideZ();let _,y,v,x;null!==i&&(_=n.getData(),y=n.getStrideX(),v=n.getStrideY(),x=n.getStrideZ());const S=1/this._xAxis.x,b=1/this._yAxis.y,M=1/this._zAxis.z;let w=[],E=[];const T=AL.allocateTyped(Float32Array,3*o);function A(t,e,n,i){i[0]=(1-t)*p[e]+t*p[n],i[1]=(1-t)*p[e+1]+t*p[n+1],i[2]=(1-t)*p[e+2]+t*p[n+2]}function C(t,n,i,r){const s=e[t];if(null!=s){w[s.index]=s;const e=n*i*r*_[t];void 0===E[s.index]?E[s.index]=e:E[s.index]+=e}}const R=AL.allocateTyped(Int32Array,o);let P=0;for(r=0;r<o;r++){const e=3*r,o=(a[e]-l.x)*S,c=(a[e+1]-l.y)*b,p=(a[e+2]-l.z)*M,_=0|Math.min(Math.max(o,0),h),L=0|Math.min(Math.max(c,0),u),I=0|Math.min(Math.max(p,0),d),N=o-_,D=c-L,O=p-I;if(null!=i){w=[],E=[],s=n.getDirectIdx(_,L,I),C(s,1-N,1-D,1-O),C(s+y,N,1-D,1-O),C(s+v,1-N,D,1-O),C(s+y+v,N,D,1-O),C(s+x,1-N,1-D,O),C(s+y+x,N,1-D,O),C(s+v+x,1-N,D,O),C(s+y+v+x,N,D,O);let t=0,e=-1;for(const n in E)E[n]>t&&(e=n,t=E[n]);if(e<0||!i.includesAtom(w[e])){R[r]=-1;continue}}R[r]=P++;const U=_<h?f:0,F=L<u?m:0,B=I<d?g:0,z=[0,0,0],V=[0,0,0],k=[0,0,0],G=[0,0,0];s=t.getDirectIdx(_,L,I),A(N,s,s+U,z),A(N,s+F,s+U+F,V),A(N,s+B,s+U+B,k),A(N,s+F+B,s+U+F+B,G);const H=[0,0,0];H[0]=(1-D)*z[0]+D*V[0],H[1]=(1-D)*z[1]+D*V[1],H[2]=(1-D)*z[2]+D*V[2];const W=[0,0,0];W[0]=(1-D)*k[0]+D*G[0],W[1]=(1-D)*k[1]+D*G[1],W[2]=(1-D)*k[2]+D*G[2],T[e]=(1-O)*H[0]+O*W[0],T[e+1]=(1-O)*H[1]+O*W[1],T[e+2]=(1-O)*H[2]+O*W[2]}if(this._colors=T,null!=i){for(r=0;r<o;++r){const t=R[r];t<0||(this._position[3*t]=this._position[3*r],this._position[3*t+1]=this._position[3*r+1],this._position[3*t+2]=this._position[3*r+2],this._normals[3*t]=this._normals[3*r],this._normals[3*t+1]=this._normals[3*r+1],this._normals[3*t+2]=this._normals[3*r+2],this._colors[3*t]=this._colors[3*r],this._colors[3*t+1]=this._colors[3*r+1],this._colors[3*t+2]=this._colors[3*r+2])}const t=this._indices.length/3;let e=0;for(r=0;r<t;++r){const t=R[this._indices[3*r]],n=R[this._indices[3*r+1]],i=R[this._indices[3*r+2]];t>=0&&n>=0&&i>=0&&(this._indices[3*e]=t,this._indices[3*e+1]=n,this._indices[3*e+2]=i,++e)}this._position=new Float32Array(this._position.buffer.slice(0,3*P*4)),this._normals=new Float32Array(this._normals.buffer.slice(0,3*P*4)),this._colors=new Float32Array(this._colors.buffer.slice(0,3*P*4)),this._indices=new Uint32Array(this._indices.buffer.slice(0,3*e*4))}}toMesh(){const t=new $P.BufferGeometry;return t.setIndex(new $P.BufferAttribute(this._indices,1)),t.setAttribute("position",new $P.BufferAttribute(this._position,3)),t.setAttribute("normal",new $P.BufferAttribute(this._normals,3)),t.setAttribute("color",new $P.BufferAttribute(this._colors,3)),t.computeBoundingSphere(),t}}const cO=lO,hO=class extends tO{_build(){const t=this._opts;this.numVoxels=[128,128,128],this.xAxis=new $P.Vector3(1,0,0),this.yAxis=new $P.Vector3(0,1,0),this.zAxis=new $P.Vector3(0,0,1),this.origin=new $P.Vector3(0,0,0),this._visibilitySelector=t.visibilitySelector,this._calcSurface(t)}_findMinMax(t){const e=t.length/4,n=[t[0],t[1],t[2],t[3]],i=[t[0],t[1],t[2],t[3]];for(let r=1;r<e;++r){const e=4*r;for(let r=0;r<4;++r){const s=t[e+r];n[r]=Math.max(s,n[r]),i[r]=Math.min(s,i[r])}}return{maxPosRad:n,minPosRad:i}}_findNumVoxels(t,e){const{numVoxels:n}=this,i=this._findMinMax(t),r=i.minPosRad,s=i.maxPosRad;r[3]>4&&(e.gridSpacing*=r[3]);let o=e.radScale*s[3]*1.7,a=o;a=.65*Math.sqrt(4/3*Math.PI*a*a*a),o=Math.max(o,a);let l=0;for(;l<3;++l)r[l]-=o,s[l]+=o;for(l=0;l<3;++l)n[l]=Math.ceil((s[l]-r[l])/e.gridSpacing);return this.xAxis.x=(n[0]-1)*e.gridSpacing,this.yAxis.y=(n[1]-1)*e.gridSpacing,this.zAxis.z=(n[2]-1)*e.gridSpacing,[this.origin.x,this.origin.y,this.origin.z]=r,{bbox:i,dim:n}}_makeSurface(t,e){const n=new cO;n.compute(t.volMap,this.origin,e.isoValue,1),n.vertexFusion(9,9),n._numTriangles>0?(n.setColorVolTex(t.volTexMap,t.atomMap,t.atomWeightMap,this._visibilitySelector),this.setIndex(new $P.BufferAttribute(n._indices,1)),this.setAttribute("position",new $P.BufferAttribute(n._position,3)),this.setAttribute("normal",new $P.BufferAttribute(n._normals,3)),this.setAttribute("color",new $P.BufferAttribute(n._colors,3))):this.setAttribute("position",new $P.BufferAttribute(AL.allocateTyped(Float32Array,0),3))}_calcSurface(t){const e={posRad:this._posRad,colors:this._colors,atoms:this._opts.atoms};if(0===e.posRad.length)return;const n=this._findNumVoxels(e.posRad,t),i=new $P.Box3(this.origin,new $P.Vector3(this.xAxis.x,this.yAxis.y,this.zAxis.z).add(this.origin)),r=this._computeSurface(e,i,n,t);this._makeSurface(r,t)}},{Volume:uO}=DN;function dO(t,e,n,i){const r=t.length/4,s=e[0],o=e[1],a=e[2],l=n[0],c=n[1],h=n[2];function u(t,e){return Math.floor((t-e)/i)}const d=u(l,s)+1,p=u(c,o)+1,f=u(h,a)+1,m=d*p*f,g=p*f,_=function(t,e,n){return(u(t,s)*p+u(e,o))*f+u(n,a)},y=[];let v,x;for(v=0;v<r;v++){const e=4*v;x=_(t[e],t[e+1],t[e+2]),void 0===y[x]?y[x]=[v]:y[x].push(v)}const S=AL.allocateTyped(Uint32Array,m),b=AL.allocateTyped(Uint16Array,m),M=AL.allocateTyped(Uint32Array,r);let w,E=0,T=0;for(v=0;v<m;v++){const t=S[v]=E,e=y[v];if(void 0!==e)for(w=0;w<e.length;w++)M[E]=e[w],E++;const n=E-t;b[v]=n,n>T&&(T=n)}this.neighbourListLength=27*T+1,this.withinRadii=function(e,n,i,r,l){let c=0;const h=u(e,s),m=u(n,o),_=u(i,a),y=Math.max(0,h-1),E=Math.max(0,m-1),T=Math.max(0,_-1),A=Math.min(d-1,h+1),C=Math.min(p-1,m+1),R=Math.min(f-1,_+1);for(v=y;v<=A;++v){const s=v*g;for(w=E;w<=C;++w){const o=w*f;for(let a=T;a<=R;++a){x=s+o+a;const h=S[x],u=h+b[x];for(let s=h;s<u;s++){const o=4*M[s],a=t[o]-e,h=t[o+1]-n,u=t[o+2]-i,d=t[o+3]+r;a*a+h*h+u*u<=d*d&&(l[c++]=M[s])}}}}l[c]=-1}}const pO=function(t,e,n,i){const{posRad:r,colors:s,atoms:o}=t,a=r.length/4,{bbox:l}=e,c=l.minPosRad,h=l.maxPosRad;let u,d,p,f,m,g,_,y,v,x,S,b,M,w,E,T,A=-1,C=null,R=null,P=null;const L=new $P.Vector3(0,0,0),I=new $P.Vector3(0,0,0),N=new $P.Vector3(0,0,0);let D;function O(t,e,n){for(let i=0;i<t.length;i++)t[i]=e+n*i}function U(){({probeRadius:p,scaleFactor:f,probePositions:m,visibilitySelector:P}=n),u=AL.allocateTyped(Float32Array,a),d=0;for(let t=0;t<a;++t){const e=r[4*t+3]+=p;e>d&&(d=e),u[t]=e*e}(function(){({scaleFactor:f}=n),({dim:g}=e),D=Math.min(5,2+Math.floor(p*f));const t=g[0]*g[1]*g[2];_=function(t,e){const n=AL.allocateTyped(t,e);for(let t=0;t<e;++t)n[t]=-1001;return n}(Float32Array,t),y=AL.allocateTyped(Float32Array,3*t),v=AL.allocateTyped(Float32Array,t),P&&(C=AL.allocateTyped(Float32Array,t),R=[]),x=AL.allocateTyped(Float32Array,g[0]),S=AL.allocateTyped(Float32Array,g[1]),b=AL.allocateTyped(Float32Array,g[2]),O(x,c[0],1/f),O(S,c[1],1/f),O(b,c[2],1/f)})(),function(){let t=0;const e=2*Math.PI/m;w=AL.allocateTyped(Float32Array,m),M=AL.allocateTyped(Float32Array,m);for(let n=0;n<m;n++)w[n]=Math.cos(t),M[n]=Math.sin(t),t+=e}(),E=new dO(r,c,h,2.01*d),T=new Int32Array(E.neighbourListLength),A=-1}function F(t,e,n,i){const s=4*t,o=u[t],a=r[s]-e,l=r[s+1]-n,c=r[s+2]-i;return a*a+l*l+c*c<o}function B(t,e,n,i,r){let s;if(-1!==A){if(s=A,s!==i&&s!==r&&F(s,t,e,n))return s;A=-1}let o=0;for(s=T[o];s>=0;){if(s!==i&&s!==r&&F(s,t,e,n))return A=s,s;s=T[++o]}return A=-1,-1}function z(t,e){const n=4*t,i=4*e,s=r[n],o=r[n+1],a=r[n+2],l=r[n+3];let h=L.x=r[i]-s,u=L.y=r[i+1]-o,d=L.z=r[i+2]-a;const p=r[i+3];let y=h*h+u*u+d*d;const v=Math.sqrt(y),E=l*((l*l+v*v-p*p)/(2*l*v));var T,C;L.normalize(),C=L,(T=I).x=T.y=T.z=1,0!==C.x?T.x=(C.y+C.z)/-C.x:0!==C.y?T.y=(C.x+C.z)/-C.y:0!==C.z&&(T.z=(C.x+C.y)/-C.z),I.normalize(),N.crossVectors(L,I),N.normalize();const R=Math.sqrt(l*l-E*E);I.multiplyScalar(R),N.multiplyScalar(R),L.multiplyScalar(E),L.x+=s,L.y+=o,L.z+=a,A=-1;const P=D;for(let n=0;n<m;n++){const i=w[n],r=M[n],s=L.x+i*I.x+r*N.x,o=L.y+i*I.y+r*N.y,a=L.z+i*I.z+r*N.z;if(-1===B(s,o,a,t,e)){const t=Math.floor(f*(s-c[0])),e=Math.floor(f*(o-c[1])),n=Math.floor(f*(a-c[2])),i=Math.max(0,t-P),r=Math.max(0,e-P),l=Math.max(0,n-P),p=Math.min(g[0],t+P+2),m=Math.min(g[1],e+P+2),v=Math.min(g[2],n+P+2);for(let t=l;t<v;t++){d=a-b[t];const e=g[1]*g[0]*t;for(let t=r;t<m;t++){u=o-S[t];const n=d*d+u*u,r=e+g[0]*t;for(let t=i;t<p;t++){h=s-x[t],y=n+h*h;const e=t+r,i=_[e];i>0&&y<i*i&&(_[e]=Math.sqrt(y))}}}}}}this.build=function(){console.time("ContactSurface.getVolume"),console.time("ContactSurface.init"),U(),console.timeEnd("ContactSurface.init"),console.time("ContactSurface.projectPoints"),function(){for(let t=0;t<a;t++){const e=4*t,n=r[e],i=r[e+1],a=r[e+2],l=r[e+3],h=u[t];E.withinRadii(n,i,a,l,T);const d=Math.ceil(l*f),p=Math.floor(f*(n-c[0])),m=Math.floor(f*(i-c[1])),M=Math.floor(f*(a-c[2])),w=Math.max(0,p-d),A=Math.max(0,m-d),L=Math.max(0,M-d),I=Math.min(g[0],p+d+2),N=Math.min(g[1],m+d+2),D=Math.min(g[2],M+d+2),O=3*t,U=s[O],F=s[O+1],z=s[O+2];for(let e=L;e<D;e++){const r=b[e]-a,s=g[1]*g[0]*e;for(let e=A;e<N;e++){const c=S[e]-i,u=r*r+c*c,d=s+g[0]*e;for(let e=w;e<I;e++){const s=e+d,p=x[e]-n,f=u+p*p;if(f<h){const e=Math.exp(.28125*-f),h=3*s;y[h]+=U*e,y[h+1]+=F*e,y[h+2]+=z*e,v[s]+=e,null!==P&&e>C[s]&&(C[s]=e,R[s]=o[t]),_[s]<0&&(_[s]=-_[s]);const u=Math.sqrt(f),d=l/u;let m=p*d,g=c*d,x=r*d;if(m+=n,g+=i,x+=a,-1===B(m,g,x,t,-1)){const t=l-u;t<_[s]&&(_[s]=t)}}}}}}}(),console.timeEnd("ContactSurface.projectPoints"),console.time("ContactSurface.projectTorii"),function(){for(let t=0;t<a;t++){const e=4*t;E.withinRadii(r[e],r[e+1],r[e+2],r[e+3],T);let n=0,i=T[n];for(;i>=0;)t<i&&z(t,i),i=T[++n]}}(),console.timeEnd("ContactSurface.projectTorii"),function(){for(let t=0,e=_.length;t<e;t++){_[t]<0&&(_[t]=0);let e=v[t];if(e>0){e=1/e;const n=3*t;y[n]*=e,y[n+1]*=e,y[n+2]*=e}}}(),console.timeEnd("ContactSurface.getVolume"),this.volTexMap=y,this.weightsMap=C,this.atomMap=R,this.volMap=_}},{Volume:fO}=DN,mO=class{constructor(t,e){this.coord=new $P.Vector3,this.coord.copy(t),this.radius=e,this.colorX=.99999,this.colorY=0,this.colorZ=0,this.atomType=0,this.srcAtom=null}},gO=class{constructor(t,e,n,i,r){this._numAtoms=t,this._atoms=e,this._vBoxMin=new $P.Vector3,this._vBoxMax=new $P.Vector3,this._vBoxMin.copy(n),this._vBoxMax.copy(i),this._probeRadius=r,this._atomsList=null,this._voxelList=null}createVoxels(){let t,e;const n=0|this._numAtoms,i=this._atoms,r=this._vBoxMax.x-this._vBoxMin.x,s=this._vBoxMax.y-this._vBoxMin.y,o=this._vBoxMax.z-this._vBoxMin.z;let a=r<s?r:s;a=o<a?o:a;let l,c=0,h=0;for(l=0;l<n;l++)e=2*(i[l].radius+this._probeRadius),c=e>c?e:c,h+=e;let u=Math.floor(a/c);u<2&&(u=2),h/=n,this._numCells=u,this._aveRad=h,this._maxRad=c;const d=u,p=u*u,f=u*u*u,m=this._xScale=1/(this._vBoxMax.x-this._vBoxMin.x),g=this._yScale=1/(this._vBoxMax.y-this._vBoxMin.y),_=this._zScale=1/(this._vBoxMax.z-this._vBoxMin.z);let y=0;const v=m*u,x=g*u,S=_*u;for(l=0;l<n;l++){const t=4.5*(i[l].radius+this._probeRadius)*2;let e=Math.floor(v*t+.8),n=Math.floor(x*t+.8),r=Math.floor(S*t+.8);e++,n++,r++,y+=e*n*r}this._voxelList=AL.allocateTyped(Int32Array,f);const b=[];if(b.length=y,null===this._voxelList||null===b)return-1;for(l=0;l<f;l++)this._voxelList[l]=-1;for(t=0,l=0;l<n;l++){e=4.5*(i[l].radius+this._probeRadius);let n=Math.floor((i[l].coord.x-this._vBoxMin.x-e)*u*m),r=Math.floor((i[l].coord.y-this._vBoxMin.y-e)*u*g),s=Math.floor((i[l].coord.z-this._vBoxMin.z-e)*u*_),o=Math.floor((i[l].coord.x-this._vBoxMin.x+e)*u*m),a=Math.floor((i[l].coord.y-this._vBoxMin.y+e)*u*g),c=Math.floor((i[l].coord.z-this._vBoxMin.z+e)*u*_);n=n>=0?n:0,r=r>=0?r:0,s=s>=0?s:0,o=o<u?o:u-1,a=a<u?a:u-1,c=c<u?c:u-1;for(let e=s;e<=c;e++)for(let i=r;i<=a;i++)for(let r=n;r<=o;r++){const n=r+i*d+e*p;if(this._voxelList[n]<0){b[2*t+0]=l,b[2*t+1]=-1,this._voxelList[n]=t,t++;continue}const s=this._voxelList[n];this._voxelList[n]=t,b[2*t+0]=l,b[2*t+1]=s,t++}}return this._atomsList=Int32Array.from(b),0}destroyVoxels(){this._atomsList=null,this._voxelList=null,this._atoms=null,this._vertices=null,this._vBoxMin=null,this._vBoxMax=null}forEachRelatedAtom(t,e){const n=Math.floor((t.x-this._vBoxMin.x)*this._numCells*this._xScale),i=Math.floor((t.y-this._vBoxMin.y)*this._numCells*this._yScale),r=Math.floor((t.z-this._vBoxMin.z)*this._numCells*this._zScale),s=n+i*this._numCells+r*this._numCells*this._numCells,o=this._atoms;for(let t=this._voxelList[s];t>=0;t=this._atomsList[2*t+1])e(o[this._atomsList[2*t]])}getClosestAtom(t){let e=null,n=Number.MAX_VALUE;return this.forEachRelatedAtom(t,i=>{const r=t.distanceToSquared(i.coord);r<n&&(n=r,e=i)}),e}buildNormals(t,e,n){const i=this;let r,s=0,o=0,a=0,l=0,c=0,h=0,u=0,d=0,p=0;const f=2.5*this._aveRad,m=f*f,g=.1*-this._aveRad,_=function(t){const e=o-t.coord.x,n=a-t.coord.y,f=l-t.coord.z;if(r=e*e+n*n+f*f,r>m)return;const _=t.radius+i._probeRadius;d=r-_*_,d<0&&(d=-d),p=Math.exp(g*d),c+=e*p,h+=n*p,u+=f*p,s++};let y=0;for(let i=0;i<t;i++)o=e[i].x,a=e[i].y,l=e[i].z,s=0,c=h=u=0,this.forEachRelatedAtom(e[i],_),y=s>y?s:y,r=c*c+h*h+u*u,s>0&&(d=1/Math.sqrt(r),c*=d,h*=d,u*=d),n[i].x=c,n[i].y=h,n[i].z=u;return 0}buildColors(t,e,n,i){const r=this;let s=0,o=0,a=0,l=0,c=0;const h=i*i;let u=[],d=[],p=0;const f=function(t){const e=s-t.coord.x,n=o-t.coord.y,i=a-t.coord.z,f=e*e+n*n+i*i;if(f>h)return;const m=t.radius+r._probeRadius;l=f-m*m,l<0&&(l=-l),c=1/(.8+l),u.push([t.colorX,t.colorY,t.colorZ]),d.push(c),p+=c};for(let i=0;i<t;i++){s=e[i].x,o=e[i].y,a=e[i].z,u=[],d=[],p=0,this.forEachRelatedAtom(e[i],f);for(let t=0;t<u.length;++t){const e=d[t]/p;n[i].x+=u[t][0]*e,n[i].y+=u[t][1]*e,n[i].z+=u[t][2]*e}}return 0}},_O=class{constructor(t,e,n){let i;for(this._maxNumVertices=t,this._maxNumTriangles=e,this._vertices=new Array(t),this._normals=new Array(t),this._colors=null,n&&(this._colors=new Array(t)),this._indices=new Array(3*e),this._numVertices=0,this._numTriangles=0,i=0;i<t;i++)this._vertices[i]=new $P.Vector3,this._normals[i]=new $P.Vector3;for(i=0;i<3*e;i++)this._indices[i]=-1;if(n)for(i=0;i<t;i++)this._colors[i]=new $P.Vector3}destroy(){this._vertices=null,this._normals=null,this._indices=null}},{Element:yO}=DN,vO={InstancedSpheresGeometry:rD,SimpleSpheresGeometry:cD,Simple2CCylindersGeometry:pD,Instanced2CCylindersGeometry:MD,ExtrudedObjectsGeometry:class extends aD{constructor(t,e,n){const i=function(t,e){const n=new $P.BufferGeometry,i=t.length,r=i*e,s=r<=65536?Uint16Array:Uint32Array,o=(e-1)*i*2,a=new $P.BufferAttribute(AL.allocateTyped(s,3*o),1);let l=0,c=0;for(let t=0;t<e;t++){if(t!==e-1)for(let t=0;t<i;t++){const e=l+t,n=l+i+t,r=l+i+(t+1)%i,s=l+(t+1)%i;a.setXYZ(3*c,e,s,n),c++,a.setXYZ(3*c,n,s,r),c++}l+=i}n.setIndex(a);const h=AL.allocateTyped(Float32Array,3*r);return n.setAttribute("position",new $P.BufferAttribute(h,3)),n._positions=t,n}(t,e);super(i,n),this._ringsCount=e;const r=this._tmpShape=[];for(let e=0;e<t.length;++e)r[e]=new $P.Vector3}setItem(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=this._chunkGeo._positions.length,s=this._ringsCount,o=r*this._ringsCount*t*3;this._setPoints(e,r,s,o),n?this._setSlopeNormals(r,s,o):this._setBaseNormals(r,s,o),i&&this._addCut(r,s,o)}_setPoints(t,e,n,i){const r=this._tmpShape,s=this._positions,o=this._chunkGeo._positions;for(let a=0,l=i;a<n;++a){const n=t[a];for(let t=0;t<e;++t,l+=3)r[t].copy(o[t]).applyMatrix4(n).toArray(s,l)}}_setBaseNormals(t,e,n){const i=3*t;for(let r=0,s=n;r<e;++r,s+=i)this._countNormalsInRing(t,s,!1)}_setSlopeNormals(t,e,n){const i=this._normals,r=3*t;let s=n;for(let e=0;e<t;++e,s+=3)AD.toArray(i,s);if(s-2*r>0)for(let e=0;e<t;++e,s+=3)TD.fromArray(i,s-2*r).toArray(i,s);else this._countNormalsInRing(t,s,!0,+r),s+=r;for(let n=2;n<e;++n,s+=r)this._countNormalsInRing(t,s,!0,-r)}_countNormalsInRing(t,e,n,i){const r=this._tmpShape,s=this._normals;r[0].fromArray(this._positions,e),r[t-1].fromArray(this._positions,e+3*(t-1));for(let o=0;o<t;++o,e+=3)o<t-1&&r[o+1].fromArray(this._positions,e+3),n?(RD.fromArray(this._positions,e+i),wD.subVectors(r[(o+t-1)%t],r[(o+1)%t]).normalize(),ED.subVectors(r[o],RD).normalize(),TD.crossVectors(ED,wD).normalize().toArray(s,e)):(wD.subVectors(r[o],r[(o+t-1)%t]).normalize(),ED.subVectors(r[o],r[(o+1)%t]).normalize(),TD.addVectors(wD,ED).normalize().toArray(s,e))}_addCut(t,e,n){if(t<3||e<2)return;const i=this._positions,r=this._normals,s=this._tmpShape,o=3*t;s[0].fromArray(i,n),s[1].fromArray(i,n+3),s[2].fromArray(i,n+6),wD.subVectors(s[1],s[0]).normalize(),ED.subVectors(s[1],s[2]).normalize(),CD.crossVectors(wD,ED).normalize();let a=n;for(let e=0;e<2*t;++e,a+=3)CD.toArray(r,a);if(e>2)for(let e=0;e<t;++e,a+=3)TD.fromArray(i,a-o).toArray(i,a)}},ChunkedLinesGeometry:GD,TwoColorLinesGeometry:jD,CrossGeometry:JD,QuickSurfGeometry:class extends hO{_computeSurface(t,e,n,i){this._shiftByOrigin(t.posRad);const r={volMap:new uO(Float32Array,this.numVoxels,e),volTexMap:new uO(Float32Array,this.numVoxels,e,3)};return null!=this._visibilitySelector&&(r.atomMap=[],r.atomWeightMap=new uO(Float32Array,this.numVoxels,e)),this.gaussdensity(r,t,null,i),r}gaussdensity(t,e,n,i){const r=e.posRad.length/4,{posRad:s,colors:o}=e,{numVoxels:a}=this,{radScale:l,gaussLim:c,gridSpacing:h}=i,u=1/i.isoValue,d=1/h,p=a[0]-1,f=a[1]-1,m=a[2]-1,{volMap:g,volTexMap:_}=t,y=g.getData(),v=g.getStrideX(),x=_.getData(),S=_.getStrideX();let b;null!=this._visibilitySelector&&(b=t.atomWeightMap.getData());const{atomMap:M}=t;for(let t=0;t<r;++t){const i=4*t,r=s[i+3]*l,a=null===n?1:n[t],w=1/(2*r*r);let E=c*r;const T=E*E;E*=d;let A=s[i]*d;const C=Math.max(A-E|0,0),R=Math.min(A+E|0,p);A=s[i+1]*d;const P=Math.max(A-E|0,0),L=Math.min(A+E|0,f);A=s[i+2]*d;const I=Math.max(A-E|0,0),N=Math.min(A+E|0,m);let D=I*h-s[i+2];for(let n=I;n<=N;++n,D+=h){let r=P*h-s[i+1];for(let l=P;l<=L;++l,r+=h){const c=r*r+D*D;if(c>=T)continue;let d=g.getDirectIdx(C,l,n),p=_.getDirectIdx(C,l,n),f=C*h-s[i];for(let n=C;n<=R;++n,f+=h,d+=v,p+=S){const n=-(f*f+c)*w;let i=Math.exp(n)*a;null!=this._visibilitySelector&&i>b[d]&&(b[d]=i,M[d]=e.atoms[t]),y[d]+=i,i*=u;const r=3*t;x[p]+=i*o[r],x[p+1]+=i*o[r+1],x[p+2]+=i*o[r+2]}}}}}_shiftByOrigin(t){const e=this.origin.x,n=this.origin.y,i=this.origin.z,r=t.length/4;for(let s=0;s<r;++s){const r=4*s;t[r]-=e,t[r+1]-=n,t[r+2]-=i}}},ContactSurfaceGeometry:class extends hO{_computeSurface(t,e,n,i){const r=new pO(t,n,i);return r.build(),{volMap:new fO(Float32Array,this.numVoxels,e,1,r.volMap),volTexMap:new fO(Float32Array,this.numVoxels,e,3,r.volTexMap),atomMap:r.atomMap,atomWeightMap:new fO(Float32Array,this.numVoxels,e,1,r.weightsMap)}}},SSIsosurfaceGeometry:class extends tO{_build(){this._innerBuild();const t=this.getGeo();this.destroy(),this._fromGeo(t)}_fromGeo(t){let e=null;const n=AL.allocateTyped(Float32Array,3*t._numVertices),i=AL.allocateTyped(Float32Array,3*t._numVertices);null!==t._colors&&(e=AL.allocateTyped(Float32Array,3*t._numVertices));const r=AL.allocateTyped(Uint32Array,3*t._numTriangles);for(let e=0,r=0;e<t._numVertices;e++)n[r+0]=t._vertices[e].x,n[r+1]=t._vertices[e].y,n[r+2]=t._vertices[e].z,i[r+0]=t._normals[e].x,i[r+1]=t._normals[e].y,i[r+2]=t._normals[e].z,r+=3;if(null!==e)for(let n=0,i=0;n<t._numVertices;n++,i+=3)e[i+0]=t._colors[n].x,e[i+1]=t._colors[n].y,e[i+2]=t._colors[n].z;const s=3*t._numTriangles;for(let e=0;e<s;e++)r[e]=t._indices[e];this.setIndex(new $P.BufferAttribute(r,1)),this.setAttribute("position",new $P.BufferAttribute(n,3)),this.setAttribute("normal",new $P.BufferAttribute(i,3)),this.setAttribute("color",new $P.BufferAttribute(e,3)),this.computeBoundingBox(),this.computeBoundingSphere(),t.destroy()}convertToAtomsColored(t,e){const{atoms:n,colors:i}=t;for(let t=0,r=n.length;t<r;t++){const r=n[t].position,{radius:s}=n[t].element;e[t]=new mO(r,s);const o=n[t].element.number;e[t].atomType=this.getType(o);let a=3*t;e[t].colorX=i[a++],e[t].colorY=i[a++],e[t].colorZ=i[a],e[t].srcAtom=n[t]}}getGeo(){return this.geoOut}destroy(){this.atoms=null,this.hashLines=null,this.hashEntries=null}getBoundingBox(t,e,n){const i=1e7;e.x=e.y=e.z=i,n.x=n.y=n.z=0-i;const r=this.probeRadius*this.atomRadiusScale;let s=0;for(let i=0,o=t.length;i<o;i++){const o=t[i].coord,a=t[i].radius+r;s=a>s?a:s,o.x-a<e.x&&(e.x=o.x-a),o.y-a<e.y&&(e.y=o.y-a),o.z-a<e.z&&(e.z=o.z-a),o.x+a>n.x&&(n.x=o.x+a),o.y+a>n.y&&(n.y=o.y+a),o.z+a>n.z&&(n.z=o.z+a)}e.x-=s,e.y-=s,e.z-=s,n.x+=s,n.y+=s,n.z+=s}getCornerCoord(t,e,n,i,r,s,o){const a=1/(s-1),l=n*a,c=i*a,h=r*a;o.x=t.x*(1-l)+e.x*l,o.y=t.y*(1-c)+e.y*c,o.z=t.z*(1-h)+e.z*h}buildEdgePoint(t,e,n,i,r,s){if(n[t]^n[e]){const n=24,o=(0-i.pointsValuesLinear[r+n+t])/(i.pointsValuesLinear[r+n+e]-i.pointsValuesLinear[r+n+t]),a=i.pointsValuesLinear[r+3*t+0],l=i.pointsValuesLinear[r+3*t+1],c=i.pointsValuesLinear[r+3*t+2],h=i.pointsValuesLinear[r+3*e+0],u=i.pointsValuesLinear[r+3*e+1],d=i.pointsValuesLinear[r+3*e+2];s.x=a*(1-o)+h*o,s.y=l*(1-o)+u*o,s.z=c*(1-o)+d*o}}isTriangleVisible(t,e,n){const i=this.voxelWorld.getClosestAtom(t),r=this.voxelWorld.getClosestAtom(e),s=this.voxelWorld.getClosestAtom(n);return null!==i&&null!==r&&null!==s&&null!==i.srcAtom&&null!==r.srcAtom&&null!==s.srcAtom&&this.visibilitySelector.includesAtom(i.srcAtom)&&this.visibilitySelector.includesAtom(r.srcAtom)&&this.visibilitySelector.includesAtom(s.srcAtom)}addTriangle(t,e,n){if(this.visibilitySelector&&!this.isTriangleVisible(t,e,n))return!0;const i=this.geoOut;if(i._numTriangles>=this.maxNumTriangles)return!1;const r=this.addVertexToGeo(i,t),s=this.addVertexToGeo(i,e),o=this.addVertexToGeo(i,n);if((r|s|o)<0)return!1;const a=3*i._numTriangles;return i._indices[a+0]=r,i._indices[a+1]=s,i._indices[a+2]=o,i._numTriangles++,!0}buildGeoFromCorners(t,e,n,i,r,s){const o=t-1,a=t,l=t*t,c=new Array(12);for(let t=0;t<12;t++)c[t]=new $P.Vector3;const h=[];for(let t=0;t<8;t++)h[t]=1;const u=new $P.Vector3;let d=0,p=0;for(let i=0;i<o;i++,p+=l){let l=0;for(let p=0;p<o;p++,l+=a)for(let a=0;a<o;a++){if(!s.hasIntersection[d]){d++;continue}const o=s.bitsInside[d];this.getCornerCoord(e,n,a,i,p,t,u);const l=32*d;for(let t=0,e=0;t<8;t++)s.pointsValuesLinear[l+e++]=u.x,s.pointsValuesLinear[l+e++]=u.y,s.pointsValuesLinear[l+e++]=u.z;s.pointsValuesLinear[l+3]+=r.x,s.pointsValuesLinear[l+6]+=r.x,s.pointsValuesLinear[l+15]+=r.x,s.pointsValuesLinear[l+18]+=r.x,s.pointsValuesLinear[l+6+2]+=r.z,s.pointsValuesLinear[l+9+2]+=r.z,s.pointsValuesLinear[l+18+2]+=r.z,s.pointsValuesLinear[l+21+2]+=r.z,s.pointsValuesLinear[l+12+1]+=r.y,s.pointsValuesLinear[l+15+1]+=r.y,s.pointsValuesLinear[l+18+1]+=r.y,s.pointsValuesLinear[l+21+1]+=r.y;const f=l+24;for(let t=0;t<8;++t)h[t]=s.pointsValuesLinear[f+t]<0?1:0;this.buildEdgePoint(0,1,h,s,l,c[0]),this.buildEdgePoint(1,2,h,s,l,c[1]),this.buildEdgePoint(2,3,h,s,l,c[2]),this.buildEdgePoint(3,0,h,s,l,c[3]),this.buildEdgePoint(4,5,h,s,l,c[4]),this.buildEdgePoint(5,6,h,s,l,c[5]),this.buildEdgePoint(6,7,h,s,l,c[6]),this.buildEdgePoint(7,4,h,s,l,c[7]),this.buildEdgePoint(0,4,h,s,l,c[8]),this.buildEdgePoint(1,5,h,s,l,c[9]),this.buildEdgePoint(2,6,h,s,l,c[10]),this.buildEdgePoint(3,7,h,s,l,c[11]);const m=16*o;for(let t=0,e=0;t<6;t++,e+=3){const t=s.striIndicesMarchCube[m+e];if(t<0)break;const n=s.striIndicesMarchCube[m+e+1],i=s.striIndicesMarchCube[m+e+2];if(!this.addTriangle(c[t],c[n],c[i]))return-2}d++}}return 0}getNumIntersectedCells(t,e,n,i){const r=t*t;let s=0,o=0,a=0;for(let l=0;l<e;l++,a+=r){let l=0;for(let c=0;c<e;c++,l+=t)for(let c=0;c<e;c++){const e=32*o+24,h=c+l+a;i.pointsValuesLinear[e]=n[h],i.pointsValuesLinear[e+1]=n[h+1],i.pointsValuesLinear[e+2]=n[h+t+1],i.pointsValuesLinear[e+3]=n[h+t],i.pointsValuesLinear[e+4]=n[r+h],i.pointsValuesLinear[e+5]=n[r+h+1],i.pointsValuesLinear[e+6]=n[r+h+t+1],i.pointsValuesLinear[e+7]=n[r+h+t];let u=0;for(let t=0;t<8;++t)i.pointsValuesLinear[e+t]<0&&(u|=1<<t);0===u||255===u?i.hasIntersection[o]=!1:(i.hasIntersection[o]=!0,s++),i.bitsInside[o]=u,o++}}return s}getType(t){const e=[0,0,1,1,2,6,3,6,4,6,5,6,6,0,7,3,8,2,9,6,10,6,11,6,12,6,13,6,14,6,15,4,16,5,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6,28,6,29,6,30,6,31,6,32,6,33,6,34,6,35,6,36,6,37,6,38,6,39,6,40,6,41,6,42,6,43,6,44,6,45,6,46,6,47,6,48,6,49,6,50,6,51,6,52,6,53,6,54,6,55,6,56,6,57,6,58,6,59,6,60,6,61,6,62,6,63,6,64,6,65,6,66,6,67,6,68,6,69,6,70,6,71,6,72,6,73,6,74,6,75,6,76,6,77,6,78,6,79,6,80,6,81,6,82,6,83,6,84,6,85,6,86,6,87,6,88,6,89,6,90,6,91,6,92,6,93,6,94,6,95,6,96,6,97,6,98,6,99,6,100,6,101,6,102,6,103,6,104,6,105,6,106,6,107,6,108,6,109,6];if(t<1||t>e.length/2||2*Object.keys(yO.ByAtomicNumber).length!==e.length)throw new Error("atomT.length  should be equal Element.ByAtomicNumber.length * 2");return e[2*t]}calculateGridCorners(t,e,n,i,r,s){const o=e*e,a=o*e,l=new $P.Vector3,c=new $P.Vector3;for(let e=0;e<a;e++)t[e]=1e12;const h=(e-1)/(i.x-n.x),u=(e-1)/(i.y-n.y),d=(e-1)/(i.z-n.z);for(let a=0,p=r.length;a<p;a++){const p=r[a],f=p.radius+s,m=(p.coord.x-f-n.x)*h,g=(p.coord.y-f-n.y)*u,_=(p.coord.z-f-n.z)*d,y=Math.floor(m),v=Math.floor(g),x=Math.floor(_);let S=Math.floor((p.coord.x+f-n.x)*h),b=Math.floor((p.coord.y+f-n.y)*u),M=Math.floor((p.coord.z+f-n.z)*d);S++,b++,M++,S=S<=e-1?S:e-1,b=b<=e-1?b:e-1,M=M<=e-1?M:e-1;for(let r=v;r<=b;r++){const s=r*o;for(let o=x;o<=M;o++){const a=o*e;for(let h=y;h<=S;h++){const u=s+a+h;this.getCornerCoord(n,i,h,r,o,e,l),c.x=l.x-p.coord.x,c.y=l.y-p.coord.y,c.z=l.z-p.coord.z;const d=Math.sqrt(c.x*c.x+c.y*c.y+c.z*c.z)-f;d<t[u]&&(t[u]=d)}}}}}createVertexHash(t,e){if(this.hashLines=AL.allocateTyped(Int32Array,65536),null===this.hashLines)return-1;for(let t=0,e=0;t<32768;t++)this.hashLines[e++]=0,this.hashLines[e++]=-1;if(this.maxNumVertices=t,this.maxNumTriangles=e,this.numHashEtriesAllocated=t,this.hashEntries=AL.allocateTyped(Int32Array,2*this.numHashEtriesAllocated),null===this.hashEntries)return-1;for(let t=0,e=0;t<this.numHashEtriesAllocated;t++)this.hashEntries[e++]=-1,this.hashEntries[e++]=-1;return this.numHashEntryIndex=0,0}getNewHashEntry(){if(this.numHashEntryIndex<this.numHashEtriesAllocated){const t=this.numHashEntryIndex;return this.numHashEntryIndex++,t}return-1}addVertexToGeo(t,e){let n;const i=.01,r=this.marCubeResoultion<<2,s=new $P.Vector3,o=Math.floor(r*(e.x-this.vBoxMin.x)/(this.vBoxMax.x+i-this.vBoxMin.x)),a=Math.floor(r*(e.y-this.vBoxMin.y)/(this.vBoxMax.y+i-this.vBoxMin.y));let l=815851*o+37633*Math.floor(r*(e.z-this.vBoxMin.z)/(this.vBoxMax.z+i-this.vBoxMin.z))+2453543*a;l&=32767;const c=l+l;if(null!==this.vBoxMin&&null!==this.vBoxMax)for(n=this.hashLines[c+1];n>=0;n=this.hashEntries[2*n+1]){const i=this.hashEntries[2*n+0];if(s.copy(t._vertices[i]),s.x-=e.x,s.y-=e.y,s.z-=e.z,s.x*s.x+s.y*s.y+s.z*s.z<1e-6)return i}if(t._numVertices>=this.maxNumVertices)return-1;const h=t._numVertices;if(t._vertices[h].copy(e),null!==this.vBoxMin&&null!==this.vBoxMax){if(n=this.getNewHashEntry(),n<0)return-1;const t=this.hashLines[c+1];this.hashLines[c+1]=n,this.hashEntries[2*n+0]=h,this.hashEntries[2*n+1]=t,this.hashLines[c+0]++}return t._numVertices++,h}modifyExcludedFromGeo(t,e,n,i,r,s){let o,a,l;function c(){l>0?(s[o]<0&&(s[o]=l),l>s[o]&&(s[o]=l)):l>s[o]&&(s[o]=l)}const h=t*t,u=(t-1)/(i.x-n.x),d=(t-1)/(i.y-n.y),p=(t-1)/(i.z-n.z),f=2*e*(2*e),m=1/(t-1);for(let s=0;s<r._numVertices;s++){const g=r._vertices[s],_=1.1*e;let y=Math.floor((g.x-_-n.x)*u),v=Math.floor((g.y-_-n.y)*d),x=Math.floor((g.z-_-n.z)*p),S=Math.floor((g.x+_-n.x)*u),b=Math.floor((g.y+_-n.y)*d),M=Math.floor((g.z+_-n.z)*p);y=y>=0?y:0,v=v>=0?v:0,x=x>=0?x:0,S=S<=t-1?S:t-1,b=b<=t-1?b:t-1,M=M<=t-1?M:t-1;for(let r=v;r<=b;r++){const s=r*h;for(let h=x;h<=M;h++){const u=h*t;for(let t=y;t<=S;t++){o=s+u+t;let d=t*m;const p=n.x*(1-d)+i.x*d;d=r*m;const _=n.y*(1-d)+i.y*d;d=h*m;const y=n.z*(1-d)+i.z*d,v=p-g.x,x=_-g.y,S=y-g.z,b=v*v+x*x+S*S;b<f&&(a=Math.sqrt(b),l=-(a-e),c())}}}}return 0}_innerBuild(){let t;const e=1.2,n={posRad:this._posRad,colors:this._colors,atoms:this._opts.atoms};this.complex=this._opts.parent,this.atoms=n.atoms,this.meshResolution=this._opts.gridSpacing,this.atomRadiusScale=this._opts.radScale,this.colorMode=this._opts.colorMode,this.probeRadius=this._opts.probeRadius,this.useVertexColors=!0,this.excludeProbe=this._opts.excludeProbe,this.visibilitySelector=this._opts.visibilitySelector,this.geoOut=null,this.hashLines=null,this.hashEntries=null,this.numHashEtriesAllocated=0,this.numHashEntryIndex=0,this.maxNumVertices=0,this.maxNumTriangles=0;const i=new Array(this.atoms.length);this.convertToAtomsColored(n,i);const r=this.vBoxMin=new $P.Vector3,s=this.vBoxMax=new $P.Vector3;this.getBoundingBox(i,r,s);const o=this.marCubeResoultion=4*this.meshResolution,a=o,l=a*a*a,c=AL.allocateTyped(Float32Array,l),h=this.probeRadius*this.atomRadiusScale;this.calculateGridCorners(c,a,r,s,i,h);const u=o-1,d=new nO;if(t=d.create(u),t<0)return t;const p=new $P.Vector3;p.x=(s.x-r.x)/u,p.y=(s.y-r.y)/u,p.z=(s.z-r.z)/u;let f=this.getNumIntersectedCells(a,u,c,d),m=Math.floor(f*e),g=Math.floor(f*e*2);if(this.geoOut=new _O(m,g,this.useVertexColors),t=this.createVertexHash(m,g),t<0)return t;let _=h;if(this.excludeProbe&&(_=.01),this.voxelWorld=new gO(i.length,i,r,s,_),this.voxelWorld.createVoxels(),t=this.buildGeoFromCorners(o,r,s,c,p,d),this.excludeProbe){if(this.modifyExcludedFromGeo(a,h,r,s,this.geoOut,c),this.geoOut._vertices=null,this.geoOut._colors=null,this.geoOut._indices=null,this.geoOut._normals=null,this.geoOut._numVertices=0,this.geoOut._numTriangles=0,this.geoOut=null,f=this.getNumIntersectedCells(a,u,c,d),m=Math.floor(f*e),g=Math.floor(f*e*2),this.geoOut=new _O(m,g,this.useVertexColors),t=this.createVertexHash(m,g),t<0)return t;t=this.buildGeoFromCorners(a,r,s,c,p,d)}this.voxelWorld.buildNormals(this.geoOut._vertices.length,this.geoOut._vertices,this.geoOut._normals);let y=6.5;return this.excludeProbe&&(y-=1.5),this.useVertexColors&&this.voxelWorld.buildColors(this.geoOut._vertices.length,this.geoOut._vertices,this.geoOut._colors,y),this.voxelWorld.destroyVoxels(),this.voxelWorld=null,d.destroy(),t}},LabelsGeometry:class extends hL{constructor(t,e){super(),this._opts=e,this.items=[],this.needsUpdate=!1;let n=-50,i=-50;switch(e.horizontalAlign){case"left":n=0;break;case"right":n=-100}switch(e.verticalAlign){case"top":i=-100;break;case"bottom":i=0}const r=new $P.Vector3(e.dx||0,e.dy||0,e.dz||0);this.userData={translation:`translate(${n}%, ${i}%)`,offset:r}}setItem(t,e,n){const i=this._opts,r=this.items[t]||function(t){const e=document.createElement("div");if(e.className="label","string"==typeof t){const n=document.createElement("span");n.style.fontSize="150%";const i=t.split("\n");for(let t=0,e=i.length;t<e;++t){const r=document.createElement("span"),s=document.createTextNode(i[t]);r.appendChild(s),n.appendChild(r),t<e-1&&n.appendChild(document.createElement("br"))}e.appendChild(n)}else e.appendChild(t);return e.worldPos=new $P.Vector3,e}(n);r.worldPos.copy(e),r.style.textAlign=i.horizontalAlign,r.style.verticalAlign=i.verticalAlign,this.items[t]=r}setColor(t,e,n){this.items[t].opts={color:e,background:n}}startUpdate(){return!0}finishUpdate(){this.needsUpdate=!0,this.dispatchEvent({type:"update"})}finalize(){this.finishUpdate()}raycast(){}setOpacity(){}getSubset(){return[]}}},xO={precision:"mediump",init(t){this.precision=t.capabilities.getMaxPrecision("highp")}},SO=new Uint8Array([24,52,0,255,254,145,0,255,122,0,0,255,7,170,0,255,34,214,0,255,173,8,0,255,86,249,0,255,160,4,0,255,226,46,0,255,224,211,0,255,3,157,0,255,174,247,0,255,12,182,0,255,220,216,0,255,1,109,0,255,253,154,0,255]),bO=$P.RepeatWrapping,MO=$P.RepeatWrapping,wO=$P.NearestFilter,EO=$P.NearestFilter,TO=$P.UVMapping,AO=new $P.DataTexture(SO,4,4,$P.RGBAFormat,$P.UnsignedByteType,TO,bO,MO,EO,wO,1);AO.needsUpdate=!0;const CO={noiseWidth:4,noiseHeight:4,noiseTexture:AO},RO=[new $P.Vector2(-.541978,.840393),new $P.Vector2(.125533,-.992089),new $P.Vector2(.374329,.927296),new $P.Vector2(-.105475,.994422)],PO=$P.UniformsUtils.merge([$P.UniformsLib.fog,$P.UniformsLib.lights,{diffuse:{value:new $P.Color(15658734)},opacity:{value:1},specular:{type:"c",value:new $P.Color(1118481)},shininess:{type:"f",value:30},fixedColor:{type:"c",value:new $P.Color(16777215)},zOffset:{type:"f",value:0},zClipValue:{type:"f",value:0},clipPlaneValue:{type:"f",value:0},nearPlaneValue:{type:"f",value:-.5},invModelViewMatrix:{type:"4fv",value:new $P.Matrix4},world2colorMatrix:{type:"4fv",value:new $P.Matrix4},dashedLineSize:{type:"f",value:.1},dashedLinePeriod:{type:"f",value:.2},projMatrixInv:{type:"4fv",value:new $P.Matrix4},viewport:{type:"v2",value:new $P.Vector2},lineWidth:{type:"f",value:2},fogAlpha:{type:"f",value:1},samplesKernel:{type:"v2v",value:null},noiseTex:{type:"t",value:null},noiseTexelSize:{type:"v2",value:null},srcTexelSize:{type:"v2",value:null}}]),LO=["shininess","opacity","zOffset","diffuse","specular","fixedColor","zClipCoef","zClipValue","clipPlaneValue","world2colorMatrix","dashedLineSize","dashedLinePeriod","projMatrixInv","viewport","lineWidth","fogAlpha","samplesKernel","noiseTex","noiseTexelSize","srcTexelSize"],IO={diffuse:new $P.Color(16777215),specular:new $P.Color(1118481),shininess:30,opacity:1,fixedColor:new $P.Color(16777215),zOffset:0,zClipCoef:2,zClipValue:0,clipPlaneValue:0,world2colorMatrix:new $P.Matrix4,dashedLineSize:.1,dashedLinePeriod:.3,projMatrixInv:new $P.Matrix4,viewport:new $P.Vector2(800,600),lineWidth:2,fogAlpha:1,samplesKernel:RO,noiseTex:CO.noiseTexture,noiseTexelSize:new $P.Vector2(1/CO.noiseWidth,1/CO.noiseHeight),srcTexelSize:new $P.Vector2(1/800,1/600),copy(t){this.diffuse.copy(t.diffuse),this.specular.copy(t.specular),this.shininess=t.shininess,this.opacity=t.opacity,this.fixedColor.copy(t.fixedColor),this.zOffset=t.zOffset,this.zClipCoef=t.zClipCoef,this.zClipValue=t.zClipValue,this.clipPlaneValue=t.clipPlaneValue,this.world2colorMatrix.copy(t.world2colorMatrix),this.dashedLineSize=t.dashedLineSize,this.dashedLinePeriod=t.dashedLinePeriod,this.projMatrixInv=t.projMatrixInv,this.viewport=t.viewport,this.lineWidth=t.lineWidth,this.toonShading=t.toonShading,this.fogAlpha=t.fogAlpha,this.samplesKernel=t.samplesKernel,this.noiseTex=t.noiseTex,this.noiseTexelSize=t.noiseTexelSize,this.srcTexelSize=t.srcTexelSize}};class NO extends $P.RawShaderMaterial{constructor(t){super(t),this.fog=!0,this.instancedPos=!1,this.instancedMatrix=!1,this.attrColor=!1,this.attrColor2=!1,this.attrAlphaColor=!1,this.overrideColor=!1,this.sphereSprite=!1,this.cylinderSprite=!1,this.zClip=!1,this.clipPlane=!1,this.fakeOpacity=!1,this.prepassTransparancy=!1,this.colorFromPos=!1,this.shadowmap=!1,this.shadowmapType="random",this.colorFromDepth=!1,this.orthoCam=!1,this.dashedLine=!1,this.transparent=!0,this.thickLine=!1,this.fogTransparent=!1,this.normalsToGBuffer=!1,this.toonShading=!1,this.uberOptions=Object.create(NO.prototype.uberOptions),super.setValues({uniforms:$P.UniformsUtils.clone(PO),vertexShader:this.precisionString()+"float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t  vec4 worldPosition;\r\n\t  // see THREE.WebGLProgram.unrollLoops\r\n\t  #pragma unroll_loop_start\r\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n\t  }\r\n\t  #pragma unroll_loop_end\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n",fragmentShader:this.precisionString()+"#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  \t}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   \t  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      \t#endif\r\n\r\n      \t#ifdef SHADOWMAP_PCF_SHARP\r\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  \t#pragma unroll_loop_start\r\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  \t    #ifdef SHADOWMAP\r\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  \t\t}\r\n  \t\t#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n",lights:!0,fog:!0,side:$P.DoubleSide}),this.setValues(t)}precisionString(){const{precision:t}=xO;return`precision ${t} float;\nprecision ${t} int;\n\n`}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=$P.UniformsUtils.clone(t.uniforms),this.defines={...t.defines},this.extensions=t.extensions,this.fog=t.fog,this.instancedPos=t.instancedPos,this.instancedMatrix=t.instancedMatrix,this.attrColor=t.attrColor,this.attrColor2=t.attrColor2,this.attrAlphaColor=t.attrAlphaColor,this.overrideColor=t.overrideColor,this.sphereSprite=t.sphereSprite,this.cylinderSprite=t.cylinderSprite,this.zClip=t.zClip,this.clipPlane=t.clipPlane,this.fakeOpacity=t.fakeOpacity,this.colorFromPos=t.colorFromPos,this.shadowmap=t.shadowmap,this.shadowmapType=t.shadowmapType,this.colorFromDepth=t.colorFromDepth,this.orthoCam=t.orthoCam,this.prepassTransparancy=t.prepassTransparancy,this.dashedLine=t.dashedLine,this.thickLine=t.thickLine,this.fogTransparent=t.fogTransparent,this.normalsToGBuffer=t.normalsToGBuffer,this.toonShading=t.toonShading,this.uberOptions.copy(t.uberOptions),this}createInstance(){const t=new NO;return t.copy(this),t.uberOptions=Object.create(this.uberOptions),t}setValues(t){if(void 0===t)return;super.setValues(t);const e={},n={};this.fog&&(e.USE_FOG=1),this.instancedPos&&(e.INSTANCED_POS=1),this.instancedMatrix&&(e.INSTANCED_MATRIX=1),this.attrColor&&(e.ATTR_COLOR=1),this.attrColor2&&(e.ATTR_COLOR2=1),this.attrAlphaColor&&(e.ATTR_ALPHA_COLOR=1),this.overrideColor&&(e.OVERRIDE_COLOR=1),this.sphereSprite&&(e.SPHERE_SPRITE=1,n.fragDepth=!0),this.cylinderSprite&&(e.CYLINDER_SPRITE=1,n.fragDepth=!0),this.zClip&&(e.ZCLIP=1),this.clipPlane&&(e.CLIP_PLANE=1),this.fakeOpacity&&(e.FAKE_OPACITY=1),this.lights&&(e.USE_LIGHTS=1),this.colorFromPos&&(e.COLOR_FROM_POS=1),this.shadowmap&&(e.SHADOWMAP=1,"pcf"===this.shadowmapType?e.SHADOWMAP_PCF_SHARP=1:"random"===this.shadowmapType?e.SHADOWMAP_PCF_RAND=1:e.SHADOWMAP_BASIC=1),this.colorFromDepth&&(e.COLOR_FROM_DEPTH=1),this.orthoCam&&(e.ORTHOGRAPHIC_CAMERA=1),this.prepassTransparancy&&(e.PREPASS_TRANSP=1),this.dashedLine&&(e.DASHED_LINE=1),this.thickLine&&(e.THICK_LINE=1),this.fogTransparent&&(e.FOG_TRANSPARENT=1),this.normalsToGBuffer&&(n.drawBuffers=!0,e.NORMALS_TO_G_BUFFER=1),this.toonShading&&(e.TOON_SHADING=1),this.defines=e,this.extensions=n}setUberOptions(t){if(void 0!==t)for(const e in t)t.hasOwnProperty(e)&&(this.uberOptions[e]instanceof $P.Color?this.uberOptions[e]=t[e].clone():this.uberOptions[e]=t[e])}clone(t){return t?this.createInstance():super.clone()}updateUniforms(){const t=this;LO.forEach(e=>{t.uniforms.hasOwnProperty(e)&&(t.uberOptions[e]instanceof $P.Color||t.uberOptions[e]instanceof $P.Matrix4?t.uniforms[e].value=t.uberOptions[e].clone():t.uniforms[e].value=t.uberOptions[e])})}}NO.prototype.uberOptions=IO;const DO=NO;function OO(t){class e extends t{constructor(){super(...arguments),this.onBeforeRender=e.prototype.onBeforeRender}onBeforeRender(t,e,n,i,r,s){this._onBeforeRender(t,e,n,i,r,s),this._update()}_onBeforeRender(){}_update(){const{material:t}=this;t&&t instanceof DO&&t.updateUniforms()}}return e}const UO=OO($P.Mesh),FO=class extends UO{constructor(){super(...arguments),this.castShadow=!0,this.receiveShadow=!0}_onBeforeRender(t,e,n,i,r,s){UO.prototype._onBeforeRender.call(this,t,e,n);const{material:o}=this;o&&o.uniforms.invModelViewMatrix&&(this.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,this.matrixWorld),o.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert(),o.uniforms.nearPlaneValue.value=n.near,o.uniformsNeedUpdate=!0)}},BO=OO($P.Mesh);class zO extends BO{constructor(t,e){super(t,e),this.castShadow=!0,this.receiveShadow=!0}static _mvLength=(()=>new $P.Vector3)();static _center=(()=>new $P.Vector3)();static _modelView=(()=>new $P.Matrix4)();_onBeforeRender(t,e,n){BO.prototype._onBeforeRender.call(this,t,e,n);const i=this.geometry,{material:r}=this;if(!i.zClip||!r.uberOptions)return;const s=zO._modelView,o=zO._mvLength,a=zO._center;s.multiplyMatrices(this.matrixWorld,n.matrixWorldInverse);const l=o.setFromMatrixColumn(s,0).length();a.copy(i.boundingSphere.center),this.localToWorld(a),r.uberOptions.zClipValue=n.position.z-a.z-l*(.5*i.boundingSphere.radius)}}const VO=zO;class kO extends $P.Group{constructor(t,e){super(),this.geometry=t;const n=this;n.initialized=!1,this.geometry.addEventListener("update",()=>{n.update()})}init(){const{children:t}=this;for(let e=t.length-1;e>=0;--e)this.remove(t[e]);const{items:e,userData:n}=this.geometry;for(let t=0,i=e.length;t<i;++t){const i=e[t];if(!i)continue;const r=AL.shallowCloneNode(i),s=new UN(r);s.userData=qP.default.clone(n),s.getElement().style.visibility="visible",s.source=i,this.add(s)}this.initialized=!0}update(){if(!this.geometry.needsUpdate)return;const{children:t}=this;this.initialized||this.init();for(let e=0,n=t.length;e<n;++e){const n=t[e],i=n.source;n.position.copy(i.worldPos),n.userData.color=i.opts.color,n.userData.background=i.opts.background}}}const GO=kO,HO=OO($P.Mesh),WO=OO($P.Mesh),jO=new $P.Vector2,XO=class extends WO{_onBeforeRender(t,e,n,i,r,s){const{material:o}=this;o.uberOptions&&(o.uberOptions.projMatrixInv.copy(n.projectionMatrix).invert(),t.getSize(jO),o.uberOptions.viewport.set(jO.width,jO.height))}},YO=OO($P.Mesh),qO={ZClipped:VO,ZSprite:FO,Text:GO,Line:OO($P.Line),LineSegments:OO($P.LineSegments),Mesh:class extends HO{constructor(t,e){super(t,e),this.castShadow=!0,this.receiveShadow=!0}},ThickLineMesh:XO,Instanced:class extends YO{constructor(){super(...arguments),this.castShadow=!0,this.receiveShadow=!0}}};function $O(t,e){return function(n){n.setValues(t),n.setUberOptions(e)}}function ZO(t,e){return{Geometry:function(n,i){return new vO.Instanced2CCylindersGeometry(n,i,t,e)},Object:t?qO.ZSprite:qO.Instanced,initMaterial:$O({instancedMatrix:!0,attrColor:!0,attrColor2:!0,attrAlphaColor:!0,cylinderSprite:t})}}function JO(t,e){const n=t.prototype instanceof UD,i=e.lineWidth||0;return{Geometry:t,Object:n?qO.ThickLineMesh:qO.LineSegments,initMaterial:$O({lights:!1,attrColor:!0,attrAlphaColor:!0,thickLine:n},{lineWidth:i})}}function KO(t,e,n,i){const r={wireframe:!!i.wireframe,fakeOpacity:n.now.isoSurfaceFakeOpacity,zClip:i.zClip};return{Geometry:t,Object:qO.ZClipped,initMaterial:$O({attrColor:!0,attrAlphaColor:!1,wireframe:r.wireframe,fakeOpacity:r.fakeOpacity,zClip:r.zClip})}}const QO=class{static createSpheres(t,e){const n=e.now.zSprites;return{Geometry:function(t,e){return new vO.InstancedSpheresGeometry(t,e,n)},Object:n?qO.ZSprite:qO.Instanced,initMaterial:$O({instancedPos:!0,attrColor:!0,attrAlphaColor:!0,sphereSprite:n})}}static create2CClosedCylinders(t,e){return ZO(!1,!1)}static create2CCylinders(t,e){return ZO(e.now.zSprites,!0)}static create2CLines(t,e,n){return JO(vO.TwoColorLinesGeometry,n)}static createCrosses(t,e,n){return JO(vO.CrossGeometry,n)}static createExtrudedChains(t,e){return{Geometry:vO.ExtrudedObjectsGeometry,Object:qO.Mesh,initMaterial:$O({attrColor:!0,attrAlphaColor:!0})}}static createChunkedLines(t,e,n){return JO(vO.ChunkedLinesGeometry,n)}static createQuickSurface(t,e,n){return KO(vO.QuickSurfGeometry,0,e,n)}static createContactSurface(t,e,n){return KO(vO.ContactSurfaceGeometry,0,e,n)}static createSASSES(t,e,n){return KO(vO.SSIsosurfaceGeometry,0,e,n)}static createLabels(t,e){return{Geometry:vO.LabelsGeometry,Object:qO.Text,initMaterial(){}}}};class tU extends $P.Object3D{static _inverseMatrix=(()=>new $P.Matrix4)();static _ray=(()=>new $P.Ray)();constructor(t,e,n,i){super(),this._geometry=t,this._geoParams=e;const r=n.createInstance();e.initMaterial(r),this._material=r,this._transforms=i.length>0?i:[new $P.Matrix4];const s=this._createMeshes(t);for(let t=0,e=s.length;t<e;++t)this.add(s[t])}raycast(t,e){const n=tU._ray,i=tU._inverseMatrix,{children:r}=this;n.copy(t.ray);for(let s=0,o=r.length;s<o;++s){const o=r[s];if(!jN.belongToSelectLayers(o))continue;o.updateMatrixWorld();const a=o.matrixWorld;i.copy(a).invert(),t.ray.copy(n).applyMatrix4(i);const l=[];this._geometry.raycast(t,l);for(let t=0,i=l.length;t<i;++t){const i=l[t];i.point&&(i.point.applyMatrix4(a),i.distance=n.origin.distanceTo(i.point)),i.object=o,e[e.length]=i}}t.ray.copy(n)}getSubset(t){const e=this._geometry.getSubset(t),n=[];let i=0;for(let t=0,r=e.length;t<r;++t){const r=this._createMeshes(e[t]);for(let t=0,e=r.length;t<e;++t)n[i++]=r[t]}return n}_createMeshes(t){const e=this._transforms,n=this._geoParams.Object,i=this._material,r=[];for(let s=0,o=e.length;s<o;++s){const o=new n(t,i);o.applyMatrix4(e[s]),r[s]=o}return r}}const eU=tU;class nU extends BN{constructor(t,e,n,i,r,s,o){if(super(),this.constructor===nU)throw new Error("Can not instantiate abstract class!");this._selection=e,this._mode=i,this._colorer=n,this._chunksIdc=e.chunks,this._polyComplexity=s,this._geo=new(function(t,e){const n=[t].concat(e);return t.bind(...n)}(t.Geometry,this._makeGeoArgs())),this._mesh=new eU(this._geo,t,o,r),this.add(this._mesh),this._build()}_makeGeoArgs(){throw new Error("ChemGroup subclass must override _makeGeoArgs() method")}getSubset(t,e){e=void 0!==e&&e;const n=this._calcChunksList(t,e);return 0===n.length?[]:this._mesh.getSubset(n)}_changeSubsetOpacity(t,e,n){const i=this._calcChunksList(t,n);0!==i.length&&this._geo.setOpacity(i,e)}enableSubset(t,e){e=void 0===e||e,this._changeSubsetOpacity(t,1,e)}disableSubset(t,e){e=void 0===e||e,this._changeSubsetOpacity(t,0,e)}}const iU=nU,rU=class extends iU{raycast(t,e){const{atoms:n}=this._selection,i=[];this._mesh.raycast(t,i);const r=this._chunksIdc;for(let t=0,s=i.length;t<s;++t){if(!i[t].hasOwnProperty("chunkIdx"))continue;const s=r[i[t].chunkIdx];s<n.length&&(i[t].atom=n[s],e.push(i[t]))}}_calcChunksList(t){const e=[],{atoms:n}=this._selection,i=this._chunksIdc;for(let r=0,s=i.length;r<s;++r)0!==(n[i[r]].mask&t)&&e.push(r);return e}},sU=class extends rU{_makeGeoArgs(){return[this._selection.chunks.length,this._polyComplexity]}_build(){const t=this._selection.chunks,{atoms:e,parent:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo;for(let o=0,a=t.length;o<a;++o){const a=e[t[o]];s.setItem(o,a.position,i.calcAtomRadius(a)),s.setColor(o,r.getAtomColor(a,n))}s.finalize()}updateToFrame(t){const e=this._selection.chunks,{atoms:n}=this._selection,i=this._mode,r=this._colorer,s=t.needsColorUpdate(r),o=this._geo;for(let a=0,l=e.length;a<l;++a){const l=n[e[a]];o.setItem(a,t.getAtomPos(e[a]),i.calcAtomRadius(l)),s&&o.setColor(a,t.getAtomColor(r,l))}o.finalize()}};function oU(t){return null!==t.name.getNode()?t.name.getNode():t.getVisualName()}const aU={none:t=>t,adjust:function(t){let e=t>>16&255,n=t>>8&255,i=255&t;return.2126*e+.7152*n+.0722*i>127?(e=3*e/10,n=3*n/10,i=3*i/10):(e=255-3*(255-e)/10,n=255-3*(255-n)/10,i=255-3*(255-i)/10),e<<16|n<<8|i},inverse:function(t){return 255-(t>>16&255)<<16|255-(t>>8&255)<<8|255-(255&t)}};function lU(t,e){let n;if(aU.hasOwnProperty(e))n=AL.hexColor(aU[e](t));else{const t=parseInt(e,16);n=!Number.isNaN(t)&&e.toLowerCase().startsWith("0x")?AL.hexColor(t):"#000000"}return n}const cU={serial:t=>t.serial,name:t=>t.getVisualName(),elem:t=>t.element.name,residue:t=>t.residue.getType().getName(),sequence:t=>t.residue.getSequence(),chain:t=>t.residue.getChain().getName(),hetatm:t=>t.isHet(),water:t=>"HOH"===t.residue.getType().getName()||"WAT"===t.residue.getType().getName()},hU=function(t,e){return e.replace(/\{\{(\s*\w+\s*)\}\}/g,e=>{let n=e.replace(/\s+/g,"");return n=n.substring(2,n.length-2).toLowerCase(),cU.hasOwnProperty(n)?cU[n](t):"null"})};function uU(t,e,n,i){const r=Math.sin(t);return e.clone().multiplyScalar(Math.sin((1-i)*t)/r).addScaledVector(n,Math.sin(i*t)/r)}const dU=class extends rU{_buildInner(t,e){const n=this._selection.chunks,i=new $P.Vector3,r=new $P.Vector3,s=this._segmentsHeight,o=1/s,a=this._colorer,{cycles:l,parent:c}=this._selection;let h=0,u=n[h];for(let d=0,p=l.length;d<p;++d){const p=l[d],f=p.atoms,m=[],g=[],{center:_}=p,y=p.radius-t,v=f.length;let x=0;const S=f[v-1].position;let b=f[x].position;i.subVectors(S,_),r.subVectors(b,_);const M=r.clone().cross(i).normalize();for(;x<v;++x){const t=i.angleTo(r);g[x]=uU(t,i,r,.5).normalize(),b=f[(x+1)%v].position,i.copy(r),r.subVectors(b,_)}for(x=0;x<v;++x){if(f[x].index!==u)continue;const t=g[x],i=g[(x+1)%v],r=a.getAtomColor(f[x],c),l=t.angleTo(i);for(let e=0;e<=s;++e)m[e]=uU(l,t,i,e*o).multiplyScalar(y).add(_);e(h++,r,m,_,M),u=n[h]}}}};function pU(t,e){const n=[];for(let i=0;i<e;++i){const r=-2*i/e*Math.PI;n.push(new $P.Vector3(Math.cos(r)*t,Math.sin(r)*t,0))}return n}const{calcChunkMatrix:fU}=jN,mU=class extends iU{raycast(t,e){const{residues:n}=this._selection,i=[];this._mesh.raycast(t,i);const r=this._chunksIdc;for(let t=0,s=i.length;t<s;++t){if(!i[t].hasOwnProperty("chunkIdx"))continue;const s=r[i[t].chunkIdx];s<n.length&&(i[t].residue=n[s],e.push(i[t]))}}_calcChunksList(t){const e=[],{residues:n}=this._selection,i=this._chunksIdc;for(let r=0,s=i.length;r<s;++r)0!==(n[i[r]]._mask&t)&&e.push(r);return e}},gU=class extends mU{raycast(t,e){const{residues:n}=this._selection,i=[];this._mesh.raycast(t,i);const r=this._chunksIdc;for(let t=0,s=i.length;t<s;++t){if(!i[t].hasOwnProperty("chunkIdx"))continue;const s=r[Math.floor(i[t].chunkIdx/2)];s<n.length&&(i[t].residue=n[s],e.push(i[t]))}}_build(){const{residues:t,parent:e}=this._selection,n=this._colorer,i=this._geo,r=this._mode.calcStickRadius();let s=0;const o=this._selection.chunks;for(let i=0,a=o.length;i<a;++i){const a=t[o[i]],l=n.getResidueColor(a,e);this._processItem(s++,a._cylinders[0],a._cylinders[1],r,l)}i.finalize()}_calcChunksList(t){const e=[];let n=0;const{residues:i}=this._selection,r=this._chunksIdc;for(let s=0,o=r.length;s<o;++s)0!==(i[r[s]]._mask&t)&&(e[n++]=2*s,e[n++]=2*s+1);return e}updateToFrame(t){const e=t.getResidues(),{parent:n}=this._selection,i=this._colorer,r=this._geo,s=this._mode.calcStickRadius();let o=0;const a=this._selection.chunks;for(let t=0,r=a.length;t<r;++t){const r=e[a[t]],l=i.getResidueColor(r,n);this._processItem(o++,r._cylinders[0],r._cylinders[1],s,l)}r.finishUpdate()}};var _U=XP(690);const{ResidueType:yU}=DN,vU=jN.calcChunkMatrix;function xU(t,e){const n=(0,_U.Smooth)(t,{method:_U.Smooth.METHOD_CUBIC,clip:_U.Smooth.CLIP_CLAMP,cubicTension:e,scaleTo:1});return function(e,i){let r=i;null===r&&(r=function(e){return(e*(t.length-1-2)+1)/(t.length-1)});const s=r(e),o=n(s);return new $P.Vector3(o[0],o[1],o[2])}}function SU(t,e,n,i){if(!i._isValid)return t[n]=t[n-1],void(e[n]=e[n-1]);const r=i._controlPoint;t[n]=[r.x,r.y,r.z];const s=r.clone().add(i._wingVector);e[n]=[s.x,s.y,s.z]}const bU=class{constructor(t,e,n,i,r,s){const o=function(t,e,n,i){const r=i.start,s=i.end;function o(e){return e>r&&t[e-1]._isValid?e-1:e}function a(e){return e<s&&t[e+1]._isValid?e+1:e}const l=[],c=[];let h=0;function u(e,n){const i=t[e]._controlPoint.clone().lerp(t[n]._controlPoint,-.25),r=i.clone().add(t[e]._wingVector);c[h]=[i.x,i.y,i.z],l[h++]=[r.x,r.y,r.z],c[h]=[i.x,i.y,i.z],l[h++]=[r.x,r.y,r.z]}const d=o(e),p=a(n);if(d===p)return function(t,e,n,i){const r=0!==(i._type.flags&yU.Flags.NUCLEIC),s=r?"C5'":"N",o=r?"C3'":"C";let a,l;if(i.forEachAtom(t=>{const e=t.getVisualName();a||e!==s?l||e!==o||(l=t.position):a=t.position}),a&&l||(a=i._firstAtom.position,l=i._lastAtom.position),a&&l){const r=l.clone().sub(a),s=i._wingVector,o=i._controlPoint,c=o.clone().add(s),h=o.clone().sub(r),u=h.clone().add(s);t[n]=[h.x,h.y,h.z],e[n]=[u.x,u.y,u.z],t[++n]=[h.x,h.y,h.z],e[n]=[u.x,u.y,u.z],t[++n]=[o.x,o.y,o.z],e[n]=[c.x,c.y,c.z],++n;const d=o.clone().add(r),p=d.clone().add(s);t[n]=[d.x,d.y,d.z],e[n]=[p.x,p.y,p.z],t[++n]=[d.x,d.y,d.z],e[n]=[p.x,p.y,p.z]}}(c,l,h,t[e]),{centerPoints:c,topPoints:l};e===d?u(e,a(e)):(SU(c,l,h++,t[o(d)]),SU(c,l,h++,t[d]));for(let i=e;i<=n;++i)SU(c,l,h++,t[i]);return p===a(p)?u(n,o(n)):(SU(c,l,h++,t[p]),SU(c,l,h,t[a(p)])),{centerPoints:c,topPoints:l}}(t,e,n,s);this._topInterp=xU(o.topPoints,r),this._centerInterp=xU(o.centerPoints,r),this._shift=.5/(n-e+2),this._valueStep=(1-2*this._shift)/(2*(n-e+1)*(i-1)),this._segmentsCount=i}prepareMatrices(t,e,n){const i=this._segmentsCount,r=new Array(i),s=new $P.Vector2(0,0),o=this._topInterp,a=this._centerInterp;let l=this._shift+this._valueStep*(i-1)*t;for(let t=0;t<i;++t){const c=Math.min(1,t/(i-1));s.lerpVectors(e,n,c);const h=o(l,null),u=a(l,null);l+=this._valueStep;const d=a(l,null);r[t]=vU(u.clone(),d.clone(),h.clone().sub(u),s)}return r}};function MU(t,e){const n=[];for(let i=0;i<e;++i){const r=Math.PI/2-2*Math.PI*i/e;n.push(new $P.Vector3(Math.cos(r)*t,Math.sin(r)*t,0))}return n}function wU(t,e,n,i,r,s){for(let o=0,a=t.length;o<a;++o){const a=t[o].arr,{boundaries:l}=t[o];for(let t=0,o=a.length;t<o;++t){const o=[a[t].start,a[t].end],c=new bU(e,o[0],o[1],n,i,l);let h=null;const u=2*a[t].start,d=2*a[t].end+1;let p=r.getResidueRadius(e[0],0);for(let t=u;t<=d;++t){const i=e[t/2|0],a=r.getResidueRadius(i,t%2),l=r.getResidueRadius(i,1+t%2),u=c.prepareMatrices(t-2*o[0],a,l);u.unshift(null===h?u[0]:h),s(i,u,a.x!==l.x||a.y!==l.y,a.x!==p.x||a.y!==p.y),h=u[n],p=l}}}}const EU=class extends iU{_makeGeoArgs(){const t=this._mode.drawMultiorderBonds(),e=this._mode.showAromaticLoops(),n=this._selection.chunks,{bonds:i}=this._selection;let r=0;for(let s=0,o=n.length;s<o;++s)r+=this.getBondOrder(i[n[s]],t,e);return[r,this._polyComplexity]}getBondOrder(t,e,n){let i=1;return!e||n&&t._type===oI.BondType.AROMATIC||(i=function(t){return t<2?1:t}(t._order)),i}raycast(t,e){const{bonds:n}=this._selection,i=[];this._mesh.raycast(t,i);const r=this._chunksIdc;for(let t=0,s=i.length;t<s;++t){if(!i[t].hasOwnProperty("chunkIdx"))continue;const{chunkIdx:s}=i[t],o=r[Math.floor(s/2)];if(o<n.length){const r=n[o];i[t].atom=s%2==0?r._left:r._right,e.push(i[t])}}}_calcChunksList(t,e){const n=[],{bonds:i}=this._selection,r=this._chunksIdc;for(let s=0,o=r.length;s<o;++s){const o=i[r[s]];o._left.mask&t&&(!e||o._right.mask&t)&&n.push(2*s),o._right.mask&t&&(!e||o._left.mask&t)&&n.push(2*s+1)}return n}},TU=.15,AU=sU,CU=class extends sU{_makeGeoArgs(){const t=[],{atoms:e,chunks:n}=this._selection,i=n.length;for(let r=0;r<i;++r)t[r]=e[n[r]];const r=this._mode.getSurfaceOpts();return r.atoms=t,[i,r]}},RU=class extends sU{_makeGeoArgs(){const t=[],{atoms:e,chunks:n}=this._selection,i=n.length;for(let r=0;r<i;++r)t[r]=e[n[r]];const r=this._mode.getSurfaceOpts();return r.atoms=t,r.selection=this._selection,r.colorMode=this._colorer,[i,r]}},PU=class extends rU{_makeGeoArgs(){const t=this._mode.getLabelOpts();return[this._selection.chunks.length,t]}_build(){const t=this._mode.getLabelOpts(),e=this._selection.chunks,{atoms:n,parent:i}=this._selection,r=this._colorer,s=this._geo;for(let o=0,a=e.length;o<a;++o){const a=n[e[o]],l=t.template?hU(a,t.template):oU(a);if(!l)continue;const c=r.getAtomColor(a,i),h=parseInt(lU(c,t.fg).substring(1),16),u=t.showBg?parseInt(lU(c,t.bg).substring(1),16):"transparent";s.setItem(o,a.position,l),s.setColor(o,h,u)}s.finalize()}updateToFrame(t){const e=this._mode.getLabelOpts(),n=this._selection.chunks,{atoms:i}=this._selection,r=this._colorer,s=this._geo,o=t.needsColorUpdate(r);for(let a=0,l=n.length;a<l;++a){const l=i[n[a]],c=e.template?hU(l,e.template):oU(l);if(!c)continue;const h=t.getAtomColor(r,l),u=parseInt(lU(h,e.fg).substring(1),16),d=e.showBg?parseInt(lU(h,e.bg).substring(1),16):"transparent";s.setItem(a,t.getAtomPos(n[a]),c),o&&s.setColor(a,u,d)}s.finalize()}},LU=class extends dU{_build(){const t=this._segmentsHeight,e=this._mode.getAromRadius(),n=new $P.Vector2(e,e),i=this._mode.calcStickRadius()+2*e,r=new $P.Vector3,s=[],o=this._geo;this._buildInner(i,(e,i,a,l,c)=>{for(let e=0;e<=t;++e){const t=a[e],i=t.clone().sub(l).cross(c);r.addVectors(t,i),s[e]=fU(t,r,c,n)}o.setItem(e,s),o.setColor(e,i)}),o.finalize()}_makeGeoArgs(){return this._segmentsHeight=this._polyComplexity,[pU(1,this._polyComplexity),this._segmentsHeight+1,this._selection.chunks.length]}},IU=class extends dU{_build(){const t=this._geo,e=this._mode.getAromaticOffset();this._buildInner(e,(e,n,i)=>{let r=i[0];for(let n=1;n<=this._segmentsHeight;++n){const s=i[n];t.setSegment(e,n-1,r,s),r=s}t.setColor(e,n)}),t.finalize()}_makeGeoArgs(){return this._segmentsHeight=this._mode.getAromaticArcChunks(),[this._selection.chunks.length,this._segmentsHeight,!0]}},NU=class extends gU{_makeGeoArgs(){return[this._selection.chunks.length,this._polyComplexity]}_processItem(t,e,n,i,r){const s=this._geo;s.setItem(t,e,n,i),s.setColor(t,r,r)}},DU=class extends gU{_makeGeoArgs(){return[2*this._selection.chunks.length,this._polyComplexity]}_processItem(t,e,n,i,r){const s=this._geo;let o=2*t;s.setItem(o,e,i),s.setColor(o,r),o++,s.setItem(o,n,i),s.setColor(o,r)}},OU=class extends mU{_makeGeoArgs(){const t=this._mode.getHeightSegmentsRatio();return this._segmentsHeight=this._polyComplexity*t|0,[MU(1,this._polyComplexity),this._segmentsHeight+1,2*this._selection.chunks.length]}_build(){const{residues:t,parent:e}=this._selection,n=this._mode,i=this._colorer,r=n.getTension(),s=this._geo;let o=0;const a=[];wU(this._selection.subdivs,t,this._segmentsHeight,r,n,function(t,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const c=i.getResidueColor(t,e);a[o]=t._index,s.setItem(o,n,r,l),s.setColor(o++,c)}),this._chunksIdc=a,s.finalize()}updateToFrame(t){const{parent:e}=this._selection,n=this._mode,i=this._colorer,r=n.getTension(),s=this._geo,o=t.getResidues();let a=0;const l=t.needsColorUpdate(i);wU(this._selection.subdivs,o,this._segmentsHeight,r,n,(t,n)=>{s.setItem(a,n),l&&s.setColor(a,i.getResidueColor(t,e)),a++}),s.finalize()}},UU=class extends iU{_makeGeoArgs(){const t=this._selection.subdivs;let e=0;for(let n=0,i=t.length;n<i;++n){const i=t[n].arr;for(let t=0,n=i.length;t<n;++t)e+=i[t].end-i[t].start}return[e,this._polyComplexity]}_build(){const{residues:t,parent:e}=this._selection,n=this._mode,i=this._colorer,r=this._geo;let s=0;const o=[],a=this._selection.subdivs,l=n.calcStickRadius();for(let n=0,c=a.length;n<c;++n){const c=a[n].arr;for(let n=0,a=c.length;n<a;++n){const a=c[n].start,h=c[n].end;let u=t[a];for(let n=a+1;n<=h;++n){const a=t[n];o[s]={first:u._index,second:a._index},r.setItem(s,u._controlPoint,a._controlPoint,l),r.setColor(s,i.getResidueColor(u,e),i.getResidueColor(a,e)),s++,u=a}}}this._chunksIdc=o,r.finalize()}updateToFrame(t){const e=t.getResidues(),{parent:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo;let o=0;const a=this._selection.subdivs,l=i.calcStickRadius(),c=t.needsColorUpdate(r);for(let t=0,i=a.length;t<i;++t){const i=a[t].arr;for(let t=0,a=i.length;t<a;++t){const a=i[t].start,h=i[t].end;let u=e[a];for(let t=a+1;t<=h;++t){const i=e[t];s.setItem(o,u._controlPoint,i._controlPoint,l),c&&s.setColor(o,r.getResidueColor(u,n),r.getResidueColor(i,n)),o++,u=i}}}s.finalize()}raycast(t,e){const n=[],{residues:i}=this._selection;this._mesh.raycast(t,n);const r=this._chunksIdc;for(let t=0,s=n.length;t<s;++t){if(!n[t].hasOwnProperty("chunkIdx"))continue;const{chunkIdx:s}=n[t],o=r[Math.floor(s/2)],a=s%2==0?o.first:o.second;a<i.length&&(n[t].residue=i[a],e.push(n[t]))}}_calcChunksList(t){const e=[],n=this._chunksIdc,{residues:i}=this._selection;for(let r=0,s=n.length;r<s;++r){const s=n[r];i[s.first]._mask&t&&e.push(2*r),i[s.second]._mask&t&&e.push(2*r+1)}return e}},FU=class extends EU{_build(){const t=this._selection.chunks,{bonds:e,parent:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo,o=i.drawMultiorderBonds(),a=i.showAromaticLoops(),l=i.calcStickRadius(),c=i.calcSpaceFraction();let h;const u=new $P.Vector3,d=new $P.Vector3;let p=0;const f=[];for(let m=0,g=t.length;m<g;++m){const g=e[t[m]],_=g._left,y=g._right,v=_.position,x=y.position;h=g.calcNormalDir();const S=this.getBondOrder(g,o,a),b=2*Math.min(i.calcAtomRadius(_),i.calcAtomRadius(y))/S,M=o?Math.min(l,.5*b*(1-c)):l;for(let t=0;t<S;++t){const e=b*(S%2==0?(.5+(t/2|0))*(1-t%2*2):((t+1)/2|0)*(t%2*2-1));f[p]=g._index,u.copy(v),u.addScaledVector(h,e),d.copy(x),d.addScaledVector(h,e),s.setItem(p,u,d,M),s.setColor(p++,r.getAtomColor(_,n),r.getAtomColor(y,n))}}s.finalize(),this._chunksIdc=f}updateToFrame(t){const e=this._selection.chunks,{bonds:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo,o=i.drawMultiorderBonds(),a=i.showAromaticLoops(),l=i.calcStickRadius(),c=i.calcSpaceFraction();let h;const u=new $P.Vector3,d=new $P.Vector3;let p=0;const f=t.needsColorUpdate(r);for(let m=0,g=e.length;m<g;++m){const g=n[e[m]],_=g._left,y=g._right,v=t.getAtomPos(_.index).clone(),x=t.getAtomPos(y.index);h=g.calcNormalDir();const S=this.getBondOrder(g,o,a),b=2*Math.min(i.calcAtomRadius(_),i.calcAtomRadius(y))/S,M=o?Math.min(l,.5*b*(1-c)):l;for(let e=0;e<S;++e){const n=b*(S%2==0?(.5+(e/2|0))*(1-e%2*2):((e+1)/2|0)*(e%2*2-1));u.copy(v),u.addScaledVector(h,n),d.copy(x),d.addScaledVector(h,n),s.setItem(p,u,d,M),f&&s.setColor(p,t.getAtomColor(r,_),t.getAtomColor(r,y)),p++}}s.finalize()}},BU=class extends EU{_build(){const t=this._selection.chunks,{bonds:e,parent:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo,o=i.drawMultiorderBonds(),a=i.showAromaticLoops(),l=new $P.Vector3,c=new $P.Vector3,h=new $P.Vector3;let u=0;const d=[];for(let i=0,p=t.length;i<p;++i){const p=e[t[i]],f=p._left,m=p._right,g=f.position,_=m.position,y=1===f.bonds.length,v=1===m.bonds.length;l.subVectors(_,g);const x=l.length(),S=p.calcNormalDir(),b=this.getBondOrder(p,o,a);for(let t=0;t<b;++t){c.copy(g),h.copy(_);let e=b%2==0?(.5+(t/2|0))*(1-t%2*2):((t+1)/2|0)*(t%2*2-1);d[u]=p._index,2!==b||y||v||(e-=.5,e*=-1),!y&&!v&&b>1&&0!==e&&(c.lerpVectors(g,_,TU/x),h.lerpVectors(g,_,1-TU/x)),e*=TU,c.addScaledVector(S,e),h.addScaledVector(S,e),s.setItem(u,c,h),s.setColor(u++,r.getAtomColor(f,n),r.getAtomColor(m,n))}}s.finalize(),this._chunksIdc=d}updateToFrame(t){const e=this._selection.chunks,{bonds:n}=this._selection,i=this._mode,r=this._colorer,s=this._geo,o=i.drawMultiorderBonds(),a=i.showAromaticLoops(),l=new $P.Vector3,c=new $P.Vector3,h=new $P.Vector3;let u=0;const d=t.needsColorUpdate(r);for(let i=0,p=e.length;i<p;++i){const p=n[e[i]],f=p._left,m=p._right,g=t.getAtomPos(f.index).clone(),_=t.getAtomPos(m.index),y=1===f.bonds.length,v=1===m.bonds.length;l.subVectors(_,g);const x=l.length(),S=p.calcNormalDir(),b=this.getBondOrder(p,o,a);for(let e=0;e<b;++e){c.copy(g),h.copy(_);let n=b%2==0?(.5+(e/2|0))*(1-e%2*2):((e+1)/2|0)*(e%2*2-1);2!==b||y||v||(n-=.5,n*=-1),!y&&!v&&b>1&&0!==n&&(c.lerpVectors(g,_,TU/x),h.lerpVectors(g,_,1-TU/x)),n*=TU,c.addScaledVector(S,n),h.addScaledVector(S,n),s.setItem(u,c,h),d&&s.setColor(u,t.getAtomColor(r,f),t.getAtomColor(r,m)),u++}}s.finalize()}},zU=class extends BN{constructor(t,e,n,i,r,s,o,a){super();const l=this;this._complex=n,this._mode=r;const c=n.getAtoms(),h=n.getTransforms();n.forEachComponent(u=>{const d=[];let p=0;if(u.forEachAtom(t=>{l._checkAtom(t,o)&&(d[p++]=t.index)}),0===p)return;const f=new t(e,{atoms:c,chunks:d,parent:n},i,r,h,s,a);f._component=u,l.add(f)})}_checkAtom(t,e){return t.mask&e}getSubset(t,e){const n=[],{children:i}=this;let r=0;for(let s=0,o=i.length;s<o;++s)if(i[s].getSubset){const o=i[s].getSubset(t,e);for(let t=0,e=o.length;t<e;++t){const e=o[t];e._component=i[s]._component,n[r++]=e}}return n}},VU=class extends BN{constructor(t,e,n,i,r,s,o,a){super();const l=this;this._complex=n;const c=n.getResidues(),h=n.getTransforms();n.forEachComponent(u=>{let d=0;const p=[];if(u.forEachResidue(t=>{l._checkResidue(t,o)&&(p[d++]=t._index)}),0===d)return;const f=new t(e,{residues:c,chunks:p,parent:n},i,r,h,s,a);f._component=u,l.add(f)})}checkResidue(t,e){return t._mask&e}getSubset(t,e){const n=[],{children:i}=this;let r=0;for(let s=0,o=i.length;s<o;++s)if(i[s].getSubset){const o=i[s].getSubset(t,e);for(let t=0,e=o.length;t<e;++t){const e=o[t];e._component=i[s]._component,n[r++]=e}}return n}},kU=zU,GU=class extends zU{_checkAtom(t,e){if(!(t.mask&e))return!1;const{bonds:n}=t;for(let t=0,i=n.length;t<i;++t)if(n[t]._left.mask&e&&n[t]._right.mask&e)return!1;return!0}},HU=class extends VU{_checkResidue(t,e){return e&t._mask&&null!==t._cylinders}},WU=class extends BN{constructor(t,e,n,i,r,s,o,a){super();const l=this;this._complex=n;const c=n.getResidues(),h=n.getTransforms();n.forEachComponent(u=>{const d=u.getMaskedSubdivSequences(o);let p=0;const f=[];for(let t=0,e=d.length;t<e;++t){const e=d[t].arr;for(let t=0,n=e.length;t<n;++t)for(let n=e[t].start,i=e[t].end;n<=i;++n)f[p++]=c[n]._index}if(0===p)return;const m=new t(e,{residues:c,chunks:f,subdivs:d,parent:n},i,r,h,s,a);m._component=u,l.add(m)})}getSubset(t,e){const n=[],{children:i}=this;let r=0;for(let s=0,o=i.length;s<o;++s)if(i[s].getSubset){const o=i[s].getSubset(t,e);for(let t=0,e=o.length;t<e;++t){const e=o[t];e._component=i[s]._component,n[r++]=e}}return n}},jU=class extends BN{constructor(t,e,n,i,r,s,o,a){super();const l=this;this._complex=n;const c=n.getBonds(),h=n.getTransforms();n.forEachComponent(u=>{const d=[];let p=0;if(u.forEachBond(t=>{const e=t._left,n=t._right;e.mask&o&&n.mask&o&&(d[p++]=t._index)}),0===p)return;const f=new t(e,{bonds:c,chunks:d,parent:n},i,r,h,s,a);f._component=u,l.add(f)})}getSubset(t,e){const n=[],{children:i}=this;let r=0;for(let s=0,o=i.length;s<o;++s)if(i[s].getSubset){const o=i[s].getSubset(t,e);for(let t=0,e=o.length;t<e;++t){const e=o[t];e._component=i[s]._component,n[r++]=e}}return n}},XU=class extends BN{constructor(t,e,n,i,r,s,o,a){super();const l=this;this._complex=n;const c=n.getAtoms(),h=n.getTransforms();r.showAromaticLoops()&&n.forEachComponent(u=>{const d=[];let p=0;const f=[];let m=0;u.forEachCycle(t=>{const e=t.atoms;let n=0;for(let t=0,i=e.length;t<i;++t)0!==(e[t].mask&o)&&(++n,d[p++]=e[t].index);n>0&&(f[m++]=t)});const g=new t(e,{cycles:f,atoms:c,chunks:d,parent:n},i,r,h,s,a);g._component=u,l.add(g)})}getSubset(t,e){const n=[],{children:i}=this;let r=0;for(let s=0,o=i.length;s<o;++s)if(i[s].getSubset){const o=i[s].getSubset(t,e);for(let t=0,e=o.length;t<e;++t){const e=o[t];e._component=i[s]._component,n[r++]=e}}return n}};function YU(t,e,n){return function(i,r,s,o,a,l){return new e(n,t,i,r,s,o,a,l)}}const qU=class{static AtomsSpheres(t,e){return YU(QO.createSpheres(t,e),kU,AU)}static OrphanedAtomsCrosses(t,e,n){return YU(QO.createCrosses(t,e,n),GU,AU)}static BondsCylinders(t,e){return YU(QO.create2CCylinders(t,e),jU,FU)}static BondsLines(t,e,n){return YU(QO.create2CLines(t,e,n),jU,BU)}static CartoonChains(t,e){return YU(QO.createExtrudedChains(t,e),WU,OU)}static TraceChains(t,e){return YU(QO.create2CClosedCylinders(t,e),WU,UU)}static NucleicSpheres(t,e){return YU(QO.createSpheres(t,e),HU,DU)}static NucleicCylinders(t,e){return YU(QO.create2CCylinders(t,e),HU,NU)}static ALoopsTorus(t,e){return YU(QO.createExtrudedChains(t,e),XU,LU)}static ALoopsLines(t,e,n){return YU(QO.createChunkedLines(t,e,n),XU,IU)}static QuickSurfGeo(t,e,n){return YU(QO.createQuickSurface(t,e,n),kU,CU)}static ContactSurfaceGeo(t,e,n){return YU(QO.createContactSurface(t,e,n),kU,CU)}static SASSESSurfaceGeo(t,e,n){return YU(QO.createSASSES(t,e,n),kU,RU)}static TextLabelsGeo(t,e){return YU(QO.createLabels(t,e),kU,PU)}};class $U{constructor(t){if(this.constructor===$U)throw new Error("Can not instantiate abstract class!");this.opts=qP.default.merge(AL.deriveDeep(this.settings.now.modes[this.id],!0),t)}identify(){const t=AL.objectsDiff(this.opts,this.settings.now.modes[this.id]);return qP.default.isEmpty(t)?this.id:[this.id,t]}buildGeometry(t,e,n,i){const r=this.opts.polyComplexity?this.opts.polyComplexity[this.settings.now.resolution]:0,s=this.depGroups,o=s.length,a=new jN.RCGroup,l=this;for(let c=0;c<o;++c){let o=s[c],h={};qP.default.isArray(o)&&(h=o[1].call(this),[o]=o);const u=new(qU[o](null,this.settings,h))(t,e,l,r,n,i);u.children.length>0&&a.add(u)}return a}}KN($U.prototype),$U.prototype.id="__",$U.prototype.depGroups=[];const ZU=$U;function JU(){return{lineWidth:this.opts.lineWidth}}class KU extends ZU{static id="LN";constructor(t){super(t),this.depGroups=this.depGroups.slice(0);const e=this.depGroups;for(let t=0,n=e.length;t<n;++t)e[t]=[e[t],JU]}drawMultiorderBonds(){return this.opts.multibond}calcAtomRadius(){return this.opts.atom}getAromaticOffset(){return this.opts.offsarom}getAromaticArcChunks(){return this.opts.chunkarom}showAromaticLoops(){return this.opts.showarom}}KU.prototype.id="LN",KU.prototype.name="Lines",KU.prototype.shortName="Lines",KU.prototype.depGroups=["ALoopsLines","BondsLines","OrphanedAtomsCrosses"];const QU=KU;class tF extends ZU{static id="LC";calcAtomRadius(t){return this.opts.bond}calcStickRadius(){return this.opts.bond}calcSpaceFraction(){return this.opts.space}getAromRadius(){return this.opts.aromrad}showAromaticLoops(){return this.opts.showarom}drawMultiorderBonds(){return this.opts.multibond}}tF.prototype.id="LC",tF.prototype.name="Licorice",tF.prototype.shortName="Licorice",tF.prototype.depGroups=["AtomsSpheres","BondsCylinders","ALoopsTorus"];const eF=tF;class nF extends ZU{static id="BS";calcAtomRadius(t){return t.element.radius*this.opts.atom}calcStickRadius(){return this.opts.bond}getAromRadius(){return this.opts.aromrad}showAromaticLoops(){return this.opts.showarom}calcSpaceFraction(){return this.opts.space}drawMultiorderBonds(){return this.opts.multibond}}nF.prototype.id="BS",nF.prototype.name="Balls and Sticks",nF.prototype.shortName="Balls",nF.prototype.depGroups=["AtomsSpheres","BondsCylinders","ALoopsTorus"];const iF=nF;class rF extends ZU{static id="VW";calcAtomRadius(t){return t.element.radius}}rF.prototype.id="VW",rF.prototype.name="Van der Waals",rF.prototype.shortName="VDW",rF.prototype.depGroups=["AtomsSpheres"];const sF=rF;class oF extends ZU{static id="TR";calcStickRadius(){return this.opts.radius}}oF.prototype.id="TR",oF.prototype.name="Trace",oF.prototype.shortName="Trace",oF.prototype.depGroups=["TraceChains"];const aF=oF;class lF extends ZU{static id="TU";getResidueRadius(t){return this.TUBE_RADIUS}getHeightSegmentsRatio(){return this.opts.heightSegmentsRatio}getTension(){return this.opts.tension}buildGeometry(t,e,n,i){const r=this.opts.radius;return this.TUBE_RADIUS=new $P.Vector2(r,r),ZU.prototype.buildGeometry.call(this,t,e,n,i)}}lF.prototype.id="TU",lF.prototype.name="Tube",lF.prototype.shortName="Tube",lF.prototype.depGroups=["CartoonChains"];const cF=lF;class hF extends ZU{static id="CA";constructor(t){super(t),this.secCache={}}getResidueStartRadius(t){const e=t.getSecondary();if(!e||!e.generic)return this.TUBE_RADIUS;const n=this.secCache[e.generic];return n?e.term===t?n.start:n.center:this.TUBE_RADIUS}getResidueEndRadius(t){const e=t.getSecondary();if(null===e||!e.generic)return this.TUBE_RADIUS;const n=this.secCache[e.generic];return n?e.term===t?this.ARROW_END:n.center:this.TUBE_RADIUS}getResidueRadius(t,e){const n=this.getResidueStartRadius(t);if(0===e)return n;const i=this.getResidueEndRadius(t);return 2===e?i:n.clone().lerp(i,e/2)}calcStickRadius(t){return this.opts.radius}getHeightSegmentsRatio(){return this.opts.heightSegmentsRatio}getTension(){return this.opts.tension}buildGeometry(t,e,n,i){const r=this.opts.radius,s=this.opts.depth;this.TUBE_RADIUS=new $P.Vector2(r,r),this.ARROW_END=new $P.Vector2(s,r);const o={},a=this.opts.ss;for(const t in a)o[t]={center:new $P.Vector2(s,a[t].width),start:new $P.Vector2(s,a[t].arrow)};return this.secCache=o,ZU.prototype.buildGeometry.call(this,t,e,n,i)}}hF.prototype.id="CA",hF.prototype.name="Cartoon",hF.prototype.shortName="Cartoon",hF.prototype.depGroups=["CartoonChains","NucleicSpheres","NucleicCylinders"];const uF=hF,{selectors:dF}=DN;function pF(){return{wireframe:this.opts.wireframe,zClip:this.opts.zClip}}class fF extends ZU{constructor(t){super(t),this.depGroups=this.depGroups.slice(0);const e=this.surfaceNames,n=this.depGroups;for(let t=0,i=e.length;t<i;++t)n[n.length]=[e[t],pF]}calcAtomRadius(t){return t.element.radius}getVisibilitySelector(){let t=null;if(""!==this.opts.subset){const e=dF.parse(this.opts.subset);e.error||(t=e.selector)}return t}}fF.prototype.isSurface=!0,fF.prototype.surfaceNames=[];const mF=fF;class gF extends mF{static id="QS";getSurfaceOpts(){return{useBeads:!1,isoValue:this.opts.isoValue,gaussLim:this.opts.gaussLim[this.settings.now.resolution],radScale:this.opts.scale,gridSpacing:this.opts.gridSpacing[this.settings.now.resolution],zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector()}}}gF.prototype.id="QS",gF.prototype.name="Quick Surface",gF.prototype.shortName="Quick Surf",gF.prototype.surfaceNames=["QuickSurfGeo"];const _F=gF;class yF extends mF{constructor(t,e){super(e),this._excludeProbe=t}calcAtomRadius(t){return t.element.radius}getSurfaceOpts(){return{gridSpacing:this.opts.polyComplexity[this.settings.now.resolution],radScale:this._radScale,zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector(),probeRadius:this.opts.probeRadius,excludeProbe:this._excludeProbe}}}yF.prototype.id="SU",yF.prototype.name="Surface",yF.prototype.shortName="Surface",yF.prototype.surfaceNames=["SASSESSurfaceGeo"],yF.prototype._radScale=1,yF.prototype._excludeProbe=!1;const vF=yF;class xF extends vF{static id="SA";constructor(t){super(!1,t)}}xF.prototype.id="SA",xF.prototype.name="Solvent Accessible Surface",xF.prototype.shortName="SAS";const SF=xF;class bF extends vF{static id="SE";constructor(t){super(!0,t)}}bF.prototype.id="SE",bF.prototype.name="Solvent Excluded Surface",bF.prototype.shortName="SES";const MF=bF;class wF extends mF{static id="CS";getSurfaceOpts(){return{probeRadius:this.opts.probeRadius,radScale:this.opts.polyComplexity[this.settings.now.resolution],scaleFactor:this.opts.polyComplexity[this.settings.now.resolution],gridSpacing:1/this.opts.polyComplexity[this.settings.now.resolution],isoValue:this.opts.isoValue,probePositions:this.opts.probePositions,zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector()}}}wF.prototype.id="CS",wF.prototype.name="Contact Surface",wF.prototype.shortName="Contact Surf",wF.prototype.isSurface=!0,wF.prototype.surfaceNames=["ContactSurfaceGeo"];const EF=wF;class TF extends ZU{static id="TX";getTemplateOptions(){return this.opts.template}getLabelOpts(){return qP.default.merge(this.opts,{colors:!0,adjustColor:!0,transparent:!0})}}TF.prototype.id="TX",TF.prototype.name="Text mode",TF.prototype.shortName="Text",TF.prototype.depGroups=["TextLabelsGeo"];const AF=new JN([QU,eF,iF,sF,aF,cF,uF,_F,SF,MF,EF,TF]);function CF(t,e,n){return t<=n?t<0?0:t:n}class RF{constructor(t,e){this.name=t||"Custom",this.id=e||"CP"}getElementColor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this.elementColors[t];return void 0!==n||e?n:this.defaultElementColor}getResidueColor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this.residueColors[t];return void 0!==n||e?n:this.defaultResidueColor}getChainColor(t){let e=t.charCodeAt(0);return e=(31&(e<0?0:e>=256?e-256:e))%this.chainColors.length,this.chainColors[e]}getSecondaryColor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this.secondaryColors[t];return void 0!==n||e?n:this.defaultSecondaryColor}getSequentialColor(t){const{colors:e}=this,n=e.length;return t<0?e[t%n+n]:e[t%n]}getGradientColor(t,e){const n=this.gradients[e];if(!n)return this.defaultNamedColor;const i=n.length,r=t*(i-1);let s=Math.floor(r);const o=CF(s+1,0,i-1);return s=CF(s,0,i-1),function(t,e,n){const i=1-n;return i*(t>>16&255)+n*(e>>16&255)<<16|i*(t>>8&255)+n*(e>>8&255)<<8|i*(255&t)+n*(255&e)}(n[s],n[o],r-s)}getNamedColor(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this.namedColors[t];return void 0!==n||e?n:this.defaultNamedColor}}qP.default.assign(RF.prototype,{colors:[16777215,16711680,65280,255,8421504],minRangeColor:0,midRangeColor:8355711,maxRangeColor:16777215,defaultElementColor:16777215,elementColors:{},defaultResidueColor:16777215,residueColors:{},chainColors:[16777215],defaultSecondaryColor:16777215,secondaryColors:{},defaultGradientColor:0,defaultNamedColor:16777215,namedColorsArray:[["indianred",13458524],["lightcoral",15761536],["salmon",16416882],["darksalmon",15308410],["lightsalmon",16752762],["crimson",14423100],["red",16711680],["firebrick",11674146],["darkred",9109504],["pink",16761035],["lightpink",16758465],["hotpink",16738740],["deeppink",16716947],["mediumvioletred",13047173],["palevioletred",14381203],["coral",16744272],["tomato",16737095],["orangered",16729344],["darkorange",16747520],["orange",16753920],["gold",16766720],["yellow",16776960],["lightyellow",16777184],["lemonchiffon",16775885],["lightgoldenrodyellow",16448210],["papayawhip",16773077],["moccasin",16770229],["peachpuff",16767673],["palegoldenrod",15657130],["khaki",15787660],["darkkhaki",12433259],["lavender",15132410],["thistle",14204888],["plum",14524637],["violet",15631086],["orchid",14315734],["fuchsia",16711935],["magenta",16711935],["mediumorchid",12211667],["mediumpurple",9662683],["rebeccapurple",6697881],["blueviolet",9055202],["darkviolet",9699539],["darkorchid",10040012],["darkmagenta",9109643],["purple",8388736],["indigo",4915330],["slateblue",6970061],["mediumslateblue",8087790],["darkslateblue",4734347],["greenyellow",11403055],["chartreuse",8388352],["lawngreen",8190976],["lime",65280],["limegreen",3329330],["palegreen",10025880],["lightgreen",9498256],["mediumspringgreen",64154],["springgreen",65407],["mediumseagreen",3978097],["seagreen",3050327],["forestgreen",2263842],["green",32768],["darkgreen",25600],["yellowgreen",10145074],["olivedrab",7048739],["olive",8421376],["darkolivegreen",5597999],["mediumaquamarine",6737322],["darkseagreen",9419919],["lightseagreen",2142890],["darkcyan",35723],["teal",32896],["aqua",65535],["cyan",65535],["lightcyan",14745599],["paleturquoise",11529966],["aquamarine",8388564],["turquoise",4251856],["mediumturquoise",4772300],["darkturquoise",52945],["cadetblue",6266528],["steelblue",4620980],["lightsteelblue",11584734],["powderblue",11591910],["lightblue",11393254],["skyblue",8900331],["lightskyblue",8900346],["deepskyblue",49151],["dodgerblue",2003199],["cornflowerblue",6591981],["royalblue",4286945],["blue",255],["mediumblue",205],["darkblue",139],["navy",128],["midnightblue",1644912],["cornsilk",16775388],["blanchedalmond",16772045],["bisque",16770244],["navajowhite",16768685],["wheat",16113331],["burlywood",14596231],["tan",13808780],["rosybrown",12357519],["sandybrown",16032864],["goldenrod",14329120],["darkgoldenrod",12092939],["peru",13468991],["chocolate",13789470],["saddlebrown",9127187],["sienna",10506797],["brown",10824234],["maroon",8388608],["white",16777215],["snow",16775930],["honeydew",15794160],["mintcream",16121850],["azure",15794175],["aliceblue",15792383],["ghostwhite",16316671],["whitesmoke",16119285],["seashell",16774638],["beige",16119260],["oldlace",16643558],["floralwhite",16775920],["ivory",16777200],["antiquewhite",16444375],["linen",16445670],["lavenderblush",16773365],["mistyrose",16770273],["gainsboro",14474460],["lightgray",13882323],["silver",12632256],["darkgray",11119017],["gray",8421504],["dimgray",6908265],["lightslategray",7833753],["slategray",7372944],["darkslategray",3100495],["black",0]],namedColors:{},gradients:{rainbow:[255,65535,65280,16776960,16711680],temp:[255,32767,16777215,16744192,16711680],hot:[16777215,16744192,16711680],cold:[16777215,32767,255],"blue-red":[255,16777215,16711680],reds:[16777215,16711680],blues:[16777215,255]}});const{namedColorsArray:PF,namedColors:LF}=RF.prototype;for(let t=0,{length:e}=PF;t<e;++t){const[e,n]=PF[t];LF[e]=n}const IF=RF,NF=new IF("CPK","CP");NF.elementColors={H:16777215,C:2105376,N:2121983,O:15605776,F:65280,P:8397055,S:16776960,CL:47872,FE:13684944,CO:13684944,NI:13684944,CU:13684944,BR:34816,I:21760};const DF=NF,OF=new IF("Jmol","JM");OF.colors=[255,22015,44031,65535,65451,65365,65280,5635840,11271936,16776960,16755456,16733440,16711680,16711765,16711851,16711935,11206911,5570815],OF.elementColors={H:16777215,D:16777152,T:16777120,HE:14286847,LI:13402367,BE:12779264,B:16758197,C:9474192,N:3166456,O:16715021,F:9494608,NE:11789301,NA:11230450,MG:9109248,AL:12560038,SI:1578e4,P:16744448,S:16777008,CL:2093087,AR:8442339,K:9388244,CA:4062976,SC:15132390,TI:12567239,V:10921643,CR:9083335,MN:10255047,FE:14706227,CO:15765664,NI:5296208,CU:13140019,ZN:8224944,GA:12750735,GE:6721423,AS:12419299,SE:16752896,BR:10889513,KR:6076625,RB:7351984,SR:65280,Y:9764863,ZR:9756896,NB:7586505,MO:5551541,TC:3907230,RU:2396047,RH:687500,PD:27013,AG:12632256,CD:16767375,IN:10909043,SN:6717568,SB:10380213,TE:13924864,I:9699476,XE:4366e3,CS:5707663,BA:51456,LA:7394559,CE:16777159,PR:14286791,ND:13107143,PM:10747847,SM:9437127,EU:6422471,GD:4587463,TB:3211207,DY:2097095,HO:65436,ER:58997,TM:54354,YB:48952,LU:43812,HF:5096191,TA:5089023,W:2200790,RE:2522539,OS:2516630,IR:1528967,PT:13684960,AU:16765219,HG:12105936,TL:10900557,PB:5724513,BI:10375093,PO:11230208,AT:7688005,RN:4358806,FR:4325478,RA:32e3,AC:7384058,TH:47871,PA:41471,U:36863,NP:33023,PU:27647,AM:5528818,CM:7888099,BK:9064419,CF:10565332,ES:11739092,FM:11739066,MD:11734438,NO:12389767,LR:13041766,RF:13369433,DB:13697103,SG:14221381,BH:14680120,HS:15073326,MT:15400998},OF.defaultResidueColor=12492910,OF.residueColors={ALA:13158600,ARG:1334015,ASN:56540,ASP:15075850,CYS:15132160,GLN:56540,GLU:15075850,GLY:15461355,HIS:8553170,ILE:1016335,LEU:1016335,LYS:1334015,MET:15132160,PHE:3289770,PRO:14456450,SER:16422400,THR:16422400,TRP:11819700,TYR:3289770,VAL:1016335,A:10526975,C:16747595,G:16740464,I:8454143,T:10551200,U:16744576,DA:10526975,DC:16747595,DG:16740464,DI:8454143,DT:10551200,DU:16744576,"+A":10526975,"+C":16747595,"+G":16740464,"+I":8454143,"+T":10551200,"+U":16744576},OF.chainColors=[4294967295,4290826495,4289789872,4294951112,4294967168,4294951167,4289786096,4294955120,4293951616,4294303411,4278239231,4291648604,4284927402,4288335154,4293821166,4278243025,4278255487,4282168177,4278190219,4290623339,4278215680,4286578688,4286611456,4286578816,4278222976,4290283019,4289864226];const UF=SI.Type;OF.secondaryColors={[UF.HELIX_ALPHA]:16711808,[UF.HELIX_PI]:6291584,[UF.HELIX_310]:10485888,[UF.STRAND]:16762880,[UF.TURN]:6324479,dna:11403518,rna:16580962};const FF=OF,BF=new IF("VMD","VM");BF.colors=[255,16711680,6316128,16744448,16776960,8421427,10066329,65280,16777215,16751001,4243648,10879142,8447590,15099571,8408320,8421568],BF.defaultElementColor=8408320,BF.elementColors={H:16777215,C:4243391,N:255,O:16711680,P:8421427,S:16776960},BF.defaultResidueColor=4243648,BF.residueColors={ALA:255,ARG:16777215,ASN:8421427,ASP:16711680,CYS:16776960,GLN:16744448,GLU:16751001,GLY:16777215,HIS:4243648,ILE:65280,LEU:16751001,LYS:4243648,MET:16776960,PHE:10879142,PRO:8408064,SER:16776960,THR:15099571,TRP:10066329,TYR:65280,VAL:8421427,A:255,C:16744448,G:16776960,T:10879142,U:65280,DA:255,DC:16744448,DG:16776960,DT:10879142,DU:65280,"+A":255,"+C":16744448,"+G":16776960,"+T":10879142,"+U":65280,WAT:4243648,H2O:4243648,HOH:4243648},BF.chainColors=[16777215].concat(BF.colors);const zF=SI.Type;BF.secondaryColors={[zF.HELIX_ALPHA]:10879142,[zF.HELIX_310]:255,[zF.HELIX_PI]:16711680,[zF.STRAND]:16776960,[zF.BRIDGE]:8421427,[zF.TURN]:4243648};const VF=new JN([DF,FF,BF]);class kF{constructor(t){if(this.constructor===kF)throw new Error("Can not instantiate abstract class!");this.opts=qP.default.merge(AL.deriveDeep(LL.now.colorers[this.id],!0),t),this.palette=VF.first}identify(){const t=AL.objectsDiff(this.opts,LL.now.colorers[this.id]);return qP.default.isEmpty(t)?this.id:[this.id,t]}}kF.prototype.id="__";const GF=kF;class HF extends GF{static id="EL";getAtomColor(t,e){const n=t.element.name;return"C"===n&&this.opts.carbon>=0?this.opts.carbon:this.palette.getElementColor(n)}getResidueColor(t,e){return this.palette.defaultResidueColor}}HF.prototype.id="EL",HF.prototype.name="Element",HF.prototype.shortName="Element";const WF=HF;class jF extends GF{static id="RT";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){return this.palette.getResidueColor(t._type._name)}}jF.prototype.id="RT",jF.prototype.name="Residue Type",jF.prototype.shortName="Residue";const XF=jF;class YF extends GF{static id="SQ";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){const n=t._chain;if(n.minSequence===Number.POSITIVE_INFINITY&&n.maxSequence===Number.NEGATIVE_INFINITY)return this.palette.defaultNamedColor;const i=n.minSequence,r=n.maxSequence>i?n.maxSequence:i+1;return this.palette.getGradientColor((t._sequence-i)/(r-i),this.opts.gradient)}}YF.prototype.id="SQ",YF.prototype.name="Sequence",YF.prototype.shortName="Sequence";const qF=YF;class $F extends GF{static id="CH";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){return this.palette.getChainColor(t.getChain()._name)}}$F.prototype.id="CH",$F.prototype.name="Chain",$F.prototype.shortName="Chain";const ZF=$F;class JF extends GF{static id="SS";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){if(t._type.flags&gI.Flags.DNA)return this.palette.getSecondaryColor("dna");if(t._type.flags&gI.Flags.RNA)return this.palette.getSecondaryColor("rna");const n=t.getSecondary();if(n){let t=this.palette.getSecondaryColor(n.type,!0);return void 0===t&&(t=this.palette.getSecondaryColor(n.generic)),t}return this.palette.defaultSecondaryColor}}JF.prototype.id="SS",JF.prototype.name="Secondary Structure",JF.prototype.shortName="Structure";const KF=JF;class QF extends GF{static id="UN";getAtomColor(t,e){return this.opts.color}getResidueColor(t,e){return this.opts.color}}QF.prototype.id="UN",QF.prototype.name="Uniform",QF.prototype.shortName="Uniform";const tB=QF;class eB extends GF{static id="CO";constructor(t){super(t);const e=YI.parse(this.opts.subset);this._subsetCached=e.error?YI.none():e.selector}getAtomColor(t,e){return this._subsetCached.includesAtom(t)?this.opts.color:this.opts.baseColor}getResidueColor(t,e){const n=this._subsetCached,i=t._atoms;for(let t=0,e=i.length;t<e;++t)if(!n.includesAtom(i[t]))return this.opts.baseColor;return this.opts.color}}eB.prototype.id="CO",eB.prototype.name="Conditional",eB.prototype.shortName="Conditional";const nB=eB;class iB extends GF{static id="CF";getAtomColor(t,e){return this.palette.getChainColor(String.fromCharCode(t.location))}getResidueColor(t,e){return this.palette.defaultResidueColor}}iB.prototype.id="CF",iB.prototype.name="Conformation",iB.prototype.shortName="Conformation";const rB=iB;class sB extends GF{static id="TM";getAtomColor(t,e){const{opts:n}=this;let i=1;return t.temperature&&n?(i=n.min===n.max?t.temperature>n.max?1:0:(t.temperature-n.min)/(n.max-n.min),this.palette.getGradientColor(i,n.gradient)):this.palette.defaultGradientColor}getResidueColor(t,e){const{opts:n}=this;if(!n)return this.palette.defaultGradientColor;if(t.temperature){let e=0;return e=n.min===n.max?t.temperature>n.max?1:0:(t.temperature-n.min)/(n.max-n.min),this.palette.getGradientColor(e,n.gradient)}return this.palette.defaultGradientColor}}sB.prototype.id="TM",sB.prototype.name="Temperature",sB.prototype.shortName="Temperature";const oB=sB;class aB extends GF{static id="OC";_getColorByOccupancy(t,e){if(void 0!==t){const n=1-t;return this.palette.getGradientColor(n,e.gradient)}return this.palette.defaultGradientColor}getAtomColor(t,e){const{opts:n}=this;return this._getColorByOccupancy(t.occupancy,n)}getResidueColor(t,e){const{opts:n}=this;return this._getColorByOccupancy(t.occupancy,n)}}aB.prototype.id="OC",aB.prototype.name="Occupancy",aB.prototype.shortName="Occupancy";const lB=aB;class cB extends GF{static id="HY";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){let n=this.palette.defaultResidueColor;if(void 0!==t._type.hydrophobicity){const e=-4.5,i=4.5;n=this.palette.getGradientColor((t._type.hydrophobicity-e)/(i-e),this.opts.gradient)}return n}}cB.prototype.id="HY",cB.prototype.name="Hydrophobicity",cB.prototype.shortName="Hydrophobicity";const hB=cB;class uB extends GF{static id="MO";getAtomColor(t,e){return this.getResidueColor(t.residue,e)}getResidueColor(t,e){const n=t._molecule,i=e.getMoleculeCount();return i>1?this.palette.getGradientColor((n.index-1)/(i-1),this.opts.gradient):this.palette.getGradientColor(0,this.opts.gradient)}}uB.prototype.id="MO",uB.prototype.name="Molecule",uB.prototype.shortName="Molecule";const dB=uB;class pB extends GF{static id="CB";getAtomColor(t,e){const n=this.opts.color,i=(r=n,(s=this.opts.factor)*(r>>16&255)<<16|s*(r>>8&255)<<8|s*(255&r));var r,s;return t.flags&tI.Flags.CARBON?n:i}getResidueColor(t,e){return this.opts.color}}pB.prototype.id="CB",pB.prototype.name="Carbon",pB.prototype.shortName="Carbon";const fB=new JN([WF,XF,qF,ZF,KF,tB,nB,rB,oB,lB,hB,dB,pB]);function mB(t){return new $P.Color(t,t,t)}const gB=[{id:"DF",name:"Diffuse",shortName:"Diffuse",uberOptions:{diffuse:mB(1),specular:mB(0),shininess:1,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"SF",name:"Soft Plastic",shortName:"Soft",uberOptions:{diffuse:mB(1),specular:mB(.1),shininess:30,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"PL",name:"Glossy Plastic",shortName:"Glossy",uberOptions:{diffuse:mB(.56),specular:mB(.28),shininess:100,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"ME",name:"Metal",shortName:"Metal",uberOptions:{diffuse:mB(.56),specular:mB(.55),shininess:30,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"TR",name:"Transparent",shortName:"Transparent",uberOptions:{diffuse:mB(1),specular:mB(0),shininess:1,opacity:.5},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!0,toonShading:!1}},{id:"GL",name:"Glass",shortName:"Glass",uberOptions:{diffuse:mB(.5),specular:mB(.65),shininess:100,opacity:.5},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!0,toonShading:!1}},{id:"BA",name:"Backdrop",shortName:"Backdrop",uberOptions:{diffuse:mB(1),specular:mB(0),shininess:1,opacity:1},values:{lights:!1,fog:!1,depthWrite:!1,transparent:!1,toonShading:!1}},{id:"TN",name:"Toon",shortName:"Toon",uberOptions:{diffuse:mB(1),specular:mB(0),shininess:1,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!0}},{id:"FL",name:"Flat",shortName:"Flat",uberOptions:{diffuse:mB(1),specular:mB(0),shininess:0,opacity:1},values:{lights:!1,fog:!0,depthWrite:!0,transparent:!1}}],_B=new JN(gB);function yB(t,e,n){const i=t.material.createInstance();i.setValues(e);const r=new t.constructor(t.geometry,i);return r.material.needsUpdate=!0,r.applyMatrix4(t.matrix),r.layers.set(n),r}function vB(t,e,n){const i=function(t,e){const n=[];return t.traverse(t=>{for(let i=0;i<e.length;i++)if(t instanceof e[i]){n[n.length]=t;break}}),n}(t,e);for(let t=0,e=i.length;t<e;++t){const e=i[t];e.parent&&n(e)}}function xB(t,e){!function t(n){n instanceof $P.Mesh&&e(n);for(let e=0,i=n.children.length;e<i;e++)t(n.children[e])}(t)}const SB={applyTransformsToMeshes:function(t,e){const n=e.length;n<1||vB(t,[$P.Mesh,$P.LineSegments,$P.Line],t=>{t.applyMatrix4(e[0]);for(let i=1;i<n;++i){const n=new t.constructor(t.geometry,t.material);t.parent.add(n),n.applyMatrix4(e[i])}})},processTransparentMaterial:function(){const t={prepassTransparancy:!0,fakeOpacity:!1,transparent:!1,colorFromDepth:!1,lights:!1,shadowmap:!1,fog:!1};return function(e,n){n instanceof DO&&vB(e,[$P.Mesh,$P.LineSegments],e=>{e.material.setValues({prepassTransparancy:!1,fakeOpacity:!1}),e.material.needsUpdate=!0,e.layers.set(jN.LAYERS.TRANSPARENT);const n=yB(e,t,jN.LAYERS.PREPASS_TRANSPARENT);e.parent.add(n)})}}(),processColFromPosMaterial:function(){const t={colorFromPos:!0,transparent:!1,colorFromDepth:!1,lights:!1,shadowmap:!1,fog:!1,overrideColor:!1,fogTransparent:!1,attrColor:!1,attrColor2:!1,attrAlphaColor:!1,fakeOpacity:!1};return function(e,n){n instanceof DO&&vB(e,[$P.Mesh,$P.LineSegments],e=>{const n=yB(e,t,jN.LAYERS.COLOR_FROM_POSITION);e.parent.add(n)})}}(),createShadowmapMaterial:function(){const t={colorFromDepth:!0,orthoCam:!0,lights:!1,shadowmap:!1,fog:!1};return function(e,n){n instanceof DO&&vB(e,[$P.Mesh,$P.LineSegments],e=>{if(!e.receiveShadow&&e.material.shadowmap&&e.material.setValues({shadowmap:!1}),!e.material.lights)return;if(!e.castShadow)return;if(!jN.belongToSelectLayers(e))return;const n=yB(e,t,jN.LAYERS.SHADOWMAP);n.isShadowmapMesh=!0,e.parent.add(n)})}}(),removeShadowmapMaterial:function(t,e){e instanceof DO&&vB(t,[$P.Mesh,$P.LineSegments],t=>{t.isShadowmapMesh&&t.parent.remove(t)})},forEachMeshInGroup:xB,countTriangles:function(t){let e=0;return xB(t,t=>{e+=function(t){const e=t.geometry;if(e instanceof $P.InstancedBufferGeometry){const t=e.attributes;for(const n in t)if(t.hasOwnProperty(n)&&t[n]instanceof $P.InstancedBufferAttribute){const i=t[n];return(e.index?e.index.array.length/3:0)*i.array.length/i.itemSize}return 0}return e instanceof $P.BufferGeometry?e.index?e.index.array.length/3:0:e.faces?e.faces.length:0}(t)}),e}},{selectors:bB}=DN,MB=class{constructor(t,e,n,i){const r={clipPlane:LL.now.draft.clipPlane,fogTransparent:LL.now.bg.transparent,shadowmap:LL.now.shadow.on,shadowmapType:LL.now.shadow.type};this.index=t,this.mode=e,this.colorer=n,this.selector=i,this.selectorString="",this.count=0,this.material=new DO,this.material.setValues(r),this.material.setUberOptions({fogAlpha:LL.now.fogAlpha}),this.materialPreset=_B.first,this.needsRebuild=!0,this.visible=!0,this.setMode(e)}markAtoms(t){return this.count=t.markAtoms(this.selector,1<<this.index),this.needsRebuild=!0,this.count}unmarkAtoms(t){t.clearAtomBits(1<<this.index),this.count=0}setMode(t){this.mode=t}setMaterialPreset(t){this.materialPreset=t,this.material.setUberOptions(t.uberOptions),this.material.setValues(t.values)}reset(){this.geo=null,this.selectionGeo=null}buildGeometry(t){return this.reset(),this.needsRebuild=!1,LL.now.ao&&this.material.setValues({normalsToGBuffer:LL.now.ao}),this.geo=this.mode.buildGeometry(t,this.colorer,1<<this.index,this.material),this.material.uberOptions.opacity<.99&&"prepass"===LL.now.transparency&&SB.processTransparentMaterial(this.geo,this.material),this.geo.visible=this.visible,jN.processObjRenderOrder(this.geo,this.materialPreset.id),SB.processColFromPosMaterial(this.geo,this.material),LL.now.shadow.on&&SB.createShadowmapMaterial(this.geo,this.material),this.geo}buildSelectionGeometry(t){let e=null;if(this.geo&&"getSubset"in this.geo){const n=this.geo.getSubset(t);if(n&&n.length>0){e=new $P.Group,e.matrixAutoUpdate=!1,e.matrix=this.geo.matrix;for(let t=0;t<n.length;t++){const i=n[t];e.add(i)}}}return e&&(e.visible=this.visible),this.selectionGeo=e,this.selectionGeo}compare(t){const e={},n=String(this.selector);t&&n.valueOf()===String(t.selector).valueOf()||(e.selector=n);const i=this.mode.identify();t&&!Array.isArray(i)&&i===t.mode||(e.mode=i);const r=this.colorer.identify();return t&&!Array.isArray(r)&&r===t.colorer||(e.colorer=r),t&&this.materialPreset.id===t.material||(e.material=this.materialPreset.id),e}change(t,e,n,i){const r={};if(t.selector){const n=bB.parse(t.selector).selector,i=String(n);this.selectorString!==i&&(r.selector=i,this.selectorString=i,this.selector=n,this.markAtoms(e))}if(t.mode){const e=t.mode;qP.default.isEqual(this.mode.identify(),e)||(r.mode=e,this.setMode(n))}if(t.colorer){const e=t.colorer;qP.default.isEqual(this.colorer.identify(),e)||(r.colorer=e,this.colorer=i)}if(t.material){const e=t.material;qP.default.isEqual(this.materialPreset.id,e)||(r.material=e,this.setMaterialPreset(_B.get(t.material)))}return r}show(t){this.visible=t,this.geo&&(this.geo.visible=t),this.selectionGeo&&(this.selectionGeo.visible=t)}};function wB(t,e,n){const{children:i}=t;if(i)for(let t=0,r=i.length;t<r;++t){const r=i[t];r._component===e&&n(r),r instanceof jN.RCGroup&&wB(r,e,n)}}function EB(){}const TB=class extends EB{constructor(t){super(),this._complexVisual=t,this._inProgress=!1}begin(){const t=this._complexVisual.getComplex();this._componentTransforms=[];for(let e=0;e<t._components.length;++e){const n=t._components[e];this._componentTransforms[n._index]=new $P.Object3D}return this._inProgress=!0,!0}apply(){if(!this._inProgress)return;const t=this._complexVisual.getComplex();for(let e=0;e<t._components.length;++e)this._bakeComponentTransform(t._components[e]);t.onAtomPositionChanged(),this._resetComponentTransform(),this._complexVisual.finalizeEdit()}discard(){this._inProgress&&(this._resetComponentTransform(),this._complexVisual.finalizeEdit())}getAltObj(){const t={objects:[],pivot:new $P.Vector3(0,0,0)},e=this._complexVisual,n=e.getSelectedComponent();if(null===n)return t;const i=this._complexVisual.getSelectionGeo(),r=1<<e.getSelectionBit();let s,o,a,l;for(wB(e,n,e=>{t.objects.push(e)}),s=0;s<i.children.length;++s)for(a=i.children[s],o=0;o<a.children.length;++o)l=a.children[o],l.hasOwnProperty("_component")&&l._component===n&&t.objects.push(l);t.objects.push(this._componentTransforms[n._index]);const c=new $P.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),h=new $P.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return n.forEachResidue(t=>{const e=t._atoms;for(o=0;o<e.length;++o)e[o].mask&r&&(c.min(e[o].position),h.max(e[o].position))}),t.pivot.lerpVectors(c,h,.5),t}_bakeComponentTransform(t){const e=this._componentTransforms[t._index];!e||0===e.position.x&&0===e.position.y&&0===e.position.z&&0===e.quaternion.x&&0===e.quaternion.y&&0===e.quaternion.z&&1===e.quaternion.w||(e.updateMatrix(),t.forEachResidue(t=>{const n=t._atoms;for(let t=0;t<n.length;++t)n[t].position.applyMatrix4(e.matrix)}))}_resetComponentTransform(){const t=this._complexVisual,e=this._complexVisual.getSelectionGeo();let n,i,r,s;for(n=0;n<this._componentTransforms.length;++n)s=this._componentTransforms[n],s.position.set(0,0,0),s.quaternion.set(0,0,0,1);for(n=0;n<t.children.length;++n)for(r=t.children[n],i=0;i<r.children.length;++i)s=r.children[i],s.hasOwnProperty("_component")&&(s.position.set(0,0,0),s.quaternion.set(0,0,0,1));for(n=0;n<e.children.length;++n)for(r=e.children[n],i=0;i<r.children.length;++i)s=r.children[i],s.hasOwnProperty("_component")&&(s.position.set(0,0,0),s.quaternion.set(0,0,0,1))}},AB=class extends EB{constructor(t){super(),this._complexVisual=t,this._inProgress=!1}begin(){const t=this._complexVisual,e=this._complexVisual.getSelectionGeo(),n=this._getSelectionBorderAtoms();if(n.length<1||n.length>2)return fL.error("Can only edit fragments with one or two bound atoms."),!1;this._fragmentBoundAtoms=n;const i=1<<t.getSelectionBit();t.disableSubset(i,!0);for(let t=0;t<e.children.length;++t)e.children[t].visible=!1;const r=n[0].position.clone();2===n.length&&r.lerp(n[1].position,.5),this._fragmentGeo=new $P.Group,t.add(this._fragmentGeo),this._fragmentGeo.position.copy(r),this._fragmentSelectionGeo=new $P.Group,e.add(this._fragmentSelectionGeo),this._fragmentSelectionGeo.position.copy(r);const s=r.clone();s.negate();for(let e=0;e<t.children.length;++e){const n=t.children[e];if(!("getSubset"in n))continue;const r=new $P.Group;this._fragmentGeo.add(r);const o=new $P.Group;this._fragmentSelectionGeo.add(o);const a=n.getSubset(i,!0);for(let t=0;t<a.length;t++){const e=a[t];r.add(e),e.position.copy(s)}const l=n.getSubset(i,!0);for(let t=0;t<l.length;t++){const e=l[t];o.add(e),e.position.copy(s)}}return jN.applySelectionMaterial(this._fragmentSelectionGeo),this._inProgress=!0,!0}apply(){if(!this._inProgress)return;const t=this._complexVisual,e=t.getSelectionBit(),n=this._fragmentGeo.position,i=this._fragmentGeo.matrix.clone();i.multiply((new $P.Matrix4).makeTranslation(-n.x,-n.y,-n.z)),this._bakeAtomTransform(i,1<<e),t.enableSubset(1<<e,!0),t.getComplex().onAtomPositionChanged(),t.finalizeEdit()}discard(){if(!this._inProgress)return;const t=this._complexVisual,e=this._complexVisual.getSelectionGeo();this._fragmentGeo.parent.remove(this._fragmentGeo),t.enableSubset(1<<t.getSelectionBit(),!0);for(let t=0;t<e.children.length;++t){const n=e.children[t];n.visible?e.remove(n):n.visible=!0}t.finalizeEdit()}isFreeRotationAllowed(){return this._fragmentBoundAtoms.length<2}getAltObj(){const t={objects:[],pivot:new $P.Vector3(0,0,0)};t.objects.push(this._fragmentGeo,this._fragmentSelectionGeo);const e=this._fragmentBoundAtoms;if(1===e.length){if(1===e[0].bonds.length){const n=e[0].bonds[0];t.axis=(new $P.Vector3).subVectors(n._right.position,n._left.position),t.axis.normalize(),t.axis.transformDirection(this._complexVisual.matrixWorld)}}else 2===e.length&&(t.axis=(new $P.Vector3).subVectors(e[1].position,e[0].position),t.axis.normalize(),t.axis.transformDirection(this._complexVisual.matrixWorld));return t}_getSelectionBorderAtoms(){const t=this._complexVisual.getComplex(),e=1<<this._complexVisual.getSelectionBit(),n={};t.forEachBond(t=>{t._left.mask&e?0===(t._right.mask&e)&&(n[t._left.index]=1):t._right.mask&e&&(n[t._right.index]=1)});const i=[],r=Object.keys(n);for(let e=0,n=r.length;e<n;++e){const n=r[e];i.push(t._atoms[n])}return i}_bakeAtomTransform(t,e){this._complexVisual.getComplex().forEachAtom(n=>{n.mask&e&&n.position.applyMatrix4(t)})}},{selectors:CB}=DN;function RB(t,e){Array.isArray(e)||(e=[e]);const[n,i]=e;return new(t.get(n)||t.first)(i)}class PB extends qN{constructor(t,e){super(t,e),this._complex=e,this._reprList=[],this._repr=null,this._reprListChanged=!0,this._selectionBit=0,this._reprUsedBits=0,this._selectionCount=0,this._selectionGeometry=new $P.Group}getBoundaries(){return this._complex.getBoundaries()}release(){this._selectionGeometry.parent&&this._selectionGeometry.remove(this._selectionGeometry),qN.prototype.release.call(this)}getComplex(){return this._complex}getSelectionCount(){return this._selectionCount}getSelectionGeo(){return this._selectionGeometry}getSelectionBit(){return this._selectionBit}getEditor(){return this._editor}resetReps(t){this._complex&&this._complex.clearAtomBits(-1),this._reprListChanged=!0,this._reprUsedBits=0,this._reprList.length=t.length;for(let e=0,n=t.length;e<n;++e){const n=t[e];let i,r;"string"==typeof n.selector?(r=n.selector,({selector:i}=CB.parse(r))):void 0===n.selector?(r=LL.now.presets.default[0].selector,({selector:i}=CB.parse(r))):(({selector:i}=n),r=i.toString());const s=RB(AF,n.mode),o=RB(fB,n.colorer),a=_B.get(n.material)||_B.first;this._reprList[e]=new MB(e,s,o,i),this._reprList[e].setMaterialPreset(a),this._reprList[e].selectorString=r,this._complex&&this._complex.markAtoms(i,1<<e),this._reprUsedBits|=1<<e}this._repr=t.length>0?this._reprList[0]:null,this._selectionBit=t.length,this._reprUsedBits|=1<<this._selectionBit,this._selectionCount=0,this._complex&&this._complex.update()}repCount(){return this._reprList.length}repCurrent(t){return t>=0&&t<this._reprList.length?this._repr=this._reprList[t]:t=this._reprList.indexOf(this._repr),t}rep(t,e){if(!e&&(void 0===t||t instanceof Object)&&(e=t,t=this.repCurrent()),t<0||t>this._reprList.length)return fL.error(`Rep ${t} does not exist!`),null;if(t===this._reprList.length){const n=this.repAdd(e);return fL.warn(`Rep ${t} does not exist! New representation was created.`),{desc:n.desc,index:t,status:"created"}}const n=this._reprList[t],i={selector:n.selectorString,mode:n.mode.identify(),colorer:n.colorer.identify(),material:n.materialPreset.id};if(e){const r=n.change(e,this._complex,RB(AF,e.mode),RB(fB,e.colorer));if(!qP.default.isEmpty(r)){n.needsRebuild=!0;for(const e in r)r.hasOwnProperty(e)&&(i[e]=r[e],fL.debug(`rep[${t}].${e} changed to ${r[e]}`));return r.mode&&n.mode.isSurface&&("ultra"===LL.now.resolution||"high"===LL.now.resolution)&&(fL.report('Surface resolution was changed to "medium" to avoid hang-ups.'),LL.set("resolution","medium")),{desc:i,index:t,status:"changed"}}}return{desc:i,index:t,status:""}}repGet(t){return(void 0===t||t instanceof Object)&&(t=this.repCurrent()),t<0||t>=this._reprList.length?null:this._reprList[t]}_getFreeReprIdx(){let t=this._reprUsedBits;for(let e=0;e<=PB.NUM_REPRESENTATION_BITS;++e,t>>=1)if(!(1&t))return e;return-1}repAdd(t){if(this._reprList.length>=PB.NUM_REPRESENTATION_BITS)return null;const e=this._getFreeReprIdx();if(e<0)return null;const n=this.buildSelectorFromMask(1<<this._selectionBit),i=LL.now.presets.default[0],r=qP.default.merge({selector:i.selector,mode:i.mode,colorer:i.colorer,material:i.material},t),s="string"==typeof r.selector?CB.parse(r.selector).selector:r.selector,o=new MB(this._selectionBit,RB(AF,r.mode),RB(fB,r.colorer),s);return o.selectorString=s.toString(),o.setMaterialPreset(_B.get(r.material)),o.markAtoms(this._complex),this._reprList.push(o),this._selectionBit=e,this._reprUsedBits|=1<<this._selectionBit,this._complex.markAtoms(n,1<<this._selectionBit),{desc:r,index:this._reprList.length-1}}repRemove(t){void 0===t&&(t=this.repCurrent());let e=this._reprList.length;if(t<0||t>=e||e<=1)return;const n=this._reprList[t];n.unmarkAtoms(this._complex),this._reprUsedBits&=~(1<<n.index),this._reprList.splice(t,1),n===this._repr&&(--e,t=t<e?t:e-1,this._repr=this._reprList[t]),this._reprListChanged=!0}repHide(t,e){void 0===e&&(e=!0),t<0||t>=this._reprList.length||this._reprList[t].show(!e)}select(t,e){e?this._selectionCount+=this._complex.markAtomsAdditionally(t,1<<this._selectionBit):this._selectionCount=this._complex.markAtoms(t,1<<this._selectionBit),this._complex.updateStructuresMask(),this.rebuildSelectionGeometry()}resetSelectionMask(){0!==this._selectionCount&&(this._selectionCount=0,this._complex&&this._complex.clearAtomBits(1<<this._selectionBit))}updateSelectionMask(t){const e=this,{atom:n}=t;let{residue:i,chain:r,molecule:s}=t;const o=1<<this._selectionBit,a=~o;if(n)i=n.residue,r=i._chain,s=i._molecule,n.mask&o?(n.mask&=a,i._mask&=a,r._mask&=a,s&&(s.mask&=a),this._selectionCount--):(n.mask|=o,this._selectionCount++,i.collectMask(),r.collectMask(),s&&s.collectMask());else if(i)r=i._chain,s=i._molecule,i._mask&o?(i._mask&=a,r._mask&=a,i.forEachAtom(t=>{t.mask&o&&(t.mask&=a,e._selectionCount--)})):(i._mask|=o,i.forEachAtom(t=>{t.mask&o||(t.mask|=o,e._selectionCount++)}),r.collectMask(),s&&s.collectMask());else if(r||s){const t=r||s;t._mask&o?(t._mask&=a,t.forEachResidue(t=>{t._mask&o&&(t._mask&=a,t.forEachAtom(t=>{t.mask&o&&(t.mask&=a,e._selectionCount--)}),t._mask&=a)})):(t._mask|=o,t.forEachResidue(t=>{if(!(t._mask&o)){t._mask|=o,t.forEachAtom(t=>{t.mask&o||(t.mask|=o,e._selectionCount++)});const n=r?t.getMolecule():t.getChain();n&&n.collectMask()}}))}else this.resetSelectionMask()}expandSelection(){const t=this,e=1<<this._selectionBit,n=1<<31;this._complex.forEachBond(t=>{t._left.mask&e?0===(t._right.mask&e)&&(t._right.mask|=n):t._right.mask&e&&(t._left.mask|=n)});const i=~n;this._complex.forEachAtom(r=>{r.mask&n&&(r.mask=r.mask&i|e,++t._selectionCount)}),this._complex.updateStructuresMask()}shrinkSelection(){const t=this,e=1<<this._selectionBit,n=1<<31;this._complex.forEachBond(t=>{t._left.mask&e?0===(t._right.mask&e)&&(t._left.mask|=n):t._right.mask&e&&(t._right.mask|=n)}),this._complex.forEachAtom(t=>{t.mask&e&&1===t.bonds.length&&(t.mask|=n)});const i=~(e|n);this._complex.forEachAtom(e=>{e.mask&n&&(e.mask&=i,--t._selectionCount)}),this._complex.updateStructuresMask()}getSelectedComponent(){const t=1<<this._selectionBit;let e=null,n=!1;return this._complex.forEachAtom(i=>{i.mask&t&&(null===e?e=i.residue._component:e!==i.residue._component&&(n=!0))}),n?null:e}getSelectionCenter(t,e,n){t.set(0,0,0);let i=0;return this._complex.forEachAtom(r=>{e(r,n)&&(t.add(r.position),i++)}),0!==i&&(t.divideScalar(i),t.applyMatrix4(this.matrix),!0)}needsRebuild(){if(this._reprListChanged)return!0;const t=this._reprList;for(let e=0,n=t.length;e<n;++e)if(t[e].needsRebuild)return!0;return!1}rebuild(){const t=this;return jN.clearTree(this),new Promise(e=>{const n=t._complex;if(!n)return void e();let i=!1;setTimeout(()=>{console.time("build");const r=t._reprList,s=VF.get(LL.now.palette)||VF.first;let o=!1;for(let e=0,a=r.length;e<a;++e){const a=r[e];if(a.colorer.palette=s,a.needsRebuild){a.reset();try{a.buildGeometry(n)}catch(t){if(!(t instanceof AL.OutOfMemoryError))throw t;a.needsRebuild=!1,a.reset(),fL.error(`Not enough memory to build geometry for representation ${a.index+1}`),i=!0}}o=i||o||jN.groupHasGeometryToRender(a.geo),a.geo&&t.add(a.geo)}t._reprListChanged=!1,console.timeEnd("build"),e()},10)})}setNeedsRebuild(){const t=this._reprList;for(let e=0,n=t.length;e<n;++e)t[e].needsRebuild=!0}rebuildSelectionGeometry(){const t=1<<this._selectionBit;jN.clearTree(this._selectionGeometry);for(let e=0,n=this._reprList.length;e<n;++e){const n=this._reprList[e].buildSelectionGeometry(t);if(n){this._selectionGeometry.add(n);for(let t=0;t<n.children.length;t++){const e=n.children[t];if(this._editor&&this._editor._componentTransforms){const t=this._editor._componentTransforms[e._component._index];t&&(e.position.copy(t.position),e.quaternion.copy(t.quaternion))}}jN.applySelectionMaterial(n)}}}_buildSelectorFromSortedLists(t,e,n){const i=this._complex;function r(t){const e=[];let n=0,i=NaN,r=NaN;for(let s=0,o=t.length;s<o;++s){const o=t[s];o===r+1?r=o:(Number.isNaN(i)||(e[n++]=new CB.Range(i,r)),i=r=o)}return Number.isNaN(i)||(e[n]=new CB.Range(i,r)),e}let s=null;if(n.length===i._chains.length)s=CB.all();else{let i;if(n.length>0&&(i=CB.chain(n),s=s?CB.or(s,i):i),Object.keys(e).length>0)for(const t in e)e.hasOwnProperty(t)&&(i=CB.and(CB.chain(t),CB.residx(r(e[t]))),s=s?CB.or(s,i):i);t.length>0&&(i=CB.serial(r(t)),s=s?CB.or(s,i):i),s||(s=CB.none())}return s}buildSelectorFromMask(t){const e=this._complex,n=[],i={},r=[];return e.forEachChain(e=>{e._mask&t&&n.push(e._name)}),e.forEachResidue(e=>{if(e._mask&t&&!(e._chain._mask&t)){const t=e._chain._name;t in i?i[t].push(e._index):i[t]=[e._index]}}),e.forEachAtom(e=>{e.mask&t&&!(e.residue._mask&t)&&r.push(e.serial)}),this._buildSelectorFromSortedLists(r,i,n)}forSelectedResidues(t){const e=1<<this._selectionBit;this._complex.forEachResidue(n=>{n._mask&e&&t(n)})}beginComponentEdit(){if(this._editor)return null;const t=new TB(this);return t.begin()?(this._editor=t,t):null}beginFragmentEdit(){if(this._editor)return null;const t=new AB(this);return t.begin()?(this._editor=t,t):null}finalizeEdit(){this._editor=null}setMaterialValues(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;for(let i=0,r=this._reprList.length;i<r;++i){const r=this._reprList[i];r.material.setValues(t),e&&r.geo.traverse(e=>{e instanceof $P.Mesh&&(e.material.setValues(t),void 0!==n&&n(e),e.material.needsUpdate=!0)})}}setUberOptions(t){for(let e=0,n=this._reprList.length;e<n;++e)this._reprList[e].material.setUberOptions(t)}within(t,e){const n=this._complex.getVoxelWorld();if(null===n)return!1;const i=1<<this._selectionBit;return this._complex.markAtoms(t,i),n&&n.forEachAtomWithinDistFromMasked(this._complex,i,Number(e),t=>{t.mask|=i}),this._selectionCount=this._complex.countAtomsByMask(i),this._complex.updateStructuresMask(),this.buildSelectorFromMask(i)}}PB.NUM_REPRESENTATION_BITS=30;const LB=PB,IB=$P.UniformsUtils.merge([{volumeDim:{type:"v3",value:new $P.Vector3(512,512,512)},tileTex:{type:"t",value:null},tileTexSize:{type:"v2",value:new $P.Vector2(512,512)},tileStride:{type:"v2",value:new $P.Vector2(512,512)},boxAngles:{type:"v3",value:new $P.Vector3(1,1,1)},delta:{type:"v3",value:new $P.Vector3(0,0,0)},_isoLevel0:{type:"v2",value:new $P.Vector3(.5,.75,1)},_flipV:{type:"f",value:0},_BFLeft:{type:"t",value:null},_BFRight:{type:"t",value:null},_FFLeft:{type:"t",value:null},_FFRight:{type:"t",value:null},_WFFLeft:{type:"t",value:null},_WFFRight:{type:"t",value:null}}]);function NB(t,e){const n=$P.UniformsUtils.clone(e);for(const e in t)n.hasOwnProperty(e)&&(n[e].value=t[e]);return n}function DB(t,e){return{uniforms:NB(t,{}),vertexShader:"varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:"varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}",transparent:!1,depthTest:!1,depthWrite:!1,side:e}}class OB extends $P.ShaderMaterial{constructor(t){super(DB(t,$P.BackSide))}}class UB{constructor(t,e,n,i){this.uniforms=NB(t,e),this.vertexShader=n,this.fragmentShader=i,this.transparent=!1,this.depthTest=!1,this.depthWrite=!1,this.side=$P.FrontSide}}class FB extends $P.ShaderMaterial{constructor(t){const e=$P.UniformsUtils.merge([{aspectRatio:{type:"f",value:0},farZ:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},matWorld2Volume:{type:"4fv",value:new $P.Matrix4}}]);super(new UB(t,e,"varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n","varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}"))}}class BB extends $P.ShaderMaterial{constructor(t){super(DB(t,$P.FrontSide))}}class zB extends $P.ShaderMaterial{constructor(t){const e=new UB(t,IB,"varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}","uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n");e.transparent=!0,e.depthTest=!0,super(e),this.updateDefines()}updateDefines(){this.defines={ISO_MODE:LL.now.modes.VD.isoMode,STEPS_COUNT:100*LL.now.modes.VD.polyComplexity[LL.now.resolution]},this.needsUpdate=!0}}const VB={BackFacePosMaterial:OB,BackFacePosMaterialFarPlane:FB,FrontFacePosMaterial:BB,VolumeMaterial:zB};class kB extends $P.Mesh{volumeInfo={};constructor(){const t=new $P.BufferGeometry;super(t),this.clipPlane=new $P.Plane;const e=new $P.Vector3(.5,.5,.5);this.size=e,this.cullFlag=[!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!1,!1],this.faces=[{indices:[],norm:new $P.Vector3(0,0,-1)},{indices:[],norm:new $P.Vector3(0,0,1)},{indices:[],norm:new $P.Vector3(0,-1,0)},{indices:[],norm:new $P.Vector3(0,1,0)},{indices:[],norm:new $P.Vector3(-1,0,0)},{indices:[],norm:new $P.Vector3(1,0,0)},{indices:[],norm:new $P.Vector3(0,0,0)}],this.vertices=[new $P.Vector3(-e.x,-e.y,-e.z),new $P.Vector3(-e.x,e.y,-e.z),new $P.Vector3(e.x,-e.y,-e.z),new $P.Vector3(e.x,e.y,-e.z),new $P.Vector3(-e.x,-e.y,e.z),new $P.Vector3(-e.x,e.y,e.z),new $P.Vector3(e.x,-e.y,e.z),new $P.Vector3(e.x,e.y,e.z),new $P.Vector3(0,0,0),new $P.Vector3(0,0,0),new $P.Vector3(0,0,0),new $P.Vector3(0,0,0),new $P.Vector3(0,0,0),new $P.Vector3(0,0,0)],t.setAttribute("position",new $P.BufferAttribute(new Float32Array(3*this.vertices.length),3)),this.name="VolumeMesh"}static _corners=[[-1,-1,-1,0,4,8],[1,-1,-1,0,5,9],[1,1,-1,1,5,10],[-1,1,-1,1,4,11],[-1,-1,1,2,6,8],[1,-1,1,2,7,9],[1,1,1,3,7,10],[-1,1,1,3,6,11]];static _edges=[[0,1,0,-1,-1],[2,3,0,1,-1],[4,5,0,-1,1],[6,7,0,1,1],[0,3,-1,0,-1],[1,2,1,0,-1],[4,7,-1,0,1],[5,6,1,0,1],[0,4,-1,-1,0],[1,5,1,-1,0],[2,6,-1,1,0],[3,7,1,1,0]];static _edgeIntersections=function(){const t=[];for(let e=0;e<12;++e)t.push(new $P.Vector3);return t}();_updateVertices(){const t=kB._corners,e=kB._edges,n=kB._edgeIntersections;let i;const r=this.clipPlane.normal,s=this.clipPlane.constant,o=this.vertices,{size:a}=this,l=[0,0,0,0,0,0,0,0],c=[1,1,1,1,1,1,1,1,1,1,1,1],h=new $P.Vector3;let u=null;function d(){if(0===r.x)return 0;const t=-(r.dot(h)+s)/r.x;return-a.x<=t&&t<=a.x?(u.set(t,h.y,h.z),t===a.x?2:t===-a.x?-2:1):0}function p(){if(0===r.y)return 0;const t=-(r.dot(h)+s)/r.y;return-a.y<=t&&t<=a.y?(u.set(h.x,t,h.z),t===a.y?2:t===-a.y?-2:1):0}function f(){if(0===r.z)return 0;const t=-(r.dot(h)+s)/r.z;return-a.z<=t&&t<=a.z?(u.set(h.x,h.y,t),t===a.z?2:t===-a.z?-2:1):0}for(let t=0;t<12;++t){const i=e[t];u=n[t],h.set(i[2],i[3],i[4]),h.multiply(a);let r=0;0===i[2]&&(r=d()),0===i[3]&&(r=p()),0===i[4]&&(r=f()),-2===r?l[i[0]]=1:2===r?l[i[1]]=1:0===r&&(c[t]=0)}const m={indices:[],norm:r.clone().negate()};let g=8;for(i=0;i<8;++i)1===l[i]&&(o[g].set(t[i][0],t[i][1],t[i][2]).multiply(a),m.indices.push(g++),c[t[i][3]]=0,c[t[i][4]]=0,c[t[i][5]]=0);for(i=0;i<12;++i)1===c[i]&&(o[g].copy(n[i]),m.indices.push(g++));this.faces[6]=m;const _=new $P.Vector3,y=new $P.Vector3;for(this.clipPlane.coplanarPoint(y),i=0;i<o.length;++i)this.cullFlag[i]=!1,i<8?(_.subVectors(o[i],y),this.cullFlag[i]=r.dot(_)>=0):i<8+m.indices.length&&(this.cullFlag[i]=!0);const v=this.geometry.getAttribute("position");let x=0;for(i=0;i<o.length;++i)v.array[x++]=o[i].x,v.array[x++]=o[i].y,v.array[x++]=o[i].z;v.needsUpdate=!0}_collectVertices(t,e){let n;const i=this.vertices;for(t.indices=[],n=0;n<i.length;++n)this.cullFlag[n]&&e(i[n])&&t.indices.push(n)}_sortIndices(t,e){let n,i;const r=this.vertices,s=[],o=new $P.Vector3;for(n=1;n<t.indices.length;++n)o.subVectors(r[t.indices[n]],r[t.indices[0]]),o.normalize(),o.cross(e),o.negate(),s[n]=t.norm.dot(o);for(n=1;n<t.indices.length-1;++n)for(i=n+1;i<t.indices.length;++i)if(s[i]<s[n]){let e=s[n];s[n]=s[i],s[i]=e,e=t.indices[n],t.indices[n]=t.indices[i],t.indices[i]=e}}_updateIndices(){let t,e,n;const i=this.vertices,{size:r}=this;this._collectVertices(this.faces[0],t=>t.z===-r.z),this._collectVertices(this.faces[1],t=>t.z===r.z),this._collectVertices(this.faces[2],t=>t.y===-r.y),this._collectVertices(this.faces[3],t=>t.y===r.y),this._collectVertices(this.faces[4],t=>t.x===-r.x),this._collectVertices(this.faces[5],t=>t.x===r.x);const s=new $P.Vector3,o=new $P.Vector3,a=new $P.Vector3;for(e=0;e<this.faces.length;++e){if(n=this.faces[e],0===n.indices.length)continue;for(s.set(0,0,0),t=0;t<n.indices.length;++t)s.add(i[n.indices[t]]);s.multiplyScalar(1/n.indices.length),o.subVectors(i[n.indices[0]],s),o.normalize();const r=[];for(t=0;t<n.indices.length;++t)a.subVectors(i[n.indices[t]],s),r[t]=a.dot(o);for(t=1;t<n.indices.length;++t)if(r[t]<r[0]){let e=r[0];r[0]=r[t],r[t]=e,[e]=n.indices,n.indices[0]=n.indices[t],n.indices[t]=e}this._sortIndices(n,o)}let l=0;for(e=0;e<this.faces.length;++e)n=this.faces[e],n.indices.length>=3&&(l+=3*(n.indices.length-2));let c=0;const h=new Uint16Array(l);for(e=0;e<this.faces.length;++e)for(n=this.faces[e],t=0;t<n.indices.length-2;++t)h[c]=n.indices[0],h[c+1]=n.indices[t+1],h[c+2]=n.indices[t+2],c+=3;this.geometry.setIndex(new $P.BufferAttribute(h,1))}setDataSource(t){const e=new VB.VolumeMaterial,n=t.getDimensions(),i=t.getTiledTextureStride(),r=t.buildTiledTexture(),s=t.getBox();e.uniforms.volumeDim.value.set(n[0],n[1],n[2]),e.uniforms.tileTex.value=r,e.uniforms.tileTexSize.value.set(r.image.width,r.image.height),e.uniforms.tileStride.value.set(i[0],i[1]),Object.assign(this.volumeInfo,t.getVolumeInfo());const o=this.volumeInfo;e.uniforms.delta.value.copy(o.delta),e.uniforms.boxAngles.value.set(o.obtuseAngle[0],o.obtuseAngle[1],o.obtuseAngle[2]),this.material=e,s.getSize(this.scale),s.getCenter(this.position)}_updateIsoLevel(){const{kSigma:t,kSigmaMed:e,kSigmaMax:n}=LL.now.modes.VD,i=this.volumeInfo,r=i.dmean-i.dmin,s=i.dmax-i.dmin,o=t=>(r+t*i.sd)/s;this.material.uniforms._isoLevel0.value.set(o(t),o(e),o(n))}static _nearClipPlaneOffset=.2;static _pos=(()=>new $P.Vector3)();static _norm=(()=>new $P.Vector3)();static _norm4D=(()=>new $P.Vector4)();static _matrixWorldToLocal=(()=>new $P.Matrix4)();static _clipPlane=(()=>new $P.Plane)();rebuild(t){const e=kB._nearClipPlaneOffset,n=kB._pos,i=kB._norm,r=kB._norm4D,s=kB._matrixWorldToLocal,o=kB._clipPlane;this._updateIsoLevel(),t.getWorldDirection(i),t.getWorldPosition(n),n.addScaledVector(i,t.near+e),s.copy(this.matrixWorld).invert(),n.applyMatrix4(s),r.set(i.x,i.y,i.z,0),r.applyMatrix4(s),i.copy(r),i.normalize(),o.setFromNormalAndCoplanarPoint(i,n),this.clipPlane.equals(o)||(this.clipPlane=o.clone(),this._updateVertices(),this._updateIndices())}}const GB=kB;class HB{static _projectionTable={XY:["x",2],XZ:["y",1],YZ:["z",0]};constructor(t,e){const{delta:n}=e,{obtuseAngle:i}=e,r=new $P.Vector3;t.getSize(r),r.multiplyScalar(.5);const s=this._getBaseVertices(n,i),o=new $P.BufferGeometry,a=[];for(let t=0;t<4;t++)a.push(s[t].clone().multiply(r)),a.push(s[(t+1)%4].clone().multiply(r));const l=new $P.Vector3(2*r.x*(1-n.x-n.y),0,0);for(let t=0;t<8;t++)a.push(a[t].clone().add(l));for(let t=0;t<4;t++)a.push(a[2*t].clone()),a.push(a[2*t+8].clone());const c=new $P.Vector3;t.getCenter(c),a.forEach(t=>t.add(c));const h=function(t){const e=t.length,n=new Float32Array(3*e);for(let i=0;i<e;++i){const e=3*i,r=t[i];n[e]=r.x,n[e+1]=r.y,n[e+2]=r.z}return n}(a);o.setAttribute("position",new $P.BufferAttribute(h,3)),this._lines=new $P.LineSegments(o,new $P.LineBasicMaterial({color:16777215})),this._lines.layers.set(jN.LAYERS.VOLUME)}_getBaseVertices(t,e){const n=HB._projectionTable,i=(i,r)=>{const s=t[n[i][0]];return(-.5*(r-1)+r*e[n[i][1]])*s};return[new $P.Vector3(2*(i("XZ",1)+i("XY",1))-1,2*i("YZ",1)-1,-1),new $P.Vector3(2*(i("XZ",-1)+i("XY",1))-1,2*i("YZ",-1)-1,1),new $P.Vector3(2*(i("XZ",-1)+i("XY",-1))-1,1-2*i("YZ",1),1),new $P.Vector3(2*(i("XZ",1)+i("XY",-1))-1,1-2*i("YZ",-1),-1)]}getMesh(){return this._lines}}const WB=HB,jB=class{constructor(t,e,n){const i=this._initPlaneGeo(e,n),r=new VB.BackFacePosMaterialFarPlane;this._plane=new qO.Mesh(i,r),this._plane.frustumCulled=!1,this._plane.doubleSided=!0;const s=new $P.Matrix4;this._plane._onBeforeRender=function(e,n,i,r,o,a){const{material:l}=this;if(!t||!l)return;const c=new $P.Vector4(0,0,-(i.far-.1),1);c.applyMatrix4(i.matrixWorld),this.matrix.identity(),this.matrix.makeTranslation(c.x,c.y,c.z),this.matrixWorld.copy(this.matrix),this.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,this.matrixWorld),this.normalMatrix.getNormalMatrix(this.modelViewMatrix);const h=t.matrixWorld;s.copy(h).invert(),l.uniforms.aspectRatio.value=i.aspect,l.uniforms.farZ.value=i.far,l.uniforms.tanHalfFOV.value=Math.tan(.5*$P.MathUtils.DEG2RAD*i.fov),l.uniforms.matWorld2Volume.value=s},this._plane.layers.set(jN.LAYERS.VOLUME_BFPLANE)}_initPlaneGeo(t,e){const n=new $P.BufferGeometry;t=t||1,e=e||1;const i=new Float32Array([-.5*t,.5*e,0,.5*t,.5*e,0,-.5*t,-.5*e,0,.5*t,-.5*e,0]);return n.setAttribute("position",new $P.BufferAttribute(i,3)),n.setIndex([0,2,1,2,3,1]),n}getMesh(){return this._plane}},XB=class extends qN{constructor(t,e){super(t,e),this._mesh=new GB,this._mesh.setDataSource(e),this.add(this._mesh),this._frame=new WB(this.getBoundaries().boundingBox,this._mesh.volumeInfo),this.add(this._frame.getMesh()),this.showFrame(LL.now.modes.VD.frame),this._farPlane=new jB(this._mesh,2,2),this.add(this._farPlane.getMesh())}getBoundaries(){const t=this._dataSource.getBox(),e=new $P.Sphere;return t.getBoundingSphere(e),{boundingBox:t,boundingSphere:e}}getMesh(){return this._mesh}showFrame(t){this._frame.getMesh().material.visible=t}};class YB extends hL{constructor(t,e){super(),this._source=t,this._options=e||{},this._abort=!1,this._agent=null}load(){return Promise.reject(new Error("Loading from this source is not implemented"))}abort(){this._abort=!0,this._agent&&this._agent.abort()}static extractName(t){}}KN(YB.prototype);class qB extends YB{constructor(t,e){super(t,e),e=this._options,this._binary=!0===e.binary}load(){return new Promise((t,e)=>{if(this._abort)throw new Error("Loading aborted");const n=this._source,i=this._agent=new FileReader;i.addEventListener("load",()=>{t(i.result)}),i.addEventListener("error",()=>{e(i.error)}),i.addEventListener("abort",()=>{e(new Error("Loading aborted"))}),i.addEventListener("progress",t=>{this.dispatchEvent(t)}),this._binary?i.readAsArrayBuffer(n):i.readAsText(n)})}static canProbablyLoad(t){return File&&t instanceof File||Blob&&t instanceof Blob}static extractName(t){return t&&t.name}}qB.types=["file","blob"];const $B=/^(https?|ftp):\/\//i;class ZB extends YB{constructor(t,e){super(t,e),e=this._options,this._binary=!0===e.binary}load(){return new Promise((t,e)=>{if(this._abort)throw new Error("Loading aborted");const n=this._source,i=this._agent=new XMLHttpRequest;i.addEventListener("load",()=>{200===i.status?t(i.response):e(new Error(`HTTP ${i.status} while fetching ${n}`))}),i.addEventListener("error",()=>{e(new Error("HTTP request failed"))}),i.addEventListener("abort",()=>{e(new Error("Loading aborted"))}),i.addEventListener("progress",t=>{this.dispatchEvent(t)}),i.open("GET",n),this._binary?i.responseType="arraybuffer":i.responseType="text",i.send()})}static canProbablyLoad(t){return qP.default.isString(t)&&$B.test(t)}static extractName(t){if(t){const e=(t.indexOf("?")+1||t.lastIndexOf("#")+1||t.length+1)-1;return t.slice(t.lastIndexOf("/",e)+1,e)}}}ZB.types=["url"];class JB extends YB{load(){return new Promise(t=>{if(this._abort)throw new Error("Loading aborted");t(this._source)})}static canProbablyLoad(t){return!1}}JB.types=["immediate"];const KB=new class extends JN{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],["types"])}find(t){let e=[];if(t.type)e=this._dict.types[t.type.toLowerCase()]||[];else if(t.source)return this._list.filter(e=>e.canProbablyLoad&&e.canProbablyLoad(t.source));return[...e]}}([qB,ZB,JB]);class QB{constructor(t,e){this._data=t,this._options=e||{},this._abort=!1}parseSync(){throw new Error("Parsing this type of data is not implemented")}parse(){return new Promise((t,e)=>{setTimeout(()=>{try{return this._abort?e(new Error("Parsing aborted")):t(this.parseSync())}catch(t){return e(t)}})})}getModel(){return this.model._parseHeader(this._data),this.model}abort(){this._abort=!0}}KN(QB.prototype);class tz{constructor(){this.matrices=[],this._matrix=null,this._matrixIndex=-1}parse(t){let e=this._matrix;if("  SMTRY"===t.readString(12,18)){const n=t.readCharCode(19)-49,i=t.readString(20,80).trim().split(/\s+/),r=parseInt(i[0],10);null!==this._matrix&&r===this._matrixIndex||(this._matrixIndex=r,this._matrix=e=new $P.Matrix4,this.matrices[this.matrices.length]=e);const{elements:s}=e;s[n]=parseFloat(i[1]),s[n+4]=parseFloat(i[2]),s[n+8]=parseFloat(i[3]),s[n+12]=parseFloat(i[4])}}}tz.prototype.id=290;const ez=tz,{Assembly:nz}=DN;class iz{constructor(t){this._complex=t,this.assemblies=[],this._assembly=null,this._matrix=null,this._matrixIndex=-1}parse(t){let e=this._assembly,n=this._matrix;if(e&&"  BIOMT"===t.readString(12,18)){const i=t.readCharCode(19)-49,r=t.readString(20,80).trim().split(/\s+/),s=parseInt(r[0],10);null!==this._matrix&&s===this._matrixIndex||(this._matrixIndex=s,this._matrix=n=new $P.Matrix4,e.addMatrix(n));const{elements:o}=n;o[i]=parseFloat(r[1]),o[i+4]=parseFloat(r[2]),o[i+8]=parseFloat(r[3]),o[i+12]=parseFloat(r[4])}else if(e&&"CHAINS:"===t.readString(35,41)){const n=t.readString(42,80).split(",");for(let t=0,i=n.length;t<i;++t){const i=n[t].trim();i.length>0&&e.addChain(i)}}else"BIOMOLECULE:"===t.readString(12,23)&&(this._matrix=null,this._matrixIndex=-1,this._assembly=e=new nz(this._complex),this.assemblies.push(e))}}iz.prototype.id=350;const rz=iz,sz=class{constructor(t){this._data=t,this._start=0,this._nextCR=-1,this._nextLF=-1,this._next=-1,this._end=t.length,this.next()}readLine(){return this._data.slice(this._start,this._next)}readChar(t){return(t=this._start+t-1)<this._next?this._data[t]:" "}readCharCode(t){return(t=this._start+t-1)<this._next?this._data.charCodeAt(t):32}readString(t,e){const n=this._start+t-1,i=this._start+e;return this._data.slice(n,i<this._next?i:this._next)}readInt(t,e){return parseInt(this.readString(t,e),10)}readFloat(t,e){return parseFloat(this.readString(t,e))}end(){return this._start>=this._end}next(){const t=this._next+1;this._start=t<this._end?t:this._end,this._start>this._nextCR&&(this._nextCR=(this._data.indexOf("\r",this._start)+1||this._end+1)-1),this._start>this._nextLF&&(this._nextLF=(this._data.indexOf("\n",this._start)+1||this._end+1)-1),this._next=this._nextCR+1<this._nextLF?this._nextCR:this._nextLF}},{Complex:oz,Element:az,Helix:lz,Sheet:cz,Strand:hz,Bond:uz,Molecule:dz}=DN,pz=/^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i,fz={290:ez,350:rz};class mz extends QB{constructor(t,e){super(t,e),this._complex=null,this._chain=null,this._residue=null,this._sheet=null,this._serialAtomMap=null,this._modelId=1,this._compaundFound=!1,this._biomoleculeFound=!1,this._allowedChainsIDs=null,this._lastMolId=-1,this._remarks={},this._remark=null,this._molecules=[],this._molecule=null,this._compndCurrToken="",this._options.fileType="pdb"}static canProbablyParse(t){return qP.default.isString(t)&&pz.test(t)}_finalize(){this._fixBondsArray(),this._fixChains();const t=this._remarks[290];this._complex.symmetry=qP.default.isUndefined(t)?[]:t.matrices;const e=this._remarks[350];this._complex.units=this._complex.units.concat(qP.default.isUndefined(e)?[]:e.assemblies),this._finalizeMolecules(),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}_finalizeMolecules(){const t={};let e;const n=this._complex._chains;for(e=0;e<n.length;++e){const i=n[e];t[i._name]=i}for(e=0;e<this._molecules.length;e++){const n=this._molecules[e];let i=[];for(let e=0;e<n._chains.length;e++){const r=t[n._chains[e]];i=i.concat(r._residues.slice())}const r=new dz(this._complex,n._name,e+1);r.residues=i,this._complex._molecules[e]=r}}_fixChains(){const t={},e=this._complex;for(let n=0;n<e._chains.length;n++){const i=e._chains[n];t[i._name.charCodeAt(0)]=i}}_fixBondsArray(){const t=this._serialAtomMap={},e=this._complex,n=e._atoms;for(let e=0,i=n.length;e<i;++e){const i=n[e];t[i.serial]=i}const i=e._bonds,{logger:r}=this;for(let e=0,n=i.length;e<n;++e){const n=i[e];n._right<n._left&&r.debug("_fixBondsArray: Logic error."),n._left=t[n._left]||null,n._right=t[n._right]||null}}_parseATOM(t){if(1!==this._modelId)return;const e=72===t.readCharCode(1),n=e?t.readInt(7,11):t.readInt(6,11);let i=t.readString(13,16);const r=t.readChar(17),s=t.readString(18,20).trim(),o=t.readChar(22),a=t.readInt(23,26),l=t.readChar(27),c=t.readFloat(31,38),h=t.readFloat(39,46),u=t.readFloat(47,54),d=t.readFloat(55,60),p=t.readFloat(61,66),f=t.readString(77,78).trim()||function(t){const e=4===t.trim().length;return t.slice(0,e?1:2).trim()}(i),m=t.readInt(79,80)||0;if(this.settings.now.nowater&&("HOH"===s||"WAT"===s))return;i=i.trim();const g=az.getByName(f),_=az.Role[i];let y=this._chain;y&&y.getName()===o||(this._chain=y=this._complex.getChain(o)||this._complex.addChain(o),this._residue=null);let v=this._residue;v&&v.getSequence()===a&&v.getICode()===l||(this._residue=v=y.addResidue(s,a,l));const x=new $P.Vector3(c,h,u);v.addAtom(i,g,x,_,e,n,r,d,p,m)}_parseENDMDL(){this._modelId+=1}_parseCONECT(t){const e=t.readInt(7,11),n=t.readInt(12,16),i=t.readInt(17,21),r=t.readInt(22,26),s=t.readInt(27,31),o=this._complex;n&&n>e&&o.addBond(e,n,0,uz.BondType.UNKNOWN,!0),i&&i>e&&o.addBond(e,i,0,uz.BondType.UNKNOWN,!0),r&&r>e&&o.addBond(e,r,0,uz.BondType.UNKNOWN,!0),s&&s>e&&o.addBond(e,s,0,uz.BondType.UNKNOWN,!0)}_parseCOMPND(t){const e=t.readString(11,80),n=e.indexOf(":");if(this._compndCurrToken=n>0?e.substring(0,n).trim():this._compndCurrToken,"MOL_ID"===this._compndCurrToken)this._molecule={_index:"",_chains:[]},this._molecule._index=parseInt(e.substring(n+1,e.indexOf(";")),10),this._molecules.push(this._molecule);else if("MOLECULE"===this._compndCurrToken&&null!=this._molecule)this._molecule._name=e.substring(n+1,e.indexOf(";")).trim();else if("CHAIN"===this._compndCurrToken&&null!=this._molecule){let t=e.substring(n+1,80).trim();const i=t[t.length-1];";"!==i&&","!==i||(t=t.slice(0,-1)),t=t.replace(/\s+/g,"");const r=t.split(",");this._molecule._chains=this._molecule._chains.concat(r)}}_parseREMARK(t){const e=t.readInt(8,10);let n=this._remarks[e];if(qP.default.isUndefined(n)){const t=fz[e];qP.default.isFunction(t)&&(this._remarks[e]=n=new t(this._complex))}qP.default.isUndefined(n)||n.parse(t)}_parseHELIX(t){this._parseSTRUCTURE(t,[20,22,32,34],t=>{this._complex.addHelix(t),this._complex.structures.push(t)})}_parseSHEET(t){this._parseSTRUCTURE(t,[22,23,33,34],t=>{this._complex.addSheet(t)})}_parseSTRUCTURE(t,e,n){const i=t.readInt(8,10),r=t.readString(12,14).trim(),s=t.readString(41,70).trim(),o=t.readInt(72,76),a=t.readInt(39,40),l=t.readInt(15,16),c=t.readInt(42,45),h=t.readInt(57,60),u=t.readString(e[0],e[2]+1).charCodeAt(0),d=t.readString(e[2],e[2]+1).charCodeAt(0),p=t.readInt(e[1],e[1]+3);let f=t.readString(e[1]+4,e[1]+4),m=0;f.length>0&&(m=f.charCodeAt(0));const g=t.readInt(e[3],e[3]+3);f=t.readString(e[3]+4,e[3]+4);let _,y=0;f.length>0&&(y=f.charCodeAt(0));let v=this._sheet;if(83===t.readCharCode(1)){null!==v&&v.getName()!==r&&(v=null,this._sheet=null),null===v?(this._sheet=_=new cz(r,l),n(_)):_=v;const t=new hz(_,this._complex.getUnifiedSerial(u,p,m),this._complex.getUnifiedSerial(d,g,y),a,c,h);_.addStrand(t),this._complex.structures.push(t)}else _=new lz(a,this._complex.getUnifiedSerial(u,p,m),this._complex.getUnifiedSerial(d,g,y),i,r,s,o),n(_)}_parseHEADER(t){const{metadata:e}=this._complex;e.classification=t.readString(11,50).trim(),e.date=t.readString(51,59).trim();const n=t.readString(63,66).trim();e.id=n,n&&(this._complex.name=n),e.format="pdb"}_parseTITLE(t){const{metadata:e}=this._complex;e.title=e.title||[];const n=t.readInt(9,10)||1;e.title[n-1]=t.readString(11,80).trim()}static tagParsers=(()=>({HEADER:mz.prototype._parseHEADER,"TITLE ":mz.prototype._parseTITLE,"ATOM  ":mz.prototype._parseATOM,HETATM:mz.prototype._parseATOM,ENDMDL:mz.prototype._parseENDMDL,CONECT:mz.prototype._parseCONECT,COMPND:mz.prototype._parseCOMPND,REMARK:mz.prototype._parseREMARK,"HELIX ":mz.prototype._parseHELIX,"SHEET ":mz.prototype._parseSHEET,"ATOM 1":mz.prototype._parseATOM,"ATOM 2":mz.prototype._parseATOM,"ATOM 3":mz.prototype._parseATOM,"ATOM 4":mz.prototype._parseATOM,"ATOM 5":mz.prototype._parseATOM,"ATOM 6":mz.prototype._parseATOM,"ATOM 7":mz.prototype._parseATOM,"ATOM 8":mz.prototype._parseATOM,"ATOM 9":mz.prototype._parseATOM}))();parseSync(){const t=new sz(this._data),e=this._complex=new oz;for(;!t.end();){const e=t.readString(1,6),n=mz.tagParsers[e];qP.default.isFunction(n)&&n.call(this,t),t.next()}if(this._finalize(),this._serialAtomMap=null,this._sheet=null,this._residue=null,this._chain=null,this._complex=null,0===e.getAtomCount())throw new Error("The data does not contain valid atoms");return e}}mz.formats=["pdb"],mz.extensions=[".pdb",".ent"];const gz=mz,{Complex:_z,Element:yz,SGroup:vz,Bond:xz}=DN,Sz={A:0,S:1,D:2,T:3},bz=/\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;class Mz extends QB{constructor(t,e){super(t,e),this._complex=null,this._residue=null,this._serialAtomMap=null,this._modelId=1,this._lastMolId=-1,this._readOnlyOneMolecule=!1,this._options.fileType="cml"}static canProbablyParse(t){return qP.default.isString(t)&&bz.test(t)}_rebuidBondIndexes(t,e){const n=t.length;for(let i=0;i<n;i++){const n=t[i].id,r=e.length;for(let t=0;t<r;t++){const r=e[t].atomRefs2.split(" ");r[0]===n&&(e[t].start=i),r[1]===n&&(e[t].end=i)}}}_createSGroup(t,e){const n=new vz(t.id,t.fieldData,new $P.Vector3(parseFloat(t.x),parseFloat(t.y),0),t.atomRefs,t);"Relative"===t.placement&&(n._center=new $P.Vector3(0,0,0)),"MDLBG_FRAGMENT_CHARGE"===t.fieldName&&(n._charge=parseInt(t.fieldData,10)||0),"MDLBG_FRAGMENT_COEFFICIENT"===t.fieldName&&(n._repeat=parseInt(t.fieldData,10)||1),e.push(n)}_extractSGroup(t,e){if(Array.isArray(e)||(e=[]),t)if(Array.isArray(t)){const n=t.length;for(let i=0;i<n;i++)t[i].molecule&&(e=e.concat(this._extractSGroup(t[i].molecule))),this._createSGroup(t[i],e)}else t.molecule&&t.molecule&&(e=e.concat(this._extractSGroup(t.molecule))),this._createSGroup(t,e);return e}_extractSGroups(t,e){const n=this._extractSGroup(t),i=e.length;let r,s;for(r=0;r<i;r++){const t=e[r].id;for(s=0;s<n.length;s++)n[s]._atoms.split(" ")[0]===t&&(e[r].sgroupRef||(e[r].sgroupRef=[]),e[r].sgroupRef.push(n[s]))}let o={},a=null;const l=1e8,c=new $P.Vector3(l,l,l),h=new $P.Vector3(-l,-l,-l);function u(t){a=o[t],a&&n[s]._atoms.push(a.a)}function d(t){a=o[t],a&&(c.set(Math.min(c.x,a.x),Math.min(c.y,a.y),Math.min(c.z,a.z)),h.set(Math.max(h.x,a.x),Math.max(h.y,a.y),Math.max(h.z,a.z)),u(t))}for(r=0;r<e.length;r++)o[e[r].id]={},o[e[r].id].x=e[r].x2,e[r].x3&&(o[e[r].id].x=e[r].x3),o[e[r].id].x=parseFloat(o[e[r].id].x),o[e[r].id].y=e[r].y2,e[r].y3&&(o[e[r].id].y=e[r].y3),o[e[r].id].y=parseFloat(o[e[r].id].y),o[e[r].id].z="0.0",e[r].z3&&(o[e[r].id].z=e[r].z3),o[e[r].id].z=parseFloat(o[e[r].id].z),o[e[r].id].a=e[r];let p;for(s=0;s<n.length;s++)null!==n[s]._center?(c.set(l,l,l),h.set(-l,-l,-l),p=n[s]._atoms.split(" "),n[s]._atoms=[],p.forEach(d),n[s]._center.addVectors(c,h),n[s]._center.multiplyScalar(.5)):(p=n[s]._atoms.split(" "),n[s]._atoms=[],p.forEach(u));o=null}_traverseData(t){const e={};return t.childNodes.length&&function t(e,n){if("#text"===e.nodeName&&""===e.nodeValue.trim())return;const i={};i.xmlNode=e;const r=n[e.nodeName];var s;let o,a;if(r?(s=r,"[object Array]"!==Object.prototype.toString.apply(s)?n[e.nodeName]=[r,i]:n[e.nodeName].push(i)):n[e.nodeName]=i,e.attributes)for(({length:o}=e.attributes),a=0;a<o;a++){const t=e.attributes[a];i[t.nodeName]=t.nodeValue}for(({length:o}=e.childNodes),a=0;a<o;a++)t(e.childNodes[a],i)}(t.childNodes[0],e),e}_findSuitableMolecule(t,e){for(const n in t)if("xmlNode"!==n)if("molecule"===n){if(t.molecule&&(t.molecule.atomArray&&t.molecule.atomArray.atom&&e.push(t),Array.isArray(t.molecule)))for(let n=0;n<t.molecule.length;n++)t.molecule[n].atomArray&&t.molecule[n].atomArray.atom&&e.push({molecule:t.molecule[n]})}else t[n]&&null!==t[n]&&"object"==typeof t[n]&&this._findSuitableMolecule(t[n],e)}_selectComponents(t){const e=(new DOMParser).parseFromString(t,"application/xml"),n=this._traverseData(e);let i;const r=this;i=n.cml?n.cml:n;const s=[],o=[];return this._findSuitableMolecule(i,o),this._readOnlyOneMolecule&&o.length>1&&o.splice(1,o.length-1),o.forEach(t=>{const n=function(t){let n,i=[];if(t.molecule&&t.molecule.atomArray&&t.molecule.atomArray.atom)Array.isArray(t.molecule.atomArray.atom)?i=t.molecule.atomArray.atom:i.push(t.molecule.atomArray.atom);else if(!t.molecule)return{atomLabels:null,labelsCount:1};t.molecule.molecule&&r._extractSGroups(t.molecule.molecule,i);let s=i.length;for(let t=0;t<s;t++)n=i[t],n.edges=[];let o,a=[];function l(t){return o=a[t],n=i[o.start],!!n&&(n.edges.push(o.end),n=i[o.end],!!n&&(n.edges.push(o.start),!0))}t.molecule.bondArray&&t.molecule.bondArray.bond&&(Array.isArray(t.molecule.bondArray.bond)?a=t.molecule.bondArray.bond:a.push(t.molecule.bondArray.bond)),s=a.length,r._rebuidBondIndexes(i,a);for(let t=0;t<s;t++){if(!l(t))continue;const e=o.xmlNode.getAttribute("order"),n=parseInt(e,10);if(a[t].order=0,a[t].type=xz.BondType.UNKNOWN,n>1)a[t].order=n;else{const n=Sz[e];void 0!==n&&(a[t].order=n,"A"===e&&(a[t].type=xz.BondType.AROMATIC))}}s=i.length;for(let t=0;t<s;t++)n=i[t],n.edges.sort();const c=r._breadWidthSearch(i,0),h={};return h.atoms=i,h.bonds=a,h.labels=c.atomLabels,h.count=Math.min(1,c.labelsCount),h.curr=-1,h.originalCML=e,h}(t);n.atoms.length>0&&s.push(n)}),s}_packLabel(t,e){return(e<<16)+t}_unpackLabel(t){return{molId:t>>>16,compId:65535&t}}_breadWidthSearch(t,e){const n=new Array(t.length);let i;for(i=0;i<n.length;i++)n[i]=this._packLabel(0,e);const r=[];let s=0,o=t.length;for(;o>0;){s++;let a=-1;for(i=0;i<n.length;i++)if(0===this._unpackLabel(n[i]).compId){a=i;break}if(a<0)break;for(r.push(t[a]),n[a]=this._packLabel(s,e),o--;r.length>0;){const e=r.shift();if(e)for(let i=0;i<e.edges.length;i++)n[e.edges[i]]!==s&&(r.push(t[e.edges[i]]),n[e.edges[i]]=s,o--)}}const a={};return a.atomLabels=n,a.labelsCount=s,a}_parseBond(t,e,n,i){if(t>=0){const r=[Math.min(t,e),Math.max(t,e)];this._complex.addBond(r[0],r[1],n,i,!0)}}_fixBondsArray(){const t=this._serialAtomMap={},e=this._complex,n=e._atoms;for(let e=0,i=n.length;e<i;++e){const i=n[e];t[i.serial]=i}const i=e._bonds,{logger:r}=this;for(let e=0,n=i.length;e<n;++e){const n=i[e];n._right<n._left&&r.debug("_fixBondsArray: Logic error."),n._left=t[n._left]||null,n._right=t[n._right]||null}}_parseSet(t){const e=this._complex=new _z,n=t,i=n.curr,{atoms:r,labels:s}=n;let o,a,l=null;const c=r.length;function h(t){t.xmlNodeRef=l,l.x2&&(l.x3=l.x2,delete l.x2),l.y2&&(l.y3=l.y2,delete l.y2),l.z3||(l.z3="0.0"),l.complexAtom=t}let u={};const d=[];for(o=0;o<c;o++)d.push(o);for(d.sort((t,e)=>s[t]-s[e]),o=0;o<c;o++){const t=0,n=s[d[o]];if(this._unpackLabel(n).molId===this._unpackLabel(i).molId){l=r[d[o]];const i=l.elementType;if(l.sgroupRef){const t=l.sgroupRef.length;for(let n=0;n<t;++n)e._sgroups.push(l.sgroupRef[n])}if(l.x3||l.x2){const e=this._unpackLabel(n).compId,r=" ",s=e,o=" ";let a=e.toString();1===a.length&&(a=`0${a}`);const c=`N${a}`;let d=u[r];d&&d.getName()===r||(u[r]=d=this._complex.getChain(r)||this._complex.addChain(r),this._residue=null);let p=this._residue;p&&p.getSequence()===s&&p.getICode()===o||(this._residue=p=d.addResidue(c,s,o));let f=null;l.x3?f=new $P.Vector3(parseFloat(l.x3),parseFloat(l.y3),parseFloat(l.z3)):l.x2&&(f=new $P.Vector3(parseFloat(l.x2),parseFloat(l.y2),0));let m=yz.ByName[l.elementType.toUpperCase()];m||(m=JSON.parse(JSON.stringify(yz.ByName[Object.keys(yz.ByName)[Object.keys(yz.ByName).length-1]])),m.number+=1,m.name=l.elementType.toUpperCase(),m.fullName="Unknown",yz.ByName[l.elementType.toUpperCase()]=m);const g=parseInt(l.id.replace(/[^0-9]/,""),10),_=p.addAtom(i,m,f,yz.Role.SG,!0,g," ",1,0,t);l.hydrogenCount&&(_.hydrogenCount=parseInt(l.hydrogenCount,10)),l.mrvValence&&(_.valence=parseInt(l.mrvValence,10)),h(_)}}}for(u=null,o=0;o<n.bonds.length;o++){const t=n.bonds[o];if(this._unpackLabel(s[t.start]).molId===this._unpackLabel(i).molId&&this._unpackLabel(s[t.end]).molId===this._unpackLabel(i).molId){if(l=r[t.start],!l||!r[t.end])continue;this._parseBond(parseInt(l.id.replace(/[^0-9]/,""),10),parseInt(r[t.end].id.replace(/[^0-9]/,""),10),t.order,t.type)}}for(o=0;o<this._complex.getSGroupCount();o++){const t=this._complex.getSGroups()[o];for(a=0;a<t._atoms.length;a++)t._atoms[a]=t._atoms[a].complexAtom}for(o=0;o<c;o++)this._unpackLabel(s[o]).molId===this._unpackLabel(i).molId&&(l=r[o],l.complexAtom=null,delete l.complexAtom);return this._complex.originalCML=n.originalCML,this._fixBondsArray(),e.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._serialAtomMap=null,this._complex=null,e}parseSync(){const t=[],e=this;this._selectComponents(this._data).forEach(n=>{n.curr=2,0===n.count&&(n.count=1);for(let i=0;i<n.count;i++)n.curr=i+1,t.push(e._parseSet(n,!1))});let n=0;if(t.forEach(t=>{n+=t.getAtomCount()}),n<=0)throw new Error("The data does not contain valid atoms");if(t.length>1){const e=new _z;return e.joinComplexes(t),e.originalCML=t[0].originalCML,e}return 1===t.length?t[0]:new _z}}Mz.formats=["cml"],Mz.extensions=[".cml"];const wz=Mz;var Ez=XP(660),Tz=XP.n(Ez);const{Complex:Az,Chain:Cz,Atom:Rz,Element:Pz,Helix:Lz,Sheet:Iz,Strand:Nz,Bond:Dz,Assembly:Oz,Molecule:Uz}=DN;class Fz{constructor(t){this._original=Array.from(t),this._original.sort(),this._sum=0;for(let t=0;t<this._original.length;++t)this._sum+=this._original[t]}compare(t){const e=t.length;if(e!==this._original.length)return!1;let n,i=0;for(n=0;n<e;++n)i+=t[n];if(i!==this._sum)return!1;const r=Array.from(t);for(r.sort(),n=0;n<e;++n)if(r[n]!==this._original[n])return!1;return!0}}Fz.prototype.constructor=Fz;const Bz=SI.Type,zz=[Bz.HELIX_PI,Bz.BEND,Bz.HELIX_ALPHA,Bz.STRAND,Bz.HELIX_310,Bz.BRIDGE,Bz.TURN,Bz.COIL];class Vz extends QB{constructor(t,e){super(t,e),this._options.fileType="mmtf"}static canProbablyParse(t){return qP.default.isArrayBuffer(t)&&223==(1|new Uint8Array(t,0,1)[0])}_onModel(t){}_onChain(t){if(0!==t.modelIndex)return;const e=new Cz(this._complex,t.chainName);this._complex._chains[t.chainIndex]=e,e._index=t.chainIndex}_onGroup(t){if(0!==t.modelIndex)return;if(this.settings.now.nowater&&("HOH"===t.groupName||"WAT"===t.groupName))return;const e=this._complex._chains[t.chainIndex],n=t.insCode.charCodeAt(0)?t.insCode:"",i=e.addResidue(t.groupName,t.groupId,n);i._index=t.groupIndex,this._updateSecStructure(this._complex,i,t)}_onAtom(t){if(0!==t.modelIndex)return;const e=t.altLoc.charCodeAt(0)?t.altLoc:"",n=new Rz(t.groupIndex,t.atomName,Pz.getByName(t.element.toUpperCase()),new $P.Vector3(t.xCoord,t.yCoord,t.zCoord),Pz.Role[t.atomName],!1,t.atomId,e,t.occupancy,t.bFactor,t.formalCharge);this._complex._atoms[t.atomIndex]=n,n.index=t.atomIndex,this._serialAtomMap[t.atomId]=n}_onBond(t){const e=Math.max(t.atomIndex1,t.atomIndex2);if(e>=this._complex._atoms.length)return;const n=Math.min(t.atomIndex1,t.atomIndex2);this._complex.addBond(this._complex._atoms[n],this._complex._atoms[e],t.bondOrder,Dz.BondType.UNKNOWN,!0)}_updateSecStructure(t,e,n){const i=[3,-1,1,-1,5];if(!qP.default.isUndefined(n)&&n.secStruct===this._ssType)return e._secondary=this._ssStruct,void(this._ssStruct&&(this._ssStruct.term=e));if(!qP.default.isUndefined(n)){const r=zz[n.secStruct];this._ssType=n.secStruct,this._ssStart=e;let s=null;switch(this._ssType){case-1:case 7:break;case 0:case 2:case 4:s=new Lz(i[this._ssType],e,e,0,"","",0),t._helices.push(s);break;case 3:{const n=new Iz("",0);t._sheets.push(n),s=new Nz(n,e,e,0,null,null);break}default:void 0!==r&&(s=new SI(r,e,e))}this._ssStruct=s,e._secondary=s,s&&t.structures.push(s)}}_updateMolecules(t){const e=t.entityList;if(!e)return;const n=t.chainsPerModel[0];for(let t=0;t<e.length;t++){const i=e[t],r=i.chainIndexList;let s=[];for(let t=0;t<r.length;t++){const e=r[t];if(e>=n)continue;const i=this._complex._chains[e];s=s.concat(i._residues.slice())}const o=new Uz(this._complex,i.description,t+1);o.residues=s,this._complex._molecules[t]=o}}_traverse(t){const e=this,{metadata:n}=this._complex;n.id=t.structureId,n.title=[],n.title[0]=t.title,n.date=t.releaseDate,n.format="mmtf";const i={onModel(t){e._onModel(t)},onChain(t){e._onChain(t)},onGroup(t){e._onGroup(t)},onAtom(t){e._onAtom(t)},onBond(t){e._onBond(t)}};this._ssType=-1,this._ssStruct=null,this._ssStart=null,Tz().traverse(t,i),this._updateSecStructure(this._complex),this._updateMolecules(t)}_linkAtomsToResidues(){for(let t=0;t<this._complex._atoms.length;++t){const e=this._complex._atoms[t],n=this._complex._residues[e.residue];e.residue=n,n._atoms.push(e)}}_findSynonymousChains(){const t={};for(let e=0;e<this._complex._chains.length;++e){const n=this._complex._chains[e],i=n.getName();t.hasOwnProperty(i)||(t[i]=[]),t[i].push(n._index)}return t}_parseAssemblyInfo(t){let e,n,i;const r=[],{logger:s}=this;for(e=0;e<t.bioAssemblyList.length;++e){const o=t.bioAssemblyList[e];if(0===o.transformList.length)continue;const a=o.transformList[0].chainIndexList,l=new Fz(a),c={};for(n=0;n<a.length;++n)c[this._complex._chains[a[n]].getName()]=1;const h=[];let u;for(u in c)c.hasOwnProperty(u)&&Array.prototype.push.apply(h,this._chainsByName[u]);l.compare(h)||s.debug("MMTF: Assembly is missing some of the synonymous chains. Skipping...");const d=new Oz(this._complex);for(u in c)c.hasOwnProperty(u)&&d.addChain(u);for(d.addMatrix((new $P.Matrix4).fromArray(o.transformList[0].matrix).transpose()),n=1;n<o.transformList.length;++n){const t=o.transformList[n];if(!l.compare(t.chainIndexList)){s.debug("MMTF: Chain lists differ for different transforms in one assembly. Skipping...");continue}const e=(new $P.Matrix4).fromArray(t.matrix).transpose();for(i=0;i<d.matrices.length&&!d.matrices[i].equals(e);++i);i===d.matrices.length&&d.addMatrix(e)}d.finalize(),r.push(d)}return r}_markHeteroAtoms(t){const e=t.chainsPerModel[0];for(let n=0;n<t.entityList.length;++n){const i=t.entityList[n];if("polymer"!==i.type)for(let t=0;t<i.chainIndexList.length;++t){const n=i.chainIndexList[t];if(n>=e)continue;const r=this._complex._chains[n];for(let t=0;t<r._residues.length;++t){const e=r._residues[t];for(let t=0;t<e._atoms.length;++t)e._atoms[t].het=!0}}}}_joinSynonymousChains(){let t,e;const n=[],i={};for(t=0;t<this._complex._chains.length;++t){const r=this._complex._chains[t],s=r.getName();if(!i.hasOwnProperty(s)){i[s]=r,r._index=n.length,n.push(r);continue}const o=i[s];for(e=0;e<r._residues.length;++e){const t=r._residues[e];o._residues.push(t),t._chain=o}}this._complex._chains=n}parseSync(){const t=Tz().decode(this._data);return this._complex=new Az,this._serialAtomMap={},this._traverse(t),this._linkAtomsToResidues(),this._markHeteroAtoms(t),this._chainsByName=this._findSynonymousChains(),Array.prototype.push.apply(this._complex.units,this._parseAssemblyInfo(t)),this._joinSynonymousChains(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._complex}}Vz.formats=["mmtf"],Vz.extensions=[".mmtf"],Vz.binary=!0;const kz=Vz;class Gz extends Error{constructor(t,e,n){super(`data:${e}:${n}: ${t}`),Error.captureStackTrace&&Error.captureStackTrace(this,Gz),this.name="ParsingError",this.parseLine=e,this.parseColumn=n}}const Hz=Gz;function Wz(t){return 32===t||10===t||13===t||9===t}function jz(t,e,n){const i=e.length;let r=-1;for(;n<i&&(r=e.charCodeAt(n),r!==t&&10!==r);)++n;return r===t?n:-1}const{Complex:Xz,Element:Yz,Helix:qz,Sheet:$z,Strand:Zz,Assembly:Jz,Molecule:Kz}=DN,Qz=["auth_seq_id","Cartn_x","Cartn_y","Cartn_z","label_atom_id"],tV={helx:"helix",turn:"turn",strn:"strand"};function eV(t){const e=/[A-Za-z]+/.exec(t);return e?tV[e[0].toLowerCase()]:null}function nV(t){return null==t||qP.default.isArray(t)?t:[t]}function iV(t){const e=4===t.trim().length;return t.slice(0,e?1:2).trim()}class rV extends Error{constructor(t){super(),this.name="AtomDataError",this.message=t}}function sV(t,e){const n=(t=qP.default.isString(t)?t:`${t}`).replace(/\)\s*\(/g,"!").replace(/[()']/g,"").split("!"),i=[];for(let t=0,r=n.length;t<r;++t){const r=n[t].split(","),s=[];let o=0;for(let t=0,n=r.length;t<n;++t){const n=r[t];if(n.includes("-")){const t=n.split("-");let i=parseInt(t[0],10);const r=parseInt(t[1],10);for(;i<=r;++i)s[o++]=e[i]}else s[o++]=e[n]}i.push(s)}const r=[];let s=0;return function t(e,n){for(let o=0,a=i[e].length;o<a;++o){const a=n?n.clone():new $P.Matrix4;a.multiplyMatrices(i[e][o],a),0===e?r[s++]=a:t(e-1,a)}}(i.length-1),r}class oV extends QB{constructor(t,e){super(t,e),this.asymDict={},this.molecules=[],this._options.fileType="cif"}static canProbablyParse(t){return qP.default.isString(t)&&/^\s*data_/i.test(t)}parseSync(){this.logger.info("Parsing CIF file..");const t=function(t){let e=0,n=0;const i=t.length;let r,s=NaN,o=!0,a=1,l=1,c=0;const h={};let u,d={},p=[],f=0,m="",g=[],_=0;function y(){let r;if((46===s||63===s)&&(e+1>=i||Wz(t.charCodeAt(e+1))))return++l,void++e;if(o&&59===s){n=e;let c=0;do{if(n=jz(10,t,n+1),-1===n)throw new Hz("Unterminated text block found",a,l);++c}while(n+1<i&&t.charCodeAt(n+1)!==s||n+1>=i);return r=t.substring(e+1,n).replace(/\r/g,""),e=n+2,a+=c,l=1,o=!1,r}if(39===s||34===s){n=e;do{if(n=jz(s,t,n+1),-1===n)throw new Hz("Unterminated quoted string found",a,l)}while(n+1<i&&!Wz(t.charCodeAt(n+1)));return r=t.substring(e+1,n),l+=n-e+1,e=n+1,r}for(n=e;n<i&&!Wz(t.charCodeAt(n));)++n;r=t.substring(e,n),l+=n-e,e=n;const c=Number(r);return Number.isNaN(c)?r:c}function v(t){p[f++]=t}function x(t){return g[_%f].push(t),++_,t}for(;e<=i;){if(s=t.charCodeAt(e),13===s);else if(10===s)o=!0,++a,l=1;else{if(32!==s&&9!==s){if(35===s){if(e=jz(10,t,e+1),-1===e)break;continue}if(0===c){if(68!==s&&100!==s||"ata_"!==t.substr(e+1,4).toLowerCase()){if(Number.isNaN(s))break;throw new Hz(`Unexpected character in state ${c}`,a,l)}for(n=e+5,r=n;n<i&&!Wz(t.charCodeAt(n));)++n;if(l+=n-e,e=n,r<e){h[t.substring(r,e)]=d={},c=1;continue}throw new Hz("Data block name missing",a,l)}if(1===c){if(68!==s&&100!==s||"ata_"!==t.substr(e+1,4).toLowerCase()){if(95===s){for(n=e+1,r=n;n<i&&!Wz(t.charCodeAt(n));)++n;if(l+=n-e,e=n,r<e){m=t.substring(r,e),c=2;continue}throw new Hz("Tag name missing",a,l)}if(76!==s&&108!==s||"oop_"!==t.substr(e+1,4).toLowerCase()){if(Number.isNaN(s))break;throw new Hz(`Unexpected character in state ${c}`,a,l)}if(e+=5,l+=5,e<i&&!Wz(t.charCodeAt(e)))throw new Hz(`Unexpected character in state ${c}`,a,l);p=[],f=0,g=[],_=0,c=3;continue}c=0;continue}if(2===c){if(Number.isNaN(s))break;u=y(),qP.default.set(d,m,u),c=1;continue}if(3===c){if(95===s){for(n=e+1,r=n;n<i&&!Wz(t.charCodeAt(n));)++n;if(l+=n-e,e=n,r<e){v(t.substring(r,e));continue}throw new Hz("Tag name missing",a,l)}if(f>0){for(let t=0;t<f;++t)u=[],g[t]=u,qP.default.set(d,p[t],u);c=4;continue}throw new Hz("Data tags are missing inside a loop",a,l)}if(4===c){68!==s&&100!==s||"ata_"!==t.substr(e+1,4).toLowerCase()?95===s?c=1:76!==s&&108!==s||"oop_"!==t.substr(e+1,4).toLowerCase()?Number.isNaN(s)?c=0:x(y()):c=1:c=0;continue}throw new Hz(`Unexpected internal state ${c}`,a,l)}o=!1,++l}++e}if(2===c)throw new Hz(`Unexpected end of file in state ${c}`,a,l);return h}(this._data);return this._toComplex(t)}_toComplex(t){const e=new Xz,n=t[Object.keys(t)[0]];return this._extractAtoms(e,n),this._extractSecondary(e,n),this._extractAssemblies(e,n),this._extractMolecules(e,n),this._extractMetadata(e,n),e.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing}),e}_extractMetadata(t,e){const{metadata:n}=t;n.id=e.entry.id,n.classification=e.struct_keywords.pdbx_keywords;const i=e.database_PDB_rev;n.date=i&&i.date_original?i.date_original:"",n.format="cif",n.title=[],n.title[0]=e.struct.title}_extractMolecules(t,e){const n=nV(e.entity.pdbx_description),i=n.length;let r;for(r=0;r<i;r++)this.molecules[r]?this.molecules[r].name=n[r]:this.molecules[r]={name:n[r],residues:[]};const s=t.getMolecules();for(r=0;r<i;r++){const e=this.molecules[r];s[r]=new Kz(t,e.name,r+1),s[r].residues=e.residues}}_extractAtoms(t,e){const n=e.atom_site;if(!n)throw new rV("CIF parsing error: atom_site is not specified!");for(let t=0,e=Qz.length;t<e;++t)if(!n[Qz[t]])throw new rV(`CIF parsing error: requires field ${Qz[t]} not found!`);const{asymDict:i}=this,r=nV(n.auth_seq_id),s=nV(n.Cartn_x),o=nV(n.Cartn_y),a=nV(n.Cartn_z),l=nV(n.label_atom_id),c=l.length,h=nV(n.group_PDB)||[],u=nV(n.auth_asym_id)||[],d=nV(n.label_asym_id)||[],p=nV(n.id)||[],f=nV(n.pdbx_PDB_ins_code)||[],m=nV(n.label_comp_id)||[],g=nV(n.type_symbol)||[],_=nV(n.B_iso_or_equiv)||[],y=nV(n.occupancy)||[],v=nV(n.pdbx_formal_charge)||[],x=nV(n.label_alt_id)||[],S=nV(n.pdbx_PDB_model_num)||[],b=nV(n.label_entity_id)||[];let M=null,w=null;for(let e=0;e<c;++e){if(1!==(S[e]||1))continue;const n=String(u[e]||" ");M&&M.getName()===n||(M=t.getChain(n)||t.addChain(n)),i[String(d[e]||" ")]=n;const c=r[e],E=String(f[e]||" "),T=String(m[e]||"");if(!w||w.getSequence()!==c||w.getICode()!==E){w=M.addResidue(T,c,E);const t=b[e]-1;let n=this.molecules[t];n||(this.molecules[t]={name:"",residues:[]},n=this.molecules[t]),n.residues.push(w)}const A=l[e],C=g[e]||iV(A),R=Yz.getByName(C),P=Yz.Role[A.trim()],L=new $P.Vector3(s[e],o[e],a[e]),I="HETATM"===h[e]||!1,N=p[e]||e,D=_[e]||0,O=y[e]||0,U=String(x[e]||""),F=v[e]||0;w.addAtom(A,R,L,P,I,N,U,O,D,F)}}_extractSecondary(t,e){e.struct_conf&&this._extractConfs(t,e.struct_conf),e.struct_sheet_range&&this._extractSheets(t,e.struct_sheet_range)}_extractSheets(t,e){const{asymDict:n}=this;if(!(e.sheet_id&&e.id&&e.beg_label_seq_id&&e.end_label_seq_id&&e.beg_label_asym_id))return;const i=t._sheets;function r(t){const e=i.length;for(let n=0;n<e;++n)if(i[n]._name===t)return i[n];return i[e]=new $z(t,0),i[e]}const s=nV(e.sheet_id),o=nV(e.id),a=nV(e.beg_auth_seq_id),l=nV(e.end_auth_seq_id),c=nV(e.beg_label_asym_id),h=nV(e.pdbx_beg_PDB_ins_code)||[],u=nV(e.pdbx_end_PDB_ins_code)||[];for(let e=0,i=o.length;e<i;++e){const i=t.getChain(n[c[e]]),o=r(s[e]),d=a[e],p=l[e],f=h[e]||" ",m=u[e]||" ",g=i.findResidue(d,f),_=i.findResidue(p,m);if(!g||!_)continue;const y=new Zz(o,g[0],_[0],0,null,null),v=i.getResidues();for(let t=g[1];t<=_[1];++t)v[t]._secondary=y;o.addStrand(y),t.structures.push(y)}}_extractConfs(t,e){const{asymDict:n}=this;if(!(e.conf_type_id&&e.beg_label_seq_id&&e.end_label_seq_id&&e.beg_label_asym_id))return;const i=nV(e.conf_type_id),r=nV(e.beg_auth_seq_id),s=nV(e.pdbx_beg_PDB_ins_code)||[],o=nV(e.end_auth_seq_id),a=nV(e.pdbx_end_PDB_ins_code)||[],l=nV(e.details)||[],c=nV(e.pdbx_PDB_helix_length)||[],h=nV(e.pdbx_PDB_helix_class)||[],u=nV(e.id)||[],d=nV(e.beg_label_asym_id);for(let e=0,p=i.length;e<p;++e){const p=eV(i[e]);if(!p)continue;const f=u[e]||i[e],m=t.getChain(n[d[e]]),g=r[e],_=o[e],y=s[e]||" ",v=a[e]||" ",x=m.findResidue(g,y),S=m.findResidue(_,v);if(!x||!S)continue;const b=l[e]||"",M=c[e]||0,w=h[e]||" ";let E;if("helix"===p){const e=t._helices.length;E=new qz(w,x[0],S[0],e,f,b,M),t.addHelix(E),t.structures.push(E)}else"turn"===p?(E=new SI(SI.Type.TURN,x[0],S[0]),t.structures.push(E)):E=null;if(!E)continue;const T=m.getResidues();for(let t=x[1];t<=S[1];++t)T[t]._secondary=E}}_extractAssemblies(t,e){const{asymDict:n}=this,i=e.pdbx_struct_assembly_gen;if(!i)return;const r=nV(i.assembly_id),s=nV(i.oper_expression),o=nV(i.asym_id_list);if(!r||!s||!o)return;const a=function(t){if(!t)return null;const e=nV(t.id),{matrix:n,vector:i}=t;if(!e||!n||!i)return null;const r=[];for(let t=0,s=e.length;t<s;++t){const s=new $P.Matrix4,{elements:o}=s;for(let e=0;e<3;++e){const r=n[e+1];o[e]=nV(r[1])[t],o[e+4]=nV(r[2])[t],o[e+8]=nV(r[3])[t],o[e+12]=nV(i[e+1])[t]}r[e[t]]=s}return r}(e.pdbx_struct_oper_list);if(a)for(let e=0,i=r.length;e<i;++e){const i=new Jz(t),r=sV(s[e],a),l=o[e].split(",");for(let t=0,e=l.length;t<e;++t){const e=l[t].trim();e.length>0&&i.addChain(n[e])}i.matrices=r,t.units.push(i)}}}oV.formats=["cif","mmcif"],oV.extensions=[".cif",".mmcif"];const aV=oV,lV=class{_xyz2crs=[];_origin=(()=>new $P.Vector3(0,0,0))();constructor(){this._header={},this._boxSize=new $P.Vector3,this._boxStart=new $P.Vector3,this._header.delta={},this._header.extent=[],this._header.nstart=[],this._header.grid=[],this._header.crs2xyz=[],this._header.cellDims=new $P.Vector3,this._header.angles=[],this._header.origin=new $P.Vector3(0,0,0),this._header.dmin=0,this._header.dmean=0,this._header.dmax=0}_typedCheck(){if(qP.default.isTypedArray(this._buff))this._buff=this._buff.buffer;else if(!qP.default.isArrayBuffer(this._buff))throw new TypeError("Expected ArrayBuffer or TypedArray")}_fillHeader(t,e){for(const n in t)if(t.hasOwnProperty(n))switch(t[n][0]){case 0:this._header[n]=e[t[n][1]][t[n][2]];break;case 2:this._parseArray(this._header[n],e[t[n][1]],t[n][2]);break;case 1:this._parseVector(this._header[n],e[t[n][1]],t[n][2]);break;case 3:this._header[n]=new Uint8Array(e[t[n][1]],4*[t[n][2]],4*[t[n][3]])}}_parseVector(t,e,n){[t.x,t.y,t.z]=[e[n],e[n+1],e[n+2]]}_parseArray(t,e,n){t[0]=e[n],t[1]=e[n+1],t[2]=e[n+2]}_parseHeader(t){}_setAxisIndices(){}_setOrigins(){}_getAxis(){const t=this._header,e=t.cellDims.x/t.grid[0],n=t.cellDims.y/t.grid[1],i=t.cellDims.z/t.grid[2],[r,s,o]=t.angles,a=Math.cos(s),l=(Math.cos(r)-Math.cos(s)*Math.cos(o))/Math.sin(o),c=Math.sqrt(1-a*a-l*l);return[new $P.Vector3(e,0,0),new $P.Vector3(Math.cos(o)*n,Math.sin(o)*n,0),new $P.Vector3(a*i,l*i,c*i)]}_getXYZdim(){return[this._header.extent[this._xyz2crs[0]],this._header.extent[this._xyz2crs[1]],this._header.extent[this._xyz2crs[2]]]}_getVolumeInfo(){const t=qP.default.pick(this._header,["dmean","dmin","dmax","sd","delta"]);return t.obtuseAngle=this._header.angles.map(t=>Number(t>=Math.PI/2)),t}_setBoxParams(t,e,n){let i=0,r=0;const[s,o,a]=this._header.angles;a>=Math.PI/2&&(i+=Math.abs(e.x)),o>=Math.PI/2&&(i+=Math.abs(n.x)),s>=Math.PI/2&&(r+=Math.abs(n.y)),this._boxStart=new $P.Vector3(this._origin.x-i,this._origin.y-r,this._origin.z),this._boxSize=new $P.Vector3(Math.abs(t.x)+Math.abs(e.x)+Math.abs(n.x),Math.abs(e.y)+Math.abs(n.y),Math.abs(n.z));const l=(t,e)=>Math.abs(t[e])/this._boxSize[e];this._header.delta.x=l(e,"x"),this._header.delta.y=l(n,"x"),this._header.delta.z=l(n,"y")}_getXYZbox(){return new $P.Box3(this._boxStart.clone(),this._boxStart.clone().add(this._boxSize))}_toXYZData(){}parse(t){return this._parseHeader(t),this._setOrigins(),new NN(Float32Array,this._getXYZdim(),this._getXYZbox(),1,this._toXYZData(),this._getVolumeInfo())}},cV={extent:[2,"u32",0],type:[0,"u32",3],nstart:[2,"i32",4],grid:[2,"u32",7],cellDims:[1,"f32",10],angles:[2,"f32",13],crs2xyz:[2,"i32",16],dmin:[0,"f32",19],dmax:[0,"f32",20],dmean:[0,"f32",21],ispg:[0,"u32",22],nsymbt:[0,"u32",23],lksflg:[0,"u32",24],customData:[3,"buffer",25,9],origin:[1,"f32",34],map:[3,"buffer",52,1],machine:[0,"u32",53],sd:[0,"f32",54],nlabel:[0,"f32",55],label:[3,"buffer",56,200]};class hV extends lV{_parseHeader(t){this._buff=t,this._typedCheck();const e={};e.u32=new Uint32Array(this._buff,0,56),e.i32=new Int32Array(this._buff,0,56),e.f32=new Float32Array(this._buff,0,56),e.buffer=this._buff;const n=this._header;this._fillHeader(cV,e),n.angles.forEach((t,e,n)=>{n[e]*=Math.PI/180})}_setAxisIndices(){const t=this._header;0===t.cellDims.x&&0===t.cellDims.y&&0===t.cellDims.z&&t.cellDims.set(1,1,1);const{crs2xyz:e}=this._header;0===e[0]&&0===e[1]&&0===e[2]&&(e[0]=1,e[1]=2,e[2]=3);const n=this._xyz2crs;n[e[0]-1]=0,n[e[1]-1]=1,n[e[2]-1]=2}_setOrigins(){const[t,e,n]=this._getAxis();this._setAxisIndices();const i=this._header,r=this._xyz2crs;if(0===i.origin.x&&0===i.origin.y&&0===i.origin.z?(this._origin.addScaledVector(t,i.nstart[r[0]]),this._origin.addScaledVector(e,i.nstart[r[1]]),this._origin.addScaledVector(n,i.nstart[r[2]])):this._origin=i.origin,t.multiplyScalar(i.extent[r[0]]-1),e.multiplyScalar(i.extent[r[1]]-1),n.multiplyScalar(i.extent[r[2]]-1),2!==i.type)throw new Error(`CCP4: Unsupported format ${i.type}`);this._data=new Float32Array(this._buff,1024+i.nsymbt,i.extent[0]*i.extent[1]*i.extent[2]),this._setBoxParams(t,e,n)}_toXYZData(){const t=this._header,e=this._data,n=this._xyz2crs,i=new Float32Array(e.length),r=this._getXYZdim(),s=r[0],o=r[1];let a=0;const l=[];let c,h,u;for(l[2]=0;l[2]<t.extent[2];l[2]++)for(l[1]=0;l[1]<t.extent[1];l[1]++)for(l[0]=0;l[0]<t.extent[0];l[0]++,a++)c=l[n[0]],h=l[n[1]],u=l[n[2]],i[c+s*(h+o*u)]=e[a];return i}}class uV extends QB{constructor(t,e){super(t,e),this._options.fileType="ccp4",this.model=new hV}static canProbablyParse(t){return!1}parseSync(){return this.model.parse(this._data)}}uV.formats=["ccp4"],uV.extensions=[".ccp4",".map",".mrc"],uV.binary=!0;const dV=uV,{Complex:pV,Element:fV,Molecule:mV}=DN,{Complex:gV,Element:_V}=DN;class yV extends QB{constructor(t,e){super(t,e),this._options.fileType="pubchem+json"}static canProbablyParse(t){return qP.default.isString(t)&&"{"===t[0]}parseSync(){return this.logger.info("Parsing PubChem JSON file..."),this._toComplex(JSON.parse(this._data))}_toComplex(t){const e=new gV,n=t.PC_Compounds&&t.PC_Compounds[0];return n&&(this._extractAtoms(e,n),e.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing})),e}_extractAtoms(t,e){let n=e.atoms&&e.atoms.aid,i=n&&e.atoms.element;if(!i||n.length!==i.length)throw new Error("Unable to parse atom elements");i=qP.default.fromPairs(qP.default.zip(n,i));const r={},s=e.coords&&e.coords[0],o=s&&s.conformers&&s.conformers[0],a=o&&o.x,l=o&&o.y,c=o&&o.z||[];if(n=s&&s.aid,!n||!a||!l)throw new Error("Coordinates are not found in the file");const h=t.addChain(" ").addResidue("UNK",1," ");for(let t=0,e=n.length;t<e;++t){const e=n[t],s=_V.ByAtomicNumber[i[e]],o=new $P.Vector3(a[t],l[t],c[t]||0);r[e]=h.addAtom(s.name,s,o,void 0,!0,e," ",1,0,0)}const u=e.bonds&&e.bonds.aid1,d=e.bonds&&e.bonds.aid2,p=e.bonds&&e.bonds.order||[];if(u&&d&&u.length===d.length)for(let e=0,n=u.length;e<n;++e)t.addBond(r[u[e]],r[d[e]],p[e]||1,0,!0)}}yV.formats=["pubchem","pubchem+json","pc"],yV.extensions=[".json"];const vV=yV;class xV{constructor(t){this._strings=t.split(/\r?\n|\r/),this._currentStart=0,this._currentStringIndx=0}setStart(t){t>=this._strings.length?(this._currentStart=this._strings.length-1,this._currentStringIndx=this._strings.length-1):(this._currentStart=t,this._currentStringIndx=t)}getNextString(){return this._strings[++this._currentStringIndx]}getCurrentString(){return this._strings[this._currentStringIndx]}getStringFromStart(t){return this._currentStringIndx=this._currentStart+t,this._strings[this._currentStart+t]}findNextDataItem(){let t=this.getNextString(),e=!1;for(;!qP.default.isUndefined(t)&&"$$$$"!==t.trim();){if(t.match(/>\s+<(.*)>/)){e=!0;break}t=this.getNextString()}return e}findNextCompoundStart(){let t=this.getCurrentString();for(;!qP.default.isUndefined(t)&&"$$$$"!==t.trim();)t=this.getNextString();return this.setStart(++this._currentStringIndx),this.probablyHaveDataToParse()}probablyHaveDataToParse(){return this._currentStringIndx<this._strings.length-2}}const{Complex:SV,Element:bV,Bond:MV,Molecule:wV}=DN,EV=[0,3,2,1,0,-1,-2,-3],TV=[0,1,2,3,1,1,1,2],AV=[MV.BondType.UNKNOWN,MV.BondType.COVALENT,MV.BondType.COVALENT,MV.BondType.COVALENT,MV.BondType.AROMATIC,MV.BondType.UNKNOWN,MV.BondType.AROMATIC,MV.BondType.AROMATIC],CV=/.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/,RV=/.*($$$$).*|.*>\s+<(.+)>.*/,PV=["name","id","title"],LV={name:["PUBCHEM_IUPAC_TRADITIONAL_NAME",/PUBCHEM_(.+)_NAME/,/(.+)name/,/(.+)NAME/],id:["PUBCHEM_COMPOUND_CID","id","ID",/.*CID/,/.*ID/,/.*id/],title:["msg","MSG","message","title","description","desc"]};class IV extends QB{constructor(t,e){super(t,e),this._format="sdf",this._complex=null,this._chain=null,this._residue=null,this._molecules=null,this._metadata={},this._metadata.molecules=[],this._currentMolProps={},this._compoundIndx=-1,this._assemblies=[],this._atomsParsed=0,this._atomsIndexes=[]}canProbablyParse(t){return qP.default.isString(t)&&CV.test(t)}_parseHeader(t){const e={};e.name=t.getStringFromStart(0);const n=parseInt(t.getStringFromStart(1).substr(10,6).trim(),10);e.date=n.toString()||"",e.title=t.getStringFromStart(2),this._metadata.molecules.push(e)}_parseAtoms(t,e){let n,i=this._atomsParsed;const r=function(t){if(!t)return"A";const e=[];for(;t;)e.push(65+t%26),t=Math.trunc(t/26);return e.length>1&&(e.reverse(),e[0]-=1),String.fromCharCode(...e)}(this._compoundIndx);this._chain=this._complex.getChain(r)||this._complex.addChain(r),this._residue=this._chain.addResidue("UNK",1," ");for(let r=0;r<e;r++){n=t.getNextString(),i++;const e=parseFloat(n.substr(0,10)),r=parseFloat(n.substr(10,10)),s=parseFloat(n.substr(20,10)),o=EV[parseInt(n.substr(36,3),10)],a=new $P.Vector3(e,r,s);let l=n.substr(31,3).trim().toUpperCase();const c=bV.getByName(l);this._atomsIndexes[l]||(this._atomsIndexes[l]=0),this._atomsIndexes[l]+=1,l+=this._atomsIndexes[l],this._residue.addAtom(l,c,a,void 0,!0,i," ",1,0,o)}}_parseBonds(t,e){let n;for(let i=0;i<e;i++){n=t.getNextString();let e=parseInt(n.substr(0,3),10)+this._atomsParsed,i=parseInt(n.substr(3,3),10)+this._atomsParsed;const r=parseInt(n.substr(6,3),10);e>i&&([e,i]=[i,e]),this._complex.addBond(e,i,TV[r]||1,AV[r]||MV.BondType.UNKNOWN,!0)}}_parseMOL(t){this._compoundIndx++,this._parseHeader(t);const e=t.getStringFromStart(3),n=parseInt(e.substr(0,3),10),i=parseInt(e.substr(3,3),10);this._parseAtoms(t,n),this._parseBonds(t,i),this._atomsParsed+=n,this._metadata.molecules[this._compoundIndx]._residues=[],this._metadata.molecules[this._compoundIndx]._residues.push(this._residue)}_parseDataItem(t){const e=t.getCurrentString();let n=[],i=t.getNextString();for(;""!==i.trim();)n.push(i),i=t.getNextString();1===n.length&&([n]=n),this._currentMolProps[e.replace(/[<>]/g,"").trim()]=n}_parseCompound(t){if(this._parseMOL(t),"sdf"===this._format){for(this._currentMolProps={};t.findNextDataItem();)this._parseDataItem(t);if(0!==Object.keys(this._currentMolProps).length){const t=this._metadata.molecules[this._compoundIndx];t.props=this._currentMolProps,this._tryToUpdateMoleculeData(t)}}}_fixBondsArray(){const t=this._serialAtomMap,e=this._complex._bonds;for(let n=0;n<e.length;n++){const i=e[n];i._right<i._left&&console.log("_fixBondsArray: Logic error."),i._left=t[i._left]||null,i._right=t[i._right]||null}}_buildAssemblies(){const t=this._complex._chains;if(1===t.length)return this._assemblies;for(let e=0;e<t.length;e++){const n=new $I(this._complex),i=new $P.Matrix4;n.addMatrix(i),n.addChain(t[e]._name),this._assemblies.push(n)}return this._assemblies}_buildMolecules(){this._complex._molecules=[];const{molecules:t}=this._metadata;for(let e=0;e<t.length;e++){const n=new wV(this._complex,t[e].name,e+1);n.residues=t[e]._residues,this._complex._molecules[e]=n}return this._complex._molecules}_searchTag(t,e){for(let n=0;n<e.length;n++)if(t instanceof RegExp&&t.test(e[n].tag)||t===e[n].tag)return e[n].data}_tryToFind(t,e){for(let n=0;n<t.length;n++){const i=this._searchTag(t[n],e);if(i)return i}}_tryToUpdateMoleculeData(t){let e=!1;for(let n=0;n<PV.length;n++){const i=LV[PV[n]],r=this._tryToFind(i,t.props);r&&(t[PV[n]]=r,e=!0)}return t.name=t.name||t.id,t.name.match(/^\d+$/)&&(t.name=`CID: ${t.name}`),e}_finalizeMetadata(){const{molecules:t}=this._metadata,{metadata:e}=this._complex,n=this._complex;if(1===t.length)n.name=t[0].name,e.title=t[0].title,e.date=t[0].date,e.properties=t[0].props;else if(t.length>1){e.molecules=[];for(let n=0;n<t.length;n++)e.molecules.push({name:t[n].name,date:t[n].date,title:t[n].title,properties:t[n].props})}}_finalize(){const t=this._serialAtomMap={},e=this._complex._atoms;for(let n=0;n<e.length;n++){const i=e[n];t[i.serial]=i}this._complex._finalizeBonds(),this._fixBondsArray(),this._finalizeMetadata(),this._buildAssemblies(),this._complex.units=this._complex.units.concat(this._assemblies),this._buildMolecules(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:!1,enableEditing:!1,serialAtomMap:this._serialAtomMap})}defineFormat(t){let e;return e=RV.test(t)?"sdf":"mol",e}parseSync(){const t=this._complex=new SV,e=new xV(this._data);this._format=this.defineFormat(this._data),t.metadata.format=this._format;do{this._parseCompound(e)}while(e.findNextCompoundStart());return this._finalize(),t}}IV.formats=["mol","sdf"],IV.extensions=[".mol",".sdf"];const NV={nstart:[2,"i16",0],extent:[2,"i16",3],grid:[2,"i16",6],cellDims:[1,"i16",9],angles:[2,"i16",12],div:[0,"i16",15],adder:[0,"i16",16],scaleFactor:[0,"i16",17]};class DV extends lV{_parseHeader(t){this._buff=t,this._typedCheck();const e={};if(e.i16=new Int16Array(this._buff),100!==e.i16[18])for(let t=0,n=e.i16.length;t<n;++t){const n=e.i16[t];e.i16[t]=(255&n)<<8|n>>8&255}if(100!==e.i16[18])throw new Error("DSN6: Incorrect format ");const n=this._header;this._fillHeader(NV,e),n.cellDims.multiplyScalar(1/n.scaleFactor),n.angles.forEach((t,e,i)=>{i[e]*=Math.PI/180/n.scaleFactor}),n.div/=100}_setAxisIndices(){this._xyz2crs[0]=0,this._xyz2crs[1]=1,this._xyz2crs[2]=2}_setOrigins(){const t=this._header,[e,n,i]=this._getAxis();this._setAxisIndices(),this._origin.addScaledVector(e,t.nstart[0]),this._origin.addScaledVector(n,t.nstart[1]),this._origin.addScaledVector(i,t.nstart[2]),e.multiplyScalar(t.extent[0]),n.multiplyScalar(t.extent[1]),i.multiplyScalar(t.extent[2]),this._setBoxParams(e,n,i)}_pointCalculate(t,e,n,i,r,s,o){const a=this._header;return r<a.extent[0]&&i<a.extent[1]&&n<a.extent[2]?(t[r+a.extent[0]*(i+a.extent[1]*n)]=(e[s.counter]-a.adder)/a.div,++s.counter,!0):(s.counter+=8-o,!1)}_blockCalculate(t,e,n,i,r,s){for(let o=0;o<8;++o){const a=8*n+o;for(let n=0;n<8;++n){const o=8*i+n;let l=!0,c=0;for(;l&&c<8;){const n=8*r+c;l=this._pointCalculate(t,e,a,o,n,s,c),c++}}}}_toXYZData(){const t=this._header,e=new Uint8Array(this._buff),n=new Float32Array(t.extent[0]*t.extent[1]*t.extent[2]),i=new $P.Vector3(t.extent[0]/8,t.extent[1]/8,t.extent[2]/8),r={counter:512};for(let t=0;t<i.z;++t)for(let s=0;s<i.y;++s)for(let o=0;o<i.x;++o)this._blockCalculate(n,e,t,s,o,r);return this._calculateInfoParams(n),n}_calculateInfoParams(t){this._header.dmean/=t.length;let e=0,n=t[0],i=t[0];for(let r=0;r<t.length;r++)e+=(this._header.dmean-t[r])**2,t[r]<n&&(n=t[r]),t[r]>i&&(i=t[r]);this._header.sd=Math.sqrt(e/t.length),this._header.dmax=i,this._header.dmin=n}}class OV extends QB{constructor(t,e){super(t,e),this._options.fileType="dsn6",this.model=new DV}static canParse(t,e){return!!t&&t instanceof ArrayBuffer&&QB.checkDataTypeOptions(e,"dsn6")}static canProbablyParse(t){return!1}parseSync(){return this.model.parse(this._data)}}OV.formats=["dsn6"],OV.extensions=[".dsn6",".omap"],OV.binary=!0;const UV=OV,FV=class extends sz{constructor(t){super(t),this._next=-1,this.next()}getNext(){return this._next}},{Complex:BV,Element:zV,Molecule:VV}=DN;class kV extends QB{constructor(t,e){super(t,e),this._time=null,this._numAtoms=null,this._residueNumber=null,this._residueName="",this._atomName="",this._atomNumber=null,this._atomPosition=[],this._atomVelocity=[],this._complex=null,this._molecules=[],this._molecule=null,this._options.filetype="gro"}canProbablyParse(t){return qP.default.isString(this._data)&&/^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(t)}_parseTitle(t){const{metadata:e}=this._complex;e.id=t.readLine().trim(),e.name=e.id.slice(e.id.lastIndexOf("\\")+1,e.id.lastIndexOf(".")),e.format="gro"}_parseNumberOfAtoms(t){if(this._numAtoms=t.readInt(0,t.getNext()),Number.isNaN(this._numAtoms))throw new Error("Line 2 is not representing atom number. Consider checking input file")}_parseAtom(t){this._residueNumber=t.readInt(1,5),this._residueName=t.readString(6,10).trim(),this._atomName=t.readString(11,15).trim(),this._atomNumber=t.readInt(16,20);const e=10*t.readFloat(21,28),n=10*t.readFloat(29,36),i=10*t.readFloat(37,45);if(Number.isNaN(e)||Number.isNaN(n)||Number.isNaN(i))return void(this._complex.error={message:`Atom position is invalid in "${t.readLine()}"`});const r=zV.getByName(this._atomName[0]);if("Unknown"===r.fullName)return void(this._complex.error={message:`${this._atomName[0]} hasn't been recognised as an atom name.`});const s=zV.Role[this._atomName];let o=this._chain;o||(this._chain=o=this._complex.addChain("A"));let a=this._residue;a&&a.getSequence()===this._residueNumber||(this._residue=a=o.addResidue(this._residueName,this._residueNumber," ")),this._atomPosition=new $P.Vector3(e,n,i),a.addAtom(this._atomName,r,this._atomPosition,s,!0,this._atomNumber," ",1,1,0)}_finalize(){const t=new VV(this._complex,this._complex.metadata.name,1);t.residues=this._chain._residues,t._chains=this._chain,this._complex._molecules[0]=t,this._molecules.push(t),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}parseSync(){const t=this._complex=new BV,e=new FV(this._data);let n=0;for(this._parseTitle(e),e.next(),this._parseNumberOfAtoms(e),e.next(),n=0;n<this._numAtoms&&!e.end();++n)this._parseAtom(e),e.next();if(n<this._numAtoms&&(this._complex.error={message:"File ended unexpectedly."}),t.error)throw new Error(t.error.message);return this._finalize(),this._atomPosition=null,this._complex=null,this._molecules=null,this._molecule=null,t}}kV.formats=["gro"],kV.extensions=[".gro"];const GV=kV,{Complex:HV,Element:WV,Bond:jV,Molecule:XV}=DN,YV={un:0,1:1,2:2,3:3,ar:1,am:1,nc:0,du:1},qV={un:jV.BondType.UNKNOWN,1:jV.BondType.COVALENT,2:jV.BondType.COVALENT,3:jV.BondType.COVALENT,ar:jV.BondType.AROMATIC,am:jV.BondType.COVALENT,nc:jV.BondType.UNKNOWN,du:jV.BondType.COVALENT},$V=/\d+$/,ZV=/\s+/;function JV(t){return t.trim().split(ZV)}class KV extends QB{constructor(t,e){super(t,e),this._complex=null,this._chain=null,this._residue=null,this._compoundIndx=-1,this._molecules=[],this._molecule=null,this._currPosIdx=0,this._currStartIdx=0,this._serialAtomMap={},this._options.fileType="mol2"}_parseRawStrings(t){return t.split(/\r?\n|\r/)}_toStringFromStart(t,e){const n=this._currStartIdx+t;this._currPosIdx=n<e.length?n:this._currStartIdx}_toHeaderString(t,e){for(this._toStringFromStart(0,e);this._currPosIdx<e.length;){if(e[this._currPosIdx].match(`@<TRIPOS>${t}`))return;this._currPosIdx++}this._toStringFromStart(0,e)}_toStringFromHeader(t,e,n){this._toHeaderString(t,n);const i=this._currPosIdx+e;n[this._currPosIdx].match(`@<TRIPOS>${t}`)&&i<n.length&&(this._currPosIdx=i)}_setStart(t,e){t>=e.length?this._currStartIdx=this._currPosIdx=e.length-1:this._currStartIdx=this._currPosIdx=t}_probablyHaveDataToParse(t){return this._currPosIdx<t.length-2}_findNextCompoundStart(t){for(;this._currPosIdx<t.length&&"@<TRIPOS>MOLECULE>"!==t[this._currPosIdx].trim();)this._currPosIdx++;return this._setStart(++this._currPosIdx,t),this._probablyHaveDataToParse(t)}_parseMolecule(t){this._toHeaderString("MOLECULE",t);const{metadata:e}=this._complex;e.name=t[++this._currPosIdx],e.format="mol2",this._molecule={_index:"",_chains:[]},this._molecule._index=this._compoundIndx+1,this._molecules.push(this._molecule)}_parseAtoms(t,e){this._toHeaderString("ATOM",e);for(let n=0;n<t;n++){const t=JV(e[++this._currPosIdx]);if(t.length<6)throw new Error("MOL2 parsing error: Not enough information to create atom!");const n=parseInt(t[0],10),i=t[1],r=parseFloat(t[2]),s=parseFloat(t[3]),o=parseFloat(t[4]),a=t[5].split(".")[0].toUpperCase();let l=0;t.length>=9&&(l=parseFloat(t[8])||0);let c=this._chain;if(c||(this._chain=c=this._complex.getChain("A")||this._complex.addChain("A"),this._residue=null),!this._setResidue(t))continue;const h=!1,u=" ",d=1,p=0,f=WV.getByName(a),m=WV.Role[i],g=new $P.Vector3(r,s,o);this._residue.addAtom(i,f,g,m,h,n,u,d,p,l)}}_setResidue(t){let e=1,n="UNK";if(t.length>=7&&(e=parseInt(t[6],10)),t.length>=8&&"<0>"!==t[7]&&(n=t[7].replace($V,"")),this.settings.now.nowater&&("HOH"===n||"WAT"===n))return!1;const i=this._residue,r=this._chain;return i&&i.getSequence()===e||(this._residue=r.addResidue(n,e,"A")),!0}_parseBonds(t,e){this._toHeaderString("BOND",e);for(let n=0;n<t;n++){const t=JV(e[++this._currPosIdx]);if(t.length<3)throw new Error("MOL2 parsing error: Missing information about bonds!");let n=parseInt(t[1],10),i=parseInt(t[2],10);const r=t[3];n>i&&([n,i]=[i,n]),this._complex.addBond(n,i,YV[r]||0,qV[r]||jV.BondType.UNKNOWN,!0)}}_fixSerialAtoms(){const t=this._complex._atoms;for(let e=0;e<t.length;e++){const n=t[e];this._serialAtomMap[n.serial]=n}}_fixBondsArray(){const t=this._serialAtomMap,e=this._complex;if(0===Object.keys(t).length)throw new Error("MOL2 parsing error: Missing atom information!");const n=e._bonds;for(let e=0;e<n.length;e++){const i=n[e];i._left=t[i._left]||null,i._right=t[i._right]||null}}_finalizeMolecules(){const t=this._complex._chains[0];this._complex._molecules=[];for(let e=0;e<this._molecules.length;e++){const n=this._molecules[e],i=t._residues,r=new XV(this._complex,n._name,e+1);r.residues=i,this._complex._molecules[e]=r}}_finalize(){this._complex._finalizeBonds(),this._fixSerialAtoms(),this._fixBondsArray(),this._finalizeMolecules(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}_parseCompound(t){this._compoundIndx++,this._parseMolecule(t),this._toStringFromHeader("MOLECULE",2,t);const e=t[this._currPosIdx].trim().split(ZV),n=e[0],i=e[1];this._parseAtoms(n,t),this._parseBonds(i,t)}parseSync(){const t=this._complex=new HV,e=this._parseRawStrings(this._data);do{this._parseCompound(e)}while(this._findNextCompoundStart(e));return this._finalize(),t}}KV.formats=["mol2"],KV.extensions=[".mol2",".ml2",".sy2"];const QV=new class extends JN{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],["formats","extensions"])}find(t){let e=[];return t.format?e=this._dict.formats[t.format.toLowerCase()]||[]:t.ext&&(e=this._dict.extensions[t.ext.toLowerCase()]||[]),0===e.length&&!t.format&&t.data?this._list.filter(e=>e.canProbablyParse&&e.canProbablyParse(t.data)):[...e]}}([gz,aV,kz,class extends QB{constructor(t,e){super(t,e),this._complex=null,this._atomsInf=null,this._options.fileType="xyz",this._fileName=e.name}static canProbablyParse(t){return qP.default.isString(t)&&/^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(t)}_parseToAtomsInf(t){const e=t.indexOf("\n"),n=parseInt(t.substring(0,e),10),i=t.indexOf("\n",e+1);let r=t.slice(e+1,i).trim();0===r.length&&(r=this._fileName);const s=i+t.substring(i).search(/\S/);this._atomsInf=t.substring(s).split(/[\s,]*\n[\s,]*/),Number.isNaN(n)||this._atomsInf.length-1===n?(this._complex.metadata.format="xyz",this._complex.name=r):this._complex.error={message:"wrong number of atoms"}}_parseAtomsInf(){const t=this._complex.addChain("A").addResidue("UNK",1," ");for(let e=0;e<this._atomsInf.length-1;e++){const n=this._atomsInf[e].split(/[\s,]+/);if(4!==n.length){this._complex.error={message:"missed parameters"};break}const i=e+1,r=n[0],s=new $P.Vector3(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3])),o=fV.getByName(r),a=void 0;t.addAtom(r,o,s,a,!0,i," ",1,1,0)}const e=new mV(this._complex,this._complex.name,1);e.residues=t,this._complex._molecules[0]=e}parseSync(){const t=this._complex=new pV;if(this._parseToAtomsInf(this._data),this._parseAtomsInf(),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._complex=null,this._atomsInf=null,t.error)throw new Error(t.error.message);return t}static formats=["xyz"];static extensions=[".xyz"]},wz,vV,IV,dV,UV,GV,KV]);class tk{constructor(t,e){this._source=t,this._options=e||{},this._abort=!1}exportSync(){throw new Error("Exporting to this source is not implemented")}export(){return new Promise((t,e)=>{setTimeout(()=>{try{return this._abort?e(new Error("Export aborted")):t(this.exportSync())}catch(t){return e(t)}})})}abort(){this._abort=!0}}KN(tk.prototype);class ek{constructor(){this._resultArray=[],this._currentStr=-1,this._tag=null,this._fixedNumeration=!1,this._numeration=!1,this._tagStrNum=0}getResult(){return this.writeString("\n",81,81),this._resultArray.join("")}_currentStrLength(){const t=this._resultArray[this._currentStr];return t?t.length:0}newTag(t,e){this._tag=t||null,qP.default.isUndefined(e)?(this._numeration=!1,this._fixedNumeration=!1,this._tagStrNum=0):qP.default.isNumber(e)?(this._tagStrNum=e,this._numeration=!0,this._fixedNumeration=!0):qP.default.isBoolean(e)&&(this._tagStrNum=0,this._numeration=e,this._fixedNumeration=!1)}newString(t){this.writeString("\n",81,81),this._currentStr++,this._resultArray.push(""),t?this.writeString(t,1,6):this._tag&&this.writeString(this._tag,1,6),this._numeration&&(this._fixedNumeration||this._tagStrNum++,1!==this._tagStrNum&&this.writeString(this._tagStrNum.toString(),10,8))}writeEntireString(t,e,n){e||(e=81);for(let i=0;i<t.length;i++)this._currentStrLength()===e&&i!==t.length-1&&(this.newString(),n&&this.writeString(n.tag,n.begin,n.end)),"\n"===t[i]?this.newString():this.writeString(t[i])}writeString(t,e,n){let i,r=this._resultArray[this._currentStr];const s=r?r.length:0;if(qP.default.isUndefined(t))return;qP.default.isNumber(e)||(e=s+1),qP.default.isNumber(n)||(n=s+t.length),i=qP.default.isString(t)?t:t.toString();const o=e<n?n:e,a=e<n?e:n;if(i.length>Math.abs(e-n)+1&&(i=i.substr(0,Math.abs(e-n+1))),a>s+1)this._resultArray[this._currentStr]+=" ".repeat(a-s-1);else if(a<=s){const t=this._resultArray[this._currentStr];this._resultArray[this._currentStr]=t.slice(0,a-1)}n<e&&(i=" ".repeat(e-n+1-i.length)+i),11===a&&this._numeration&&1!==this._tagStrNum&&(i=` ${i}`),this._resultArray[this._currentStr]+=i,r=this._resultArray[this._currentStr],o>r.length&&(this._resultArray[this._currentStr]+=" ".repeat(o-r.length))}writeBondsArray(t,e){const n=this._getSubArrays(t,4);for(let t=0;t<n.length;t++){this.newString(),this.writeString(e.serial,11,7);for(let i=0;i<n[t].length;i++){const r=n[t][i]._left.serial===e.serial?n[t][i]._right.serial:n[t][i]._left.serial;this.writeString(r,16+5*i,12+5*i)}}}_getSubArrays(t,e){const n=[];for(let i=0;i<t.length;i+=e)n.push(t.slice(i,i+e));return n}writeMatrix(t,e,n){for(let i=0;i<3;i++){this.newString(),this.writeString(n,14,18),this.writeString((i+1).toString(),19,19),this.writeString(e.toString(),23,20);for(let e=0;e<3;e++){const n=parseFloat(t.elements[4*i+e]).toFixed(6);this.writeString(n.toString(),33+10*e,24+10*e)}const r=parseFloat(t.elements[4*i+3]).toFixed(5);this.writeString(r.toString(),68,55)}}writeMatrices(t,e){if(!t)return;const n=new $P.Matrix4;for(let i=0;i<t.length;i++)n.copy(t[i]).transpose(),this.writeMatrix(n,i+1,e)}}class nk extends tk{constructor(t,e){super(t,e),this._tags=["HEADER","TITLE","COMPND","REMARK","HELIX","SHEET","ATOM and HETATM","CONECT"],this._result=null,this._tagExtractors={HEADER:this._extractHEADER,TITLE:this._extractTITLE,"ATOM and HETATM":this._extractATOM,CONECT:this._extractCONECT,COMPND:this._extractCOMPND,REMARK:this._extractREMARK,HELIX:this._extractHELIX,SHEET:this._extractSHEET},this._stringForRemark350="COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\nBIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\nMOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\nGIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\nCRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.",this._stringForRemark290="CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\nTHE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\nRECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\nRELATED MOLECULES."}exportSync(){const t=new ek;if(!this._source)return this._result;for(let e=0;e<this._tags.length;e++){const n=this._tags[e],i=this._tagExtractors[n];qP.default.isFunction(i)&&i.call(this,t)}return this._result=t.getResult(),this._result}_extractHEADER(t){if(!this._source.metadata)return;const{metadata:e}=this._source;t.newTag("HEADER"),t.newString(),e.classification&&t.writeString(e.classification,11,50),e.date&&t.writeString(e.date,51,59),e.id&&t.writeString(e.id,63,66)}_extractTITLE(t){if(!this._source.metadata)return;const{metadata:e}=this._source;if(e.title){t.newTag("TITLE",!0);for(let n=0;n<e.title.length;n++)t.newString(),t.writeString(e.title[n],11,80)}}_extractCONECT(t){if(!this._source._atoms)return;const e=this._source._atoms;t.newTag("CONECT");for(let n=0;n<e.length;n++){const i=e[n].bonds.filter(t=>t._fixed);0!==i.length&&t.writeBondsArray(i.reverse(),e[n])}}_extractSHEET(t){if(!this._source._sheets)return;t.newTag("SHEET");const e=this._source._sheets;for(let n=0;n<e.length;n++)if(e[n]._strands){const i=e[n]._strands;for(let r=0;r<i.length;r++)t.newString(),t.writeString(r+1,10,8),t.writeString(e[n]._name,14,12),t.writeString(i.length,16,15),t.writeString(i[r].init._type._name,18,20),t.writeString(i[r].init._chain._name,22,22),t.writeString(i[r].init._sequence,26,23),t.writeString(i[r].init._icode,27,27),t.writeString(i[r].term._type._name,29,31),t.writeString(i[r].init._chain._name,33,33),t.writeString(i[r].term._sequence,37,34),t.writeString(i[r].term._icode,38,38),t.writeString(i[r].sense,40,39)}}_extractHELIX(t){if(!this._source._helices)return;t.newTag("HELIX");const e=this._source._helices;for(let n=0;n<e.length;n++){const i=e[n],r=qP.default.invert(MI);t.newString(),t.writeString(i.serial,10,8),t.writeString(i.name,14,12),t.writeString(i.init._type._name,16,18),t.writeString(i.init._chain._name,20,20),t.writeString(i.init._sequence,25,22),t.writeString(i.init._icode,26,26),t.writeString(i.term._type._name,28,30),t.writeString(i.term._chain._name,32,32),t.writeString(i.term._sequence,37,34),t.writeString(i.term._icode,38,38),t.writeString(r[i.type],40,39),t.writeString(i.comment,41,70),t.writeString(i.length,76,72)}}_extractATOM(t){if(!this._source._atoms)return;const e=this._source._atoms;for(let n=0;n<e.length;n++){const i=e[n].het?"HETATM":"ATOM";t.newString(i);const r=e[n].element.name.length>1||e[n].name.length>3?13:14;t.writeString(e[n].serial,11,7),t.writeString(e[n].name,r,16),t.writeString(String.fromCharCode(e[n].location),17,17),t.writeString(e[n].residue._type._name,20,18),t.writeString(e[n].residue._chain._name,22,22),t.writeString(e[n].residue._sequence,26,23),t.writeString(e[n].residue._icode,27,27),t.writeString(e[n].position.x.toFixed(3),38,31),t.writeString(e[n].position.y.toFixed(3),46,39),t.writeString(e[n].position.z.toFixed(3),54,47),t.writeString(e[n].occupancy.toFixed(2),60,55),t.writeString(e[n].temperature.toFixed(2),66,61),t.writeString(e[n].element.name,78,77),e[n].charge&&t.writeString(e[n].charge,79,80)}}_extractCOMPND(t){if(!this._source._molecules)return;const e=this._source._molecules;t.newTag("COMPND",!0);for(let n=0;n<e.length;n++){const i=this._getMoleculeChains(e[n]);t.newString(),t.writeString(`MOL_ID: ${e[n].index};`,11,80),t.newString(),t.writeString(`MOLECULE: ${e[n].name};`,11,80),t.newString(),t.writeString("CHAIN: ",11,18);const r=`${i.join(", ")};`;t.writeEntireString(r,81)}}_extractREMARK(t){this._Remark290(t),this._Remark350(t)}_Remark290(t){if(this._source.symmetry&&0!==this._source.symmetry.length){const e=this._source.symmetry;t.newTag("REMARK",290),t.newString(),t.newString(),t.writeEntireString(this._stringForRemark290),t.writeMatrices(e,"SMTRY"),t.newString(),t.newString(),t.writeString("REMARK: NULL",11,80)}}_Remark350(t){if(!this._source.units)return;const{units:e}=this._source;let n=0;t.newTag("REMARK",350),t.newString(),t.newString(),t.writeEntireString(this._stringForRemark350);const i=e.filter(t=>t instanceof $I);for(let e=0;e<i.length;e++){t.newString(),t.newString(),n++,t.writeString(`BIOMOLECULE: ${n}`,11,80);const r=i[e].chains.join(", ");t.newString(),t.writeString("APPLY THE FOLLOWING TO CHAINS: "),t.writeEntireString(r,69,{tag:"AND CHAINS: ",begin:31,end:42});const{matrices:s}=i[e];t.writeMatrices(s,"BIOMT")}}_getMoleculeChains(t){const e=t.residues.map(function(t){return t._chain._name});return e.filter((t,n)=>e.indexOf(t)===n)}}function ik(t,e,n,i){n[i]=t[e],n[i+1]=t[e+1],n[i+2]=t[e+2]}function rk(t,e,n,i,r){n[i]=t[e],n[i+1]=t[e+1],n[i+2]=t[e+2],n[i+3]=r}nk.formats=["pdb"],nk.SourceClass=PN;const sk=new $P.Vector4;function ok(t,e,n,i,r){sk.set(t[e],t[e+1],t[e+2],r.w),sk.applyMatrix4(r.matrix),n[i]=sk.x,n[i+1]=sk.y,n[i+2]=sk.z}function ak(t,e,n,i,r){if(!((e.array.length-e.start)/e.stride<n||(t.array.length-t.start)/t.stride<n))if(t.stride===e.stride)e.array.set(t.array,e.start);else{let s=e.start,o=t.start;for(let a=0;a<n;++a,s+=e.stride,o+=t.stride)i(t.array,o,e.array,s,r)}}class lk{constructor(){this.positions=null,this.normals=null,this.colors=null,this.indices=null,this.lastPos=0,this.lastNorm=0,this.lastCol=0,this.lastIdx=0}init(t,e){this.positions=new Float32Array(3*t),this.normals=new Float32Array(3*t),this.colors=new Float32Array(4*t),this.indices=new Int32Array(e)}setPositions(t,e,n,i){ak({array:t,start:e,stride:i},{array:this.positions,start:this.lastPos,stride:3},n,ik),this.lastPos+=3*n}setTransformedPositions(t,e,n,i,r){let s=this.lastPos,o=e;const a={matrix:r,w:1};for(let e=0;e<n;++e,o+=i,s+=3)ok(t,o,this.positions,s,a);this.lastPos+=3*n}setNormals(t,e,n,i){ak({array:t,start:e,stride:i},{array:this.normals,start:this.lastNorm,stride:3},n,ik),this.lastNorm+=3*n}setTransformedNormals(t,e,n,i,r){let s=this.lastNorm,o=e;const a={matrix:r,w:0};for(let e=0;e<n;++e,o+=i,s+=3)ok(t,o,this.normals,s,a);this.lastNorm+=3*n}setColors(t,e,n,i){ak({array:t,start:e,stride:i},{array:this.colors,start:this.lastCol,stride:4},n,rk,1),this.lastCol+=4*n}setIndices(t,e,n){this.indices.set(t,this.lastIdx),this.lastIdx+=n}setShiftedIndices(t,e,n){const i=t.map(t=>t+n);this.setIndices(i,0,e)}getVerticesNumber(){return this.lastPos/3}addInstance(t,e){const n=this.getVerticesNumber();this.setShiftedIndices(e.indices,e.indices.length,n);const i=e.itemSize;this.setTransformedPositions(e.positions,0,e.vertsCount,i.position,t),this.setTransformedNormals(e.normals,0,e.vertsCount,i.normal,t),this.setColors(e.colors,0,e.vertsCount,i.color)}}class ck{constructor(){this.positions=null,this.normals=null,this.colors=null,this.indices=null,this.vertsCount=0,this.itemSize=null}init(t,e){const{attributes:n}=t;this.itemSize={position:n.position.itemSize,normal:n.normal.itemSize,color:n.color.itemSize}}}class hk extends ck{init(t,e){super.init(t,e);const{attributes:{position:n,normal:i},index:r}=t;this.vertsCount=n.count,this.positions=n.array,this.normals=i.array,this.colors=new Float32Array(this.vertsCount*this.itemSize.color),this.indices=r.array}setColors(t){let e=0;for(let n=0,i=this.colors.length,r=this.itemSize.color;n<i;n+=r)this.colors[e++]=t.r,this.colors[e++]=t.g,this.colors[e++]=t.b}}class uk extends ck{constructor(){super(),this._cutRawStart=0,this._cutRawEnd=0,this._facesPerSlice=0}init(t,e){super.init(t,e);const{attributes:{position:n},index:i}=t;this.vertsCount=n.count+e.addPerCylinder,this._facesPerSlice=e.addPerCylinder,this.positions=new Float32Array(this.vertsCount*n.itemSize),this.normals=new Float32Array(this.vertsCount*this.itemSize.normal),this.colors=new Float32Array(this.vertsCount*this.itemSize.color),this._extendVertices(t,e),this.indices=new Uint32Array(i.count),this._extendIndices(t,e)}_extendVertices(t,e){const{position:n}=t.attributes,{normal:i}=t.attributes,r=t.getGeoParams();this._cutRawStart=1*r.radialSegments,this._cutRawEnd=this._cutRawStart+e.addPerCylinder;{let t=n.array.slice(0,this._cutRawEnd*n.itemSize);this.positions.set(t,0),t=i.array.slice(0,this._cutRawEnd*i.itemSize),this.normals.set(t,0)}{let t=n.array.slice(this._cutRawStart*n.itemSize,n.array.length);this.positions.set(t,this._cutRawEnd*n.itemSize),t=i.array.slice(this._cutRawStart*i.itemSize,i.array.length),this.normals.set(t,this._cutRawEnd*i.itemSize)}}_extendIndices(t,e){const{index:n}=t,i=6*e.addPerCylinder,r=e.addPerCylinder;let s=n.array.slice(i,n.count);s=s.map(t=>t+r),this.indices.set(n.array,0),this.indices.set(s,i)}_setColorRange(t,e,n,i){const r=i.length;for(let s=t;s<e;s+=r)n.set(i,s)}setColors(t,e){const n=this.itemSize.color,i=this._cutRawEnd*n,r=2*i;if(this._setColorRange(0,i,this.colors,t.toArray()),this._setColorRange(i,r,this.colors,e.toArray()),r<this.colors.length){const i=(this._facesPerSlice+1)*n,s=r+i;this._setColorRange(r,s,this.colors,e.toArray());const o=s+i;this._setColorRange(s,o,this.colors,t.toArray())}}}class dk{constructor(){this._materials=[],this._models=[]}process(t){this._extractModelsAndMaterials(t);const e=this._flattenModels();return{name:t.name,models:e,materials:this._materials}}_extractModelsAndMaterials(t){const e=new $P.Layers;e.set(jN.LAYERS.DEFAULT),e.enable(jN.LAYERS.TRANSPARENT),t.traverse(t=>{t instanceof $P.Mesh&&t.layers.test(e)&&this.checkExportAbility(t)&&("InstancedBufferGeometry"===t.geometry.type?this._collectInstancedGeoInfo(t):this._collectGeoInfo(t))})}_reworkIndices(t){for(let e=2;e<t.length;e+=3)t[e]*=-1,t[e]--}_flattenModels(){let t=0;function e(e){return e+t}const n=[];for(let i=0,r=this._models.length;i<r;i++){const r=this._models[i];let s=[],o=[],a=[],l=[];t=0;for(let n=0;n<r.length;n++){const i=r[n];s.push(i.indices.map(e)),t+=i.getVerticesNumber(),o.push(i.positions),a.push(i.normals),l.push(i.colors)}s=AL.mergeTypedArraysUnsafe(s),this._reworkIndices(s),o=AL.mergeTypedArraysUnsafe(o),a=AL.mergeTypedArraysUnsafe(a),l=AL.mergeTypedArraysUnsafe(l),n.push({indices:s,positions:o,normals:a,colors:l,verticesCount:t})}return n}checkExportAbility(t){return!(0===t.geometry.attributes.position.count||(t instanceof FO?(fL.warn("Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again"),1):t instanceof XO&&(fL.warn("Currently we cannot export Lines mode"),1)))}_collectGeoInfo(t){const{geometry:{attributes:{position:e,color:n,normal:i},index:r},matrix:s}=t,o=new lk,a=e.count;o.init(a,r.count),s.isIdentity()?(o.setPositions(e.array,0,a,e.itemSize),o.setNormals(i.array,0,a,i.itemSize)):(o.setTransformedPositions(e.array,0,a,e.itemSize,s),o.setTransformedNormals(i.array,0,a,i.itemSize,s)),o.setColors(n.array,0,a,n.itemSize),o.setIndices(r.array,0,r.count);const l=this._collectMaterialInfo(t);this._addToPool(o,l)}_collectSpheresInfo(t){const{geometry:{attributes:{position:e,color:n},index:i},matrix:r}=t,s=new lk,o=t.geometry.instanceCount,a=e.count,l=i.count;s.init(o*a,o*l);const c=new hk;c.init(t.geometry);const h=new $P.Matrix4,u=new $P.Matrix4,d=new $P.Color;for(let e=0;e<o;++e){const i=e*n.itemSize;d.fromArray(n.array,i),c.setColors(d),this._getSphereInstanceMatrix(t.geometry,e,h),u.multiplyMatrices(r,h),s.addInstance(u,c)}const p=this._collectMaterialInfo(t);this._addToPool(s,p)}_collectCylindersInfo(t){const{geometry:{attributes:{position:e,color:n,color2:i},index:r},matrix:s}=t,o=new lk,a=t.geometry.instanceCount,l=new hk;l.init(t.geometry);const c=this._gatherCylindersColoringInfo(t.geometry);let h=null;c.needToSplit>0&&(h=new uk,h.init(t.geometry,c));const u=c.addPerCylinder*c.needToSplit,d=e.count,p=r.count;o.init(a*d+u,a*p);const f=new $P.Matrix4,m=new $P.Matrix4,g=new $P.Color,_=new $P.Color;let y={};for(let e=0;e<a;++e){const r=e*n.itemSize;c.is2Colored[e]?(g.fromArray(i.array,r),_.fromArray(n.array,r),h&&(h.setColors(g,_),y=h)):(g.fromArray(n.array,r),l.setColors(g),y=l),this._getCylinderInstanceMatrix(t.geometry,e,f),m.multiplyMatrices(s,f),o.addInstance(m,y)}const v=this._collectMaterialInfo(t);this._addToPool(o,v)}_addToPool(t,e){const n=this._checkExistingMaterial(e);n<0?(this._models.push([t]),this._materials.push(e)):this._models[n].push(t)}_checkExistingMaterial(t){return qP.default.findIndex(this._materials,e=>qP.default.isEqual(e,t))}_gatherCylindersColoringInfo(t){const e=t.instanceCount,n=t.attributes.color.array,i=t.attributes.color2.array,r=t.attributes.color.itemSize,s=new Array(e);let o=0,a=0;for(let t=0;t<e;t++,a+=r){const e=Math.abs(n[a]-i[a])>1e-7||Math.abs(n[a+1]-i[a+1])>1e-7||Math.abs(n[a+2]-i[a+2])>1e-7;s[t]=e,o+=e}return{is2Colored:s,needToSplit:o,addPerCylinder:t.getGeoParams().radialSegments}}_collectInstancedGeoInfo(t){t.geometry instanceof rD?this._collectSpheresInfo(t):t.geometry instanceof MD&&this._collectCylindersInfo(t)}_collectMaterialInfo(t){const{uberOptions:e}=t.material;return{diffuse:e.diffuse.toArray(),opacity:e.opacity,shininess:e.shininess,specular:e.specular.toArray()}}_getCylinderInstanceMatrix(t,e,n){const i=t.attributes.matVector1.array,r=t.attributes.matVector2.array,s=t.attributes.matVector3.array,o=4*e;n.set(i[o],i[o+1],i[o+2],i[o+3],r[o],r[o+1],r[o+2],r[o+3],s[o],s[o+1],s[o+2],s[o+3],0,0,0,1)}_getSphereInstanceMatrix(t,e,n){const{offset:i}=t.attributes,r=e*i.itemSize,s=i.array[r],o=i.array[r+1],a=i.array[r+2],l=i.array[r+3];n.set(l,0,0,s,0,l,0,o,0,0,l,a,0,0,0,1)}}class pk{constructor(){this._resultArray=[],this._info=null}getResult(t){return this._info=t,this._resultArray.push(this._writeHeader()),this._resultArray.push(this._writeDefinitions()),this._resultArray.push(this._writeObjects(t.models,t.materials)),this._resultArray.push(this._writeRelations()),this._resultArray.push(this._writeConnections()),this._info=null,this._resultArray.join("")}_writeHeader(){const t=new Date,e=`Miew FBX Exporter v${this._info.version}`;return`; FBX 6.1.0 project file\n; Created by ${e} Copyright (c) 2015-2024 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: 1003\n  FBXVersion: 6100\n  CreationTimeStamp:  {\n    Version: 1000\n    Year: ${t.getFullYear()}\n    Month: ${t.getMonth()+1}\n    Day: ${t.getDate()}\n    Hour: ${t.getHours()}\n    Minute: ${t.getMinutes()}\n    Second: ${t.getSeconds()}\n    Millisecond: ${t.getMilliseconds()}\n  }\n  Creator: "${e}"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: "${t}"\nCreator: "${e}"\n`}_writeDefinitions(){return'\n; Object definitions\n;------------------------------------------------------------------\n\n\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: "Model" {\n    Count: 1\n  }\n  ObjectType: "Geometry" {\n    Count: 1\n  }\n  ObjectType: "Material" {\n    Count: 1\n  }\n  ObjectType: "Pose" {\n    Count: 1\n  }\n  ObjectType: "GlobalSettings" {\n    Count: 1\n  }\n} \n'}_models(){let t="";const{models:e}=this._info;for(let n=0;n<e.length;++n){const i=e[n],r=i.verticesCount;t+=`\n  Model: "Model::${this._info.name}_${n}", "Mesh" {\n    Version: 232\n    Properties60: {\n      Property: "QuaternionInterpolate", "bool", "",0\n      Property: "Visibility", "Visibility", "A",1\n      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: "RotationOffset", "Vector3D", "",0,0,0\n      Property: "RotationPivot", "Vector3D", "",0,0,0\n      Property: "ScalingOffset", "Vector3D", "",0,0,0\n      Property: "ScalingPivot", "Vector3D", "",0,0,0\n      Property: "TranslationActive", "bool", "",0\n      Property: "TranslationMin", "Vector3D", "",0,0,0\n      Property: "TranslationMax", "Vector3D", "",0,0,0\n      Property: "TranslationMinX", "bool", "",0\n      Property: "TranslationMinY", "bool", "",0\n      Property: "TranslationMinZ", "bool", "",0\n      Property: "TranslationMaxX", "bool", "",0\n      Property: "TranslationMaxY", "bool", "",0\n      Property: "TranslationMaxZ", "bool", "",0\n      Property: "RotationOrder", "enum", "",0\n      Property: "RotationSpaceForLimitOnly", "bool", "",0\n      Property: "AxisLen", "double", "",10\n      Property: "PreRotation", "Vector3D", "",0,0,0\n      Property: "PostRotation", "Vector3D", "",0,0,0\n      Property: "RotationActive", "bool", "",0\n      Property: "RotationMin", "Vector3D", "",0,0,0\n      Property: "RotationMax", "Vector3D", "",0,0,0\n      Property: "RotationMinX", "bool", "",0\n      Property: "RotationMinY", "bool", "",0\n      Property: "RotationMinZ", "bool", "",0\n      Property: "RotationMaxX", "bool", "",0\n      Property: "RotationMaxY", "bool", "",0\n      Property: "RotationMaxZ", "bool", "",0\n      Property: "RotationStiffnessX", "double", "",0\n      Property: "RotationStiffnessY", "double", "",0\n      Property: "RotationStiffnessZ", "double", "",0\n      Property: "MinDampRangeX", "double", "",0\n      Property: "MinDampRangeY", "double", "",0\n      Property: "MinDampRangeZ", "double", "",0\n      Property: "MaxDampRangeX", "double", "",0\n      Property: "MaxDampRangeY", "double", "",0\n      Property: "MaxDampRangeZ", "double", "",0\n      Property: "MinDampStrengthX", "double", "",0\n      Property: "MinDampStrengthY", "double", "",0\n      Property: "MinDampStrengthZ", "double", "",0\n      Property: "MaxDampStrengthX", "double", "",0\n      Property: "MaxDampStrengthY", "double", "",0\n      Property: "MaxDampStrengthZ", "double", "",0\n      Property: "PreferedAngleX", "double", "",0\n      Property: "PreferedAngleY", "double", "",0\n      Property: "PreferedAngleZ", "double", "",0\n      Property: "InheritType", "enum", "",0\n      Property: "ScalingActive", "bool", "",0\n      Property: "ScalingMin", "Vector3D", "",1,1,1\n      Property: "ScalingMax", "Vector3D", "",1,1,1\n      Property: "ScalingMinX", "bool", "",0\n      Property: "ScalingMinY", "bool", "",0\n      Property: "ScalingMinZ", "bool", "",0\n      Property: "ScalingMaxX", "bool", "",0\n      Property: "ScalingMaxY", "bool", "",0\n      Property: "ScalingMaxZ", "bool", "",0\n      Property: "GeometricTranslation", "Vector3D", "",0,0,0\n      Property: "GeometricRotation", "Vector3D", "",0,0,0\n      Property: "GeometricScaling", "Vector3D", "",1,1,1\n      Property: "LookAtProperty", "object", ""\n      Property: "UpVectorProperty", "object", ""\n      Property: "Show", "bool", "",1\n      Property: "NegativePercentShapeSupport", "bool", "",1\n      Property: "DefaultAttributeIndex", "int", "",0\n      Property: "Color", "Color", "A+",0,0,0\n      Property: "Size", "double", "",100\n      Property: "Look", "enum", "",1\n    }\n    ${this._verticesIndices(i.positions,i.indices)}\n    ${this._normalLayer(i.normals)}\n    ${this._colorLayer(i.colors,r)}\n    \n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: ""\n      MappingInformationType: "AllSame"\n      ReferenceInformationType: "Direct"\n      Materials: 0\n    }\n    \n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: "LayerElementNormal"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementColor"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementMaterial"\n        TypedIndex: 0\n      }\n    }\n  }`}return t}_materials(){let t="";const{materials:e}=this._info;for(let n=0;n<e.length;++n){const i=e[n];t+=`\n  Material: "Material::${this._info.name}_${n}_default", "" {\n    Version: 102\n    ShadingModel: "lambert"\n    MultiLayer: 0\n    ${this._materialProperties(i)}\n  }`}return t}_writeObjects(){return`\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  ${this._models()}\n  ${this._materials()}\n  GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: "UpAxis", "int", "",1\n      Property: "UpAxisSign", "int", "",1\n      Property: "FrontAxis", "int", "",2\n      Property: "FrontAxisSign", "int", "",1\n      Property: "CoordAxis", "int", "",0\n      Property: "CoordAxisSign", "int", "",1\n      Property: "UnitScaleFactor", "double", "",1\n    }\n  }\n}\n`}_writeRelations(){let t="";for(let e=0;e<this._info.models.length;++e)t+=`\n  Model: "Model::${this._info.name}_${e}", "Mesh" {\n  }`;let e="";for(let t=0;t<this._info.materials.length;++t)e+=`\n  Material: "Material::${this._info.name}_${t}_default", "" {\n  }`;return`\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  ${t}\n  Model: "Model::Producer Perspective", "Camera" {\n  }\n  Model: "Model::Producer Top", "Camera" {\n  }\n  Model: "Model::Producer Bottom", "Camera" {\n  }\n  Model: "Model::Producer Front", "Camera" {\n  }\n  Model: "Model::Producer Back", "Camera" {\n  }\n  Model: "Model::Producer Right", "Camera" {\n  }\n  Model: "Model::Producer Left", "Camera" {\n  }\n  Model: "Model::Camera Switcher", "CameraSwitcher" {\n  }\n  ${e}\n}`}_writeConnections(){let t="";const{name:e}=this._info;for(let n=0;n<this._info.models.length;++n)t+=`\n  Connect: "OO", "Model::${e}_${n}", "Model::Scene"`;let n="";for(let t=0;t<this._info.materials.length;++t)n+=`\n  Connect: "OO", "Material::${e}_${t}_default", "Model::${e}_${t}"`;return`\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  ${t}\n  ${n}\n}`}_floatArrayToString(t){const e=[];for(let n=0;n<t.length;++n)e[n]=t[n].toFixed(6);return e.join(",")}_colorLayer(t,e){return`\n    LayerElementColor: 0 {\n      Version: 101\n      Name: ""\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct"\n      Colors: ${this._floatArrayToString(t)}\n      ColorIndex: ${[...Array(e).keys()]}\n    }`}_normalLayer(t){return`\n    LayerElementNormal: 0 {\n      Version: 101\n      Name: ""\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct"\n      Normals: ${this._floatArrayToString(t)}\n    }`}_verticesIndices(t,e){return`MultiLayer: 0\n    MultiTake: 1\n    Shading: Y\n    Culling: "CullingOff"\n    Vertices: ${this._floatArrayToString(t)}\n    PolygonVertexIndex: ${e}\n    GeometryVersion: 124`}_materialProperties(t){return`Properties60:  {\n      Property: "ShadingModel", "KString", "", "Lambert"\n      Property: "MultiLayer", "bool", "",0\n      Property: "EmissiveColor", "ColorRGB", "",0,0,0\n      Property: "EmissiveFactor", "double", "",0.0000\n      Property: "AmbientColor", "ColorRGB", "",1,1,1\n      Property: "AmbientFactor", "double", "",0.0000\n      Property: "DiffuseColor", "ColorRGB", "",${t.diffuse}\n      Property: "DiffuseFactor", "double", "",1.0000\n      Property: "Bump", "Vector3D", "",0,0,0\n      Property: "TransparentColor", "ColorRGB", "",1,1,1\n      Property: "TransparencyFactor", "double", "",0.0000\n      Property: "SpecularColor", "ColorRGB", "",${t.specular}\n      Property: "SpecularFactor", "double", "",1.0000\n      Property: "ShininessExponent", "double", "",${t.shininess}\n      Property: "ReflectionColor", "ColorRGB", "",0,0,0\n      Property: "ReflectionFactor", "double", "",1\n      Property: "Ambient", "ColorRGB", "",1,1,1\n      Property: "Diffuse", "ColorRGB", "",${t.diffuse}\n      Property: "Specular", "ColorRGB", "",${t.specular}\n      Property: "Shininess", "double", "",${t.shininess}\n      Property: "Opacity", "double", "",${t.opacity}\n      Property: "Reflectivity", "double", "",0\n    }`}}class fk extends tk{constructor(t,e){super(t,e),this._data=t,this._version=e.miewVersion||"0.0-UNSPECIFIED",this._extractor=new dk}exportSync(){const t=new pk;if(!this._source)return this._result;const e=this._extractor.process(this._data);return e.version=this._version,this._result=t.getResult(e),this._result}}fk.formats=["fbx"],fk.SourceClass=LB;const mk={loaders:KB,parsers:QV,exporters:new class extends JN{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],["formats"])}find(t){let e=[];return t.format&&(e=this._dict.formats[t.format.toLowerCase()]||[]),[...e]}}([nk,fk])},gk=new $P.Color,_k=class{constructor(){this._width=0,this._height=0,this._widthHalf=0,this._heightHalf=0,this._vector=new $P.Vector3,this._viewMatrix=new $P.Matrix4,this._projectionMatrix=new $P.Matrix4,this._domElement=document.createElement("div"),this._domElement.style.overflow="hidden",this._domElement.style.position="absolute",this._domElement.style.top="0",this._domElement.style.zIndex="0",this._domElement.style.pointerEvents="none"}getElement(){return this._domElement}reset(){const t=this.getElement();for(;t.firstChild;)t.removeChild(t.firstChild)}setSize(t,e){this._width=t,this._height=e,this._widthHalf=this._width/2,this._heightHalf=this._height/2,this._domElement.style.width=`${t}px`,this._domElement.style.height=`${e}px`}_renderObject(t,e,n){function i(t,e,n){return gk.setHex(t),gk.lerp(e,n),`#${gk.getHexString()}`}function r(t){return gk.setHex(t),`#${gk.getHexString()}`}if(t instanceof UN){if(this._vector.setFromMatrixPosition(t.matrixWorld),void 0!==t.userData&&void 0!==t.userData.offset){const e=new $P.Vector3(t.userData.offset.x,t.userData.offset.y,0);this._vector.add(e.multiplyScalar(t.matrixWorld.getMaxScaleOnAxis()))}this._vector.applyMatrix4(this._viewMatrix);const s=this._vector.z>-e.near?"hidden":"visible",o=1e4*(e.far- -this._vector.z)/(e.far-e.near),a=t.getElement();if(void 0===n.fog)a.style.color=r(t.userData.color),"transparent"!==t.userData.background&&(a.style.background=r(t.userData.background));else{const e=$P.MathUtils.smoothstep(-this._vector.z,n.fog.near,n.fog.far);a.style.color=i(t.userData.color,n.fog.color,e),"transparent"!==t.userData.background&&(a.style.background=i(t.userData.background,n.fog.color,e))}this._vector.applyMatrix4(this._projectionMatrix);const l=`${t.userData!=={}?t.userData.translation:"translate(-50%, -50%) "}translate(${this._vector.x*this._widthHalf+this._widthHalf}px,${-this._vector.y*this._heightHalf+this._heightHalf}px)`;a.style.visibility=s,a.style.WebkitTransform=l,a.style.MozTransform=l,a.style.oTransform=l,a.style.transform=l,a.style.zIndex=Number(o).toFixed(0),a.parentNode!==this._domElement&&this._domElement.appendChild(a)}for(let i=0,r=t.children.length;i<r;i++)this._renderObject(t.children[i],e,n)}render(t,e){t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),e.matrixWorldInverse.copy(e.matrixWorld).invert(),this._viewMatrix.copy(e.matrixWorldInverse),this._projectionMatrix.copy(e.projectionMatrix),this._renderObject(t,e,t)}};function yk(){try{if(void 0!==window.top.location.href)return window.top}catch(t){}return window}const vk=-1,xk=new $P.Quaternion,Sk=new $P.Matrix4;function bk(t,e,n,i){this.objects=t,[this.object]=t,this.camera=e,this.pivot=n,this.axis=new $P.Vector3(0,0,1),this.options=i,this.lastRotation={axis:new $P.Vector3,angle:0}}function Mk(t,e,n,i,r){hL.call(this);const s=this;this.object=t,this.objectPivot=e,this.camera=n,this.domElement=void 0!==i?i:document,this.getAltObj=r,this.enabled=!0,this.hotkeysEnabled=!0,this.screen={left:0,top:0,width:0,height:0},this.options={rotateFactor:Math.PI,axisRotateFactor:4*Math.PI,intertia:!0,dynamicDampingFactor:.1,intertiaThreshold:.001},this._state=vk,this._mousePrevPos=new $P.Vector2,this._mouseCurPos=new $P.Vector2,this._mainObj=new bk([this.object],this.camera,new $P.Vector3(0,0,0),this.options),this._altObj=new bk([this.object],this.camera,new $P.Vector3(0,0,0),this.options),this._affectedObj=this._mainObj,this._isAltObjFreeRotationAllowed=!0,this._isTranslationAllowed=!0,this._isKeysTranslatingObj=!1,this._pressedKeys=[],this._clock=new rL,this._clock.start(),this._lastUpdateTime=this._clock.getElapsedTime(),this._listeners=[{obj:s.domElement,type:"mousedown",handler(t){s.mousedown(t)}},{obj:s.domElement,type:"mouseup",handler(t){s.mouseup(t)}},{obj:s.domElement,type:"mousemove",handler(t){s.mousemove(t)}},{obj:s.domElement,type:"mousewheel",handler(t){s.mousewheel(t)}},{obj:s.domElement,type:"DOMMouseScroll",handler(t){s.mousewheel(t)}},{obj:s.domElement,type:"mouseout",handler(t){s.mouseup(t)}},{obj:s.domElement,type:"touchstart",handler(t){s.touchstartend(t)}},{obj:s.domElement,type:"touchend",handler(t){s.touchstartend(t)}},{obj:s.domElement,type:"touchmove",handler(t){s.touchmove(t)}},{obj:s.getKeyBindObject(),type:"keydown",handler(t){s.keydownup(t)}},{obj:s.getKeyBindObject(),type:"keyup",handler(t){s.keydownup(t)}},{obj:window,type:"resize",handler(){s.handleResize()}},{obj:window,type:"blur",handler(){s.resetKeys()}},{obj:s.domElement,type:"contextmenu",handler(t){s.contextmenu(t)}}];for(let t=0;t<this._listeners.length;t++){const e=this._listeners[t];e.obj.addEventListener(e.type,e.handler)}this.handleResize(),this.resetKeys(),this.update()}bk.prototype._rotate=function(){const t=new $P.Vector3,e=new $P.Quaternion,n=new $P.Vector3,i=new $P.Matrix4;return function(r){const s=0===this.pivot.x&&0===this.pivot.y&&0===this.pivot.z;if(i.copy(this.object.matrix),s?i.multiply(Sk.makeRotationFromQuaternion(r)):(i.multiply(Sk.makeTranslation(this.pivot.x,this.pivot.y,this.pivot.z)),i.multiply(Sk.makeRotationFromQuaternion(r)),i.multiply(Sk.makeTranslation(-this.pivot.x,-this.pivot.y,-this.pivot.z))),i.decompose(t,e,n),!s)for(let e=0;e<this.objects.length;++e)this.objects[e].position.copy(t);for(let t=0;t<this.objects.length;++t)this.objects[t].quaternion.copy(e),this.objects[t].updateMatrix()}}(),bk.prototype.setObjects=function(t){this.objects=t,[this.object]=t},bk.prototype.rotate=function(){const t={axis:new $P.Vector3,angle:0};return function(e,n,i,r){this.mouse2rotation(t,n,i,r),e.setFromAxisAngle(t.axis,t.angle),t.angle&&this._rotate(e),this.lastRotation=t}}(),bk.prototype.translate=function(){const t=new $P.Vector3,e=new $P.Vector3;return function(n){t.set(n.x/this.camera.projectionMatrix.elements[0],n.y/this.camera.projectionMatrix.elements[5],0);let i=t.length();t.normalize(),t.transformDirection(Sk.copy(this.object.matrixWorld).invert()),e.copy(this.pivot),this.object.localToWorld(e),i*=Math.abs(e.z-this.camera.position.z),i/=this.object.matrixWorld.getMaxScaleOnAxis();for(let e=0;e<this.objects.length;++e)this.objects[e].translateOnAxis(t,i)}}(),bk.prototype.update=function(){const t=new $P.Vector3;return function(e,n){if(0!==LL.now.autoRotation)return LL.now.autoRotationAxisFixed||0===this.lastRotation.axis.length()?t.set(0,1,0).transformDirection(Sk.copy(this.object.matrixWorld).invert()):t.copy(this.lastRotation.axis),this._rotate(xk.setFromAxisAngle(t,LL.now.autoRotation*e)),!0;if(this.options.intertia&&this.lastRotation.angle){const t=this.lastRotation.angle*(1-this.options.dynamicDampingFactor)**(40*n);if(!(Math.abs(t)<=this.options.intertiaThreshold))return this._rotate(xk.setFromAxisAngle(this.lastRotation.axis,t)),!0;this.lastRotation.angle=0}return!1}}(),bk.prototype.stop=function(){this.lastRotation.angle=0},bk.prototype.mouse2rotation=function(){const t=new $P.Vector3,e=new $P.Vector3,n=new $P.Vector3,i=new $P.Vector3,r=new $P.Vector3,s=new $P.Vector3,o=new $P.Vector2;return function(a,l,c,h){if(h)a.axis.copy(this.axis),a.angle=this.options.axisRotateFactor*(c.y-l.y);else{o.subVectors(c,l);const h=o.length();if(0===h)return;t.copy(this.pivot),this.object.localToWorld(t),e.subVectors(this.camera.position,t),n.copy(e).normalize(),i.copy(this.camera.up).normalize(),r.crossVectors(i,n).normalize(),i.setLength(o.y),r.setLength(o.x),s.copy(i.add(r)),a.axis.crossVectors(s,e),a.angle=-h*this.options.rotateFactor}a.axis.transformDirection(Sk.copy(this.object.matrixWorld).invert()),a.angle<0&&(a.axis.negate(),a.angle=-a.angle)}}(),Mk.prototype=Object.create(hL.prototype),Mk.prototype.constructor=Mk,Mk.prototype.resetKeys=function(){this._pressedKeys[37]=!1,this._pressedKeys[38]=!1,this._pressedKeys[39]=!1,this._pressedKeys[40]=!1},Mk.prototype.contextmenu=function(t){t.stopPropagation(),t.preventDefault()},Mk.prototype.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{const t=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=t.left+window.pageXOffset-e.clientLeft,this.screen.top=t.top+window.pageYOffset-e.clientTop,this.screen.width=t.width,this.screen.height=t.height}},Mk.prototype.enable=function(t){this.enabled=t},Mk.prototype.enableHotkeys=function(t){this.hotkeysEnabled=t},Mk.prototype.allowTranslation=function(t){this._isTranslationAllowed=t},Mk.prototype.allowAltObjFreeRotation=function(t){this._isAltObjFreeRotationAllowed=t},Mk.prototype.keysTranslateObj=function(t){this._isKeysTranslatingObj=t},Mk.prototype.isEditingAltObj=function(){return(0===this._state||1===this._state)&&this._affectedObj===this._altObj},Mk.prototype.convertMouseToOnCircle=function(t,e,n){const i=Math.min(this.screen.width,this.screen.height);0!==i?t.set((e-.5*this.screen.width-this.screen.left)/i,(.5*this.screen.height+this.screen.top-n)/i):t.set(0,0)},Mk.prototype.convertMouseToViewport=function(t,e,n){0!==this.screen.width&&0!==this.screen.height?t.set(2*(e-.5*this.screen.width-this.screen.left)/this.screen.width,2*(.5*this.screen.height+this.screen.top-n)/this.screen.height):t.set(0,0)},Mk.prototype.stop=function(){this._mainObj.stop(),this._altObj.stop()},Mk.prototype.rotateByMouse=function(){const t=new $P.Quaternion;return function(e){this._affectedObj.rotate(t,this._mousePrevPos,this._mouseCurPos,e),this.dispatchEvent({type:"change",action:"rotate",quaternion:t})}}(),Mk.prototype.rotate=function(t){this.object.quaternion.multiply(t),this.dispatchEvent({type:"change",action:"rotate",quaternion:t})},Mk.prototype.getOrientation=function(){return this.object.quaternion},Mk.prototype.setOrientation=function(t){this.object.quaternion.copy(t)},Mk.prototype.translate=function(){const t=new $P.Vector2;return function(){t.subVectors(this._mouseCurPos,this._mousePrevPos),this._affectedObj.translate(t),this.dispatchEvent({type:"change",action:"translate"})}}(),Mk.prototype.getScale=function(){return this.object.scale.x},Mk.prototype.setScale=function(t){this.object.scale.set(t,t,t)},Mk.prototype.scale=function(t){t<=0||(this.setScale(this.object.scale.x*t),this.dispatchEvent({type:"change",action:"zoom",factor:t}))},Mk.prototype.update=function(){const t=new $P.Vector2;return function(){const e=this._clock.getElapsedTime(),n=e-this._lastUpdateTime;if(this._state===vk){const t=e-this._lastMouseMoveTime;(this._mainObj.update(n,t)||this._altObj.update(n,t))&&this.dispatchEvent({type:"change",action:"auto"})}if(this._isKeysTranslatingObj){const e=Number(this._pressedKeys[39])-Number(this._pressedKeys[37]),i=Number(this._pressedKeys[38])-Number(this._pressedKeys[40]);if(0!==e||0!==i){const r=n,s=this.getAltObj();s.objects.length>0&&(this._altObj.setObjects(s.objects),this._altObj.pivot=s.pivot,"axis"in s?this._altObj.axis=s.axis.clone():this._altObj.axis.set(0,0,1),t.set(r*e,r*i),this._altObj.translate(t),this.dispatchEvent({type:"change",action:"translate"}))}}this._lastUpdateTime=e}}(),Mk.prototype.reset=function(){this._state=vk,this.object.quaternion.copy(xk.set(0,0,0,1))},Mk.prototype.mousedown=function(t){if(!1!==this.enabled&&this._state===vk){if(t.preventDefault(),t.stopPropagation(),this._state===vk)if(0===t.button){this._affectedObj.stop();let e=!1;if(t.altKey){const t=this.getAltObj();e=t.objects.length>0,e&&(this._altObj.setObjects(t.objects),this._altObj.pivot=t.pivot,"axis"in t?this._altObj.axis=t.axis.clone():this._altObj.axis.set(0,0,1))}this._affectedObj=e?this._altObj:this._mainObj,this._state=e&&t.ctrlKey&&this._isTranslationAllowed?1:0}else 2===t.button&&(this._state=3);0===this._state&&(this.convertMouseToOnCircle(this._mouseCurPos,t.pageX,t.pageY),this._mousePrevPos.copy(this._mouseCurPos)),1!==this._state&&3!==this._state||(this.convertMouseToViewport(this._mouseCurPos,t.pageX,t.pageY),this._mousePrevPos.copy(this._mouseCurPos))}},Mk.prototype.mousemove=function(t){if(!1!==this.enabled&&this._state!==vk)switch(t.preventDefault(),t.stopPropagation(),this._state){case 0:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToOnCircle(this._mouseCurPos,t.pageX,t.pageY),this.rotateByMouse(t.altKey&&!this._isAltObjFreeRotationAllowed||t.shiftKey),this._lastMouseMoveTime=this._clock.getElapsedTime();break;case 1:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToViewport(this._mouseCurPos,t.pageX,t.pageY),this.translate();break;case 3:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToViewport(this._mouseCurPos,t.pageX,t.pageY),this.translatePivotByMouse()}},Mk.prototype.mousewheel=function(t){if(!1===this.enabled||!LL.now.zooming||this._state!==vk||t.shiftKey)return;t.preventDefault();let e=0;t.wheelDelta?e=t.wheelDelta/40:t.detail&&(e=-t.detail/3);let n=1+.05*e;n=Math.max(n,.01),this.scale(n)},Mk.prototype.mouseup=function(t){!1!==this.enabled&&this._state!==vk&&(t.preventDefault(),t.stopPropagation(),this._state=vk,this._clock.getElapsedTime()-this._lastMouseMoveTime>.1&&this._affectedObj.stop())},Mk.prototype.touchstartend=function(t){if(!1!==this.enabled)switch(t.preventDefault(),t.stopPropagation(),t.touches.length){case 1:this._state=0,this.convertMouseToOnCircle(this._mouseCurPos,t.touches[0].pageX,t.touches[0].pageY),this._mousePrevPos.copy(this._mouseCurPos);break;case 2:{this._mainObj.stop(),this._altObj.stop(),this._state=2;const e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY;this._touchDistanceCur=this._touchDistanceStart=Math.sqrt(e*e+n*n),this._scaleStart=this.object.scale.x;break}default:this._state=vk}},Mk.prototype.touchmove=function(t){if(!1!==this.enabled&&this._state!==vk)switch(t.preventDefault(),t.stopPropagation(),this._state){case 0:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToOnCircle(this._mouseCurPos,t.touches[0].pageX,t.touches[0].pageY),this.rotateByMouse(!1),this._lastMouseMoveTime=this._clock.getElapsedTime();break;case 2:if(LL.now.zooming){const e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY;this._touchDistanceCur=Math.sqrt(e*e+n*n);const i=this._scaleStart*this._touchDistanceCur/this._touchDistanceStart/this.object.scale.x;this.scale(i)}}},Mk.prototype.keydownup=function(t){if(!1!==this.enabled&&!1!==this.hotkeysEnabled)switch(t.keyCode){case 37:case 38:case 39:case 40:this._pressedKeys[t.keyCode]="keydown"===t.type,t.preventDefault(),t.stopPropagation()}},Mk.prototype.getKeyBindObject=function(){return yk()},Mk.prototype.dispose=function(){for(let t=0;t<this._listeners.length;t++){const e=this._listeners[t];e.obj.removeEventListener(e.type,e.handler)}},Mk.prototype.translatePivotByMouse=function(){const t=new $P.Vector2;return function(){t.subVectors(this._mouseCurPos,this._mousePrevPos),this.translatePivotInWorld(LL.now.translationSpeed*t.x,LL.now.translationSpeed*t.y,0)}}(),Mk.prototype.translatePivotInWorld=function(t,e,n){const i=this.objectPivot.position;i.applyMatrix4(this.object.matrixWorld),i.setX(i.x+t),i.setY(i.y+e),i.setZ(i.z+n),i.applyMatrix4(Sk.copy(this.object.matrixWorld).invert()),this.dispatchEvent({type:"change",action:"translatePivot"})},Mk.prototype.translatePivot=function(t,e,n){const i=this.objectPivot.position;i.setX(i.x+t),i.setY(i.y+e),i.setZ(i.z+n),this.dispatchEvent({type:"change",action:"translatePivot"})},Mk.prototype.setPivot=function(t){this.objectPivot.position.copy(t),this.dispatchEvent({type:"change",action:"translatePivot"})};const wk=Mk;function Ek(t,e,n){hL.call(this);const i=this;this.gfxObj=t,this.camera=e,this.domElement=void 0!==n?n:document,this.screen={left:0,top:0,width:0,height:0},this._lastMousePos=new $P.Vector2(0,0),this._mouseTotalDist=0,this._lastClickBeginTime=-1e3,this._lastClickPos=new $P.Vector2(0,0),this._clickBeginTime=0,this._clock=new rL,this._clock.start(),this._listeners=[{obj:i.domElement,type:"mousedown",handler(t){i.mousedown(t)}},{obj:i.domElement,type:"mouseup",handler(t){i.mouseup(t)}},{obj:i.domElement,type:"mousemove",handler(t){i.mousemove(t)}},{obj:i.domElement,type:"touchstart",handler(t){i.touchstart(t)}},{obj:i.domElement,type:"touchend",handler(t){i.touchend(t)}},{obj:window,type:"resize",handler(){i.handleResize()}}];for(let t=0;t<this._listeners.length;t++){const e=this._listeners[t];e.obj.addEventListener(e.type,e.handler)}this.handleResize()}Ek.prototype=Object.create(hL.prototype),Ek.prototype.constructor=Ek,Ek.prototype.reset=function(){this.picked={},this.dispatchEvent({type:"newpick",obj:{}})},Ek.prototype.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{const t=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=t.left+window.pageXOffset-e.clientLeft,this.screen.top=t.top+window.pageYOffset-e.clientTop,this.screen.width=t.width,this.screen.height=t.height}},Ek.prototype.pickObject=function(t){if(!this.gfxObj)return this.picked={},void this.dispatchEvent({type:"newpick",obj:{}});const{gfxObj:e}=this,n=new $P.Raycaster;n.ray.origin.setFromMatrixPosition(this.camera.matrixWorld),n.ray.direction.set(t.x,t.y,.5).unproject(this.camera).sub(n.ray.origin).normalize();const i=LL.now.draft.clipPlane&&this.clipPlaneValue?this.clipPlaneValue:1/0,r=LL.now.fog&&this.fogFarValue?this.fogFarValue:1/0,s=n.intersectVisibleObject(e,this.camera,i,r);if(!s)return this.picked={},void this.dispatchEvent({type:"newpick",obj:{}});let o={};if(s.residue||s.atom){const t=s.residue||s.atom.residue;"chain"===LL.now.pick?o={chain:t.getChain()}:"molecule"===LL.now.pick?o={molecule:t.getMolecule()}:s.residue||"residue"===LL.now.pick?o={residue:t}:s.atom&&(o={atom:s.atom})}this.picked=o,this.dispatchEvent({type:"newpick",obj:o})},Ek.prototype.getMouseInViewport=function(t,e){return new $P.Vector2((t-this.screen.left)/this.screen.width*2-1,-(e-this.screen.top)/this.screen.height*2+1)},Ek.prototype.mousedown=function(t){t.preventDefault(),t.stopPropagation(),0===t.button&&(this._lastMousePos=this.getMouseInViewport(t.pageX,t.pageY),this._mouseTotalDist=0,this._clickBeginTime=this._clock.getElapsedTime())},Ek.prototype.mousemove=function(t){t.preventDefault(),t.stopPropagation();const e=this.getMouseInViewport(t.pageX,t.pageY);this._mouseTotalDist+=e.sub(this._lastMousePos).length()},Ek.prototype.mouseup=function(t){const e=this;if(t.preventDefault(),t.stopPropagation(),0===t.button&&this._mouseTotalDist<.01){const n=this._clock.getElapsedTime(),i=this.getMouseInViewport(t.pageX,t.pageY);if(n-this._lastClickBeginTime<.7&&(new $P.Vector2).subVectors(i,this._lastClickPos).length()<.01)return this.dispatchEvent({type:"dblclick",obj:this.picked}),this._lastClickPos=i,void(this._lastClickBeginTime=-1e3);setTimeout(()=>{e.pickObject(i)},0),this._lastClickPos=i,this._lastClickBeginTime=this._clickBeginTime}},Ek.prototype.touchstart=function(t){t.preventDefault(),t.stopPropagation(),1===t.touches.length&&(this._lastTouchdownPos=this.getMouseInViewport(t.touches[0].pageX,t.touches[0].pageY))},Ek.prototype.touchend=function(t){const e=this;t.preventDefault(),t.stopPropagation(),0===t.touches.length&&1===t.changedTouches.length&&this.getMouseInViewport(t.changedTouches[0].pageX,t.changedTouches[0].pageY).sub(this._lastTouchdownPos).length()<.01&&setTimeout(()=>{e.pickObject(e._lastTouchdownPos)},0)},Ek.prototype.dispose=function(){for(let t=0;t<this._listeners.length;t++){const e=this._listeners[t];e.obj.removeEventListener(e.type,e.handler)}};const Tk=Ek,Ak=class{constructor(t,e){this._target=t,this._targetCamera=e,this._camera=new $P.PerspectiveCamera(e.fov,e.aspect,1,100),this._object=new $P.AxesHelper(1),this._scene=new $P.Scene,this._scene.add(this._object),this._full=new $P.Vector2,this._update()}_update(){const{fov:t}=this._targetCamera,e=this._camera;e.aspect=this._targetCamera.aspect,e.setMinimalFov(t),e.setDistanceToFit(1,t),e.updateProjectionMatrix(),this._object.quaternion.copy(this._target.quaternion)}render(t){this._update(),t.getSize(this._full);const e=.25*this._full.width,n=.25*this._full.height,{autoClear:i}=t;t.autoClear=!1,t.setViewport(0,0,e,n),t.clear(!1,!0,!1),t.render(this._scene,this._camera),t.setViewport(0,0,this._full.width,this._full.height),t.autoClear=i}},Ck=["helix","strand"],Rk=["fs","ps","ns","us"];function Pk(t,e){const n=e._residues,i=n.length,r=new Uint8Array(i),s=e._atoms;for(let e=0,n=t.length;e<n;++e)r[s[e].residue._index]=t[e];const o=[];let a=0;for(;a<i;){if(0!==r[a]){const t=a,e=r[a];for(;a<i-1&&r[a+1]===e&&n[a].isConnected(n[a+1]);)++a;o.push({start:t,end:a,type:Ck[e-1]})}++a}return o}function Lk(t){return t>=524288?t-1048576:t}class Ik{constructor(t,e,n){this._complex=t,this._secondary=null,this.isLoading=!1,this._framesRange={start:0,end:-1},this.frameIsReady=!1,this._buffer=null,this._frameRequest=null,this._callbacks=n,"function"==typeof e?(this._framesRequestLength=1,this._downloadDataFn=e):this.parseBinaryData(e,!0),this.reset(),this.setFrame(0)}_prepareBuffer(t,e){if(null==t&&(t=0),null==e&&(e=t+this._framesRequestLength),void 0!==this._framesCount&&(e=Math.min(this._framesCount-1,e)),this._downloadDataFn){const n=this,i=function(i){if(n.isLoading=!1,n._callbacks&&"function"==typeof n._callbacks.onLoadStatusChanged&&n._callbacks.onLoadStatusChanged(),n._buffer={data:i,state:"ready",start:t,end:e},null!==n._frameRequest){const t=n._frameRequest;n._frameRequest=null,n.setFrame(t)}},r=function(){n.isLoading=!1,n._callbacks&&"function"==typeof n._callbacks.onError&&n._callbacks.onError("Streaming failed")};this._buffer||(this._buffer={}),this._buffer.state="downloading",this.isLoading=!0,n._callbacks&&"function"==typeof n._callbacks.onLoadStatusChanged&&n._callbacks.onLoadStatusChanged(),this._downloadDataFn({start:t,end:e+1},i,r)}}_parseBuffer(){if(this._buffer&&"ready"===this._buffer.state){this._framesRange={start:this._buffer.start,end:this._buffer.end},this.parseBinaryData(this._buffer.data,!1);let t=(this._buffer.end+1)%this._framesCount;if(t>=this._framesCount&&(t=0),this._buffer={state:"none"},this._prepareBuffer(t,t+this._framesRequestLength),null!==this._frameRequest){const t=this._frameRequest;this._frameRequest=null,this.setFrame(t)}}}parseBinaryData(t){const e=new DataView(t);let n=0;const i=e.getUint32(n,!0);n+=4;const r=e.getUint32(n,!0);this._framesCount=r,this._framesRange.end=this._framesRange.end>0?Math.min(this._framesRange.end,r-1):r-1,n+=4,this._atomsCount=i,this._framesRequestLength=Math.ceil(1048576/(8*i));const s=this._framesRange.end-this._framesRange.start+1;if(i!==this._complex._atoms.length||t.byteLength!==12+s*i*8)throw new Error;const o=this._complex;let a=e.getUint32(n,!0),l=0;for(;a>1e3&&l<Rk.length-1;)a/=1e3,++l;this._timeStep=`${a.toString()} ${Rk[l]}`,n+=4;const c=[],h=new Float32Array(s*i*3);let u=0;const d=new Int8Array(i);for(let t=0;t<s;++t){for(let t=0;t<i;++t){const i=e.getUint32(n,!0);n+=4;const r=e.getUint32(n,!0);n+=4;const s=(4026531840&r)>>>28,o=Lk((268435200&r)>>>8|0),a=Lk((255&r)<<12|(4293918720&i)>>>20),l=Lk(1048575&i);d[t]=0,s>0&&s<4?d[t]=1:4===s&&(d[t]=2),h[u++]=o/100,h[u++]=a/100,h[u++]=l/100}c.push(Pk(d,o))}this._secondaryData=c,this._data=h}nextFrame(){this.setFrame((this._currFrame+1)%this._framesCount)}needsColorUpdate(t){return t instanceof KF}getAtomColor(t,e){return t.getResidueColor(this._residues[e.residue._index],this._complex)}getResidueColor(t,e){return t.getResidueColor(this._residues[e._index],this._complex)}_updateSecondary(){let t;const e=this._residues;let n=e.length;for(t=0;t<n;++t)e[t]._secondary=null;const i=this._secondaryData[this._currFrame-this._framesRange.start];for(t=0,n=i.length;t<n;++t){const n=i[t],{start:r,end:s}=n,o={_start:e[r],_end:e[s],type:n.type,generic:n.generic};for(let t=r;t<=s;++t)e[t]._secondary=o}}reset(){const t=this._complex._residues,e=t.length;this._residues=new Array(e);const n=this._residues,i=function(){return this._secondary};for(let r=0;r<e;++r)n[r]={_type:t[r]._type,_isValid:t[r]._isValid,_controlPoint:null,_wingVector:null,_secondary:null,getSecondary:i}}setFrame(t){if(this.frameIsReady=!1,t>=this._framesRange.start&&t<=this._framesRange.end)this._currFrame=t,this._cachedResidues=!1,this._updateSecondary(),this.frameIsReady=!0;else if(this._frameRequest=t,this._buffer){const e=this;switch(this._buffer.state){case"none":this._prepareBuffer(t);break;case"ready":e._parseBuffer()}}else this._prepareBuffer(t)}disableEvents(){this._callbacks=null}static _vec=(()=>new $P.Vector3)();getAtomPos(t){const e=Ik._vec,n=this,i=n._data,r=3*(n._atomsCount*(n._currFrame-n._framesRange.start)+t);return e.set(i[r],i[r+1],i[r+2]),e}getResidues(){return this._cachedResidues||this._complex.updateToFrame(this),this._residues}}const Nk=Ik;class Dk{constructor(t,e){if(this.constructor===Dk)throw new Error("Can not instantiate abstract class!");this.params=t,this.opts=qP.default.merge(AL.deriveDeep(LL.now.objects[this.type],!0),e),this.needsRebuild=!1,this._mesh=null,this.id=null}identify(){const t={type:this.type,params:this.params},e=AL.objectsDiff(this.opts,LL.now.modes[this.id]);return qP.default.isEmpty(e)||(t.opts=e),t}toString(){return`o=${this.type},${this.params.join(",")}`+AL.compareOptionsWithDefaults(this.opts,LL.defaults.objects[this.type])}getGeometry(){return this._mesh}destroy(){this._mesh&&jN.destroyObject(this._mesh)}}Dk.prototype.type="__";const Ok=Dk;class Uk extends Ok{constructor(t,e){if(super(t,e),t.length<2)throw new Error("Wrong number of argumets on line object creation!");[this._id1,this._id2]=t}_getAtomFromName(t,e){const n=t.getAtomByFullname(e);if(!n)throw new Error(e+" - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')");return n}build(t){const e=new $P.BufferGeometry;this._atom1=this._getAtomFromName(t,this._id1),this._atom2=this._getAtomFromName(t,this._id2);const n=this._atom1.position,i=this._atom2.position,r=new Float32Array([n.x,n.y,n.z,i.x,i.y,i.z]);e.setAttribute("position",new $P.BufferAttribute(r,3)),e.computeBoundingBox(),this._line=new qO.Line(e,new DO({lights:!1,overrideColor:!0,dashedLine:!0,fogTransparent:LL.now.bg.transparent})),this._line.computeLineDistances(),this._line.material.setUberOptions({fixedColor:new $P.Color(this.opts.color),dashedLineSize:this.opts.dashSize,dashedLinePeriod:this.opts.dashSize+this.opts.gapSize}),this._line.material.updateUniforms(),this._line.raycast=function(t,e){},this._mesh=this._line;const s=t.getTransforms();s.length>0&&(this._mesh=new $P.Group,this._mesh.add(this._line),SB.applyTransformsToMeshes(this._mesh,s))}updateToFrame(t){if(!this._atom1||!this._atom2||!this._line)return;const e=this._line.geometry;e.vertices[0].copy(t.getAtomPos(this._atom1.index)),e.vertices[1].copy(t.getAtomPos(this._atom2.index)),this._line.computeLineDistances(),e.computeBoundingSphere(),e.verticesNeedUpdate=!0}}Uk.prototype.constructor=Uk,Uk.prototype.type="line";const Fk=Uk;class Bk extends $P.RawShaderMaterial{constructor(t){super(t);const e={uniforms:{srcTex:{type:"t",value:null},srcDepthTex:{type:"t",value:null},srcTexSize:{type:"v2",value:new $P.Vector2(512,512)},color:{type:"v3",value:null},threshold:{type:"f",value:null},opacity:{type:"f",value:1},thickness:{type:"v2",value:new $P.Vector2(1,1)}},vertexShader:zN,fragmentShader:"precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n",transparent:!0,depthTest:!1,depthWrite:!1};this.setValues(e)}copy(t){super.copy(t),this.depth=t.depth}setValues(t){if(void 0===t)return;super.setValues(t);const e={};this.depth&&(e.DEPTH_OUTLINE=1),this.defines=e}}Bk.prototype.depth=!1;const zk=Bk;class Vk extends $P.RawShaderMaterial{constructor(t){super(t),this.setValues.call(this,{uniforms:{srcTex:{type:"t",value:null},srcTexelSize:{type:"v2",value:new $P.Vector2(1/512,1/512)},bgColor:{type:"c",value:new $P.Color(16777215)}},vertexShader:zN,fragmentShader:"precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n",transparent:!1,depthTest:!1,depthWrite:!1}),this.setValues(t)}copy(t){super.copy(t),this.depth=t.depth}setValues(t){if(void 0===t)return;super.setValues(t);const e={};this.bgTransparent&&(e.BG_TRANSPARENT=1),this.defines=e}}Vk.prototype.bgTransparent=!1;const kk=Vk,Gk=[new $P.Vector3(.295184,.077723,.068429),new $P.Vector3(-.271976,-.365221,.838363),new $P.Vector3(.547713,.467576,.488515),new $P.Vector3(.662808,-.031733,.584758),new $P.Vector3(-.025717,.218955,.657094),new $P.Vector3(-.310153,-.365223,.370701),new $P.Vector3(-.101407,-.006313,.747665),new $P.Vector3(-.769138,.360399,.086847),new $P.Vector3(-.271988,-.27514,.905353),new $P.Vector3(.09674,-.566901,.700151),new $P.Vector3(.562872,-.735136,.094647),new $P.Vector3(.379877,.359278,.190061),new $P.Vector3(.519064,-.023055,.405068),new $P.Vector3(-.301036,.114696,.088885),new $P.Vector3(-.282922,.598305,.487214),new $P.Vector3(-.181859,.25167,.679702),new $P.Vector3(-.191463,-.635818,.512919),new $P.Vector3(-.293655,.427423,.078921),new $P.Vector3(-.267983,.680534,.13288),new $P.Vector3(.139611,.319637,.477439),new $P.Vector3(-.352086,.31104,.653913),new $P.Vector3(.321032,.805279,.487345),new $P.Vector3(.073516,.820734,.414183),new $P.Vector3(-.155324,.589983,.41146),new $P.Vector3(.335976,.170782,.527627),new $P.Vector3(.46346,-.355658,.167689),new $P.Vector3(.222654,.59655,.769406),new $P.Vector3(.922138,-.04207,.147555),new $P.Vector3(-.72705,-.329192,.369826),new $P.Vector3(-.090731,.53382,.463767),new $P.Vector3(-.323457,-.876559,.238524),new $P.Vector3(-.663277,-.372384,.342856)];class Hk extends $P.RawShaderMaterial{constructor(){super(),this.setValues.call(this,{uniforms:{noiseTexture:{type:"t",value:CO.noiseTexture},noiseTexelSize:{type:"v2",value:new $P.Vector2(1/CO.noiseWidth,1/CO.noiseHeight)},diffuseTexture:{type:"t",value:null},normalTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new $P.Vector2(1/512,1/512)},camNearFar:{type:"v2",value:new $P.Vector2(1,10)},projMatrix:{type:"mat4",value:new $P.Matrix4},aspectRatio:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},samplesKernel:{type:"v3v",value:Gk},kernelRadius:{type:"f",value:1},depthThreshold:{type:"f",value:1},factor:{type:"f",value:1}},vertexShader:zN,fragmentShader:"precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n",transparent:!1,depthTest:!1,depthWrite:!1})}}const Wk=Hk,jk=[-2,-1,0,1,2];class Xk extends $P.RawShaderMaterial{constructor(){super(),this.setValues.call(this,{uniforms:{depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new $P.Vector2(1/512,1/512)},aoMap:{type:"t",value:null},samplesOffsets:{type:"fv1",value:jk}},vertexShader:zN,fragmentShader:"precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n",transparent:!1,depthTest:!1,depthWrite:!1})}}const Yk=Xk,qk=[-2,-1,0,1,2];class $k extends $P.RawShaderMaterial{constructor(t){super(t),this.setValues.call(this,{uniforms:{diffuseTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new $P.Vector2(1/512,1/512)},aoMap:{type:"t",value:null},samplesOffsets:{type:"fv1",value:qk},projMatrix:{type:"mat4",value:new $P.Matrix4},aspectRatio:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},fogNearFar:{type:"v2",value:new $P.Vector2(100,100)},fogColor:{type:"v4",value:new $P.Vector4(0,.5,0,1)}},vertexShader:zN,fragmentShader:"precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n",transparent:!1,depthTest:!1,depthWrite:!1}),this.setValues(t)}setValues(t){if(void 0===t)return;super.setValues(t);const e={};this.useFog&&(e.USE_FOG=1),this.fogTransparent&&(e.FOG_TRANSPARENT=1),this.defines=e}}$k.prototype.useFog=!0,$k.prototype.fogTransparent=!1;const Zk=$k;class Jk extends $P.RawShaderMaterial{constructor(){super();const t={uniforms:{srcL:{type:"t",value:null},srcR:{type:"t",value:null}},vertexShader:zN,fragmentShader:"precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n",transparent:!1,depthTest:!1,depthWrite:!1};this.setValues(t)}}const Kk=Jk;class Qk{constructor(){this.position=new $P.Vector3(0,0,0),this.scale=1,this.orientation=new $P.Quaternion(0,0,0,1)}set(t,e,n){this.position=t,this.scale=e,this.orientation=n}}class tG{setup(t,e){this._startTime=void 0,this._endTime=void 0,this._isPaused=!1,this._srcView=t,this._dstView=e,this._isMoving=!1}isMoving(){return this._isMoving}wasStarted(){return void 0!==this._startTime&&void 0!==this._endTime}start(){this._startTime=Date.now();const t=LL.now.interpolateViews?1500:0;this._endTime=this._startTime+t,this._isMoving=!0}getCurrentView(){if(void 0===this._srcView||void 0===this._dstView||!this._isMoving||!this.wasStarted())return{success:!1};let t=this.createView();const e=Date.now();if(e>this._endTime)return t=this._dstView,this.reset(),{success:!0,view:t};const n=(e-this._startTime)/(this._endTime-this._startTime);return t.position.copy(this._srcView.position),t.position.lerp(this._dstView.position,n),t.scale=(1-n)*this._srcView.scale+n*this._dstView.scale,t.orientation.copy(this._srcView.orientation),t.orientation.slerp(this._dstView.orientation,n),{success:!0,view:t}}reset(){this._startTime=this._endTime=0,this._isMoving=!1}pause(){this._isPaused||(this.setup(this.getCurrentView().view,this._dstView),this._isPaused=!0)}resume(){this._isPaused=!1}createView(){return new Qk}}function eG(t,e){this.context=t,this._opts=qP.default.merge({path:"/"},e)}KN(eG.prototype),eG.prototype.removeCookie=function(t){const e=this._toCount(t);let n=this._getSimpleCookie(e);if(n){this._removeSimpleCookie(e),n=parseInt(n,10);for(let e=0;e<n;++e)this._removeSimpleCookie(t+e)}else this._removeSimpleCookie(t)},eG.prototype.setCookie=function(t,e){this.removeCookie(t);const n=function(t,e){const n=t.length,i=[];for(let r=0,s=0;s<n;r++,s+=e)i[r]=t.slice(s,s+e);return i}(e=encodeURIComponent(e),4e3-t.length-1),i=n.length;if(1===i)return void this._setSimpleCookie(t,e);const r=this._toCount(t);this._setSimpleCookie(r,i.toString());for(let e=0;e<i;++e)this._setSimpleCookie(t+e,n[e])},eG.prototype.getCookie=function(t){const e=this._toCount(t);let n=this._getSimpleCookie(e);if(!n)return this._getSimpleCookie(t);n=parseInt(n,10);const i=[];for(let e=0;e<n;++e)i[e]=this._getSimpleCookie(t+e);return i.join("")},eG.prototype._toCount=function(t){return t+"Cnt"},eG.prototype._removeSimpleCookie=function(t){document.cookie=`${t}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`},eG.prototype._getExpirationDate=function(){const t=new Date;return t.setFullYear(t.getFullYear()+10),t},eG.prototype._setSimpleCookie=function(t,e){document.cookie=`${t}=${e};expires=${this._getExpirationDate().toUTCString()};path=${this._opts.path}`},eG.prototype._getSimpleCookie=function(t){const e=document.cookie.match(new RegExp(`(?:^|; )${t}=([^;]*)`));return e?decodeURIComponent(e[1]):""},eG.prototype._exists=function(t){return document.cookie.match(new RegExp(`(?:^|; )${t}=([^;]*)`))};const nG=eG;class iG{constructor(t){this._mainCamera=new $P.PerspectiveCamera,this._button=null,this._onToggle=t,this._molContainer=new jN.RCGroup,this._user=new jN.RCGroup,this._scalingPivot=new $P.Object3D,this._user.add(this._scalingPivot),this._controller1=null,this._controller2=null,this._pressedGripsCounter=0,this._distance=0,this._gfx=null}startScalingByControllers(){this._distance=this._controller1.position.distanceTo(this._controller2.position),jN.getMiddlePoint(this._controller1.position,this._controller2.position,this._scalingPivot.position),this._scalingPivot.scale.set(1,1,1),this._scalingPivot.updateMatrix(),this._scalingPivot.updateMatrixWorld(),this._scalingPivot.addSavingWorldTransform(this._molContainer)}stopScalingByControllers(){this._gfx.scene.addSavingWorldTransform(this._molContainer)}handleGripsDown(t){this._pressedGripsCounter++,2===this._pressedGripsCounter?this.startScalingByControllers():1===this._pressedGripsCounter&&t.target.addSavingWorldTransform(this._molContainer)}handleGripsUp(t){this._pressedGripsCounter--,1===this._pressedGripsCounter?(this.stopScalingByControllers(),(t.target===this._controller1?this._controller2:this._controller1).addSavingWorldTransform(this._molContainer)):0===this._pressedGripsCounter&&this._gfx.scene.addSavingWorldTransform(this._molContainer)}enable(t){if(!t)return void fL.warn("WebVR couldn't be enabled, because gfx is not defined");this._gfx=t;const{renderer:e,camera:n}=t;if(!e)throw new Error("No renderer is available to toggle WebVR");if(!n)throw new Error("No camera is available to toggle WebVR");e.xr.enabled=!0,this._button?this._button.style.display="block":(this._button=function(t){function e(t){t.style.position="absolute",t.style.bottom="20px",t.style.padding="12px 6px",t.style.border="1px solid #fff",t.style.borderRadius="4px",t.style.background="transparent",t.style.color="#fff",t.style.font="normal 13px sans-serif",t.style.textAlign="center",t.style.opacity="0.5",t.style.outline="none",t.style.zIndex="999"}if("xr"in navigator){const n=document.createElement("button");return n.style.display="none",e(n),navigator.xr.isSessionSupported("immersive-vr").then(e=>e?function(e){e.style.display="",e.style.cursor="pointer",e.style.left="calc(50% - 50px)",e.style.width="100px",e.textContent="ENTER VR";let n=null;function i(){n.removeEventListener("end",i),e.textContent="ENTER VR",n=null}function r(r){r.addEventListener("end",i),t._gfx.renderer.xr.setReferenceSpaceType("local"),t._gfx.renderer.xr.setSession(r),e.textContent="EXIT VR",n=r}e.onmouseenter=function(){e.style.opacity="1.0"},e.onmouseleave=function(){e.style.opacity="0.5"},e.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor"]};navigator.xr.requestSession("immersive-vr",e).then(r),t.moveSceneBehindHeadset()}else n.end()}}(n):function(t){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.textContent="VR NOT FOUND",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}(n)),n}const n=document.createElement("a");return n.href="https://webvr.info",n.innerHTML="WEBXR NOT SUPPORTED",n.style.left="calc(50% - 90px)",n.style.width="180px",n.style.textDecoration="none",e(n),n}(this),document.body.appendChild(this._button)),this._mainFog=LL.now.fog,LL.set("fog",!1),this._plugVRNodesIntoScene(t,e),this._setControllersListeners(),this._onToggle&&this._onToggle(!0)}_plugVRNodesIntoScene(t,e){this._mainCamera.copy(t.camera),t.scene.add(this._user),t.scene.add(this._molContainer),this._molContainer.add(t.root),this._controller1=e.xr.getController(0),this._controller2=e.xr.getController(1);const n=this._createControllerMesh();this._controller1.add(n),this._controller2.add(n.clone()),this._user.add(this._controller1),this._user.add(this._controller2)}_setControllersListeners(){this._controller1.addEventListener("selectstart",t=>{this.handleGripsDown(t)}),this._controller1.addEventListener("selectend",t=>{this.handleGripsUp(t)}),this._controller2.addEventListener("selectstart",t=>{this.handleGripsDown(t)}),this._controller2.addEventListener("selectend",t=>{this.handleGripsUp(t)}),this._controller1.addEventListener("squeezestart",t=>{this.handleGripsDown(t)}),this._controller1.addEventListener("squeezeend",t=>{this.handleGripsUp(t)}),this._controller2.addEventListener("squeezestart",t=>{this.handleGripsDown(t)}),this._controller2.addEventListener("squeezeend",t=>{this.handleGripsUp(t)})}disable(){if(!this._gfx)return;const{renderer:t,camera:e}=this._gfx;if(!t)throw new Error("No renderer is available to toggle WebVR");t.setAnimationLoop(null);const n=t.xr.getSession();n&&n.end(),t.xr.enabled=!1,this._button&&(this._button.style.display="none"),LL.set("fog",this._mainFog),this._unplugVRNodesFromScene(e),this._onToggle&&this._onToggle(!1)}_unplugVRNodesFromScene(t){this._mainCamera&&t&&t.copy(this._mainCamera);const e=this._molContainer.children[0];e&&this._gfx.scene.add(e),this._molContainer.parent.remove(this._molContainer),this._user&&this._gfx.scene.remove(this._user),this._molContainer=null,this._user=null,this._scalingPivot=null,this._user=null,this._controller1=null,this._controller2=null}_createControllerMesh(){const t=new $P.CylinderGeometry(.04,.04,.3),e=new DO({lights:!1,overrideColor:!0});e.setUberOptions({fixedColor:new $P.Color(4474111)}),e.updateUniforms();const n=new $P.Mesh(t,e);return n.rotateX(-Math.PI/2),n}updateMoleculeScale(){if(!this._controller1||!this._controller2)return;const t=this;if(2===t._pressedGripsCounter){jN.getMiddlePoint(t._controller1.position,t._controller2.position,t._scalingPivot.position);const e=t._controller1.position.distanceTo(t._controller2.position),n=e/t._distance;t._scalingPivot.scale.multiplyScalar(n),t._distance=e}}moveSceneBehindHeadset(){const t=this._gfx,{camera:e}=t,n=this._molContainer;n.matrix.identity(),n.position.set(0,0,-4),n.updateMatrix(),n.matrixWorld.multiplyMatrices(e.matrixWorld,n.matrix),t.scene.addSavingWorldTransform(n),this._onToggle&&this._onToggle(!0)}getCanvas(){const t=this._gfx;return t&&t.renderer?t.renderer.domElement:null}}const{selectors:rG,Atom:sG,Residue:oG,Chain:aG,Molecule:lG}=DN,cG="Could not find suitable loader for this source";$P.ColorManagement.enabled=!1;const{createElement:hG}=AL;function uG(t){const e=t.lastIndexOf(".");return e>=0&&(t=t.substr(0,e)),t}function dG(t,e,n){void 0!==n?t.debug(`${e}... ${Math.floor(100*n)}%`):t.debug(`${e}...`)}function pG(){return LL.now.fogColorEnable?LL.now.fogColor:LL.now.bg.color}function fG(t){hL.call(this),this._opts=qP.default.merge({settingsCookie:"settings",cookiePath:"/"},t),this._gfx=null,this._interpolator=new tG,this._container=t&&t.container||document.getElementById("miew-container")||qP.default.head(document.getElementsByClassName("miew-container"))||document.body,this._containerRoot=this._container,this._running=!1,this._halting=!1,this._building=!1,this._needRender=!0,this._hotKeysEnabled=!0,this.settings=LL;const e=fL;e.console=!1,e.level="info",this.logger=e,this._cookies=new nG(this),this.restoreSettings(),t&&t.settings&&this.settings.set(t.settings),this._spinner=null,this._loading=[],this._animInterval=null,this._visuals={},this._curVisualName=null,this._objects=[],this._sourceWindow=null,this.reset(),this._repr&&e.debug(`Selected ${this._repr.mode.name} mode with ${this._repr.colorer.name} colorer.`);const n=this;fG.registeredPlugins.forEach(t=>{t.call(n)}),this._initOnSettingsChanged()}function mG(t,e){const n=t;for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(e)}function gG(t){return t.getExtension("EXT_frag_depth")}function _G(t){return t.getExtension("WEBGL_depth_texture")&&t.getExtension("WEBGL_draw_buffers")}fG.prototype=Object.create(hL.prototype),fG.prototype.constructor=fG,fG.prototype.getMaxRepresentationCount=function(){return LB.NUM_REPRESENTATION_BITS},fG.prototype._updateShadowCamera=function(){const t=new $P.Matrix4,e=new $P.Vector3,n={center:new $P.Vector3,halfSize:new $P.Vector3};return function(){this._gfx.scene.updateMatrixWorld();for(let i=0;i<this._gfx.scene.children.length;i++)if("DirectionalLight"===this._gfx.scene.children[i].type){const r=this._gfx.scene.children[i];t.copy(r.shadow.camera.matrixWorldInverse),this.getOBB(t,n),e.subVectors(r.target.position,r.position),r.position.subVectors(n.center,e),r.target.position.copy(n.center),r.shadow.bias=.09,r.shadow.camera.bottom=-n.halfSize.y,r.shadow.camera.top=n.halfSize.y,r.shadow.camera.right=n.halfSize.x,r.shadow.camera.left=-n.halfSize.x,r.shadow.camera.near=e.length()-n.halfSize.z,r.shadow.camera.far=e.length()+n.halfSize.z,r.shadow.camera.updateProjectionMatrix()}}}(),fG.prototype.init=function(){const t=this._container,e=AL.createElement("div",{class:"miew-canvas"});mG(t,e),this._container=e;const n=document.createDocumentFragment();if(n.appendChild(this._msgMode=hG("div",{class:"mode-message overlay"},hG("p",{},"COMPONENT EDIT MODE"))),n.appendChild(this._msgAtomInfo=hG("div",{class:"atom-info overlay"},hG("p",{},""))),t.appendChild(n),null!==this._gfx)return!0;const i=this;this._showMessage("Viewer is being initialized...");try{this._initGfx(),this._initListeners(),this._spinner=new tL({lines:13,length:28,width:14,radius:42,color:"#fff",zIndex:700});const t=yk();t.addEventListener("keydown",t=>{i._onKeyDown(t)}),t.addEventListener("keyup",t=>{i._onKeyUp(t)}),this._objectControls=new wk(this._gfx.root,this._gfx.pivot,this._gfx.camera,this._gfx.renderer.domElement,()=>i._getAltObj()),this._objectControls.addEventListener("change",t=>{switch(LL.now.shadow.on&&i._updateShadowCamera(),t.action){case"rotate":i.dispatchEvent({type:"rotate",quaternion:t.quaternion});break;case"zoom":i.dispatchEvent({type:"zoom",factor:t.factor});break;default:i.dispatchEvent({type:t.action})}i.dispatchEvent({type:"transform"}),i._needRender=!0});const e=this._gfx;this._picker=new Tk(e.root,e.camera,e.renderer.domElement),this._picker.addEventListener("newpick",t=>{i._onPick(t)}),this._picker.addEventListener("dblclick",t=>{i.center(t)})}catch(t){if("TypeError"===t.name&&"Cannot read property 'getExtension' of null"===t.message)this._showMessage("Could not create WebGL context.");else{if(!(t.message.search(/webgl/i)>1))throw this._showMessage("Viewer initialization failed."),t;this._showMessage(t.message)}return!1}const r=this._opts&&this._opts.load;if(r){const t=this._opts&&this._opts.type;this.load(r,{fileType:t,keepRepsInfo:!0})}return!0},fG.prototype.term=function(){this._showMessage("Viewer has been terminated."),this._loading.forEach(t=>{t.cancel()}),this._loading.length=0,this.halt(),this._gfx=null},fG.prototype._showMessage=function(t){const e=document.createElement("div");e.setAttribute("class","miew-message"),e.appendChild(document.createElement("p")).appendChild(document.createTextNode(t)),mG(this._container,e)},fG.prototype._showCanvas=function(){mG(this._container,this._gfx.renderer.domElement)},fG.prototype._requestAnimationFrame=function(t){const{xr:e}=this._gfx.renderer;e&&e.enabled?this._gfx.renderer.setAnimationLoop(t):requestAnimationFrame(t)},fG.prototype._initGfx=function(){const t={width:this._container.clientWidth,height:this._container.clientHeight},e={preserveDrawingBuffer:!0,alpha:!0,premultipliedAlpha:!1};LL.now.antialias&&(e.antialias=!0),t.renderer2d=new _k,t.renderer=new $P.WebGL1Renderer(e),t.renderer.shadowMap.enabled=LL.now.shadow.on,t.renderer.shadowMap.autoUpdate=!1,t.renderer.shadowMap.type=$P.PCFShadowMap,xO.init(t.renderer),gG(t.renderer.getContext())||LL.set("zSprites",!1),_G(t.renderer.getContext())||LL.set("ao",!1),t.renderer.autoClear=!1,t.renderer.setPixelRatio(window.devicePixelRatio),t.renderer.setSize(t.width,t.height),t.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent)),t.renderer.clearColor(),t.renderer2d.setSize(t.width,t.height),t.camera=new $P.PerspectiveCamera(LL.now.camFov,t.width/t.height,LL.now.camNear,LL.now.camFar),t.camera.setMinimalFov(LL.now.camFov),t.camera.position.z=LL.now.camDistance,t.camera.updateProjectionMatrix(),t.camera.layers.set(jN.LAYERS.DEFAULT),t.camera.layers.enable(jN.LAYERS.VOLUME),t.camera.layers.enable(jN.LAYERS.VOLUME_BFPLANE),t.stereoCam=new $P.StereoCamera,t.scene=new $P.Scene;const n=pG();t.scene.fog=new $P.Fog(n,LL.now.camNear,LL.now.camFar),t.root=new jN.RCGroup,t.scene.add(t.root),t.pivot=new jN.RCGroup,t.root.add(t.pivot),t.selectionScene=new $P.Scene,t.selectionRoot=new $P.Group,t.selectionRoot.matrixAutoUpdate=!1,t.selectionScene.add(t.selectionRoot),t.selectionPivot=new $P.Group,t.selectionPivot.matrixAutoUpdate=!1,t.selectionRoot.add(t.selectionPivot);const i=new $P.DirectionalLight(16777215,.45);i.position.set(0,.414,1),i.layers.enable(jN.LAYERS.TRANSPARENT),i.castShadow=!0,i.shadow.bias=.09,i.shadow.radius=LL.now.shadow.radius,i.shadow.camera.layers.set(jN.LAYERS.SHADOWMAP);const r=t.renderer.getPixelRatio(),s=Math.max(t.width,t.height)*r;i.shadow.mapSize.width=s,i.shadow.mapSize.height=s,i.target.position.set(0,0,0),t.scene.add(i),t.scene.add(i.target);const o=new $P.AmbientLight(6710886);o.layers.enable(jN.LAYERS.TRANSPARENT),t.scene.add(o),t.axes=new Ak(t.root,t.camera);const a=t.width*r,l=t.height*r;t.offscreenBuf=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.NearestFilter,format:$P.RGBAFormat,depthBuffer:!0}),t.renderer.getContext().getExtension("WEBGL_depth_texture")&&(t.offscreenBuf.depthTexture=new $P.DepthTexture,t.offscreenBuf.depthTexture.type=$P.UnsignedShortType),t.offscreenBuf2=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,depthBuffer:!1}),t.offscreenBuf3=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,depthBuffer:!1}),t.offscreenBuf4=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,depthBuffer:!1}),t.volBFTex=t.offscreenBuf3,t.volFFTex=t.offscreenBuf4,t.volWFFTex=t.offscreenBuf,t.renderer.getContext().getExtension("OES_texture_float")?(t.offscreenBuf5=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,type:$P.FloatType,depthBuffer:!1}),t.offscreenBuf6=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,type:$P.FloatType,depthBuffer:!1}),t.offscreenBuf7=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,type:$P.FloatType,depthBuffer:!0}),t.volBFTex=t.offscreenBuf5,t.volFFTex=t.offscreenBuf6,t.volWFFTex=t.offscreenBuf7):this.logger.warn("Device doesn't support OES_texture_float extension"),t.stereoBufL=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,depthBuffer:!1}),t.stereoBufR=new $P.WebGLRenderTarget(a,l,{minFilter:$P.LinearFilter,magFilter:$P.LinearFilter,format:$P.RGBAFormat,depthBuffer:!1}),this._gfx=t,this._showCanvas(),this._embedWebXR("WEBVR"===LL.now.stereo),this._container.appendChild(t.renderer2d.getElement());const c=new aL;c.domElement.style.position="absolute",c.domElement.style.right="0",c.domElement.style.bottom="0",this._container.appendChild(c.domElement),this._fps=c,this._fps.show(LL.now.fps)},fG.prototype._initListeners=function(){const t=this;window.addEventListener("resize",()=>{t._onResize()})},fG.prototype._makeUniqueVisualName=function(t){if(!t)return Math.random().toString();let e=t,n=1;for(;this._visuals.hasOwnProperty(e);)e=`${t} (${n.toString()})`,n++;return e},fG.prototype._addVisual=function(t){if(!t)return null;const e=this._makeUniqueVisualName(t.name);return t.name=e,this._visuals[e]=t,this._gfx.pivot.add(t),t.getSelectionGeo&&this._gfx.selectionPivot.add(t.getSelectionGeo()),e},fG.prototype._removeVisual=function(t){let e="",n=null;t instanceof qN?(({name:e}=t),n=t):"string"==typeof t&&(e=t,n=this._visuals[e]),n&&this._visuals.hasOwnProperty(e)&&this._visuals[e]===n&&(e===this._curVisualName&&(this._curVisualName=void 0),delete this._visuals[e],n.release(),this._needRender=!0)},fG.prototype._forEachVisual=function(t){for(const e in this._visuals)this._visuals.hasOwnProperty(e)&&t(this._visuals[e])},fG.prototype._releaseAllVisuals=function(){if(this._gfx&&this._gfx.pivot){for(const t in this._visuals)this._visuals.hasOwnProperty(t)&&this._visuals[t].release();this._visuals={}}},fG.prototype._forEachComplexVisual=function(t){if(this._gfx&&this._gfx.pivot)for(const e in this._visuals)this._visuals.hasOwnProperty(e)&&this._visuals[e]instanceof LB&&t(this._visuals[e])},fG.prototype._getComplexVisual=function(t){t=t||this._curVisualName;let e=null,n=null;return this._forEachComplexVisual(i=>{e=i,i.name===t&&(n=i)}),n||e},fG.prototype._getVolumeVisual=function(){let t=null;return this._forEachVisual(e=>{e instanceof XB&&(t=e)}),t},fG.prototype._getVisualForComplex=function(t){if(!t)return null;let e=null;return this._forEachComplexVisual(n=>{n.getComplex()===t&&(e=n)}),e},fG.prototype.getVisuals=function(){return Object.keys(this._visuals)},fG.prototype.getComplexVisualsCount=function(){let t=0;return this._forEachComplexVisual(()=>t++),t},fG.prototype.getCurrentVisual=function(){return this._curVisualName},fG.prototype.setCurrentVisual=function(t){this._visuals[t]&&(this._curVisualName=t)},fG.prototype.run=function(){if(!this._running){if(this._running=!0,this._halting)return void(this._halting=!1);this._objectControls.enable(!0),this._interpolator.resume(),this._requestAnimationFrame(()=>this._onTick())}},fG.prototype.halt=function(){this._running&&(this._discardComponentEdit(),this._discardFragmentEdit(),this._objectControls.enable(!1),this._interpolator.pause(),this._halting=!0)},fG.prototype.enableHotKeys=function(t){this._hotKeysEnabled=t,this._objectControls.enableHotkeys(t)},fG.prototype._onResize=function(){const t=this._gfx;t&&(this._needRender=!0,t.width=this._container.clientWidth,t.height=this._container.clientHeight,t.camera.aspect=t.width/t.height,t.camera.setMinimalFov(LL.now.camFov),t.camera.updateProjectionMatrix(),t.renderer.setSize(t.width,t.height),t.renderer2d.setSize(t.width,t.height),this.dispatchEvent({type:"resize"}))},fG.prototype._resizeOffscreenBuffers=function(t,e,n){const i=this._gfx,r="NONE"===(n=n||"NONE")||"ANAGLYPH"===n,s=r?1:.5;i.offscreenBuf.setSize(s*t,e),i.offscreenBuf2.setSize(s*t,e),i.offscreenBuf3.setSize(s*t,e),i.offscreenBuf4.setSize(s*t,e),i.offscreenBuf5&&i.offscreenBuf5.setSize(s*t,e),i.offscreenBuf6&&i.offscreenBuf6.setSize(s*t,e),i.offscreenBuf7&&i.offscreenBuf7.setSize(s*t,e),r&&(i.stereoBufL.setSize(t,e),i.stereoBufR.setSize(t,e))},fG.prototype._onTick=function(){if(this._halting)return this._running=!1,void(this._halting=!1);this._fps.update(),this._requestAnimationFrame(()=>this._onTick()),this._onUpdate(),this._needRender&&(this._onRender(),this._needRender=!LL.now.suspendRender||"WEBVR"===LL.now.stereo)},fG.prototype._getBSphereRadius=function(){let t=0;return this._forEachVisual(e=>{t=Math.max(t,e.getBoundaries().boundingSphere.radius)}),t*this._objectControls.getScale()},fG.prototype.getOBB=function(){const t=new $P.Sphere,e=new $P.Box3,n=new $P.Box3,i=new $P.Matrix4,r=[new $P.Vector3,new $P.Vector3,new $P.Vector3,new $P.Vector3];return function(s,o){n.makeEmpty(),this._forEachVisual(i=>{t.copy(i.getBoundaries().boundingSphere),t.applyMatrix4(i.matrixWorld).applyMatrix4(s),t.getBoundingBox(e),n.union(e)}),n.getCenter(o.center),i.copy(s).invert(),o.center.applyMatrix4(i);const{min:a}=n,{max:l}=n;r[0].set(a.x,a.y,a.z),r[1].set(l.x,a.y,a.z),r[2].set(a.x,l.y,a.z),r[3].set(a.x,a.y,l.z);for(let t=0,e=r.length;t<e;t++)r[t].applyMatrix4(i);o.halfSize.set(Math.abs(r[0].x-r[1].x),Math.abs(r[0].y-r[2].y),Math.abs(r[0].z-r[3].z)).multiplyScalar(.5)}}(),fG.prototype._updateFog=function(){const t=this._gfx;if(LL.now.fog){if(void 0===t.scene.fog||null===t.scene.fog){const e=pG();t.scene.fog=new $P.Fog(e),this._setUberMaterialValues({fog:LL.now.fog})}e=t.scene.fog,n=t.camera.position.z,i=this._getBSphereRadius(),e.near=n-i*LL.now.fogNearFactor,e.far=n+i*LL.now.fogFarFactor}else t.scene.fog&&(t.scene.fog=void 0,this._setUberMaterialValues({fog:LL.now.fog}));var e,n,i},fG.prototype._onUpdate=function(){void 0!==this.isScriptingCommandAvailable&&this.isScriptingCommandAvailable()&&!this._building&&this.callNextCmd(),this._objectControls.update(),this._forEachComplexVisual(t=>{t.getComplex().update()}),LL.now.autobuild&&!this._loading.length&&!this._building&&this._needRebuild()&&this.rebuild(),this._loading.length||this._building||this._needRebuild()||this._updateView(),this._updateFog(),this._gfx.renderer.xr.enabled&&this.webVR.updateMoleculeScale()},fG.prototype._onRender=function(){const t=this._gfx;t.scene.updateMatrixWorld(),t.camera.updateMatrixWorld(),this._clipPlaneUpdateValue(this._getBSphereRadius()),this._fogFarUpdateValue(),t.renderer.setRenderTarget(null),t.renderer.clear(),this._renderFrame(LL.now.stereo)},fG.prototype._renderFrame=function(){const t=new Kk,e=new $P.Vector2;return function(n){const i=this._gfx,{renderer:r}=i;r.getSize(e),"NONE"!==n&&(i.camera.focus=i.camera.position.z,i.stereoCam.aspect=1,"ANAGLYPH"===n?i.stereoCam.update(i.camera):i.stereoCam.updateHalfSized(i.camera,LL.now.camFov));const s=i.renderer.getPixelRatio();switch(this._resizeOffscreenBuffers(e.width*s,e.height*s,n),this._renderShadowMap(),n){case"WEBVR":case"NONE":this._renderScene(i.camera,!1);break;case"SIMPLE":case"DISTORTED":r.setScissorTest(!0),r.setScissor(0,0,e.width/2,e.height),r.setViewport(0,0,e.width/2,e.height),this._renderScene(this._gfx.stereoCam.cameraL,"DISTORTED"===n),r.setScissor(e.width/2,0,e.width/2,e.height),r.setViewport(e.width/2,0,e.width/2,e.height),this._renderScene(this._gfx.stereoCam.cameraR,"DISTORTED"===n),r.setScissorTest(!1);break;case"ANAGLYPH":this._renderScene(this._gfx.stereoCam.cameraL,!1,i.stereoBufL),this._renderScene(this._gfx.stereoCam.cameraR,!1,i.stereoBufR),r.setRenderTarget(null),t.uniforms.srcL.value=i.stereoBufL.texture,t.uniforms.srcR.value=i.stereoBufR.texture,i.renderer.renderScreenQuad(t)}i.renderer2d.render(i.scene,i.camera),LL.now.axes&&i.axes&&!i.renderer.xr.enabled&&i.axes.render(r)}}(),fG.prototype._onBgColorChanged=function(){const t=this._gfx,e=pG();t&&(t.scene.fog&&t.scene.fog.color.set(e),t.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent))),this._needRender=!0},fG.prototype._onFogColorChanged=function(){const t=this._gfx,e=pG();t&&t.scene.fog&&t.scene.fog.color.set(e),this._needRender=!0},fG.prototype._setUberMaterialValues=function(t){this._gfx.root.traverse(e=>{(e instanceof $P.Mesh||e instanceof $P.LineSegments||e instanceof $P.Line)&&e.material instanceof DO&&(e.material.setValues(t),e.material.needsUpdate=!0)})},fG.prototype._enableMRT=function(t,e,n){const i=this._gfx,r=i.renderer.getContext(),s=r.getExtension("WEBGL_draw_buffers"),{properties:o}=i.renderer;if(!t)return void s.drawBuffersWEBGL([r.COLOR_ATTACHMENT0,null]);i.renderer.setRenderTarget(n);const a=o.get(n.texture).__webglTexture;r.bindTexture(r.TEXTURE_2D,a),i.renderer.setRenderTarget(e);const l=o.get(e).__webglFramebuffer,c=o.get(e.texture).__webglTexture;r.bindFramebuffer(r.FRAMEBUFFER,l),l.width=e.width,l.height=e.height,r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,c,0),r.framebufferTexture2D(r.FRAMEBUFFER,s.COLOR_ATTACHMENT1_WEBGL,r.TEXTURE_2D,a,0),s.drawBuffersWEBGL([r.COLOR_ATTACHMENT0,s.COLOR_ATTACHMENT1_WEBGL])},fG.prototype._renderScene=function(t,e,n){e=e||!1,n=n||null;const i=this._gfx;if(i.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent)),i.renderer.setRenderTarget(n),i.renderer.clear(),i.renderer.xr.enabled)return void i.renderer.render(i.scene,t);i.renderer.setClearColor(0,0),i.renderer.setRenderTarget(i.offscreenBuf4),i.renderer.clearColor(),i.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent)),i.renderer.setRenderTarget(i.offscreenBuf),i.renderer.clear();const r=null!==this._getComplexVisual(),s=this._getVolumeVisual(),o=r&&LL.now.ao;o&&this._enableMRT(!0,i.offscreenBuf,i.offscreenBuf4),"prepass"===LL.now.transparency?this._renderWithPrepassTransparency(t,i.offscreenBuf):"standard"===LL.now.transparency&&(i.renderer.setRenderTarget(i.offscreenBuf),i.renderer.render(i.scene,t)),o&&this._enableMRT(!1,null,null);const a=r&&LL.now.outline.on,l=r&&LL.now.fxaa,c=null!==s&&null!=s.getMesh().material;let h=o||a||c||l||e?i.offscreenBuf2:n,u=i.offscreenBuf;o?(this._performAO(u,i.offscreenBuf4,i.offscreenBuf.depthTexture,h,i.offscreenBuf3,i.offscreenBuf2),l||e||c||a||(u=h,h=n,i.renderer.setRenderTarget(h),i.renderer.renderScreenQuadFromTex(u.texture,1))):(i.renderer.setRenderTarget(h),i.renderer.renderScreenQuadFromTex(u.texture,1)),a&&(u=h,h=c||l||e?i.offscreenBuf3:n,null!=u&&this._renderOutline(t,i.offscreenBuf,u,h)),this._renderSelection(t,i.offscreenBuf,h),c&&(i.renderer.setRenderTarget(i.offscreenBuf),i.renderer.renderScreenQuadFromTex(h.texture,1),h=i.offscreenBuf,this._renderVolume(s,t,h,i.volBFTex,i.volFFTex,i.volWFFTex),l||e||(i.renderer.setRenderTarget(n),i.renderer.renderScreenQuadFromTex(h.texture,1))),u=h,l&&(h=e?i.offscreenBuf4:n,this._performFXAA(u,h),u=h),e&&(h=n,this._performDistortion(u,h,!0))},fG.prototype._performDistortion=function(){const t=new $P.Scene,e=new $P.OrthographicCamera(-1,1,1,-1,-500,1e3),n=new $P.RawShaderMaterial({uniforms:{srcTex:{type:"t",value:null},aberration:{type:"fv3",value:new $P.Vector3(1)}},vertexShader:zN,fragmentShader:"precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}",transparent:!1,depthTest:!1,depthWrite:!1}),i=jN.buildDistorionMesh(10,10,LL.now.debug.stereoBarrel);return t.add(new qO.Mesh(i,n)),function(i,r,s){this._gfx.renderer.setRenderTarget(r),this._gfx.renderer.clear(),s?(n.uniforms.srcTex.value=i.texture,n.uniforms.aberration.value.set(.995,1,1.01),this._gfx.renderer.render(t,e)):this._gfx.renderer.renderScreenQuadFromTexWithDistortion(i,LL.now.debug.stereoBarrel)}}(),fG.prototype._renderOutline=function(){const t=new zk({depth:!0});return function(e,n,i,r){const s=this._gfx;t.uniforms.srcTex.value=i.texture,t.uniforms.srcDepthTex.value=n.depthTexture,t.uniforms.srcTexSize.value.set(n.width,n.height),t.uniforms.color.value=new $P.Color(LL.now.outline.color),t.uniforms.threshold.value=LL.now.outline.threshold,t.uniforms.thickness.value=new $P.Vector2(LL.now.outline.thickness,LL.now.outline.thickness),s.renderer.setRenderTarget(r),s.renderer.renderScreenQuad(t)}}(),fG.prototype._renderShadowMap=function(){const t={minFilter:$P.NearestFilter,magFilter:$P.NearestFilter,format:$P.RGBAFormat};return function(){if(!LL.now.shadow.on)return;const e=this._gfx,n=e.renderer.getRenderTarget(),i=e.renderer.getActiveCubeFace(),r=e.renderer.getActiveMipmapLevel(),s=e.renderer.state;s.setBlending($P.NoBlending),s.buffers.color.setClear(1,1,1,1),s.buffers.depth.setTest(!0),s.setScissorTest(!1);for(let n=0;n<e.scene.children.length;n++)if("DirectionalLight"===e.scene.children[n].type){const i=e.scene.children[n];null==i.shadow.map&&(i.shadow.map=new $P.WebGLRenderTarget(i.shadow.mapSize.width,i.shadow.mapSize.height,t),i.shadow.camera.updateProjectionMatrix()),i.shadow.updateMatrices(i),e.renderer.setRenderTarget(i.shadow.map),e.renderer.clear(),e.renderer.render(e.scene,i.shadow.camera)}e.renderer.setRenderTarget(n,i,r)}}(),fG.prototype._hasSelectionToRender=function(){const t=this._gfx.selectionPivot;for(let e=0;e<t.children.length;e++)if(t.children[e].children.length>0)return!0;return!1},fG.prototype._renderSelection=function(){const t=new zk;return function(e,n,i){const r=this._gfx;r.renderer.setClearColor("black",0),r.renderer.setRenderTarget(n),r.renderer.clear(!0,!1,!1),this._hasSelectionToRender()?(r.selectionRoot.matrix=r.root.matrix,r.selectionPivot.matrix=r.pivot.matrix,r.renderer.render(r.selectionScene,e)):r.renderer.renderDummyQuad(),r.renderer.setRenderTarget(i),r.renderer.renderScreenQuadFromTex(n.texture,.6),t.uniforms.srcTex.value=n.texture,t.uniforms.srcTexSize.value.set(n.width,n.height),r.renderer.renderScreenQuad(t)}}(),fG.prototype._checkVolumeRenderingSupport=function(t){if(!t)return!1;const e=this._gfx,n=e.renderer.getRenderTarget();e.renderer.setRenderTarget(t);const i=e.renderer.getContext(),r=i.checkFramebufferStatus(i.FRAMEBUFFER);return e.renderer.setRenderTarget(n),r===i.FRAMEBUFFER_COMPLETE||(this.logger.warn("Device doesn't support electron density rendering"),!1)},fG.prototype._renderVolume=function(){const t=new VB.BackFacePosMaterial,e=new VB.FrontFacePosMaterial,n=(new $P.Matrix4).makeTranslation(.5,.5,.5),i=new $P.Matrix4;let r;return function(s,o,a,l,c,h){const u=this._gfx;if(void 0===r&&(r=this._checkVolumeRenderingSupport(l)),!r)return;const d=s.getMesh();d.rebuild(u.camera),u.renderer.setClearColor("black",0),u.renderer.setRenderTarget(l),u.renderer.clear(),u.renderer.setRenderTarget(c),u.renderer.clear(),u.renderer.setRenderTarget(h),u.renderer.clear(),u.renderer.setRenderTarget(l),o.layers.set(jN.LAYERS.VOLUME_BFPLANE),u.renderer.render(u.scene,o),o.layers.set(jN.LAYERS.VOLUME),u.scene.overrideMaterial=t,u.renderer.render(u.scene,o),u.renderer.setRenderTarget(c),o.layers.set(jN.LAYERS.VOLUME),u.scene.overrideMaterial=e,u.renderer.render(u.scene,o),u.scene.overrideMaterial=null,o.layers.set(jN.LAYERS.DEFAULT),i.copy(d.matrixWorld).invert(),DO.prototype.uberOptions.world2colorMatrix.multiplyMatrices(n,i),o.layers.set(jN.LAYERS.COLOR_FROM_POSITION),u.renderer.setRenderTarget(h),u.renderer.render(u.scene,o);const p=d.material;p.uniforms._BFRight.value=l.texture,p.uniforms._FFRight.value=c.texture,p.uniforms._WFFRight.value=h.texture,o.layers.set(jN.LAYERS.VOLUME),u.renderer.setRenderTarget(a),u.renderer.render(u.scene,o),o.layers.set(jN.LAYERS.DEFAULT)}}(),fG.prototype._renderWithPrepassTransparency=function(t,e){const n=this._gfx;n.renderer.setRenderTarget(e),t.layers.set(jN.LAYERS.DEFAULT),n.renderer.render(n.scene,t),t.layers.set(jN.LAYERS.PREPASS_TRANSPARENT),n.renderer.getContext().colorMask(!1,!1,!1,!1),n.renderer.render(n.scene,t),n.renderer.getContext().colorMask(!0,!0,!0,!0),t.layers.set(jN.LAYERS.TRANSPARENT),n.renderer.render(n.scene,t),t.layers.set(jN.LAYERS.DEFAULT)},fG.prototype._performFXAA=function(){const t=new kk;return function(e,n){if(void 0===e||void 0===n)return;const i=this._gfx;i.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent)),i.renderer.setRenderTarget(n),i.renderer.clear(),t.uniforms.srcTex.value=e.texture,t.uniforms.srcTexelSize.value.set(1/e.width,1/e.height),t.uniforms.bgColor.value.set(LL.now.bg.color),t.bgTransparent!==LL.now.bg.transparent&&(t.setValues({bgTransparent:LL.now.bg.transparent}),t.needsUpdate=!0),i.renderer.renderScreenQuad(t)}}(),fG.prototype._performAO=function(){const t=new Wk,e=new Yk,n=new Zk,i=new $P.Vector3;return function(r,s,o,a,l,c){if(!(r&&s&&o&&a&&l&&c))return;const h=this._gfx,u=Math.tan(.5*$P.MathUtils.DEG2RAD*h.camera.fov);t.uniforms.diffuseTexture.value=r.texture,t.uniforms.depthTexture.value=o,t.uniforms.normalTexture.value=s.texture,t.uniforms.srcTexelSize.value.set(1/r.width,1/r.height),t.uniforms.camNearFar.value.set(h.camera.near,h.camera.far),t.uniforms.projMatrix.value=h.camera.projectionMatrix,t.uniforms.aspectRatio.value=h.camera.aspect,t.uniforms.tanHalfFOV.value=u,h.root.matrix.extractScale(i),t.uniforms.kernelRadius.value=LL.now.debug.ssaoKernelRadius*i.x,t.uniforms.depthThreshold.value=2*this._getBSphereRadius(),t.uniforms.factor.value=LL.now.debug.ssaoFactor,h.renderer.setRenderTarget(c),h.renderer.renderScreenQuad(t),e.uniforms.aoMap.value=c.texture,e.uniforms.srcTexelSize.value.set(1/c.width,1/c.height),e.uniforms.depthTexture.value=o,h.renderer.setRenderTarget(l),h.renderer.renderScreenQuad(e),n.uniforms.aoMap.value=l.texture,n.uniforms.diffuseTexture.value=r.texture,n.uniforms.srcTexelSize.value.set(1/l.width,1/l.height),n.uniforms.depthTexture.value=o,n.uniforms.projMatrix.value=h.camera.projectionMatrix,n.uniforms.aspectRatio.value=h.camera.aspect,n.uniforms.tanHalfFOV.value=u;const{fog:d}=h.scene;d&&(n.uniforms.fogNearFar.value.set(d.near,d.far),n.uniforms.fogColor.value.set(d.color.r,d.color.g,d.color.b,LL.now.fogAlpha)),n.useFog===LL.now.fog&&n.fogTransparent===LL.now.bg.transparent||(n.setValues({useFog:LL.now.fog,fogTransparent:LL.now.bg.transparent}),n.needsUpdate=!0),h.renderer.setRenderTarget(a),h.renderer.renderScreenQuad(n)}}(),fG.prototype.reset=function(){this._picker&&this._picker.reset(),this._lastPick=null,this._releaseAllVisuals(),this._setEditMode(0),this._resetObjects(),this._gfx&&(jN.clearTree(this._gfx.pivot),this._gfx.renderer2d.reset()),this.setNeedRender()},fG.prototype._resetScene=function(){this._objectControls.reset(),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this.resetReps(),this.resetPivot(),this.rebuildAll()},fG.prototype.resetView=function(){this._picker&&this._picker.reset(),this._setEditMode(0),this._resetScene(),this._forEachComplexVisual(t=>{t.updateSelectionMask({}),t.rebuildSelectionGeometry()})},fG.prototype._export=function(t){const e=qP.default.head(mk.exporters.find({format:t}));if(!e)return this.logger.error("Could not find suitable exporter for this source"),Promise.reject(new Error("Could not find suitable exporter for this source"));if(this.dispatchEvent({type:"exporting"}),this._visuals[this._curVisualName]instanceof LB){let t=null;return e.SourceClass===LB?t=this._visuals[this._curVisualName]:e.SourceClass===PN&&(t=this._visuals[this._curVisualName]._complex),new e(t,{miewVersion:fG.VERSION}).export().then(t=>t)}return this._visuals[this._curVisualName]instanceof XB?Promise.reject(new Error("Sorry, exporter for volume data not implemented yet")):Promise.reject(new Error("Unexpected format of data"))};const yG=/^(?:(pdb|cif|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i,vG=/^(?:pc|pubchem):\s*([a-z]+)$/i,xG=/^([a-z][a-z\d\-+.]*):/i;fG.prototype.load=function(t,e){e=qP.default.merge({},e,{context:this}),this.settings.now.use.multiFile||(this._loading.length&&(this._loading.forEach(t=>{t.cancel()}),this._loading.length=0),e.animation||this.reset(!0)),this._interpolator.reset(),this.dispatchEvent({type:"loading",options:e,source:t});const n=new CL;this._loading.push(n),n.addEventListener("notification",t=>{this.dispatchEvent(t.slaveEvent)}),this._spinner.spin(this._container);const i=t=>{const e=this._loading.indexOf(n);return-1!==e&&this._loading.splice(e,1),this._spinner.stop(),this._refreshTitle(),n.notify({type:"loadingDone",anything:t}),t};return function(t,e,n){return new Promise(i=>{if(n.shouldCancel())throw new Error("Operation cancelled");n.notify({type:"fetching"}),t=function(t,e){if(!qP.default.isString(t))return t;const n=yG.exec(t);if(n){let[,i="pdb",r]=n;switch(i=i.toLowerCase(),r=r.toUpperCase(),i){case"pdb":t=`https://files.rcsb.org/download/${r}.pdb`;break;case"cif":t=`https://files.rcsb.org/download/${r}.cif`;break;case"ccp4":t=`https://www.ebi.ac.uk/pdbe/coordinates/files/${r.toLowerCase()}.ccp4`;break;case"dsn6":t=`https://edmaps.rcsb.org/maps/${r.toLowerCase()}_2fofc.dsn6`;break;default:throw new Error("Unexpected data format shortcut")}return e.fileType=i,e.fileName=`${r}.${i}`,e.sourceType="url",t}const i=vG.exec(t);if(i){const n=i[1].toLowerCase();return t=`https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${n}/JSON?record_type=3d`,e.fileType="pubchem",e.fileName=`${n}.json`,e.sourceType="url",t}return"url"!==e.sourceType&&void 0!==e.sourceType||(e.sourceType="url",xG.test(t)||(t=AL.resolveURL(t))),t}(t,e);const r=qP.default.head(mk.loaders.find({type:e.sourceType,source:t}));if(!r)throw new Error(cG);const s=e.fileName||r.extractName(t);if(s){const[t,n]=AL.splitFileName(s);qP.default.defaults(e,{name:t,fileExt:n,fileName:s})}!function(t){let{binary:e}=t;if(void 0!==t.fileType){const n=qP.default.head(mk.parsers.find({format:t.fileType}));if(!n)throw new Error("Could not find suitable parser for this format");e=n.binary||!1}if(void 0===e&&void 0!==t.fileExt){const n=qP.default.head(mk.parsers.find({ext:t.fileExt}));n&&(e=n.binary||!1)}void 0!==t.fileExt&&".man"===t.fileExt.toLowerCase()&&(t.binary=!0,t.animation=!0),void 0!==e&&void 0!==t.binary&&t.binary!==e&&t.context.logger.warn("Overriding incorrect binary mode"),t.binary=e||!1}(e);let o=qP.default.get(e,"preset.expression");if(!qP.default.isUndefined(o)&&(o=JSON.parse(o),o&&o.settings)){const t=["singleUnit"];for(let e=0,n=t.length;e<n;++e){const n=t[e],i=qP.default.get(o.settings,n);qP.default.isUndefined(i)||LL.set(n,i)}}const a=new r(t,e);a.context=e.context,n.addEventListener("cancel",()=>a.abort()),a.addEventListener("progress",t=>{t.lengthComputable&&t.total>0?dG(a.logger,"Fetching",t.loaded/t.total):dG(a.logger,"Fetching")}),console.time("fetch"),i(a.load().then(t=>(console.timeEnd("fetch"),e.context.logger.info("Fetching finished"),n.notify({type:"fetchingDone",data:t}),t)).catch(t=>{throw console.timeEnd("fetch"),e.context.logger.debug(t.message),t.stack&&e.context.logger.debug(t.stack),e.context.logger.error("Fetching failed"),n.notify({type:"fetchingDone",error:t}),t}))})}(t,e,n).then(t=>function(t,e,n){if(n.shouldCancel())return Promise.reject(new Error("Operation cancelled"));n.notify({type:"parsing"});const i=qP.default.head(mk.parsers.find({format:e.fileType,ext:e.fileExt,data:t}));if(!i)return Promise.reject(new Error("Could not find suitable parser"));const r=new i(t,e);return r.context=e.context,n.addEventListener("cancel",()=>r.abort()),console.time("parse"),r.parse().then(t=>(console.timeEnd("parse"),n.notify({type:"parsingDone",data:t}),t)).catch(t=>{throw console.timeEnd("parse"),e.error=t,e.context.logger.debug(t.message),t.stack&&e.context.logger.debug(t.stack),e.context.logger.error("Parsing failed"),n.notify({type:"parsingDone",error:t}),t})}(t,e,n)).then(t=>{const n=this._onLoad(t,e);return i(n)}).catch(t=>{throw this.logger.error("Could not load data"),this.logger.debug(t),i(t)})},fG.prototype.unload=function(t){this._removeVisual(t||this.getCurrentVisual()),this.resetPivot(),LL.now.shadow.on&&this._updateShadowCamera()},fG.prototype._startAnimation=function(t){this._stopAnimation();const e=this,n=this._getComplexVisual();if(null!==n){try{this._frameInfo=new Nk(n.getComplex(),t,{onLoadStatusChanged(){e.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:e._isAnimating,isLoading:!e._frameInfo||e._frameInfo.isLoading}})},onError(t){e._stopAnimation(),e.logger.error(t)}})}catch(t){return void this.logger.error("Animation file does not fit to current complex!")}this._continueAnimation()}else this.logger.error("Unable to start animation - no molecule is loaded.")},fG.prototype._pauseAnimation=function(){null!==this._animInterval&&(this._isAnimating=!1,clearInterval(this._animInterval),this._animInterval=null,this._frameInfo&&this.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:this._isAnimating,isLoading:this._frameInfo.isLoading}}))},fG.prototype._continueAnimation=function(){this._isAnimating=!0;let t=1e3/LL.now.maxfps;t=Number.isNaN(t)?0:t;const e=this,{pivot:n}=e._gfx,i=this._getComplexVisual();i&&(i.resetSelectionMask(),i.rebuildSelectionGeometry(),this._msgAtomInfo.style.opacity=0),this._animInterval=setInterval(()=>{if(e.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:e._isAnimating,isLoading:e._frameInfo.isLoading}}),e._frameInfo.frameIsReady){n.updateToFrame(e._frameInfo),e._updateObjsToFrame(e._frameInfo),e._refreshTitle(` Frame ${e._frameInfo._currFrame} of ${e._frameInfo._framesCount} time interval - ${e._frameInfo._timeStep}`);try{e._frameInfo.nextFrame()}catch(t){return e.logger.error("Error during animation"),void e._stopAnimation()}e._needRender=!0}},t)},fG.prototype._stopAnimation=function(){null!==this._animInterval&&(clearInterval(this._animInterval),this._frameInfo.disableEvents(),this._frameInfo=null,this._animInterval=null,this.dispatchEvent({type:"mdPlayerStateChanged",state:null}))},fG.prototype._onLoad=function(t,e){const n=this._gfx;let i=null;if(e.animation)return this._refreshTitle(),this._startAnimation(t),null;if(this._stopAnimation(),e&&e.keepRepsInfo||(this._opts.reps=null,this._opts._objects=null),"Complex"===t.id){const n=t;e.fileName?n.name=n.name||uG(e.fileName).toUpperCase():e.amberFileName?n.name=n.name||uG(e.amberFileName).toUpperCase():n.name=`Dynamic ${e.fileType} molecule`,i=this._addVisual(new LB(n.name,n)),this._curVisualName=i;const r=this.info();if(this.logger.info(`Parsed ${e.fileName} (${r.atoms} atoms, ${r.bonds} bonds, ${r.residues} residues, ${r.chains} chains).`),qP.default.isNumber(this._opts.unit)&&n.setCurrentUnit(this._opts.unit),e.preset);else if(LL.now.autoPreset)switch(e.fileType){case"cml":this.resetReps("small");break;case"pdb":case"mmtf":case"cif":!function(t){let e=!1;return t.forEachComponent(t=>{t.forEachResidue(t=>{t._isValid&&(e=!0)})}),e}(n)?this.resetReps("small"):this.resetReps("macro");break;default:this.resetReps("default")}else this.resetReps("default")}else"Volume"===t.id&&(this.resetEd(),i=this._onLoadEd(t));return n.camera.updateProjectionMatrix(),this._updateFog(),n.root.resetTransform(),this.resetPivot(),this._objectControls.setScale(LL.now.radiusToFit/this._getBSphereRadius()),this._resetObjects(),LL.now.autoResolution&&this._tweakResolution(),LL.now.shadow.on&&this._updateShadowCamera(),this._opts.view&&(this.view(this._opts.view),delete this._opts.view),this._refreshTitle(),i},fG.prototype.resetEd=function(){this._edLoader&&(this._edLoader.abort(),this._edLoader=null),this._removeVisual(this._getVolumeVisual()),this._needRender=!0},fG.prototype.loadEd=function(t){this.resetEd();const e=qP.default.head(mk.loaders.find({source:t}));if(!e)return this.logger.error(cG),Promise.reject(new Error(cG));const n=this._edLoader=new e(t,{binary:!0});return n.context=this,n.load().then(t=>{const e=qP.default.head(mk.parsers.find({format:"ccp4"}));if(!e)throw new Error("Could not find suitable parser for this source");const n=new e(t);return n.context=this,n.parse().then(t=>{this._onLoadEd(t)})}).catch(t=>{this.logger.error("Could not load ED data"),this.logger.debug(t)})},fG.prototype._onLoadEd=function(t){t.normalize();const e=new XB("volume",t);e.getMesh().layers.set(jN.LAYERS.VOLUME);const n=this._addVisual(e);return this._needRender=!0,n},fG.prototype._needRebuild=function(){let t=!1;return this._forEachComplexVisual(e=>{t=t||e.needsRebuild()}),t},fG.prototype._rebuildObjects=function(){const t=this,e=this._gfx;let n,i;const r=[];for(n=0;n<e.pivot.children.length;++n){const t=e.pivot.children[n];t instanceof qN||r.push(t)}for(n=0;n<r.length;++n)r[n].parent.remove(r[n]);setTimeout(()=>{const r=t._objects;for(n=0,i=r.length;n<i;++n){const t=r[n];t.needsRebuild&&t.build(),t.getGeometry()&&e.pivot.add(t.getGeometry())}},10)},fG.prototype.changeUnit=function(t,e){const n=this._getComplexVisual(e);if(!n)throw new Error("There is no complex to change!");return void 0===t||(qP.default.isString(t)&&(t=Math.max(parseInt(t,10),0)),n.getComplex().setCurrentUnit(t)&&(this._resetScene(),this._updateInfoPanel())),function(){const t=n?n.getComplex().getCurrentUnit():0;return`Current unit: ${t} (${t>0?`Bio molecule ${t}`:"Asymmetric unit"})`}()},fG.prototype.rebuild=function(){if(this._building)return void this.logger.warn("Miew.rebuild(): already building!");this._building=!0,this.dispatchEvent({type:"rebuilding"}),this._rebuildObjects(),this._gfx.renderer2d.reset();const t=[];this._forEachComplexVisual(e=>{e.needsRebuild()&&t.push(e.rebuild().then(()=>new Promise(t=>{e.rebuildSelectionGeometry(),t()})))});const e=this;this._spinner.spin(this._container),Promise.all(t).then(()=>{e._spinner.stop(),e._needRender=!0,e._refreshTitle(),this.dispatchEvent({type:"buildingDone"}),e._building=!1})},fG.prototype.rebuildAll=function(){this._forEachComplexVisual(t=>{t.setNeedsRebuild()})},fG.prototype._refreshTitle=function(t){let e;t=void 0===t?"":t;const n=this._getComplexVisual();if(n){e=n.getComplex().name;const t=n.repGet(n.repCurrent());e+=t?` – ${t.mode.name} Mode`:""}else e=Object.keys(this._visuals).length>0?"Unknown":"No Data";e+=t,this.dispatchEvent({type:"titleChanged",data:e})},fG.prototype.setNeedRender=function(){this._needRender=!0},fG.prototype._extractRepresentation=function(){const t=[];this._forEachComplexVisual(e=>{if(0===e.getSelectionCount())return;const n=e.buildSelectorFromMask(1<<e.getSelectionBit()),i=LL.now.presets.default,r=e.repAdd({selector:n,mode:i[0].mode.id,colorer:i[0].colorer.id,material:i[0].material.id});r?(this.dispatchEvent({type:"repAdded",index:r.index,name:e.name}),e.repCurrent(r.index),t.push(e.name)):e.repCount()===LB.NUM_REPRESENTATION_BITS&&this.logger.warn(`Number of representations is limited to ${LB.NUM_REPRESENTATION_BITS}`)}),t.length>0&&this.logger.report(`New representation from selection for complexes: ${t.join(", ")}`)},fG.prototype._setReps=function(t){t=t||this._opts&&this._opts.reps||[],this._forEachComplexVisual(e=>e.resetReps(t))},fG.prototype.applyPreset=function(t){const{presets:e}=LL.now,n=[t||LL.defaults.preset,LL.defaults.preset,Object.keys(e)[0]];let i=null;for(let t=0;!i&&t<n.length;++t)LL.set("preset",n[t]),i=e[LL.now.preset],i||this.logger.warn(`Unknown preset "${LL.now.preset}"`);this._setReps(i)},fG.prototype.resetReps=function(t){const e=this._opts&&this._opts.reps;e?this._setReps(e):this.applyPreset(t)},fG.prototype.repCount=function(t){const e=this._getComplexVisual(t);return e?e.repCount():0},fG.prototype.repCurrent=function(t,e){const n=this._getComplexVisual(e),i=n?n.repCurrent(t):-1;return t&&i!==t&&this.logger.warn(`Representation ${t} was not found. Current rep remains unchanged.`),i},fG.prototype.rep=function(t,e){const n=this._getComplexVisual("");if(!n)return null;const i=n.rep(t,e);return"created"===i.status?this.dispatchEvent({type:"repAdded",index:i.index,name:n.name}):"changed"===i.status&&this.dispatchEvent({type:"repChanged",index:i.index,name:n.name}),i.desc},fG.prototype.repGet=function(t,e){const n=this._getComplexVisual(e);return n?n.repGet(t):null},fG.prototype.repAdd=function(t,e){const n=this._getComplexVisual(e);if(!n)return-1;const i=n.repAdd(t);return i?(this.dispatchEvent({type:"repAdded",index:i.index,name:e}),i.index):-1},fG.prototype.repRemove=function(t,e){const n=this._getComplexVisual(e);n&&(n.repRemove(t),this.dispatchEvent({type:"repRemoved",index:t,name:e}))},fG.prototype.repHide=function(t,e,n){this._needRender=!0;const i=this._getComplexVisual(n);return i?i.repHide(t,e):null},fG.prototype._setEditMode=function(t){this._editMode=t;const e=this._msgMode;e&&(e.style.opacity=0===t?0:1,0!==t)&&(e.getElementsByTagName("p")[0].innerHTML=1===t?"COMPONENT EDIT MODE":"FRAGMENT EDIT MODE"),this.dispatchEvent({type:"editModeChanged",data:0===t})},fG.prototype._enterComponentEditMode=function(){if(0!==this._editMode)return;const t=[];this._forEachComplexVisual(e=>{const n=e.beginComponentEdit();n&&t.push(n)}),t!==[]&&(this._editors=t,this.logger.info("COMPONENT EDIT MODE -- ON"),this._setEditMode(1),this._objectControls.keysTranslateObj(!0))},fG.prototype._applyComponentEdit=function(){if(1===this._editMode){this._objectControls.stop(),this._objectControls.keysTranslateObj(!1);for(let t=0;t<this._editors.length;++t)this._editors[t].apply();this._editors=[],this.logger.info("COMPONENT EDIT MODE -- OFF (applied)"),this._setEditMode(0),this.rebuildAll()}},fG.prototype._discardComponentEdit=function(){if(1===this._editMode){this._objectControls.stop(),this._objectControls.keysTranslateObj(!1);for(let t=0;t<this._editors.length;++t)this._editors[t].discard();this._editors=[],this.logger.info("COMPONENT EDIT MODE -- OFF (discarded)"),this._setEditMode(0),this._needRender=!0,this.rebuildAll()}},fG.prototype._enterFragmentEditMode=function(){if(0!==this._editMode)return;const t=[];if(this._forEachComplexVisual(e=>{e instanceof LB&&e.getSelectionCount()>0&&t.push(e)}),1!==t.length)return;const e=t[0].beginFragmentEdit();e&&(this._editors=[e],this.logger.info("FRAGMENT EDIT MODE -- ON (single bond)"),this._setEditMode(2),this._objectControls.allowTranslation(!1),this._objectControls.allowAltObjFreeRotation(e.isFreeRotationAllowed()),this._needRender=!0)},fG.prototype._applyFragmentEdit=function(){if(2===this._editMode){this._objectControls.stop();for(let t=0;t<this._editors.length;++t)this._editors[t].apply();this._editors=[],this.logger.info("FRAGMENT EDIT MODE -- OFF (applied)"),this._setEditMode(0),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this.rebuildAll()}},fG.prototype._discardFragmentEdit=function(){if(2===this._editMode){this._objectControls.stop();for(let t=0;t<this._editors.length;++t)this._editors[t].discard();this._editors=[],this.logger.info("FRAGMENT EDIT MODE -- OFF (discarded)"),this._setEditMode(0),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this._needRender=!0}},fG.prototype._onPick=function(t){if(!LL.now.picking)return;if(null!==this._animInterval)return;if(2===this._editMode)return;if(this._objectControls.isEditingAltObj())return;let e=null;function n(e){e.updateSelectionMask(t.obj),e.rebuildSelectionGeometry()}if(t.obj.atom?(e=t.obj.atom.residue.getChain().getComplex(),this._lastPick=t.obj.atom):t.obj.residue?(e=t.obj.residue.getChain().getComplex(),this._lastPick=t.obj.residue):t.obj.chain?(e=t.obj.chain.getComplex(),this._lastPick=t.obj.chain):t.obj.molecule?(e=t.obj.molecule.complex,this._lastPick=t.obj.molecule):this._lastPick=null,e){const t=this._getVisualForComplex(e);t&&(n(t),this._needRender=!0)}else this._forEachComplexVisual(n),this._needRender=!0;this._updateInfoPanel(),this.dispatchEvent(t)},fG.prototype._onKeyDown=function(t){if(this._running&&this._hotKeysEnabled){if(LL.now.editing)switch(t.code){case"KeyC":this._enterComponentEditMode();break;case"KeyF":this._enterFragmentEditMode();break;case"KeyA":switch(this._editMode){case 1:this._applyComponentEdit();break;case 2:this._applyFragmentEdit()}break;case"KeyD":switch(this._editMode){case 1:this._discardComponentEdit();break;case 2:this._discardFragmentEdit()}}switch(t.code){case"NumpadAdd":t.altKey&&(t.preventDefault(),t.stopPropagation(),this._forEachComplexVisual(t=>{t.expandSelection(),t.rebuildSelectionGeometry()}),this._updateInfoPanel(),this._needRender=!0);break;case"NumpadSubtract":t.altKey&&(t.preventDefault(),t.stopPropagation(),this._forEachComplexVisual(t=>{t.shrinkSelection(),t.rebuildSelectionGeometry()}),this._updateInfoPanel(),this._needRender=!0)}}},fG.prototype._onKeyUp=function(t){this._running&&this._hotKeysEnabled&&"KeyX"===t.code&&this._extractRepresentation()},fG.prototype._updateInfoPanel=function(){const t=this._msgAtomInfo.getElementsByTagName("p")[0];let e,n,i=0;for(this._forEachComplexVisual(t=>{i+=t.getSelectionCount()});t.firstChild;)t.removeChild(t.firstChild);if(0===i)return void(this._msgAtomInfo.style.opacity=0);let r=`${String(i)} atom${1!==i?"s":""} selected`;null!==this._lastPick&&(r+=", the last pick:");let s="",o="",a="";if(this._lastPick instanceof sG){e=this._lastPick,n=e.residue,o=e.name;const t=32!==e.location?String.fromCharCode(e.location):"";s=`${e.element.fullName} #${e.serial}${t}:       ${n._chain._name}.${n._type._name}${n._sequence}${n._icode.trim()}.`,s+=o,a=`Coord: (${e.position.x.toFixed(2).toString()},     ${e.position.y.toFixed(2).toString()},     ${e.position.z.toFixed(2).toString()})`}else this._lastPick instanceof oG?(n=this._lastPick,s=`${n._type._fullName}:       ${n._chain._name}.${n._type._name}${n._sequence}${n._icode.trim()}`):this._lastPick instanceof aG?s=`chain ${this._lastPick._name}`:this._lastPick instanceof lG&&(s=`molecule ${this._lastPick._name}`);t.appendChild(document.createTextNode(r)),""!==s&&(t.appendChild(document.createElement("br")),t.appendChild(document.createTextNode(s))),""!==a&&(t.appendChild(document.createElement("br")),t.appendChild(document.createTextNode(a))),this._msgAtomInfo.style.opacity=1},fG.prototype._getAltObj=function(){if(this._editors){let t=null;for(let e=0;e<this._editors.length;++e){const n=this._editors[e].getAltObj();if(n.objects.length>0){if(t){t=null;break}t=n}}if(t)return t}return{objects:[],pivot:new $P.Vector3(0,0,0)}},fG.prototype.resetPivot=function(){const t=new $P.Box3,e=new $P.Vector3;return function(){t.makeEmpty(),this._forEachVisual(e=>{t.union(e.getBoundaries().boundingBox)}),t.getCenter(e),this._objectControls.setPivot(e.negate()),this.dispatchEvent({type:"transform"})}}(),fG.prototype.setPivotResidue=function(){const t=new $P.Vector3;return function(e){const n=this._getVisualForComplex(e.getChain().getComplex());if(n){if(e._controlPoint)t.copy(e._controlPoint);else{let n=0,i=0,r=0;const s=e._atoms.length;for(let t=0;t<s;++t){const o=e._atoms[t].position;n+=o.x/s,i+=o.y/s,r+=o.z/s}t.set(n,i,r)}t.applyMatrix4(n.matrix).negate(),this._objectControls.setPivot(t),this.dispatchEvent({type:"transform"})}}}(),fG.prototype.setPivotAtom=function(){const t=new $P.Vector3;return function(e){const n=this._getVisualForComplex(e.residue.getChain().getComplex());n&&(t.copy(e.position),t.applyMatrix4(n.matrix).negate(),this._objectControls.setPivot(t),this.dispatchEvent({type:"transform"}))}}(),fG.prototype.getSelectionCenter=function(){const t=new $P.Vector3(0,0,0);return function(e,n,i){e.set(0,0,0);let r=0;return this._forEachComplexVisual(s=>{s.getSelectionCenter(t,n,i||s.getSelectionBit())&&(e.add(t),r++)}),0!==r&&(e.divideScalar(r),e.negate(),!0)}}(),fG.prototype.setPivotSubset=function(){const t=new $P.Vector3(0,0,0);function e(t,e){return t.mask&1<<e}function n(t,e){return e.selector.includesAtom(t)}return function(i){const r=i?n:e;this.getSelectionCenter(t,r,i)?(this._objectControls.setPivot(t),this.dispatchEvent({type:"transform"})):this.logger.warn("selection is empty. Center operation not performed")}}(),fG.prototype.screenshot=function(t,e){const n=this._gfx,i=n.renderer.domElement.width,r=n.renderer.domElement.height;function s(){let s;if(AL.getBrowser()===AL.browserType.SAFARI){const o=document.createElement("canvas"),a=o.getContext("2d");o.width=void 0===t?i:t,o.height=void 0===e?r:e,a.drawImage(n.renderer.domElement,0,0,o.width,o.height),s=o.toDataURL("image/png")}else s=n.renderer.domElement.toDataURL("image/png");return s}let o;if(e=e||t,void 0===t&&void 0===e||t===i&&e===r)o=s();else{const i=n.camera.aspect,r=n.camera.fov,l=function(t){return Math.tan($P.MathUtils.degToRad(.5*t))}(n.camera.fov),c=l*Math.min(n.width,n.height)/n.height,h=t/e;n.renderer.setPixelRatio(1),n.camera.aspect=h,n.camera.fov=(a=c/Math.min(h,1),2*$P.MathUtils.radToDeg(Math.atan(a))),n.camera.updateProjectionMatrix(),n.renderer.setDrawingBufferSize(t,e,1),this._renderFrame(LL.now.stereo),o=s(),n.renderer.setPixelRatio(window.devicePixelRatio),n.camera.aspect=i,n.camera.fov=r,n.camera.updateProjectionMatrix(),n.renderer.setDrawingBufferSize(n.width,n.height,window.devicePixelRatio),this._needRender=!0}var a;return o},fG.prototype.screenshotSave=function(t,e,n){const i=this.screenshot(e,n);AL.shotDownload(i,t)},fG.prototype.save=function(t){this._export(t.fileType).then(e=>{const n=this._visuals[this._curVisualName]._complex.name;AL.download(e,n,t.fileType),this._refreshTitle(),this.dispatchEvent({type:"exportingDone"})}).catch(t=>{this.logger.error("Could not export data"),this.logger.debug(t),this._refreshTitle(),this.dispatchEvent({type:"exportingDone",error:t})})},fG.prototype._tweakResolution=function(){const t=[["poor",100],["low",500],["medium",1e3],["high",5e3],["ultra",Number.MAX_VALUE]];let e=0;if(this._forEachComplexVisual(t=>{e+=t.getComplex().getAtomCount()}),e>0){const n=1e6*this._gfxScore/e;for(let e=0;e<t.length;++e)if(n<t[e][1]){this._autoChangeResolution(t[e][0]);break}}},fG.prototype._autoChangeResolution=function(t){t!==LL.now.resolution&&this.logger.report(`Your rendering resolution was changed to "${t}" for best performance.`),LL.now.resolution=t},fG.prototype.saveSettings=function(){this._cookies.setCookie(this._opts.settingsCookie,JSON.stringify(this.settings.getDiffs(!0)))},fG.prototype.restoreSettings=function(){try{const t=this._cookies.getCookie(this._opts.settingsCookie),e=t?JSON.parse(t):{};this.settings.applyDiffs(e,!0)}catch(t){this.logger.error(`Cookies parse error: ${t.message}`)}},fG.prototype.resetSettings=function(){this.settings.reset()},fG.prototype.setOptions=function(t){"string"==typeof t&&(t=fG.options.fromAttr(t)),t.reps&&(this._opts.reps=null),qP.default.merge(this._opts,t),t.settings&&this.set(t.settings),this._opts._objects=t._objects,this._resetObjects(),t.load&&this.load(t.load,{fileType:t.type}),t.preset&&(LL.now.preset=t.preset),t.reps&&this.resetReps(t.preset),this._opts.view&&(this.view(this._opts.view),delete this._opts.view);const e=this._getComplexVisual();e&&(e.getComplex().resetCurrentUnit(),qP.default.isNumber(t.unit)&&e.getComplex().setCurrentUnit(t.unit),this.resetView(),this.rebuildAll())},fG.prototype.info=function(t){const e=this._getComplexVisual(t);if(!e)return{};const n=e.getComplex(),{metadata:i}=n;return{id:i.id||n.name||"UNKNOWN",title:i.title&&i.title.join(" ")||"UNKNOWN DATA",atoms:n.getAtomCount(),bonds:n.getBondCount(),residues:n.getResidueCount(),chains:n.getChainCount()}},fG.prototype.addObject=function(t,e){let n=null;if(t.type===Fk.prototype.type&&(n=Fk),null===n)throw new Error(`Unknown scene object type - ${t.type}`);try{const e=new n(t.params,t.opts);this._addSceneObject(e)}catch(t){if(e)throw t;this.logger.debug(`Error during scene object creation: ${t.message}`)}this._needRender=!0},fG.prototype._addSceneObject=function(t){const e=this._getComplexVisual();t.build&&e&&(t.build(e.getComplex()),this._gfx.pivot.add(t.getGeometry()));const n=this._objects;n[n.length]=t},fG.prototype._updateObjsToFrame=function(t){const e=this._objects;for(let n=0,i=e.length;n<i;++n)e[n].updateToFrame&&e[n].updateToFrame(t)},fG.prototype._resetObjects=function(){const t=this._opts._objects;if(this._objects=[],t)for(let e=0,n=t.length;e<n;++e)this.addObject(t[e],!1)},fG.prototype.removeObject=function(t){const e=this._objects[t];if(!e)throw new Error(`Scene object with index ${t} does not exist`);e.destroy(),this._objects.splice(t,1),this._needRender=!0},fG.prototype.getURL=function(t){return KL.toURL(this.getState(qP.default.defaults(t,{compact:!0,settings:!1,view:!1})))},fG.prototype.getScript=function(t){return KL.toScript(this.getState(qP.default.defaults(t,{compact:!0,settings:!0,view:!0})))},fG.prototype._compareReps=function(t,e){const n={};let i=0;t&&(i=t.repCount());const r=LL.defaults.presets[LL.now.preset];let s=e;void 0===r||r.length>i?(s=!1,n.preset="empty"):LL.now.preset!==LL.defaults.preset&&(n.preset=LL.now.preset);const o=[];let a=!0;for(let e=0,n=i;e<n;++e)o[e]=t.repGet(e).compare(s?r[e]:null),qP.default.isEmpty(o[e])||(a=!1);return a||(n.reps=o),n},fG.prototype.getState=function(t){const e={};t=qP.default.defaults(t,{compact:!0,settings:!1,view:!1});const n=this._getComplexVisual();if(null!==n){const t=n.getComplex(),{metadata:i}=t;if(i.id){const t=i.format?`${i.format}:`:"";e.load=t+i.id}const r=t.getCurrentUnit();1!==r&&(e.unit=r)}const i=this._compareReps(n,t.compact);i.preset&&(e.preset=i.preset),i.reps&&(e.reps=i.reps);const r=this._objects,s=[];for(let t=0,e=r.length;t<e;++t)s[t]=r[t].identify();if(r.length>0&&(e._objects=s),t.view&&(e.view=this.view()),t.settings){const t=this.settings.getDiffs(!1);qP.default.isEmpty(t)||(e.settings=t)}return e},fG.prototype.get=function(t,e){return LL.get(t,e)},fG.prototype._clipPlaneUpdateValue=function(t){const e=Math.max(this._gfx.camera.position.z-t*LL.now.draft.clipPlaneFactor,LL.now.camNear),n={clipPlaneValue:e};this._forEachComplexVisual(t=>{t.setUberOptions(n)});for(let t=0,e=this._objects.length;t<e;++t){const e=this._objects[t];e._line&&e._line.material.setUberOptions(n)}null!==this._picker&&(this._picker.clipPlaneValue=e)},fG.prototype._fogFarUpdateValue=function(){null!==this._picker&&(this._gfx.scene.fog?this._picker.fogFarValue=this._gfx.scene.fog.far:this._picker.fogFarValue=void 0)},fG.prototype._updateShadowmapMeshes=function(t){this._forEachComplexVisual(e=>{const n=e._reprList;for(let e=0,i=n.length;e<i;++e){const i=n[e];t(i.geo,i.material)}})},fG.prototype._updateMaterials=function(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this._forEachComplexVisual(i=>i.setMaterialValues(t,e,n));for(let e=0,n=this._objects.length;e<n;++e){const n=this._objects[e];n._line&&(n._line.material.setValues(t),n._line.material.needsUpdate=!0)}},fG.prototype._fogAlphaChanged=function(){this._forEachComplexVisual(t=>{t.setUberOptions({fogAlpha:LL.now.fogAlpha})})},fG.prototype._embedWebXR=function(){if("WEBVR"!==LL.now.stereo)return this.webVR&&this.webVR.disable(),void(this.webVR=null);this.webVR||(this.webVR=new iG(()=>{this._requestAnimationFrame(()=>this._onTick()),this._needRender=!0,this._onResize()})),this.webVR.enable(this._gfx)},fG.prototype._initOnSettingsChanged=function(){const t=(t,e)=>{(t=qP.default.isArray(t)?t:[t]).forEach(t=>{this.settings.addEventListener(`change:${t}`,e)})};t("modes.VD.frame",()=>{const t=this._getVolumeVisual();null!==t&&(t.showFrame(LL.now.modes.VD.frame),this._needRender=!0)}),t("modes.VD.isoMode",()=>{const t=this._getVolumeVisual();null!==t&&(t.getMesh().material.updateDefines(),this._needRender=!0)}),t("bg.color",()=>{this._onBgColorChanged()}),t("ao",()=>{if(LL.now.ao&&!_G(this._gfx.renderer.getContext()))this.logger.warn("Your device or browser does not support ao"),LL.set("ao",!1);else{const t={normalsToGBuffer:LL.now.ao};this._setUberMaterialValues(t)}}),t("zSprites",()=>{LL.now.zSprites&&!gG(this._gfx.renderer.getContext())&&(this.logger.warn("Your device or browser does not support zSprites"),LL.set("zSprites",!1)),this.rebuildAll()}),t("fogColor",()=>{this._onFogColorChanged()}),t("fogColorEnable",()=>{this._onFogColorChanged()}),t("bg.transparent",t=>{const e=this._gfx;e&&e.renderer.setClearColor(LL.now.bg.color,Number(!LL.now.bg.transparent)),this._updateMaterials({fogTransparent:t.value}),this.rebuildAll()}),t("draft.clipPlane",t=>{this._updateMaterials({clipPlane:t.value}),this.rebuildAll()}),t("shadow.on",t=>{const e={shadowmap:t.value,shadowmapType:LL.now.shadow.type},n=this._gfx;n&&(n.renderer.shadowMap.enabled=Boolean(e.shadowmap)),this._updateMaterials(e,!0),e.shadowmap?(this._updateShadowCamera(),this._updateShadowmapMeshes(SB.createShadowmapMaterial)):this._updateShadowmapMeshes(SB.removeShadowmapMaterial),this._needRender=!0}),t("shadow.type",t=>{LL.now.shadow.on&&(this._updateMaterials({shadowmapType:t.value},!0),this._needRender=!0)}),t("shadow.radius",t=>{for(let e=0;e<this._gfx.scene.children.length;e++)void 0!==this._gfx.scene.children[e].shadow&&(this._gfx.scene.children[e].shadow.radius=t.value,this._needRender=!0)}),t("fps",()=>{this._fps.show(LL.now.fps)}),t(["fog","fogNearFactor","fogFarFactor"],()=>{this._updateFog(),this._needRender=!0}),t("fogAlpha",()=>{const{fogAlpha:t}=LL.now;(t<0||t>1)&&this.logger.warn("fogAlpha must belong range [0,1]"),this._fogAlphaChanged(),this._needRender=!0}),t("autoResolution",t=>{t.value&&!this._gfxScore&&this.logger.warn("Benchmarks are missed, autoresolution will not work! Autoresolution should be set during miew startup.")}),t("stereo",()=>{this._embedWebXR("WEBVR"===LL.now.stereo),this._needRender=!0}),t(["transparency","palette"],()=>{this.rebuildAll()}),t("resolution",()=>{this.rebuildAll();const t=this._getVolumeVisual();t&&(t.getMesh().material.updateDefines(),this._needRender=!0)}),t(["axes","fxaa","ao","outline.on","outline.color","outline.threshold","outline.thickness"],()=>{this._needRender=!0})},fG.prototype.set=function(t,e){LL.set(t,e)},fG.prototype.select=function(t,e){const n=this._getComplexVisual();if(!n)return;let i=t;qP.default.isString(t)&&(i=rG.parse(t).selector),n.select(i,e),this._lastPick=null,this._updateInfoPanel(),this._needRender=!0},fG.prototype.view=function(t){const e=this,{pivot:n}=this._gfx;let i=[];return void 0===t?function(){const t=n.position,r=e._objectControls.getScale()/LL.now.radiusToFit,s=new $P.Euler;return s.setFromQuaternion(e._objectControls.getOrientation(),"ZXY"),i=[t.x,t.y,t.z,r,s.x,s.y,s.z],"1"+AL.arrayToBase64(i,Float32Array)}():(function(){40===t.length&&(t=`0${t}`);const r=t[0];if(i=AL.arrayFromBase64(t.substr(1),Float32Array),"1"!==r){if("0"!==r)return void e.logger.warn(`Encoded view version mismatch, stored as ${r} vs 1 expected`);i[3]/=8}const s=e._interpolator,o=s.createView();o.position.copy(n.position),o.scale=e._objectControls.getScale(),o.orientation.copy(e._objectControls.getOrientation());const a=s.createView();a.position.set(i[0],i[1],i[2]),e._getComplexVisual()&&a.position.sub(e._getComplexVisual().position),a.scale=i[3],a.orientation.setFromEuler(new $P.Euler(i[4],i[5],i[6],"ZXY")),s.setup(o,a)}(),t)},fG.prototype._updateView=function(){const t=this,{pivot:e}=this._gfx,n=this._interpolator;if(n.wasStarted()||n.start(),!n.isMoving())return;const i=n.getCurrentView();if(i.success){const n=i.view;e.position.copy(n.position),t._objectControls.setScale(n.scale*LL.now.radiusToFit),t._objectControls.setOrientation(n.orientation),this.dispatchEvent({type:"transform"}),t._needRender=!0}},fG.prototype.translate=function(t,e,n){this._objectControls.translatePivot(t,e,n),this.dispatchEvent({type:"transform"}),this._needRender=!0},fG.prototype.rotate=function(t,e,n){this._objectControls.rotate((new $P.Quaternion).setFromEuler(new $P.Euler(t,e,n,"XYZ"))),this.dispatchEvent({type:"transform"}),this._needRender=!0},fG.prototype.scale=function(t){if(t<=0)throw new RangeError("Scale should be greater than zero");this._objectControls.scale(t),this.dispatchEvent({type:"transform"}),this._needRender=!0},fG.prototype.center=function(t){if(void 0===t)return this.setPivotSubset(),void(this._needRender=!0);if(void 0!==t.obj&&("atom"in t.obj||"residue"in t.obj))return"atom"in t.obj?this.setPivotAtom(t.obj.atom):this.setPivotResidue(t.obj.residue),void(this._needRender=!0);if(void 0===t.obj&&""!==t){const e=rG.parse(t);if(void 0===e.error)return this.setPivotSubset(e),void(this._needRender=!0)}this.resetPivot(),this._needRender=!0},fG.prototype.within=function(t,e){const n=this._getComplexVisual();if(!n)return rG.None();t instanceof String&&(t=rG.parse(t));const i=n.within(t,e);return i&&(n.rebuildSelectionGeometry(),this._needRender=!0),i},fG.prototype.projected=function(t,e){const n=this._getComplexVisual(e);if(!n)return!1;const i=n.getComplex().getAtomByFullname(t);if(null===i)return!1;const r=i.position.clone();return this._gfx.pivot.updateMatrixWorldRecursive(),this._gfx.camera.updateMatrixWorldRecursive(),this._gfx.pivot.localToWorld(r),r.project(this._gfx.camera),{x:.5*(r.x+1)*this._gfx.width,y:.5*(1-r.y)*this._gfx.height}},fG.prototype.dssp=function(t){const e=this._getComplexVisual(t);e&&(e.getComplex().dssp(),e._reprList.forEach(t=>{"CA"!==t.mode.id&&"SS"!==t.colorer.id||(t.needsRebuild=!0)}))},fG.prototype.exportCML=function(){const t=this,e=t._getComplexVisual(),n=e?e.getComplex():null;return n&&n.originalCML?(function(e){const{root:n}=t._gfx,i=function(t){const e=new $P.Vector3,n=new $P.Vector3,i=new $P.Vector3;t.extractBasis(e,n,i),e.normalize(),n.normalize(),i.normalize();const r=new $P.Matrix4;return r.identity(),r.makeBasis(e,n,i),r}(n.matrixWorld),r=new $P.Vector4(0,0,0,0),s=new $P.Vector4(0,0,0,0);let o=null,a=null;e.forEachAtom(t=>{t.xmlNodeRef&&t.xmlNodeRef.xmlNode&&(o=t.xmlNodeRef.xmlNode,a=t.position,r.set(a.x,a.y,a.z,1),r.applyMatrix4(i),o.setAttribute("x3",r.x.toString()),o.setAttribute("y3",r.y.toString()),o.setAttribute("z3",r.z.toString()),o.removeAttribute("x2"),o.removeAttribute("y2"))}),e.forEachSGroup(t=>{if(t.xmlNodeRef&&t.xmlNodeRef.xmlNode){o=t.xmlNodeRef.xmlNode,a=t.getPosition(),r.set(a.x,a.y,a.z,1);const e=t.getCentralPoint();null===e?r.applyMatrix4(i):(s.set(e.x,e.y,e.z,0),r.add(s),r.applyMatrix4(i),s.set(e.x,e.y,e.z,1),s.applyMatrix4(i),r.sub(s)),o.setAttribute("x",r.x.toString()),o.setAttribute("y",r.y.toString()),o.setAttribute("z",r.z.toString())}})}(n),(new XMLSerializer).serializeToString(n.originalCML)):null},fG.prototype.motm=function(){LL.set({fogColorEnable:!0,fogColor:0,outline:{on:!0,threshold:.01},bg:{color:16777215}}),this._forEachComplexVisual(t=>{const e=[],n=t.getComplex(),i=VF.get(LL.now.palette);for(let t=0;t<n.getChainCount();t++){const r=n._chains[t]._name,s=i.getChainColor(r);e[t]={selector:`chain ${r}`,mode:"VW",colorer:["CB",{color:s,factor:.9}],material:"FL"}}t.resetReps(e)})},fG.prototype.VERSION="0.11.0",qP.default.assign(fG,{VERSION:fG.prototype.VERSION,registeredPlugins:[],chem:DN,io:mk,modes:AF,colorers:fB,materials:_B,palettes:VF,options:KL,settings:LL,utils:AL,gfx:{Representation:MB},thirdParty:{lodash:qP.default,three:$P}});const SG=fG;var bG=XP(89);const MG={$help:["Rendering mode shortcut","    BS - balls and sticks mode","    LN - lines mode","    LC - licorice mode","    VW - van der waals mode","    TR - trace mode","    TU - tube mode","    CA - cartoon mode","    SA - isosurface mode","    QS - quick surface mode","    SE - solvent excluded mode","    TX - text mode"],BS:{$help:["   Balls and sticks","      aromrad = <number> #aromatic radius","      atom = <number>    #atom radius","      bond = <number>    #bond radius","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic","      space = <number>   #space value\n"]},CA:{$help:["   Cartoon","      arrow = <number>   #arrow size","      depth = <number>   #depth of surface","      heightSegmentsRatio = <number>","      radius = <number>  #tube radius","      tension = <number> #","      width = <number>  #secondary width\n"]},LN:{$help:["   Lines","      atom = <number>    #atom radius","      chunkarom = <number>","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic","      offsarom = <number>\n"]},LC:{$help:["   Licorice","      aromrad = <number> #aromatic radius","      bond = <number>    #bond radius","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic","      space = <number>   #space value\n"]},VW:{$help:["   Van der Waals","      nothing\n"]},TR:{$help:["   Trace","      radius = <number>  #tube radius\n"]},TU:{$help:["   Tube","      heightSegmentsRatio = <number>","      radius = <number>  #tube radius","      tension = <number> \n"]},SA:{$help:["   Surface","      zClip = <bool> #clip z plane\n"]},QS:{$help:["   Quick surface","      isoValue = <number>","      scale = <number>","      wireframe = <bool>","      zClip = <bool> #clip z plane\n"]},SE:{$help:["   Solvent excluded surface","      zClip = <bool> #clip z plane\n"]},TX:{$help:["   Text mode",'      template = <format string> string that can include "{{ id }}"',"          it will be replaced by value, id can be one of next:","          serial, name, type, sequence, residue, chain, hetatm, water\n",'      horizontalAlign = <string> {"left", "right", "center"}','      verticalAlign = <string> {"top", "bottom", "middle"}',"      dx = <number> #offset along x","      dy = <number> #offset along y","      dz = <number> #offset along z","      fg = <string> #text color modificator","           could be keyword, named color or hex","      fg = <string> #back color modificator","           could be keyword, named color or hex","      showBg = <bool> #if set show background","           plate under text"]}},wG={$help:["Coloring mode shortcut","    EL - color by element","    CH - color by chain","    SQ - color by sequence","    RT - color by residue type","    SS - color by secondary structure","    UN - uniform"],UN:{$help:["Parameters of coloring modes customization","   Uniform","      color = <number|color> #RGB->HEX->dec\n"],color:{$help:Object.keys(VF.get(LL.now.palette).namedColors).sort().join("\n")}}},EG={$help:["Material shortcut","    DF - diffuse","    TR - transparent","    SF - soft plastic","    PL - glossy plastic","    ME - metal","    GL - glass"]},TG={$help:["Short (packed) representation description as a set of variables","    s=<EXPRESSION>","        selector property","    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]","        render mode property","    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]","        color mode property","    mt=<MATERIAL_ID>","        material property"],s:{$help:"Selection expression string as it is in menu->representations->selection"},m:MG,c:wG,mt:EG},AG={$help:["Parameters of rendering modes customization: modes","Parameters of colorer customization: colorers","Autobuild: autobuild = (<number>|<bool>)"],modes:MG,colorers:wG},CG={$help:["help (<cmd name>| <path to property>)","You can get detailed information about command options",'   using "help cmd.opt.opt.[...]"\n',"   you can use one line comments","   everything started from (#|//) will be skipped","   Example: >build //some comment\n","List of available commands:"],reset:{$help:["Reload current object, delete all representations","    Nothing will work until load new object"]},load:{$help:["load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])","    Load new pdb object from selected source"],PDBID:{$help:"pdb id in remote molecule database"},URL:{$help:"url to source file"},f:{$help:["open file system dialog to fetch local file","optionally you can determine trajectory file","via URL for *.top model"]}},clear:{$help:"No args. Clear terminal"},add:{$help:["add [<REP_NAME>] [<DESCRIPTION>]","    Add new item to representation set with","    default or <DESCRIPTION> params"],REP_NAME:{$help:"Identifier string [_,a-z,A-Z,0-9] can not start from digit"},DESCRIPTION:TG},rep:{$help:["rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]","    set current representation by name or index","    edit current representation by <DESCRIPTION>"],REP_NAME:{$help:["Identifier string [_,a-z,A-Z,0-9] can not start from digit","Must be declared before"]},REP_INDEX:{$help:"Index of available representation"},DESCRIPTION:TG},remove:{$help:["remove (<REP_NAME>|<REP_INDEX>)","Remove representation by name or index"],REP_NAME:{$help:["Identifier string [_,a-z,A-Z,0-9] can not start from digit","Must be declared before"]},REP_INDEX:{$help:"Index of available representation"}},selector:{$help:["selector <EXPRESSION>","   set selector from EXPRESSION to current representation"],EXPRESSION:{$help:"Selection expression string as it is in menu->representations->selection"}},mode:{$help:["mode <MODE_ID> [<PARAMETER>=<VALUE>...]","   set rendering mode and apply parameters to current representation"],MODE_ID:MG},color:{$help:["color <COLORER_ID> [<PARAMETER>=<VALUE>...]","   set colorer and apply parameters to current representation"],COLORER_ID:wG},material:{$help:["material <MATERIAL_ID>","   set material to current representation"],MATERIAL_ID:EG},build:{$help:"build help str",add:{$help:"build.add",new:{$help:["add.new","add.new new line 1","add.new new line 2","add.new new line 3"]}},del:{$help:"build.del"}},list:{$help:["list [-e|-s|<REP_NAME>|<REP_INDEX>]","Print representations if no args print list of representations","    -e expand list and show all representations","    -s show all user-registered selectors","    <REP_NAME>|<REP_INDEX> show only current representation"]},hide:{$help:["hide (<REP_NAME>|<REP_INDEX>)","Hide representation referenced in args"]},show:{$help:["show (<REP_NAME>|<REP_INDEX>)","Show representation referenced in args"]},get:{$help:["get <PARAMETER>","Print <PARAMETER> value","    <PARAMETER> - path to option use get.PARAMETER to get more info"],PARAMETER:AG},set:{$help:["set <PARAMETER> <VALUE>","Set <PARAMETER> with <VALUE>","    <PARAMETER> - path to option use set.PARAMETER to get more info"],PARAMETER:AG},set_save:{$help:["set_save","Save current settings to cookie"]},set_restore:{$help:["set_restore","Load and apply settings from cookie"]},set_reset:{$help:["set_reset","Reset current settings to the defaults"]},preset:{$help:["preset [<PRESET>]","Reset current representation or set preset to <PRESET>"],PRESET:{$help:["default","wire","small","macro"]}},unit:{$help:["unit [<unit_id>]","Change current biological structure view. Zero <unit_id> value means asymmetric unit,","positive values set an assembly with corresponding number.","Being called with no parameters command prints current unit information."]},view:{$help:["view [<ENCODED_VIEW>]","Get current encoded view or set if ENCODED_VIEW placed as argument"],ENCODED_VIEW:{$help:["encoded view matrix string (binary code)"]}},rotate:{$help:["rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...","Rotate scene"]},scale:{$help:["scale <SCALE>","Scale scene"]},select:{$help:["select <SELECTOR_STRING> [as <SELECTOR_NAME>]","Select atoms using selector defined in SELECTOR_STRING","    and if SELECTOR_NAME is defined register it in viewer","    you can use it later as a complex selector"]},within:{$help:["within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>","Build within named selector","    DISTANCE        <number>","    SELECTOR_STRING <string(selection language)>","    SELECTOR_NAME   <identifier>"]},url:{$help:["url [-s] [-v]","Report URL encoded scene","    if -s set that include settings in the URL","    if -v set that include view in the URL"]},screenshot:{$help:["screenshot [<WIDTH> [<HEIGHT>]]","Make a screenshot of the scene","    WIDTH  <number> in pixels","    HEIGHT <number> in pixels, equal to WIDTH by default"]},line:{$help:["line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]","Draw dashed line between two specified atoms"]},removeobj:{$help:["removeobj <id>","Remove scene object by its index. Indices could be obtained by <listobj> command"]},listobj:{$help:["listobj","Display the list of all existing scene objects"]}},{chem:{selectors:RG},modes:PG,colorers:LG,materials:IG,palettes:NG,options:DG,settings:OG}=SG;function UG(){}const FG=function(){const t=new UG;return function(){return t}}(),BG=new class{constructor(){this.representationMap={},this.representationID={}}get(t){return this.representationMap[t]||this.representationID[t]||"<no name>"}add(t,e){if(-1===t)return"Can not create representation: there is no data";if(void 0!==e){if(this.representationMap.hasOwnProperty(t))return"This name has already existed, registered without name";this.representationMap[t.toString()]=e,this.representationID[e]=t.toString()}return`Representation ${t} successfully added`}remove(t){t&&this.representationID.hasOwnProperty(t)&&(delete this.representationMap[this.representationID[t]],delete this.representationID[t]);const e=Object.keys(this.representationID).sort();for(const n in e)if(e.hasOwnProperty(n)){const i=e[n];i>t&&(this.representationID[i-1]=this.representationID[i],this.representationMap[this.representationID[i]]-=1,delete this.representationID[i])}}clear(){this.representationMap={},this.representationID={}}};function zG(t){const e={s:"selector",m:"mode",c:"colorer",mt:"material",mode:"modes",color:"colorers",colorer:"colorers",select:"selector",material:"materials",selector:"selector"}[t];return void 0===e?t:e}const VG=new class{list(t,e,n){let i="";if(t&&void 0!==e&&(void 0===n||"-e"===n)){const r=t.repCount();for(let s=0;s<r;s++)i+=this.listRep(t,e,s,n)}return i}listRep(t,e,n,i){let r="";const s=t.repGet(n);if(!s)return fL.warn(`Rep ${n} does not exist!`),r;const o=n,a=e.get(o),{mode:l,colorer:c}=s,h=s.selectorString,u=s.materialPreset;return r+=`#${o} : ${l.name}${"<no name>"===a?"":`, ${a}`}\n`,void 0!==i&&(r+=`    selection : "${h}"\n`,r+=`    mode      : (${l.id}), ${l.name}\n`,r+=`    colorer   : (${c.id}), ${c.name}\n`,r+=`    material  : (${u.id}), ${u.name}\n`),r}listSelector(t,e){let n="";for(const t in e)e.hasOwnProperty(t)&&(n+=`${t} : "${e[t]}"\n`);return n}listObjs(t){const e=t._objects;if(!e||!Array.isArray(e)||0===e.length)return"There are no objects on the scene";const n=[];for(let t=0,i=e.length;t<i;++t)n[t]=`${t}: ${e[t].toString()}`;return n.join("\n")}joinHelpStr(t){return t instanceof Array?t.join("\n"):t}help(t){if(qP.default.isUndefined(t))return`${this.joinHelpStr(CG.$help)}\n${qP.default.slice(qP.default.sortBy(qP.default.keys(CG)),1).join(", ")}\n`;const e=qP.default.get(CG,t);return qP.default.isUndefined(e)?this.help():`${this.joinHelpStr(e.$help)}\n`}load(t,e){if(void 0===t||void 0===e||"-f"===e)return;t.awaitWhileCMDisInProcess();const n=()=>t.finishAwaitingCMDInProcess();t.load(e).then(n,n)}checkArg(t,e,n){if(void 0!==t&&void 0!==e){if("selector"===zG(t)){const t=RG.parse(e);if(void 0!==t.error)throw{message:t.error};return void 0!==n&&n?t.selector:e}const i={colorers:LG,modes:PG,materials:IG};let r,s=t;for(;s!==r;)r=s,s=zG(r);if(void 0===i[s].get(e))throw{message:`${e} is not existed in ${s}`};return e}return FG}propagateProp(t,e){if(void 0!==t){let n={};const i=DG.adapters[typeof qP.default.get(OG.defaults,t)];if(void 0===i)throw{message:`${t} is not existed`};if((t.endsWith(".color")||t.endsWith(".baseColor")||t.endsWith(".EL.carbon"))&&"number"!=typeof e&&(e=NG.get(OG.now.palette).getNamedColor(e)),t.endsWith(".fg")||t.endsWith(".bg"))if("number"!=typeof e){const t=NG.get(OG.now.palette).getNamedColor(e,!0);void 0!==t&&(e=`0x${t.toString(16)}`)}else e=`0x${e.toString(16)}`;if(t.endsWith(".template")&&(e=e.replace(/\\n/g,"\n")),void 0!==e&&i(e)!==e&&i(e)!==e>0)throw n={message:`${t} must be a "${typeof qP.default.get(OG.defaults,t)}"`},n}return e}unquoteString(t){return AL.unquoteString(t)}};function kG(t){if(t instanceof this.constructor)return t;this._values=t instanceof Array?t.slice(0):t?[t]:[]}kG.prototype.append=function(t){const e=this._values;return e[e.length]=t,this},kG.prototype.remove=function(t){const e=this._values,n=e.indexOf(t);return n>=0&&e.splice(n,1),this},kG.prototype.toJSO=function(t,e,n){const i={},r=this._values;for(let s=0,o=r.length;s<o;++s)qP.default.set(i,r[s].id,t.propagateProp(`${zG(e)}.${n}.${r[s].id}`,r[s].val));return i};const GG=Object.create({});GG.Arg=function(t,e){this.id=t,this.val=e},GG.ArgList=kG,GG.miew=null,GG.echo=null,GG.representations=BG,GG.utils=VG,GG._=qP.default,GG.CreateObjectPair=function(t,e){const n={};return n[t]=e,n},GG.keyRemap=zG,GG.Context=RG.Context,GG.ClearContext=RG.ClearContext,GG.NULL=FG,GG.notimplemented=function(){return this.NULL},SG.prototype.script=function(t,e,n){bG.parser.yy.miew=this,bG.parser.yy.echo=e,bG.parser.yy.error=n,void 0===this.cmdQueue&&(this.cmdQueue=[]),void 0===this.commandInAction&&(this.commandInAction=!1),this.cmdQueue=this.cmdQueue.concat(t.split("\n"))},SG.prototype.awaitWhileCMDisInProcess=function(){this.commandInAction=!0},SG.prototype.finishAwaitingCMDInProcess=function(){this.commandInAction=!1},SG.prototype.isScriptingCommandAvailable=function(){return void 0!==this.commandInAction&&!this.commandInAction&&void 0!==this.cmdQueue&&this.cmdQueue.length>0},SG.prototype.callNextCmd=function(){if(this.isScriptingCommandAvailable()){const t=this.cmdQueue.shift(),e={success:!1};try{bG.parser.parse(t),e.success=!0}catch(t){e.error=t.message,bG.parser.yy.error(e.error),this.finishAwaitingCMDInProcess()}return e}return""},bG.parser.yy=GG,bG.parser.yy.parseError=bG.parser.parseError;const HG=SG;var WG=YP.A;window.THREE=t,window.Miew=WG,window.FullViewer={initialize:function(t,e){console.log("Full viewer initialized"),e&&e.success&&this.initializeMiewViewer(t,e)},initializeMiewViewer:function(t,e){try{const n=new WG({container:t,settings:{autoPreset:!1,bg:{color:16777215,transparent:!0},fog:{enabled:!0},fps:!1,axes:!1,resolution:"medium"},reps:[{mode:"BS",colorer:"EL",selector:"all",material:"SF"}]});if(!n.init())throw new Error("Failed to initialize miew viewer");e.xyz_content&&n.load(e.xyz_content,{sourceType:"immediate",fileType:"xyz"}),n.run(),window.miewViewer=n,console.log("Miew viewer loaded successfully")}catch(e){console.error("Error initializing miew viewer:",e),t.innerHTML=`<div style="color: red; padding: 20px;">Error loading 3D viewer: ${e.message}</div>`}}},"undefined"!=typeof process&&process.env})();var r=window;for(var s in i)r[s]=i[s];i.__esModule&&Object.defineProperty(r,"__esModule",{value:!0})})();